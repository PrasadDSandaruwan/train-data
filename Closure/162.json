[
  {
    "id": 763,
    "file_path": "src/com/google/javascript/jscomp/Scope.java",
    "start-bug-line": 568,
    "end-bug-line": 568,
    "bug": "",
    "fix": "Iterable<Var> getVarIterable() { return vars.values(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;"
      },
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicate; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterators; import com.google.javascript.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.StaticReference; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.jstype.StaticSourceFile; import com.google.javascript.rhino.jstype.StaticSymbolTable; import java.util.Collections; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; public class Scope"
      },
      {
        "txt": "implements StaticScope<JSType>, StaticSymbolTable<Scope.Var, Scope.Var> { private final Map<String, Var> vars = new LinkedHashMap<String, Var>(); private final Scope parent; private final int depth; private final Node rootNode; private final ObjectType thisType; private final boolean isBottom; private Var arguments; private static final Predicate<Var> DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES = new Predicate<Var>() {"
      },
      {
        "txt": "@Override public boolean apply(Var var) { return var.getParentNode() != null && var.getType() == null && // no declared type var.getParentNode().getType() == Token.VAR && !var.isExtern(); } }; public static class Var implements StaticSlot<JSType>, StaticReference<JSType> { final String name;"
      },
      {
        "txt": "final Node nameNode; private JSType type; private final JSDocInfo info; private final boolean typeInferred; final CompilerInput input; final boolean isDefine; final int index; final Scope scope; private Var(boolean inferred, String name, Node nameNode, JSType type, Scope scope, int index, CompilerInput input, boolean isDefine,"
      },
      {
        "txt": "JSDocInfo info) { this.name = name; this.nameNode = nameNode; this.type = type; this.scope = scope; this.index = index; this.input = input; this.isDefine = isDefine; this.info = info; this.typeInferred = inferred;"
      },
      {
        "txt": "} @Override public String getName() { return name; } @Override public Node getNode() { return nameNode; } CompilerInput getInput() {"
      },
      {
        "txt": "return input; } @Override public StaticSourceFile getSourceFile() { return nameNode.getStaticSourceFile(); } @Override public Var getSymbol() { return this; }"
      },
      {
        "txt": "@Override public Var getDeclaration() { return nameNode == null ? null : this; } public Node getParentNode() { return nameNode == null ? null : nameNode.getParent(); } public boolean isBleedingFunction() { return NodeUtil.isFunctionExpression(getParentNode()); }"
      },
      {
        "txt": "Scope getScope() { return scope; } public boolean isGlobal() { return scope.isGlobal(); } public boolean isLocal() { return scope.isLocal(); } boolean isExtern() {"
      },
      {
        "txt": "return input == null || input.isExtern(); } public boolean isConst() { return nameNode != null && NodeUtil.isConstantName(nameNode); } public boolean isDefine() { return isDefine; } public Node getInitialValue() { Node parent = getParentNode();"
      },
      {
        "txt": "int pType = parent.getType(); if (pType == Token.FUNCTION) { return parent; } else if (pType == Token.ASSIGN) { return parent.getLastChild(); } else if (pType == Token.VAR) { return nameNode.getFirstChild(); } else { return null; }"
      },
      {
        "txt": "} @Override public JSType getType() { return type; } public Node getNameNode() { return nameNode; } public JSDocInfo getJSDocInfo() { return info;"
      },
      {
        "txt": "} void setType(JSType type) { Preconditions.checkState(isTypeInferred()); this.type = type; } void resolveType(ErrorReporter errorReporter) { if (type != null) { type = type.resolve(errorReporter, scope); } }"
      },
      {
        "txt": "@Override public boolean isTypeInferred() { return typeInferred; } public String getInputName() { if (input == null) return \"<non-file>\"; else return input.getName(); }"
      },
      {
        "txt": "public boolean isNoShadow() { if (info != null && info.isNoShadow()) { return true; } else { return false; } } @Override public boolean equals(Object other) { if (!(other instanceof Var)) { return false;"
      },
      {
        "txt": "} Var otherVar = (Var) other; return otherVar.nameNode == nameNode; } @Override public int hashCode() { return nameNode.hashCode(); } @Override public String toString() { return \"Scope.Var \" + name + \"{\" + type + \"}\";"
      },
      {
        "txt": "} } public static class Arguments extends Var { Arguments(Scope scope) { super( false, // no inferred \"arguments\", // always arguments null, // no declaration node null, // no type info scope,"
      },
      {
        "txt": "-1, // no variable index null, // input, false, // not a define null // no jsdoc ); } @Override public boolean equals(Object other) { if (!(other instanceof Arguments)) { return false; }"
      },
      {
        "txt": "Arguments otherVar = (Arguments) other; return otherVar.scope.getRootNode() == scope.getRootNode(); } @Override public int hashCode() { return System.identityHashCode(this); } } Scope(Scope parent, Node rootNode) { Preconditions.checkNotNull(parent); Preconditions.checkArgument(rootNode != parent.rootNode);"
      },
      {
        "txt": "this.parent = parent; this.rootNode = rootNode; JSType nodeType = rootNode.getJSType(); if (nodeType != null && nodeType.isFunctionType()) { thisType = nodeType.toMaybeFunctionType().getTypeOfThis(); } else { thisType = parent.thisType; } this.isBottom = false; this.depth = parent.depth + 1;"
      },
      {
        "txt": "} Scope(Node rootNode, AbstractCompiler compiler) { this.parent = null; this.rootNode = rootNode; thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); this.isBottom = false; this.depth = 0; } Scope(Node rootNode, ObjectType thisType) { this.parent = null;"
      },
      {
        "txt": "this.rootNode = rootNode; this.thisType = thisType; this.isBottom = true; this.depth = 0; } int getDepth() { return depth; } boolean isBottom() { return isBottom;"
      },
      {
        "txt": "} @Override public Node getRootNode() { return rootNode; } public Scope getParent() { return parent; } Scope getGlobalScope() { Scope result = this;"
      },
      {
        "txt": "while (result.getParent() != null) { result = result.getParent(); } return result; } @Override public StaticScope<JSType> getParentScope() { return parent; } @Override"
      },
      {
        "txt": "public ObjectType getTypeOfThis() { return thisType; } Var declare(String name, Node nameNode, JSType type, CompilerInput input) { return declare(name, nameNode, type, input, true); } Var declare(String name, Node nameNode, JSType type, CompilerInput input, boolean inferred) { Preconditions.checkState(name != null && name.length() > 0); Preconditions.checkState(vars.get(name) == null);"
      },
      {
        "txt": "JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode); Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input, info != null && info.isDefine(), info); vars.put(name, var); return var; } void undeclare(Var var) { Preconditions.checkState(var.scope == this); Preconditions.checkState(vars.get(var.name) == var); vars.remove(var.name);"
      },
      {
        "txt": "} @Override public StaticSlot<JSType> getSlot(String name) { return getVar(name); } @Override public StaticSlot<JSType> getOwnSlot(String name) { return vars.get(name); } public Var getVar(String name) {"
      },
      {
        "txt": "Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { // Recurse up the parent Scope return parent.getVar(name); } else { return null; } } public Var getArgumentsVar() {"
      },
      {
        "txt": "if (arguments == null) { arguments = new Arguments(this); } return arguments; } public boolean isDeclared(String name, boolean recurse) { Scope scope = this; if (scope.vars.containsKey(name)) return true; if (scope.parent != null && recurse) {"
      },
      {
        "txt": "} return false; } public Iterator<Var> getVars() { return vars.values().iterator(); } <extra_id_0> @Override public Iterable<Var> getReferences(Var var) { return ImmutableList.of(var); } @Override public StaticScope<JSType> getScope(Var var) {"
      },
      {
        "txt": "@Override public StaticScope<JSType> getScope(Var var) { return var.scope; } @Override public Iterable<Var> getAllSymbols() { return Collections.unmodifiableCollection(vars.values()); } public int getVarCount() { return vars.size();"
      },
      {
        "txt": "} public boolean isGlobal() { return parent == null; } public boolean isLocal() { return !isGlobal(); } public Iterator<Var> getDeclarativelyUnboundVarsWithoutTypes() { return Iterators.filter( getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);"
      }
    ]
  },
  {
    "id": 764,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 226,
    "end-bug-line": 226,
    "bug": "",
    "fix": "findAliases(t);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass {"
      },
      {
        "txt": "static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\","
      },
      {
        "txt": "\"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\","
      },
      {
        "txt": "\"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) {"
      },
      {
        "txt": "this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) {"
      },
      {
        "txt": "Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent();"
      },
      {
        "txt": "} else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall,"
      },
      {
        "txt": "scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } }"
      },
      {
        "txt": "private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; }"
      },
      {
        "txt": "@Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) {"
      },
      {
        "txt": "this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();"
      },
      {
        "txt": "private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages;"
      },
      {
        "txt": "} List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); <extra_id_0> } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null;"
      },
      {
        "txt": "aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; }"
      },
      {
        "txt": "} return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); }"
      },
      {
        "txt": "int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) {"
      },
      {
        "txt": "compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); }"
      },
      {
        "txt": "if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n);"
      },
      {
        "txt": "} } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() == 2) { int type = n.getType();"
      },
      {
        "txt": "if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return;"
      },
      {
        "txt": "} else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);"
      },
      {
        "txt": "} else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name);"
      },
      {
        "txt": "if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node);"
      },
      {
        "txt": "} } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length();"
      },
      {
        "txt": "} String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null;"
      },
      {
        "txt": "child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 765,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 271,
    "end-bug-line": 271,
    "bug": "",
    "fix": "private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); int type = n.getType(); Node parent = n.getParent(); if (parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS ="
      },
      {
        "txt": "DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler,"
      },
      {
        "txt": "@Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); }"
      },
      {
        "txt": "@Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR &&"
      },
      {
        "txt": "aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent();"
      },
      {
        "txt": "expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); }"
      },
      {
        "txt": "} } private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference;"
      },
      {
        "txt": "this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference;"
      },
      {
        "txt": "private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } }"
      },
      {
        "txt": "private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; }"
      },
      {
        "txt": "private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); }"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null;"
      },
      {
        "txt": "for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar);"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } <extra_id_0> private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY);"
      },
      {
        "txt": "if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) {"
      },
      {
        "txt": "if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString();"
      },
      {
        "txt": "int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));"
      },
      {
        "txt": "} } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 766,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 272,
    "end-bug-line": 272,
    "bug": "",
    "fix": "String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS ="
      },
      {
        "txt": "DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler,"
      },
      {
        "txt": "@Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); }"
      },
      {
        "txt": "@Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR &&"
      },
      {
        "txt": "aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent();"
      },
      {
        "txt": "expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); }"
      },
      {
        "txt": "} } private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference;"
      },
      {
        "txt": "this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference;"
      },
      {
        "txt": "private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } }"
      },
      {
        "txt": "private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; }"
      },
      {
        "txt": "private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); }"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null;"
      },
      {
        "txt": "for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar);"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } <extra_id_0> private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY);"
      },
      {
        "txt": "if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) {"
      },
      {
        "txt": "if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString();"
      },
      {
        "txt": "int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));"
      },
      {
        "txt": "} } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 767,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 273,
    "end-bug-line": 273,
    "bug": "",
    "fix": "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS ="
      },
      {
        "txt": "DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler,"
      },
      {
        "txt": "@Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); }"
      },
      {
        "txt": "@Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR &&"
      },
      {
        "txt": "aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent();"
      },
      {
        "txt": "expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); }"
      },
      {
        "txt": "} } private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference;"
      },
      {
        "txt": "this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference;"
      },
      {
        "txt": "private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } }"
      },
      {
        "txt": "private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; }"
      },
      {
        "txt": "private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); }"
      },
      {
        "txt": "} @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null;"
      },
      {
        "txt": "for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar);"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } <extra_id_0> private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY);"
      },
      {
        "txt": "if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) {"
      },
      {
        "txt": "if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString();"
      },
      {
        "txt": "int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));"
      },
      {
        "txt": "} } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 768,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 303,
    "end-bug-line": 303,
    "bug": "",
    "fix": "if (t.getScopeDepth() < 2) { return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) {"
      },
      {
        "txt": "for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); }"
      },
      {
        "txt": "} for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); }"
      },
      {
        "txt": "if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias(); }"
      },
      {
        "txt": "private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild("
      },
      {
        "txt": "aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; }"
      },
      {
        "txt": "@Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap();"
      },
      {
        "txt": "private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls;"
      },
      {
        "txt": "} boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear();"
      },
      {
        "txt": "transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } }"
      },
      {
        "txt": "return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();"
      },
      {
        "txt": "int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments));"
      },
      {
        "txt": "hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); }"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } <extra_id_0> if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name);"
      },
      {
        "txt": "String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());"
      },
      {
        "txt": "} } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS);"
      },
      {
        "txt": "} else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {"
      },
      {
        "txt": "Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child);"
      },
      {
        "txt": "} } }"
      }
    ]
  },
  {
    "id": 769,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 304,
    "end-bug-line": 304,
    "bug": "",
    "fix": "int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable;"
      },
      {
        "txt": "private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\","
      },
      {
        "txt": "\"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler;"
      },
      {
        "txt": "} @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) {"
      },
      {
        "txt": "for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); }"
      },
      {
        "txt": "} for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); }"
      },
      {
        "txt": "if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias(); }"
      },
      {
        "txt": "private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild("
      },
      {
        "txt": "aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; }"
      },
      {
        "txt": "@Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap();"
      },
      {
        "txt": "private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls;"
      },
      {
        "txt": "} boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear();"
      },
      {
        "txt": "transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } }"
      },
      {
        "txt": "return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();"
      },
      {
        "txt": "int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments));"
      },
      {
        "txt": "hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); }"
      },
      {
        "txt": "} @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } <extra_id_0> if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name);"
      },
      {
        "txt": "String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());"
      },
      {
        "txt": "} } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS);"
      },
      {
        "txt": "} else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {"
      },
      {
        "txt": "Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child);"
      },
      {
        "txt": "} } }"
      }
    ]
  },
  {
    "id": 770,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 307,
    "end-bug-line": 312,
    "bug": "int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar);",
    "fix": "if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler;"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\","
      },
      {
        "txt": "\"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; }"
      },
      {
        "txt": "@Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) {"
      },
      {
        "txt": "aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } }"
      },
      {
        "txt": "for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 ||"
      },
      {
        "txt": "traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage {"
      },
      {
        "txt": "private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree());"
      },
      {
        "txt": "} } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override"
      },
      {
        "txt": "public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false;"
      },
      {
        "txt": "private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; }"
      },
      {
        "txt": "boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent();"
      },
      {
        "txt": "if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null;"
      },
      {
        "txt": "} } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true;"
      },
      {
        "txt": "} private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();"
      },
      {
        "txt": "SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true;"
      },
      {
        "txt": "} private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);"
      },
      {
        "txt": "} else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() == 2) { <extra_id_0> aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else {"
      },
      {
        "txt": "return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString();"
      },
      {
        "txt": "Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) {"
      },
      {
        "txt": "fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) {"
      },
      {
        "txt": "endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } }"
      },
      {
        "txt": "for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 771,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 315,
    "end-bug-line": 317,
    "bug": "String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\";"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" +"
      },
      {
        "txt": "\" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler;"
      },
      {
        "txt": "this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal();"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else {"
      },
      {
        "txt": "aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock);"
      },
      {
        "txt": "NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage {"
      },
      {
        "txt": "public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override"
      },
      {
        "txt": "public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference;"
      },
      {
        "txt": "this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList();"
      },
      {
        "txt": "private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; }"
      },
      {
        "txt": "List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); }"
      },
      {
        "txt": "@Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } } @Override public void exitScope(NodeTraversal t) {"
      },
      {
        "txt": "if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false;"
      },
      {
        "txt": "} } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent();"
      },
      {
        "txt": "} int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error,"
      },
      {
        "txt": "String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY);"
      },
      {
        "txt": "} if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else {"
      },
      {
        "txt": "scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() == 2) {"
      },
      {
        "txt": "if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); <extra_id_0> return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&"
      },
      {
        "txt": "} if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) {"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue();"
      },
      {
        "txt": "aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } }"
      },
      {
        "txt": "} private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName);"
      },
      {
        "txt": "if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 772,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 322,
    "end-bug-line": 322,
    "bug": "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());",
    "fix": "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\","
      },
      {
        "txt": "\"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\","
      },
      {
        "txt": "\"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) {"
      },
      {
        "txt": "hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); }"
      },
      {
        "txt": "for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent();"
      },
      {
        "txt": "Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) {"
      },
      {
        "txt": "compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition;"
      },
      {
        "txt": "AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } }"
      },
      {
        "txt": "private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType);"
      },
      {
        "txt": "} } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() {"
      },
      {
        "txt": "return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors;"
      },
      {
        "txt": "} private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation("
      },
      {
        "txt": "n.getSourceFileName(), getSourceRegion(n)); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } }"
      },
      {
        "txt": "@Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) {"
      },
      {
        "txt": "Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {};"
      },
      {
        "txt": "pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1);"
      },
      {
        "txt": "if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override"
      },
      {
        "txt": "public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name);"
      },
      {
        "txt": "aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { <extra_id_0> } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); }"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } }"
      },
      {
        "txt": "if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } }"
      },
      {
        "txt": "JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) {"
      },
      {
        "txt": "String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode,"
      },
      {
        "txt": "aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 773,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 325,
    "end-bug-line": 328,
    "bug": "if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable;"
      },
      {
        "txt": "class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) {"
      },
      {
        "txt": "aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild("
      },
      {
        "txt": "expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } }"
      },
      {
        "txt": "} private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition;"
      },
      {
        "txt": "} @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType;"
      },
      {
        "txt": "AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() {"
      },
      {
        "txt": "return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL &&"
      },
      {
        "txt": "SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) {"
      },
      {
        "txt": "if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) {"
      },
      {
        "txt": "next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos;"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName ="
      },
      {
        "txt": "transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } <extra_id_0> if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW);"
      },
      {
        "txt": "} else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {"
      },
      {
        "txt": "Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } }"
      },
      {
        "txt": "} } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex);"
      },
      {
        "txt": "Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child);"
      },
      {
        "txt": "} } }"
      }
    ]
  },
  {
    "id": 774,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 342,
    "end-bug-line": 346,
    "bug": "if (n.getType() == Token.NAME) { String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {",
    "fix": "if (aliasVar != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable; class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler;"
      },
      {
        "txt": "private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error( \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\");"
      },
      {
        "txt": "static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable;"
      },
      {
        "txt": "this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal);"
      },
      {
        "txt": "if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) { aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent();"
      },
      {
        "txt": "} } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild( expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock);"
      },
      {
        "txt": "} if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } } } private interface AliasUsage { public void applyAlias();"
      },
      {
        "txt": "} private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition; } @Override public void applyAlias() {"
      },
      {
        "txt": "aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType; AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType;"
      },
      {
        "txt": "} @Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback { private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList();"
      },
      {
        "txt": "private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() { return aliasUsages; } List<Node> getScopeCalls() {"
      },
      {
        "txt": "return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override"
      },
      {
        "txt": "public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } } @Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) {"
      },
      {
        "txt": "aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) { if (parent == null || !isCallToScopeMethod(parent)) { return false; }"
      },
      {
        "txt": "} return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) { next = testNode.getNext(); testNode = testNode.getParent(); }"
      },
      {
        "txt": "int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos; } private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) {"
      },
      {
        "txt": "compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); } if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); }"
      },
      {
        "txt": "if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n);"
      },
      {
        "txt": "} } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() == 2) { int type = n.getType();"
      },
      {
        "txt": "if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return;"
      },
      {
        "txt": "} else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN);"
      },
      {
        "txt": "report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { <extra_id_0> Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); } } JSDocInfo info = n.getJSDocInfo(); if (info != null) {"
      },
      {
        "txt": "JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) {"
      },
      {
        "txt": "String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) { endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode,"
      },
      {
        "txt": "aliasedNode.getQualifiedName() + name.substring(endIndex))); } } for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  },
  {
    "id": 775,
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
    "start-bug-line": 355,
    "end-bug-line": 355,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import javax.annotation.Nullable;"
      },
      {
        "txt": "class ScopedAliases implements HotSwapCompilerPass { static final String SCOPING_METHOD_NAME = \"goog.scope\"; private final AbstractCompiler compiler; private final PreprocessorSymbolTable preprocessorSymbolTable; private final AliasTransformationHandler transformationHandler; static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error( \"JSC_GOOG_SCOPE_USED_IMPROPERLY\", \"The call to goog.scope must be alone in a single statement.\"); static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\", \"The call to goog.scope must take only a single parameter. It must\" + \" be an anonymous function that itself takes no parameters.\"); static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error( \"JSC_GOOG_SCOPE_REFERENCES_THIS\", \"The body of a goog.scope function cannot reference 'this'.\"); static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error( \"JSC_GOOG_SCOPE_USES_RETURN\", \"The body of a goog.scope function cannot use 'return'.\"); static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_GOOG_SCOPE_USES_THROW\", \"The body of a goog.scope function cannot use 'throw'.\"); static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error( \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\", \"The alias {0} is assigned a value more than once.\"); static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error( \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\", \"The local variable {0} is in a goog.scope and is not an alias.\"); ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable,"
      },
      {
        "txt": "AliasTransformationHandler transformationHandler) { this.compiler = compiler; this.preprocessorSymbolTable = preprocessorSymbolTable; this.transformationHandler = transformationHandler; } @Override public void process(Node externs, Node root) { hotSwapScript(root, null); } @Override"
      },
      {
        "txt": "public void hotSwapScript(Node root, Node originalRoot) { Traversal traversal = new Traversal(); NodeTraversal.traverse(compiler, root, traversal); if (!traversal.hasErrors()) { for (AliasUsage aliasUsage : traversal.getAliasUsages()) { aliasUsage.applyAlias(); } for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { if (aliasDefinition.getParent().getType() == Token.VAR && aliasDefinition.getParent().hasOneChild()) {"
      },
      {
        "txt": "aliasDefinition.getParent().detachFromParent(); } else { aliasDefinition.detachFromParent(); } } for (Node scopeCall : traversal.getScopeCalls()) { Node expressionWithScopeCall = scopeCall.getParent(); Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); scopeClosureBlock.detachFromParent(); expressionWithScopeCall.getParent().replaceChild("
      },
      {
        "txt": "expressionWithScopeCall, scopeClosureBlock); NodeUtil.tryMergeBlock(scopeClosureBlock); } if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { compiler.reportCodeChange(); } }"
      },
      {
        "txt": "} private interface AliasUsage { public void applyAlias(); } private class AliasedNode implements AliasUsage { private final Node aliasReference; private final Node aliasDefinition; AliasedNode(Node aliasReference, Node aliasDefinition) { this.aliasReference = aliasReference; this.aliasDefinition = aliasDefinition;"
      },
      {
        "txt": "} @Override public void applyAlias() { aliasReference.getParent().replaceChild( aliasReference, aliasDefinition.cloneTree()); } } private class AliasedTypeNode implements AliasUsage { private final Node aliasReference; private final String correctedType;"
      },
      {
        "txt": "AliasedTypeNode(Node aliasReference, String correctedType) { this.aliasReference = aliasReference; this.correctedType = correctedType; } @Override public void applyAlias() { aliasReference.setString(correctedType); } } private class Traversal implements NodeTraversal.ScopedCallback {"
      },
      {
        "txt": "private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList(); private final List<Node> scopeCalls = Lists.newArrayList(); private final List<AliasUsage> aliasUsages = Lists.newArrayList(); private final Map<String, Var> aliases = Maps.newHashMap(); private boolean hasErrors = false; private AliasTransformation transformation = null; Collection<Node> getAliasDefinitionsInOrder() { return aliasDefinitionsInOrder; } private List<AliasUsage> getAliasUsages() {"
      },
      {
        "txt": "return aliasUsages; } List<Node> getScopeCalls() { return scopeCalls; } boolean hasErrors() { return hasErrors; } private boolean isCallToScopeMethod(Node n) { return n.getType() == Token.CALL &&"
      },
      {
        "txt": "SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); } @Override public void enterScope(NodeTraversal t) { Node n = t.getCurrentNode().getParent(); if (n != null && isCallToScopeMethod(n)) { transformation = transformationHandler.logAliasTransformation( n.getSourceFileName(), getSourceRegion(n)); } }"
      },
      {
        "txt": "@Override public void exitScope(NodeTraversal t) { if (t.getScopeDepth() == 2) { aliases.clear(); transformation = null; } } @Override public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.FUNCTION && t.inGlobalScope()) {"
      },
      {
        "txt": "if (parent == null || !isCallToScopeMethod(parent)) { return false; } } return true; } private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.getType() == Token.SCRIPT;) {"
      },
      {
        "txt": "next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() {}; pos.setPositionInformation( n.getLineno(), n.getCharno(), endLine, endChar); return pos;"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { compiler.report(t.makeError(n, error, arguments)); hasErrors = true; } private void validateScopeCall(NodeTraversal t, Node n, Node parent) { if (preprocessorSymbolTable != null) { preprocessorSymbolTable.addReference(n.getFirstChild()); }"
      },
      {
        "txt": "if (!NodeUtil.isExpressionNode(parent)) { report(t, n, GOOG_SCOPE_USED_IMPROPERLY); } if (n.getChildCount() != 2) { report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { Node anonymousFnNode = n.getChildAtIndex(1); if (!NodeUtil.isFunction(anonymousFnNode) || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {"
      },
      {
        "txt": "report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); } else { scopeCalls.add(n); } } } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent());"
      },
      {
        "txt": "} if (t.getScopeDepth() == 2) { int type = n.getType(); if (type == Token.NAME && parent.getType() == Token.VAR) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = t.getScope().getVar(name); aliases.put(name, aliasVar); aliasDefinitionsInOrder.add(n); String qualifiedName ="
      },
      {
        "txt": "aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); return; } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());"
      },
      {
        "txt": "} if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) {"
      },
      {
        "txt": "String name = n.getString(); Var aliasVar = aliases.get(name); if (aliasVar != null && t.getScope().getVar(name) == aliasVar) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedNode(n, aliasedNode)); <extra_id_0> } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); }"
      },
      {
        "txt": "fixTypeNode(node); } } } } private void fixTypeNode(Node typeNode) { if (typeNode.getType() == Token.STRING) { String name = typeNode.getString(); int endIndex = name.indexOf('.'); if (endIndex == -1) {"
      },
      {
        "txt": "endIndex = name.length(); } String baseName = name.substring(0, endIndex); Var aliasVar = aliases.get(baseName); if (aliasVar != null) { Node aliasedNode = aliasVar.getInitialValue(); aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex))); } }"
      },
      {
        "txt": "for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { fixTypeNode(child); } } }"
      }
    ]
  }
]