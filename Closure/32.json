[
  {
    "id": 269,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1358,
    "end-bug-line": 1358,
    "bug": "",
    "fix": "int lineStartChar = -1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet; import java.util.List; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser {"
      },
      {
        "txt": "void addParserWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno,"
      },
      {
        "txt": "int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId),"
      },
      {
        "txt": "getSourceName(), lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;"
      },
      {
        "txt": "void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE,"
      },
      {
        "txt": "NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream; this.associatedNode = associatedNode; this.sourceFile = associatedNode == null"
      },
      {
        "txt": "? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); }"
      },
      {
        "txt": "private String getSourceName() { return sourceFile == null ? null : sourceFile.getName(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);"
      },
      {
        "txt": "JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno;"
      },
      {
        "txt": "int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) {"
      },
      {
        "txt": "jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } } retry: for (;;) { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC:"
      },
      {
        "txt": "if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description);"
      },
      {
        "txt": "token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string;"
      },
      {
        "txt": "token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry;"
      },
      {
        "txt": "case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); }"
      },
      {
        "txt": "} token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression("
      },
      {
        "txt": "parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token);"
      },
      {
        "txt": "continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS:"
      },
      {
        "txt": "case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; }"
      },
      {
        "txt": "if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode);"
      },
      {
        "txt": "if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); }"
      },
      {
        "txt": "} token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true;"
      },
      {
        "txt": "} if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS:"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); }"
      },
      {
        "txt": "if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) {"
      },
      {
        "txt": "token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) {"
      },
      {
        "txt": "name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } }"
      },
      {
        "txt": "} if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string;"
      },
      {
        "txt": "if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY:"
      },
      {
        "txt": "if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference);"
      },
      {
        "txt": "} token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE:"
      },
      {
        "txt": "ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = templateInfo.token; continue retry; case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION:"
      },
      {
        "txt": "ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) {"
      },
      {
        "txt": "typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break;"
      },
      {
        "txt": "} if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); }"
      },
      {
        "txt": "token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); } break; } } token = eatTokensUntilEOL(); continue retry; } } }"
      },
      {
        "txt": "break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default:"
      },
      {
        "txt": "if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next();"
      },
      {
        "txt": "} } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else {"
      },
      {
        "txt": "if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>();"
      },
      {
        "txt": "while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } }"
      },
      {
        "txt": "if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "} return token; } private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name)"
      },
      {
        "txt": "&& !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token;"
      },
      {
        "txt": "} if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; }"
      },
      {
        "txt": "private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);"
      },
      {
        "txt": "} private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,"
      },
      {
        "txt": "endLineno, endCharno, true); } return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) {"
      },
      {
        "txt": "typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno();"
      },
      {
        "txt": "jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC); } return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG:"
      },
      {
        "txt": "return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC:"
      },
      {
        "txt": "return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB:"
      },
      {
        "txt": "return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS:"
      },
      {
        "txt": "return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName());"
      },
      {
        "txt": "} private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo {"
      },
      {
        "txt": "final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() {"
      },
      {
        "txt": "stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); }"
      },
      {
        "txt": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,"
      },
      {
        "txt": "WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "} StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; <extra_id_0> do { switch (token) { case STAR: if (ignoreStar) { } else { if (builder.length() > 0) {"
      },
      {
        "txt": "} else { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) {"
      },
      {
        "txt": "builder.append(\"\\n\"); } ignoreStar = true; token = next(); continue; default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (token == JsDocToken.EOC || token == JsDocToken.EOF ||"
      },
      {
        "txt": "(token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno,"
      },
      {
        "txt": "endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "line = trimEnd(line); } builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true;"
      },
      {
        "txt": "do { switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' ');"
      },
      {
        "txt": "} builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue;"
      },
      {
        "txt": "default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next();"
      },
      {
        "txt": "} } while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else {"
      },
      {
        "txt": "break; } } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) {"
      },
      {
        "txt": "skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } }"
      },
      {
        "txt": "return typeNode; } else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next();"
      },
      {
        "txt": "if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs();"
      },
      {
        "txt": "if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else {"
      },
      {
        "txt": "next(); } } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) {"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token);"
      },
      {
        "txt": "} } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); }"
      },
      {
        "txt": "skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) {"
      },
      {
        "txt": "return null; } Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null;"
      },
      {
        "txt": "} typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS ||"
      },
      {
        "txt": "token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next()));"
      },
      {
        "txt": "} else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); }"
      },
      {
        "txt": "} return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next());"
      },
      {
        "txt": "} else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs();"
      },
      {
        "txt": "return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); }"
      },
      {
        "txt": "private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next());"
      },
      {
        "txt": "if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode;"
      },
      {
        "txt": "} private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) {"
      },
      {
        "txt": "token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs();"
      },
      {
        "txt": "Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); }"
      },
      {
        "txt": "if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) {"
      },
      {
        "txt": "parameters = parseParametersType(token); if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); }"
      },
      {
        "txt": "return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next();"
      },
      {
        "txt": "skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs();"
      },
      {
        "txt": "next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); }"
      },
      {
        "txt": "} if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); }"
      },
      {
        "txt": "if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); }"
      },
      {
        "txt": "token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) {"
      },
      {
        "txt": "return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) {"
      },
      {
        "txt": "skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next();"
      },
      {
        "txt": "} expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false;"
      },
      {
        "txt": "do { if (arg != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else {"
      },
      {
        "txt": "arg = parseTypeExpression(token); } if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs();"
      },
      {
        "txt": "} while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token);"
      },
      {
        "txt": "if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType;"
      },
      {
        "txt": "} private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) {"
      },
      {
        "txt": "Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs();"
      },
      {
        "txt": "Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) {"
      },
      {
        "txt": "switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) { return n == null ? null :"
      },
      {
        "txt": "new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "private Node newStringNode(String s, int lineno, int charno) { Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() :"
      },
      {
        "txt": "null); return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); }"
      },
      {
        "txt": "private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; }"
      },
      {
        "txt": "token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next();"
      },
      {
        "txt": "return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else {"
      },
      {
        "txt": "return current(); } } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) {"
      },
      {
        "txt": "next(); if (match(JsDocToken.STAR)) { next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() {"
      },
      {
        "txt": "return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false;"
      },
      {
        "txt": "int c; while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break;"
      },
      {
        "txt": "} } stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 270,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1364,
    "end-bug-line": 1364,
    "bug": "",
    "fix": "lineStartChar = stream.getCharno() + 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder;"
      },
      {
        "txt": "private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno);"
      },
      {
        "txt": "} void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg),"
      },
      {
        "txt": "getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null;"
      },
      {
        "txt": "private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; }"
      },
      {
        "txt": "void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, Comment commentNode,"
      },
      {
        "txt": "Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream; this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());"
      },
      {
        "txt": "} this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName(); } public static Node parseTypeString(String typeString) {"
      },
      {
        "txt": "Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, null,"
      },
      {
        "txt": "config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs();"
      },
      {
        "txt": "JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION &&"
      },
      {
        "txt": "token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } } retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno();"
      },
      {
        "txt": "charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR:"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token;"
      },
      {
        "txt": "} else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) {"
      },
      {
        "txt": "if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason);"
      },
      {
        "txt": "} token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW:"
      },
      {
        "txt": "String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token,"
      },
      {
        "txt": "WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM:"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\"));"
      },
      {
        "txt": "} if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno();"
      },
      {
        "txt": "charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno();"
      },
      {
        "txt": "charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else {"
      },
      {
        "txt": "Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);"
      },
      {
        "txt": "} token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current();"
      },
      {
        "txt": "jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) {"
      },
      {
        "txt": "type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "} String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else {"
      },
      {
        "txt": "name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name,"
      },
      {
        "txt": "lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry;"
      },
      {
        "txt": "} jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); }"
      },
      {
        "txt": "token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED:"
      },
      {
        "txt": "if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry;"
      },
      {
        "txt": "case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock();"
      },
      {
        "txt": "String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token);"
      },
      {
        "txt": "} continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE:"
      },
      {
        "txt": "case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK);"
      },
      {
        "txt": "} else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); }"
      },
      {
        "txt": "} type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); }"
      },
      {
        "txt": "break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; }"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();"
      },
      {
        "txt": "} checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL:"
      },
      {
        "txt": "if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else {"
      },
      {
        "txt": "state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) {"
      },
      {
        "txt": "if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); }"
      },
      {
        "txt": "} } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; }"
      },
      {
        "txt": "if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private JsDocToken parseModifiesTag(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else {"
      },
      {
        "txt": "break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } } return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {"
      },
      {
        "txt": "return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno();"
      },
      {
        "txt": "int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); } return typeNode; }"
      },
      {
        "txt": "private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); }"
      },
      {
        "txt": "if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC); } return typeNode;"
      },
      {
        "txt": "} private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\"; case COLON:"
      },
      {
        "txt": "return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\"; case LP: return \"(\"; case LT:"
      },
      {
        "txt": "return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\"; case RC: return \"}\"; case RP:"
      },
      {
        "txt": "return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString(); default:"
      },
      {
        "txt": "throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo { private final String string; private final JsDocToken token;"
      },
      {
        "txt": "public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) {"
      },
      {
        "txt": "this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim();"
      },
      {
        "txt": "if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption {"
      },
      {
        "txt": "PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token);"
      },
      {
        "txt": "} stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line);"
      },
      {
        "txt": "token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (ignoreStar) { <extra_id_0> if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next();"
      },
      {
        "txt": "} token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); } ignoreStar = true; token = next(); continue;"
      },
      {
        "txt": "default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim();"
      },
      {
        "txt": "} int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); }"
      },
      {
        "txt": "} while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) { case ANNOTATION: case EOC: case EOF:"
      },
      {
        "txt": "return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue;"
      },
      {
        "txt": "case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false;"
      },
      {
        "txt": "builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true); } private static String trimEnd(String s) { int trimCount = 0;"
      },
      {
        "txt": "while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; } } if (trimCount == 0) { return s;"
      },
      {
        "txt": "} return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeExpression(token); } }"
      },
      {
        "txt": "private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); }"
      },
      {
        "txt": "restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs();"
      },
      {
        "txt": "typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; }"
      },
      {
        "txt": "private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next();"
      },
      {
        "txt": "} } return typeNode; } else { return parseTypeName(token); } } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) {"
      },
      {
        "txt": "if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } }"
      },
      {
        "txt": "return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; } Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr); } return typeList; }"
      },
      {
        "txt": "private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token);"
      },
      {
        "txt": "return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next();"
      },
      {
        "txt": "return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs();"
      },
      {
        "txt": "return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token);"
      },
      {
        "txt": "} } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString();"
      },
      {
        "txt": "int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); } }"
      },
      {
        "txt": "Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");"
      },
      {
        "txt": "} next(); } } return typeNameNode; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");"
      },
      {
        "txt": "} Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr);"
      },
      {
        "txt": "boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null;"
      },
      {
        "txt": "} functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else {"
      },
      {
        "txt": "hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } }"
      },
      {
        "txt": "} if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next());"
      },
      {
        "txt": "if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false;"
      },
      {
        "txt": "Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token);"
      },
      {
        "txt": "if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType);"
      },
      {
        "txt": "if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; }"
      },
      {
        "txt": "private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID);"
      },
      {
        "txt": "} else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) {"
      },
      {
        "txt": "union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE;"
      },
      {
        "txt": "if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; }"
      },
      {
        "txt": "union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union;"
      },
      {
        "txt": "} private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; }"
      },
      {
        "txt": "array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next();"
      },
      {
        "txt": "return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token);"
      },
      {
        "txt": "if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON);"
      },
      {
        "txt": "fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default:"
      },
      {
        "txt": "return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(),"
      },
      {
        "txt": "stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) { Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); n.setLength(s.length()); return n; }"
      },
      {
        "txt": "private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null); return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do {"
      },
      {
        "txt": "if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN;"
      },
      {
        "txt": "private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2;"
      },
      {
        "txt": "} private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); } } private JsDocToken current() { JsDocToken t = unreadToken;"
      },
      {
        "txt": "unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next(); } }"
      },
      {
        "txt": "} private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); }"
      },
      {
        "txt": "JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) { c = stream.getChar(); if (c == ' ') { continue;"
      },
      {
        "txt": "} else if (c == '{') { matchedLc = true; break; } else { break; } } stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 271,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1382,
    "end-bug-line": 1382,
    "bug": "",
    "fix": "lineStartChar = 0;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile;"
      },
      {
        "txt": "import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter;"
      },
      {
        "txt": "private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId),"
      },
      {
        "txt": "getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames;"
      },
      {
        "txt": "static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; }"
      },
      {
        "txt": "private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) {"
      },
      {
        "txt": "this.stream = stream; this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames;"
      },
      {
        "txt": "this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(),"
      },
      {
        "txt": "false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next());"
      },
      {
        "txt": "} boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); }"
      },
      {
        "txt": "} retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName);"
      },
      {
        "txt": "if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string;"
      },
      {
        "txt": "if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry;"
      },
      {
        "txt": "case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) {"
      },
      {
        "txt": "if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) {"
      },
      {
        "txt": "token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) {"
      },
      {
        "txt": "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry;"
      },
      {
        "txt": "case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false;"
      },
      {
        "txt": "if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry;"
      },
      {
        "txt": "case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression("
      },
      {
        "txt": "parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry;"
      },
      {
        "txt": "case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) {"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token;"
      },
      {
        "txt": "if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next();"
      },
      {
        "txt": "if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type);"
      },
      {
        "txt": "} } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,"
      },
      {
        "txt": "lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token);"
      },
      {
        "txt": "} continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS:"
      },
      {
        "txt": "token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE:"
      },
      {
        "txt": "case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next();"
      },
      {
        "txt": "typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) {"
      },
      {
        "txt": "} else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break;"
      },
      {
        "txt": "case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; } } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "} } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true;"
      },
      {
        "txt": "case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; }"
      },
      {
        "txt": "token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "} } token = next(); } } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\","
      },
      {
        "txt": "typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); } } } }"
      },
      {
        "txt": "private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else {"
      },
      {
        "txt": "break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } } return token; } private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) {"
      },
      {
        "txt": "if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } }"
      },
      {
        "txt": "if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "} return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); }"
      },
      {
        "txt": "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) {"
      },
      {
        "txt": "int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); } return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC,"
      },
      {
        "txt": "boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); }"
      },
      {
        "txt": "if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC); } return typeNode; } private String toString(JsDocToken token) { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\";"
      },
      {
        "txt": "case LB: return \"[\"; case LC: return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\";"
      },
      {
        "txt": "case PIPE: return \"|\"; case RB: return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\";"
      },
      {
        "txt": "case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } }"
      },
      {
        "txt": "private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token;"
      },
      {
        "txt": "} } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno;"
      },
      {
        "txt": "} } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length());"
      },
      {
        "txt": "} return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE"
      },
      {
        "txt": "} @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno();"
      },
      {
        "txt": "int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false;"
      },
      {
        "txt": "do { switch (token) { case STAR: if (ignoreStar) { } else { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); }"
      },
      {
        "txt": "continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); } ignoreStar = true; <extra_id_0> continue; default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (token == JsDocToken.EOC || token == JsDocToken.EOF ||"
      },
      {
        "txt": "if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno();"
      },
      {
        "txt": "if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token));"
      },
      {
        "txt": "line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) {"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) {"
      },
      {
        "txt": "if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n');"
      },
      {
        "txt": "token = next(); continue; default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line);"
      },
      {
        "txt": "builder.append(line); token = next(); } } while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) {"
      },
      {
        "txt": "trimCount++; } else { break; } } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); }"
      },
      {
        "txt": "private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next();"
      },
      {
        "txt": "} } return typeNode; } else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs();"
      },
      {
        "txt": "boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token);"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs();"
      },
      {
        "txt": "Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode;"
      },
      {
        "txt": "} else { return parseTypeName(token); } } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "next(); } skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) {"
      },
      {
        "txt": "Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; } Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next());"
      },
      {
        "txt": "if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next();"
      },
      {
        "txt": "if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token));"
      },
      {
        "txt": "} else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next();"
      },
      {
        "txt": "return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) {"
      },
      {
        "txt": "skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString();"
      },
      {
        "txt": "if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } restoreLookAhead(token);"
      },
      {
        "txt": "return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) &&"
      },
      {
        "txt": "typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next(); typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next();"
      },
      {
        "txt": "skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); }"
      },
      {
        "txt": "} return typeNameNode; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null;"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) {"
      },
      {
        "txt": "next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false; } }"
      },
      {
        "txt": "} if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters);"
      },
      {
        "txt": "} skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else {"
      },
      {
        "txt": "functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do {"
      },
      {
        "txt": "if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else {"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");"
      },
      {
        "txt": "} skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next();"
      },
      {
        "txt": "paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; }"
      },
      {
        "txt": "} while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) {"
      },
      {
        "txt": "return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); }"
      },
      {
        "txt": "} private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null;"
      },
      {
        "txt": "do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); }"
      },
      {
        "txt": "skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) {"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB);"
      },
      {
        "txt": "Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));"
      },
      {
        "txt": "hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break;"
      },
      {
        "txt": "} skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) {"
      },
      {
        "txt": "Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next();"
      },
      {
        "txt": "recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; }"
      },
      {
        "txt": "fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs(); token = next(); } while (true); return fieldTypeList;"
      },
      {
        "txt": "} private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; }"
      },
      {
        "txt": "next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType;"
      },
      {
        "txt": "} private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default: return null; } }"
      },
      {
        "txt": "private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) {"
      },
      {
        "txt": "return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) { Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile("
      },
      {
        "txt": "this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null); return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION;"
      },
      {
        "txt": "return token; } token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; }"
      },
      {
        "txt": "private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) {"
      },
      {
        "txt": "return stream.getJsDocToken(); } else { return current(); } } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; }"
      },
      {
        "txt": "private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview();"
      },
      {
        "txt": "} boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; }"
      },
      {
        "txt": "private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break;"
      },
      {
        "txt": "} else { break; } } stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 272,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1389,
    "end-bug-line": 1389,
    "bug": "",
    "fix": "boolean isEOC = token == JsDocToken.EOC; if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class JsDocInfoParser {"
      },
      {
        "txt": "private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning("
      },
      {
        "txt": "\"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); }"
      },
      {
        "txt": "} private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {"
      },
      {
        "txt": "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION }"
      },
      {
        "txt": "JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream; this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);"
      },
      {
        "txt": "if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName();"
      },
      {
        "txt": "} public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString),"
      },
      {
        "txt": "null, null, config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno; JSTypeExpression type;"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); }"
      },
      {
        "txt": "} else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } } retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) {"
      },
      {
        "txt": "state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno);"
      },
      {
        "txt": "switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author);"
      },
      {
        "txt": "} token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string;"
      },
      {
        "txt": "if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry;"
      },
      {
        "txt": "} case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE:"
      },
      {
        "txt": "ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token;"
      },
      {
        "txt": "continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); }"
      },
      {
        "txt": "if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT:"
      },
      {
        "txt": "if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs();"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode("
      },
      {
        "txt": "token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo("
      },
      {
        "txt": "type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next();"
      },
      {
        "txt": "if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token;"
      },
      {
        "txt": "if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC:"
      },
      {
        "txt": "case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "} token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); }"
      },
      {
        "txt": "token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\","
      },
      {
        "txt": "lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); }"
      },
      {
        "txt": "} if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) {"
      },
      {
        "txt": "if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } } if (name == null) {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name,"
      },
      {
        "txt": "paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES:"
      },
      {
        "txt": "token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE:"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token;"
      },
      {
        "txt": "} else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string;"
      },
      {
        "txt": "if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry;"
      },
      {
        "txt": "case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string;"
      },
      {
        "txt": "if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token;"
      },
      {
        "txt": "continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() &&"
      },
      {
        "txt": "annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) {"
      },
      {
        "txt": "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\","
      },
      {
        "txt": "lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "break; } } token = eatTokensUntilEOL(); continue retry; } } } break; case EOC:"
      },
      {
        "txt": "if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes);"
      },
      {
        "txt": "return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next();"
      },
      {
        "txt": "continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
      },
      {
        "txt": "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token;"
      },
      {
        "txt": "} private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,"
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next();"
      },
      {
        "txt": "if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC);"
      },
      {
        "txt": "} private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) {"
      },
      {
        "txt": "Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); }"
      },
      {
        "txt": "return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else {"
      },
      {
        "txt": "typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);"
      },
      {
        "txt": "} return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA:"
      },
      {
        "txt": "return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\"; case LP:"
      },
      {
        "txt": "return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\"; case RC:"
      },
      {
        "txt": "return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING:"
      },
      {
        "txt": "return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo {"
      },
      {
        "txt": "private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno;"
      },
      {
        "txt": "final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno();"
      },
      {
        "txt": "int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);"
      },
      {
        "txt": "} private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL ||"
      },
      {
        "txt": "token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); }"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (ignoreStar) { } else {"
      },
      {
        "txt": "if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\");"
      },
      {
        "txt": "ignoreStar = true; token = next(); continue; default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; <extra_id_0> if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); }"
      },
      {
        "txt": "return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); }"
      },
      {
        "txt": "builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*');"
      },
      {
        "txt": "} token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true);"
      },
      {
        "txt": "} private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; }"
      },
      {
        "txt": "} if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next());"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else {"
      },
      {
        "txt": "return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next();"
      },
      {
        "txt": "if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode);"
      },
      {
        "txt": "} else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); }"
      },
      {
        "txt": "} return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token); } }"
      },
      {
        "txt": "private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next();"
      },
      {
        "txt": "return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; }"
      },
      {
        "txt": "Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr);"
      },
      {
        "txt": "} return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC ||"
      },
      {
        "txt": "token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token);"
      },
      {
        "txt": "if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr;"
      },
      {
        "txt": "} } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs();"
      },
      {
        "txt": "return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) {"
      },
      {
        "txt": "return newStringNode(string); } else { return parseTypeName(token); } } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) {"
      },
      {
        "txt": "return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next();"
      },
      {
        "txt": "typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType);"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode; } private Node parseFunctionType(JsDocToken token) {"
      },
      {
        "txt": "if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true;"
      },
      {
        "txt": "if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW,"
      },
      {
        "txt": "parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next();"
      },
      {
        "txt": "skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) {"
      },
      {
        "txt": "return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");"
      },
      {
        "txt": "} skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; }"
      },
      {
        "txt": "private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); }"
      },
      {
        "txt": "next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); }"
      },
      {
        "txt": "isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) {"
      },
      {
        "txt": "return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");"
      },
      {
        "txt": "} return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); }"
      },
      {
        "txt": "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next();"
      },
      {
        "txt": "Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token);"
      },
      {
        "txt": "if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); }"
      },
      {
        "txt": "next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) {"
      },
      {
        "txt": "next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); }"
      },
      {
        "txt": "if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning();"
      },
      {
        "txt": "} skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) {"
      },
      {
        "txt": "Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break;"
      },
      {
        "txt": "} next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) {"
      },
      {
        "txt": "return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) {"
      },
      {
        "txt": "return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING:"
      },
      {
        "txt": "String string = stream.getString(); return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode);"
      },
      {
        "txt": "} private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) { Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);"
      },
      {
        "txt": "n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null); return templateNode;"
      },
      {
        "txt": "} private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next());"
      },
      {
        "txt": "} private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true);"
      },
      {
        "txt": "} private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; }"
      },
      {
        "txt": "private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); }"
      },
      {
        "txt": "} private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) {"
      },
      {
        "txt": "next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); }"
      },
      {
        "txt": "JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) {"
      },
      {
        "txt": "c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break; } }"
      },
      {
        "txt": "stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 273,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1390,
    "end-bug-line": 1390,
    "bug": "",
    "fix": "builder.append(' '); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class JsDocInfoParser {"
      },
      {
        "txt": "private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning("
      },
      {
        "txt": "\"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); }"
      },
      {
        "txt": "} private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {"
      },
      {
        "txt": "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION }"
      },
      {
        "txt": "JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream; this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);"
      },
      {
        "txt": "if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName();"
      },
      {
        "txt": "} public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString),"
      },
      {
        "txt": "null, null, config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno; JSTypeExpression type;"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); }"
      },
      {
        "txt": "} else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } } retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) {"
      },
      {
        "txt": "state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno);"
      },
      {
        "txt": "switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author);"
      },
      {
        "txt": "} token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string;"
      },
      {
        "txt": "if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry;"
      },
      {
        "txt": "} case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE:"
      },
      {
        "txt": "ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token;"
      },
      {
        "txt": "continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); }"
      },
      {
        "txt": "if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT:"
      },
      {
        "txt": "if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs();"
      },
      {
        "txt": "token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode("
      },
      {
        "txt": "token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo("
      },
      {
        "txt": "type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next();"
      },
      {
        "txt": "if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "} else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token;"
      },
      {
        "txt": "if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC:"
      },
      {
        "txt": "case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "} token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); }"
      },
      {
        "txt": "token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\","
      },
      {
        "txt": "lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); }"
      },
      {
        "txt": "} if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) {"
      },
      {
        "txt": "if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno); } } } if (name == null) {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name,"
      },
      {
        "txt": "paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES:"
      },
      {
        "txt": "token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE:"
      },
      {
        "txt": "if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token;"
      },
      {
        "txt": "} else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string;"
      },
      {
        "txt": "if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry;"
      },
      {
        "txt": "case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string;"
      },
      {
        "txt": "if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token;"
      },
      {
        "txt": "continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() &&"
      },
      {
        "txt": "annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) {"
      },
      {
        "txt": "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\","
      },
      {
        "txt": "lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) {"
      },
      {
        "txt": "ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else {"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "break; } } token = eatTokensUntilEOL(); continue retry; } } } break; case EOC:"
      },
      {
        "txt": "if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes);"
      },
      {
        "txt": "return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next();"
      },
      {
        "txt": "continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
      },
      {
        "txt": "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token;"
      },
      {
        "txt": "} private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,"
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next();"
      },
      {
        "txt": "if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC);"
      },
      {
        "txt": "} private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) {"
      },
      {
        "txt": "Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); }"
      },
      {
        "txt": "return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else {"
      },
      {
        "txt": "typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);"
      },
      {
        "txt": "} return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA:"
      },
      {
        "txt": "return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\"; case LP:"
      },
      {
        "txt": "return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\"; case RC:"
      },
      {
        "txt": "return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING:"
      },
      {
        "txt": "return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo {"
      },
      {
        "txt": "private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno;"
      },
      {
        "txt": "final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno();"
      },
      {
        "txt": "int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);"
      },
      {
        "txt": "} private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL ||"
      },
      {
        "txt": "token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); }"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (ignoreStar) { } else {"
      },
      {
        "txt": "if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\");"
      },
      {
        "txt": "ignoreStar = true; token = next(); continue; default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; <extra_id_0> if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); }"
      },
      {
        "txt": "return new ExtractionInfo(multilineText, token); } if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); }"
      },
      {
        "txt": "builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*');"
      },
      {
        "txt": "} token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true);"
      },
      {
        "txt": "} private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; }"
      },
      {
        "txt": "} if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next());"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else {"
      },
      {
        "txt": "return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next();"
      },
      {
        "txt": "if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode);"
      },
      {
        "txt": "} else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); }"
      },
      {
        "txt": "} return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token); } }"
      },
      {
        "txt": "private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next();"
      },
      {
        "txt": "return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; }"
      },
      {
        "txt": "Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr);"
      },
      {
        "txt": "} return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC ||"
      },
      {
        "txt": "token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token);"
      },
      {
        "txt": "if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr;"
      },
      {
        "txt": "} } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs();"
      },
      {
        "txt": "return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) {"
      },
      {
        "txt": "return newStringNode(string); } else { return parseTypeName(token); } } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) {"
      },
      {
        "txt": "return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) { next();"
      },
      {
        "txt": "typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeNameNode.addChildToFront(memberType);"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode; } private Node parseFunctionType(JsDocToken token) {"
      },
      {
        "txt": "if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true;"
      },
      {
        "txt": "if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode( isThis ? Token.THIS : Token.NEW,"
      },
      {
        "txt": "parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next();"
      },
      {
        "txt": "skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) {"
      },
      {
        "txt": "return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");"
      },
      {
        "txt": "} skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; }"
      },
      {
        "txt": "private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); }"
      },
      {
        "txt": "next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); }"
      },
      {
        "txt": "isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) {"
      },
      {
        "txt": "return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");"
      },
      {
        "txt": "} return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); }"
      },
      {
        "txt": "private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next();"
      },
      {
        "txt": "Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token);"
      },
      {
        "txt": "if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); }"
      },
      {
        "txt": "next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) {"
      },
      {
        "txt": "next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); }"
      },
      {
        "txt": "if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning();"
      },
      {
        "txt": "} skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) {"
      },
      {
        "txt": "Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break;"
      },
      {
        "txt": "} next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) {"
      },
      {
        "txt": "return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) {"
      },
      {
        "txt": "return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING:"
      },
      {
        "txt": "String string = stream.getString(); return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode);"
      },
      {
        "txt": "} private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) { Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);"
      },
      {
        "txt": "n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null); return templateNode;"
      },
      {
        "txt": "} private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next());"
      },
      {
        "txt": "} private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next(); } while (true);"
      },
      {
        "txt": "} private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; }"
      },
      {
        "txt": "private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); }"
      },
      {
        "txt": "} private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) {"
      },
      {
        "txt": "next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); }"
      },
      {
        "txt": "JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c; while (true) {"
      },
      {
        "txt": "c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break; } }"
      },
      {
        "txt": "stream.ungetChar(c); return matchedLc; }"
      }
    ]
  },
  {
    "id": 274,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1414,
    "end-bug-line": 1416,
    "bug": "if (builder.length() > 0) { builder.append(' '); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.Set; public final class JsDocInfoParser { private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser();"
      },
      {
        "txt": "private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno);"
      },
      {
        "txt": "} void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning("
      },
      {
        "txt": "\"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords ="
      },
      {
        "txt": "ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State {"
      },
      {
        "txt": "SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream;"
      },
      {
        "txt": "this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter;"
      },
      {
        "txt": "this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName(); } public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false,"
      },
      {
        "txt": "LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); }"
      },
      {
        "txt": "boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token);"
      },
      {
        "txt": "token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } }"
      },
      {
        "txt": "retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry;"
      },
      {
        "txt": "case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token,"
      },
      {
        "txt": "WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) {"
      },
      {
        "txt": "fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null;"
      },
      {
        "txt": "if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "} token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next();"
      },
      {
        "txt": "matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);"
      },
      {
        "txt": "} type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\","
      },
      {
        "txt": "lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL &&"
      },
      {
        "txt": "token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN:"
      },
      {
        "txt": "if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) {"
      },
      {
        "txt": "token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING:"
      },
      {
        "txt": "ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token));"
      },
      {
        "txt": "if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM:"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) {"
      },
      {
        "txt": "token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) {"
      },
      {
        "txt": "token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); }"
      },
      {
        "txt": "} if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);"
      },
      {
        "txt": "} } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next());"
      },
      {
        "txt": "continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF:"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token);"
      },
      {
        "txt": "} if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else {"
      },
      {
        "txt": "switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription("
      },
      {
        "txt": "returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF:"
      },
      {
        "txt": "if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; } } token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "} } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF:"
      },
      {
        "txt": "jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next();"
      },
      {
        "txt": "continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; }"
      },
      {
        "txt": "} token = next(); } } private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno);"
      },
      {
        "txt": "} } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString());"
      },
      {
        "txt": "token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break;"
      },
      {
        "txt": "} } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} } } return token; } private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name, stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } }"
      },
      {
        "txt": "return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,"
      },
      {
        "txt": "int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) { int endLineno = stream.getLineno();"
      },
      {
        "txt": "int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); } return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) {"
      },
      {
        "txt": "Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } if (typeNode != null) {"
      },
      {
        "txt": "int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC); } return typeNode; } private String toString(JsDocToken token) { switch (token) { case ANNOTATION:"
      },
      {
        "txt": "return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB:"
      },
      {
        "txt": "return \"[\"; case LC: return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE:"
      },
      {
        "txt": "return \"|\"; case RB: return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS:"
      },
      {
        "txt": "return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) {"
      },
      {
        "txt": "return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; }"
      },
      {
        "txt": "} private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type; this.lineno = lineno; this.charno = charno; }"
      },
      {
        "txt": "} private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); }"
      },
      {
        "txt": "return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE }"
      },
      {
        "txt": "@SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1;"
      },
      {
        "txt": "String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do {"
      },
      {
        "txt": "switch (token) { case STAR: if (ignoreStar) { } else { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next();"
      },
      {
        "txt": "continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); } ignoreStar = true; token = next(); continue; default: ignoreStar = false;"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno();"
      },
      {
        "txt": "if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } <extra_id_0> builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line);"
      },
      {
        "txt": "} builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do {"
      },
      {
        "txt": "switch (token) { case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); }"
      },
      {
        "txt": "builder.append('*'); } token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default:"
      },
      {
        "txt": "if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); }"
      },
      {
        "txt": "} while (true); } private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break;"
      },
      {
        "txt": "} } if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs();"
      },
      {
        "txt": "Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode;"
      },
      {
        "txt": "} else { return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) {"
      },
      {
        "txt": "token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) {"
      },
      {
        "txt": "typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next();"
      },
      {
        "txt": "} } return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token); }"
      },
      {
        "txt": "} private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs();"
      },
      {
        "txt": "token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null;"
      },
      {
        "txt": "} Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; }"
      },
      {
        "txt": "typeList.addChildToBack(typeExpr); } return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB ||"
      },
      {
        "txt": "token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else {"
      },
      {
        "txt": "Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } }"
      },
      {
        "txt": "return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) {"
      },
      {
        "txt": "skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next());"
      },
      {
        "txt": "} else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) {"
      },
      {
        "txt": "if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "next(); typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) {"
      },
      {
        "txt": "typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode; }"
      },
      {
        "txt": "private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next();"
      },
      {
        "txt": "boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode("
      },
      {
        "txt": "isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "next(); skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token);"
      },
      {
        "txt": "if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType;"
      },
      {
        "txt": "} private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");"
      },
      {
        "txt": "} next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next();"
      },
      {
        "txt": "} isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } }"
      },
      {
        "txt": "if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next();"
      },
      {
        "txt": "skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null);"
      },
      {
        "txt": "} private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs();"
      },
      {
        "txt": "token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); }"
      },
      {
        "txt": "expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");"
      },
      {
        "txt": "} next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do {"
      },
      {
        "txt": "if (arg != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token);"
      },
      {
        "txt": "} if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA));"
      },
      {
        "txt": "if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) {"
      },
      {
        "txt": "return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; }"
      },
      {
        "txt": "private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "break; } next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token);"
      },
      {
        "txt": "if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next());"
      },
      {
        "txt": "if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) {"
      },
      {
        "txt": "case STRING: String string = stream.getString(); return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(),"
      },
      {
        "txt": "stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) {"
      },
      {
        "txt": "Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null);"
      },
      {
        "txt": "return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() {"
      },
      {
        "txt": "return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next();"
      },
      {
        "txt": "} while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token;"
      },
      {
        "txt": "} private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current();"
      },
      {
        "txt": "} } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next();"
      },
      {
        "txt": "if (match(JsDocToken.STAR)) { next(); } } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated();"
      },
      {
        "txt": "} JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() { boolean matchedLc = false; int c;"
      },
      {
        "txt": "while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else { break; }"
      },
      {
        "txt": "} stream.ungetChar(c); return matchedLc; }"
      }
    ]
  }
]