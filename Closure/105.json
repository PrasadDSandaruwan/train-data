[
  {
    "id": 436,
    "file_path": "src/com/google/javascript/jscomp/FoldConstants.java",
    "start-bug-line": 1477,
    "end-bug-line": 1477,
    "bug": "StringBuilder sb = new StringBuilder();",
    "fix": "StringBuilder sb = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.List; import java.util.regex.Pattern; class FoldConstants extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error( \"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"); static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\", \"Can't negate non-numeric value: {0}\"); static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error( \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\", \"Invalid flags to RegExp constructor: {0}\");"
      },
      {
        "txt": "static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\");"
      },
      {
        "txt": "private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND); private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR); private final AbstractCompiler compiler; FoldConstants(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node jsRoot) { NodeTraversal.traverse(compiler, jsRoot, this); } public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "int type = n.getType(); if (type == Token.BLOCK) { tryFoldBlock(t, n, parent); return; } Node left = n.getFirstChild(); if (left == null) { return; } if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {"
      },
      {
        "txt": "String newValue = null; switch (left.getType()) { case Token.STRING: newValue = \"string\"; break; case Token.NUMBER: newValue = \"number\"; break; case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "newValue = \"boolean\"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: newValue = \"object\"; break; case Token.NAME: if (\"undefined\".equals(left.getString())) { newValue = \"undefined\";"
      },
      {
        "txt": "} break; } if (newValue != null) { parent.replaceChild(n, Node.newString(newValue)); t.getCompiler().reportCodeChange(); } return; } if (type == Token.NOT ||"
      },
      {
        "txt": "type == Token.NEG || type == Token.BITNOT) { Preconditions.checkState(n.hasOneChild()); if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild()); t.getCompiler().reportCodeChange(); return; } if (type == Token.NOT && tryMinimizeNot(t, n, parent)) { return;"
      },
      {
        "txt": "} if (!NodeUtil.isLiteralValue(left)) { return; } switch (type) { case Token.NOT: int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE; parent.replaceChild(n, new Node(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "break; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) { return; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } } double negNum = -left.getDouble(); parent.replaceChild(n, Node.newNumber(negNum)); t.getCompiler().reportCodeChange(); } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break;"
      },
      {
        "txt": "case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { parent.replaceChild(n, Node.newNumber(~intVal)); t.getCompiler().reportCodeChange(); } else { error(t, FRACTIONAL_BITWISE_OPERAND, left);"
      },
      {
        "txt": "} } else { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); } } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; } return;"
      },
      {
        "txt": "} else if (type == Token.NEW) { if (Token.NAME == left.getType()) { String className = left.getString(); if (\"RegExp\".equals(className)) { tryFoldRegularExpressionConstructor(t, n, parent); } else if (left.getNext() == null) { if (\"Array\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.ARRAYLIT); } else if (\"Object\".equals(className)) {"
      },
      {
        "txt": "tryFoldLiteralConstructor( t, n, parent, className, Token.OBJECTLIT); } } } } if (type == Token.EXPR_RESULT) { tryMinimizeCondition(t, left, n); return; }"
      },
      {
        "txt": "if (type == Token.RETURN) { tryReduceReturn(t, n); return; } Node right = left.getNext(); if (right == null) { return; } if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left)"
      },
      {
        "txt": "&& !NodeUtil.mayHaveSideEffects(right)) { if (NodeUtil.isImmutableValue(left)) { parent.replaceChild(n, new Node(Token.FALSE)); t.getCompiler().reportCodeChange(); return; } if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { parent.replaceChild(n, new Node(Token.TRUE)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } } if (type == Token.IF || type == Token.HOOK) { tryMinimizeCondition(t, n.getFirstChild(), n); boolean changes = tryFoldHookIf(t, n, parent); if (type == Token.IF && !changes) { tryMinimizeIf(t, n, parent); } return;"
      },
      {
        "txt": "} if (type == Token.DO) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldDo(t, n, parent); return; } if (type == Token.WHILE) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldWhile(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.FOR) { Node condition = NodeUtil.getConditionExpression(n); if (condition != null) { tryMinimizeCondition(t, condition, n); condition = NodeUtil.getConditionExpression(n); this.tryFoldForCondition(condition, n); } tryFoldFor(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.AND || type == Token.OR) { tryFoldAndOr(t, n, left, right, parent); return; } if (type == Token.BITOR || type == Token.BITAND) { tryFoldBitAndOr(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.LSH || type == Token.RSH || type == Token.URSH) { tryFoldShift(t, n, left, right, parent); return; } if (type == Token.GETPROP) { tryFoldGetProp(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.CALL) { tryFoldStringJoin(t, n, left, right, parent); tryFoldStringIndexOf(t, n, left, right, parent); return; } if (type == Token.ASSIGN) { tryFoldAssign(t, n, left, right); } if (!NodeUtil.isLiteralValue(left) ||"
      },
      {
        "txt": "!NodeUtil.isLiteralValue(right)) { if (type == Token.ADD) tryFoldLeftChildAdd(t, n, left, right, parent); if (type == Token.LT || type == Token.GT) { tryFoldComparison(t, n, left, right, parent); } return; // The subsequent ops only work if the LHS & RHS are consts } if (type == Token.ADD) {"
      },
      {
        "txt": "tryFoldAdd(t, n, left, right, parent); return; } if (type == Token.SUB || type == Token.MUL || type == Token.DIV) { tryFoldArithmetic(t, n, left, right, parent); return; } if (type == Token.LT ||"
      },
      {
        "txt": "type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) { tryFoldComparison(t, n, left, right, parent); return; }"
      },
      {
        "txt": "if (type == Token.GETELEM) { tryFoldGetElem(t, n, left, right, parent); return; } } private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) { t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString())); } private boolean consumesDanglingElse(Node n) { while (true) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.IF: if (n.getChildCount() < 3) return true; n = n.getLastChild(); continue; case Token.WITH: case Token.WHILE: case Token.FOR: n = n.getLastChild(); continue;"
      },
      {
        "txt": "default: return false; } } } private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return;"
      },
      {
        "txt": "} if (NodeUtil.mayHaveSideEffects(left)) { return; } Node leftChild = right.getFirstChild(); if (!compiler.areNodesEqualForInlining(left, leftChild)) { return; } int newType = -1; switch (right.getType()) {"
      },
      {
        "txt": "case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR: newType = Token.ASSIGN_BITOR; break; case Token.BITXOR:"
      },
      {
        "txt": "newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH; break; case Token.MOD: newType = Token.ASSIGN_MOD;"
      },
      {
        "txt": "break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH: newType = Token.ASSIGN_RSH; break; case Token.SUB: newType = Token.ASSIGN_SUB; break;"
      },
      {
        "txt": "case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return; } n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent())); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "void tryFoldBlock(NodeTraversal t, Node n, Node parent) { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // save c.next, since 'c' may be removed if (!NodeUtil.mayHaveSideEffects(c)) { n.removeChild(c); // lazy kids t.getCompiler().reportCodeChange(); } c = next; } if (n.isSyntheticBlock() || parent == null) {"
      },
      {
        "txt": "return; } if (NodeUtil.tryMergeBlock(n)) { t.getCompiler().reportCodeChange(); } } boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) { int type = n.getType(); Node cond = n.getFirstChild(); Node thenBody = cond.getNext();"
      },
      {
        "txt": "Node elseBody = thenBody.getNext(); boolean changes = false; if (type == Token.IF) { if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) { n.removeChild(elseBody); elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {"
      },
      {
        "txt": "n.removeChild(elseBody); n.replaceChild(thenBody, elseBody); Node notCond = new Node(Token.NOT); n.replaceChild(cond, notCond); notCond.addChildToFront(cond); cond = notCond; thenBody = cond.getNext(); elseBody = null; t.getCompiler().reportCodeChange(); changes = true;"
      },
      {
        "txt": "} if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) { if (NodeUtil.mayHaveSideEffects(cond)) { n.removeChild(cond); parent.replaceChild(n, NodeUtil.newExpr(cond)); } else { NodeUtil.removeChild(parent, n); } t.getCompiler().reportCodeChange(); return true; // The if has been removed. There is nothing to do."
      },
      {
        "txt": "} } else { Preconditions.checkState(type == Token.HOOK); if (NodeUtil.isExpressionNode(parent)) { if (!NodeUtil.mayHaveSideEffects(thenBody)) { Node ifNode = new Node(Token.IF); if (cond.getType() == Token.NOT) { Node expr = cond.getFirstChild(); cond.removeChild(expr); ifNode.addChildToBack(expr);"
      },
      {
        "txt": "} else { Node not = new Node(Token.NOT); n.removeChild(cond); not.addChildToBack(cond); ifNode.addChildToBack(not); } n.removeChild(elseBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))); parent.getParent().replaceChild(parent, ifNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } else if (!NodeUtil.mayHaveSideEffects(elseBody)) { Node ifNode = new Node(Token.IF); n.removeChild(cond); ifNode.addChildToBack(cond); n.removeChild(thenBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))); parent.getParent().replaceChild(parent, ifNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } } } if (!NodeUtil.isLiteralValue(cond)) { return changes; // We can't remove branches otherwise! } boolean condTrue = NodeUtil.getBooleanValue(cond); if (n.getChildCount() == 2) {"
      },
      {
        "txt": "Preconditions.checkState(type == Token.IF); if (condTrue) { Node thenStmt = n.getFirstChild().getNext(); n.removeChild(thenStmt); parent.replaceChild(n, thenStmt); t.getCompiler().reportCodeChange(); } else { NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } else { Node firstBranch = n.getFirstChild().getNext(); Node secondBranch = firstBranch.getNext(); Node branch = condTrue ? firstBranch : secondBranch; Node notBranch = condTrue ? secondBranch : firstBranch; NodeUtil.redeclareVarsInsideBranch(notBranch); n.removeChild(branch); parent.replaceChild(n, branch); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} return true; } private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) { Node notChild = n.getFirstChild(); int complementOperator; switch (notChild.getType()) { case Token.EQ: complementOperator = Token.NE; break;"
      },
      {
        "txt": "case Token.NE: complementOperator = Token.EQ; break; case Token.SHEQ: complementOperator = Token.SHNE; break; case Token.SHNE: complementOperator = Token.SHEQ; break; default:"
      },
      {
        "txt": "return false; } Node newOperator = n.removeFirstChild(); newOperator.setType(complementOperator); parent.replaceChild(n, newOperator); t.getCompiler().reportCodeChange(); return true; } void tryMinimizeIf(NodeTraversal t, Node n, Node parent) { Node cond = n.getFirstChild();"
      },
      {
        "txt": "Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(t, expr)) { return; } if (cond.getType() == Token.NOT) { if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) &&"
      },
      {
        "txt": "isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) { return; } Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); return;"
      },
      {
        "txt": "} if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) { return; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } return; } tryRemoveRepeatedStatements(t, n); if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node returnNode = new Node(Token.RETURN, hookNode);"
      },
      {
        "txt": "parent.replaceChild(n, returnNode); t.getCompiler().reportCodeChange(); return; } boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {"
      },
      {
        "txt": "if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !NodeUtil.mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = new Node(Token.HOOK, cond, thenExpr,"
      },
      {
        "txt": "elseExpr); Node assign = new Node(thenOp.getType(), assignName, hookNode); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } else if (NodeUtil.isCall(thenOp)) { n.removeChild(cond); thenOp.detachFromParent();"
      },
      {
        "txt": "elseOp.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp); Node expr = NodeUtil.newExpr(hookNode); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } return; } boolean thenBranchIsVar = isVarBlock(thenBranch);"
      },
      {
        "txt": "boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) { Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {"
      },
      {
        "txt": "Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&"
      },
      {
        "txt": "NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild(); if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren();"
      },
      {
        "txt": "cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name2.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } } private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.IF); Node parent = n.getParent(); if (!NodeUtil.isStatementBlock(parent)) { return; } Node cond = n.getFirstChild(); Node trueBranch = cond.getNext(); Node falseBranch = trueBranch.getNext(); Preconditions.checkNotNull(trueBranch); Preconditions.checkNotNull(falseBranch);"
      },
      {
        "txt": "while (true) { Node lastTrue = trueBranch.getLastChild(); Node lastFalse = falseBranch.getLastChild(); if (lastTrue == null || lastFalse == null || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) { break; } lastTrue.detachFromParent(); lastFalse.detachFromParent(); parent.addChildAfter(lastTrue, n);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } private void tryReduceReturn(NodeTraversal t, Node n) { Node result = n.getFirstChild(); if (result != null) { switch (result.getType()) { case Token.VOID: Node operand = result.getFirstChild(); if (!NodeUtil.mayHaveSideEffects(operand)) {"
      },
      {
        "txt": "n.removeFirstChild(); t.getCompiler().reportCodeChange(); } return; case Token.NAME: String name = result.getString(); if (name.equals(\"undefined\")) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "return; } } } private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) { final boolean[] found = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { found[0] |= (n.getType() == Token.GETPROP && parent.getType() == Token.ASSIGN);"
      },
      {
        "txt": "} }).traverse(n); return found[0]; } private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n, final int precedence) { final boolean[] lower = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { lower[0] |= NodeUtil.precedence(n.getType()) < precedence;"
      },
      {
        "txt": "} }).traverse(n); return lower[0]; } void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { Node result = null; int type = n.getType(); if (NodeUtil.isLiteralValue(left)) { boolean lval = NodeUtil.getBooleanValue(left);"
      },
      {
        "txt": "if (lval && type == Token.OR || !lval && type == Token.AND) { result = left; } else { result = right; } } else if (NodeUtil.isLiteralValue(right)) { int pt = parent.getType(); if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||"
      },
      {
        "txt": "(pt == Token.HOOK && parent.getFirstChild() == n)) { boolean rval = NodeUtil.getBooleanValue(right); if (type == Token.OR && !rval || type == Token.AND && rval) { result = left; } else { if (!NodeUtil.mayHaveSideEffects(left)) { result = right; } }"
      },
      {
        "txt": "} } if (result != null) { n.removeChild(result); parent.replaceChild(n, result); t.getCompiler().reportCodeChange(); } } void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) { Node ll = left.getFirstChild(); Node lr = ll.getNext(); if (lr.getType() != Token.STRING) return; String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) {"
      },
      {
        "txt": "left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { parent.replaceChild(n, Node.newString(leftString + rightString)); t.getCompiler().reportCodeChange(); } } else { tryFoldArithmetic(t, n, left, right, parent);"
      },
      {
        "txt": "} } void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); switch (n.getType()) {"
      },
      {
        "txt": "case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval; break; case Token.MUL: result = lval * rval; break; case Token.DIV:"
      },
      {
        "txt": "if (rval == 0) { error(t, DIVIDE_BY_0_ERROR, right); return; } result = lval / rval; break; default: throw new Error(\"Unknown arithmetic operator\"); } if (String.valueOf(result).length() <="
      },
      {
        "txt": "String.valueOf(lval).length() + String.valueOf(rval).length() + 1) { parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {"
      },
      {
        "txt": "double result; double lval = left.getDouble(); double rval = right.getDouble(); if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) { return; } int lvalInt = (int) lval; if (lvalInt != lval) { return;"
      },
      {
        "txt": "} int rvalInt = (int) rval; if (rvalInt != rval) { return; } switch (n.getType()) { case Token.BITAND: result = lvalInt & rvalInt; break; case Token.BITOR:"
      },
      {
        "txt": "result = lvalInt | rvalInt; break; default: throw new Error(\"Unknown bitwise operator\"); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } void tryFoldShift(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); return; }"
      },
      {
        "txt": "if (!(rval >= 0 && rval < 32)) { error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return; } int lvalInt = (int) lval; if (lvalInt != lval) { error(t, FRACTIONAL_BITWISE_OPERAND, left); return; } int rvalInt = (int) rval;"
      },
      {
        "txt": "if (rvalInt != rval) { error(t, FRACTIONAL_BITWISE_OPERAND, right); return; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt;"
      },
      {
        "txt": "break; case Token.URSH: result = lvalInt >>> rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } @SuppressWarnings(\"fallthrough\") void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) { int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\"))"
      },
      {
        "txt": "|| (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild()))); switch (left.getType()) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild())) { return; } else if (!rightLiteral) { return; } else { boolean nullRight = (Token.NULL == right.getType());"
      },
      {
        "txt": "boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight;"
      },
      {
        "txt": "break; case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break;"
      },
      {
        "txt": "default: return; } } break; case Token.NULL: if (undefinedRight) { result = (op == Token.EQ); break; }"
      },
      {
        "txt": "case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = false; break; } case Token.THIS: int tt = right.getType(); if (tt != Token.THIS && tt != Token.TRUE &&"
      },
      {
        "txt": "tt != Token.FALSE && tt != Token.NULL) return; switch (op) { case Token.EQ: result = left.getType() == right.getType(); break; case Token.NE: result = left.getType() != right.getType(); break;"
      },
      {
        "txt": "default: return; // we only handle == and != here } break; case Token.STRING: if (undefinedRight) { result = false; break; } if (Token.STRING != right.getType()) {"
      },
      {
        "txt": "return; // Only eval if they are the same type } switch (op) { case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.NE: result = !left.getString().equals(right.getString()); break; default:"
      },
      {
        "txt": "return; // we only handle == and != here } break; case Token.NUMBER: if (undefinedRight) { result = false; break; } if (Token.NUMBER != right.getType()) { return; // Only eval if they are the same type"
      },
      {
        "txt": "} double lv = left.getDouble(); double rv = right.getDouble(); switch (op) { case Token.EQ: result = lv == rv; break; case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break;"
      },
      {
        "txt": "default: return; // don't handle that op } break; case Token.NAME: if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight;"
      },
      {
        "txt": "switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break;"
      },
      {
        "txt": "case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break; default:"
      },
      {
        "txt": "return; } break; } } if (Token.NAME != right.getType()) { return; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString();"
      },
      {
        "txt": "if (!ln.equals(rn)) { return; // Not the same value name. } switch (op) { case Token.LT: case Token.GT: result = false; break; default: return; // don't handle that op"
      },
      {
        "txt": "} break; default: return; } parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE)); t.getCompiler().reportCodeChange(); } void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node lstringNode = left.getFirstChild(); Node functionName = lstringNode.getNext(); if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(\"indexOf\") && !functionName.getString().equals(\"lastIndexOf\"))) { return;"
      },
      {
        "txt": "} String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.getString().equals(\"indexOf\"); Node firstArg = right; Node secondArg = right.getNext(); String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return; } int fromIndex = isIndexOf ? 0 : lstring.length();"
      },
      {
        "txt": "if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return; } else { fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex);"
      },
      {
        "txt": "Node newNode = Node.newNumber(indexVal); parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node arrayNode = left.getFirstChild();"
      },
      {
        "txt": "if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return; } String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); <extra_id_0> int foldedSize = 0; Node elem = arrayNode.getFirstChild(); while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString);"
      },
      {
        "txt": "if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); }"
      },
      {
        "txt": "foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); } foldedSize += arrayFoldedChildren.size() - 1;"
      },
      {
        "txt": "int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\"); parent.replaceChild(n, emptyStringNode); break; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return;"
      },
      {
        "txt": "} arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) { Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode); foldedStringNode = replacement; } parent.replaceChild(n, foldedStringNode); break; default:"
      },
      {
        "txt": "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead; foldedSize += InlineCostEstimator.getCost(right); if (foldedSize > originalSize) { return; } arrayNode.detachChildren();"
      },
      {
        "txt": "for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); } break; } t.getCompiler().reportCodeChange(); } void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.ARRAYLIT) {"
      },
      {
        "txt": "if (right.getType() != Token.NUMBER) { return; } double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) { t.getCompiler().report(JSError.make(t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf(index))); return; }"
      },
      {
        "txt": "if (intIndex < 0) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) {"
      },
      {
        "txt": "t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } left.removeChild(elem); parent.replaceChild(n, elem); t.getCompiler().reportCodeChange(); } } void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) { case Token.ARRAYLIT: if (NodeUtil.mayHaveSideEffects(left)) { return; } knownLength = left.getChildCount();"
      },
      {
        "txt": "break; case Token.STRING: knownLength = left.getString().length(); break; default: return; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); parent.replaceChild(n, lengthNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } void tryFoldRegularExpressionConstructor( NodeTraversal t, Node n, Node parent) { Node constructor = n.getFirstChild(); Node pattern = constructor.getNext(); // e.g. ^foobar$ Node flags = null != pattern ? pattern.getNext() : null; // e.g. gi if (null == pattern || (null != flags && null != flags.getNext())) { return;"
      },
      {
        "txt": "} if (// is pattern folded pattern.getType() == Token.STRING && !\"\".equals(pattern.getString()) && pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && !containsUnicodeEscape(pattern.getString())) { pattern = makeForwardSlashBracketSafe(pattern); Node regexLiteral; if (null == flags || \"\".equals(flags.getString())) {"
      },
      {
        "txt": "regexLiteral = new Node(Token.REGEXP, pattern); } else { if (!areValidRegexpFlags(flags.getString())) { error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags); return; } if (!areSafeFlagsToFold(flags.getString())) { return; } n.removeChild(flags);"
      },
      {
        "txt": "regexLiteral = new Node(Token.REGEXP, pattern, flags); } parent.replaceChild(n, regexLiteral); t.getCompiler().reportCodeChange(); } } private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\"); private static boolean areValidRegexpFlags(String flags) { return REGEXP_FLAGS_RE.matcher(flags).matches(); }"
      },
      {
        "txt": "private static boolean areSafeFlagsToFold(String flags) { return flags.indexOf('g') < 0; } private static Node makeForwardSlashBracketSafe(Node n) { String s = n.getString(); StringBuilder sb = null; int pos = 0; for (int i = 0; i < s.length(); ++i) { switch (s.charAt(i)) { case '\\\\': // skip over the next char after a '\\\\'."
      },
      {
        "txt": "++i; break; case '/': // escape it if (null == sb) { sb = new StringBuilder(s.length() + 16); } sb.append(s, pos, i).append('\\\\'); pos = i; break; } } if (null == sb) { return n.cloneTree(); }"
      },
      {
        "txt": "sb.append(s, pos, s.length()); return Node.newString(sb.toString()); } void tryFoldLiteralConstructor( NodeTraversal t, Node n, Node parent, String className, int type) { Scope.Var var = t.getScope().getVar(className); if (var != null && var.isLocal()) { return; } Node literalNode = new Node(type);"
      },
      {
        "txt": "parent.replaceChild(n, literalNode); t.getCompiler().reportCodeChange(); } static boolean containsUnicodeEscape(String s) { String esc = CodeGenerator.regexpEscape(s); for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) { int nSlashes = 0; while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) { ++nSlashes; }"
      },
      {
        "txt": "if (0 == (nSlashes & 1)) { return true; } } return false; } void tryFoldWhile(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.WHILE); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; }"
      },
      {
        "txt": "NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldFor(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.FOR); if (n.getChildCount() != 4) return; if (n.getFirstChild().getType() != Token.EMPTY) return; Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {"
      },
      {
        "txt": "return; } NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldDo(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.DO); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {"
      },
      {
        "txt": "return; } if (hasBreakOrContinue(n)) { return; } Preconditions.checkState( NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); Node block = n.removeFirstChild(); parent.replaceChild(n, block); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} boolean hasBreakOrContinue(Node n) { return NodeUtil.has( n, Predicates.<Node>or( new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.NOT: Node first = n.getFirstChild(); switch (first.getType()) { case Token.NOT: { Node newRoot = first.removeFirstChild(); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); tryMinimizeCondition(t, n, parent);"
      },
      {
        "txt": "return; } case Token.AND: case Token.OR: { Node leftParent = first.getFirstChild(); Node rightParent = first.getLastChild(); if (leftParent.getType() != Token.NOT || rightParent.getType() != Token.NOT) { break; }"
      },
      {
        "txt": "Node left = leftParent.removeFirstChild(); Node right = rightParent.removeFirstChild(); int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND; Node newRoot = new Node(newOp, left, right); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); } break; }"
      },
      {
        "txt": "break; case Token.OR: case Token.AND: break; default: if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); int equivalentResult = result ? 1 : 0; maybeReplaceChildWithNumber(t, n, parent, equivalentResult); }"
      },
      {
        "txt": "return; } for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // c may be removed. tryMinimizeCondition(t, c, n); c = next; } } private void tryFoldForCondition(Node n, Node parent) { if (NodeUtil.isLiteralValue(n)) {"
      },
      {
        "txt": "boolean result = NodeUtil.getBooleanValue(n); if (result) { parent.replaceChild(n, new Node(Token.EMPTY)); compiler.reportCodeChange(); } } } private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent, int num) { Node newNode = Node.newNumber(num);"
      },
      {
        "txt": "if(!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } } private boolean isExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { return NodeUtil.isExpressionNode(n.getFirstChild()); }"
      },
      {
        "txt": "} return false; } private Node getBlockExpression(Node n) { Preconditions.checkState(isExpressBlock(n)); return n.getFirstChild(); } private boolean isReturnExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) {"
      },
      {
        "txt": "Node first = n.getFirstChild(); if (first.getType() == Token.RETURN) { return first.hasOneChild(); } } } return false; } private Node getBlockReturnExpression(Node n) { Preconditions.checkState(isReturnExpressBlock(n));"
      },
      {
        "txt": "return n.getFirstChild().getFirstChild(); } private boolean isVarBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node first = n.getFirstChild(); if (first.getType() == Token.VAR) { return first.hasOneChild(); } }"
      },
      {
        "txt": "} return false; } private Node getBlockVar(Node n) { Preconditions.checkState(isVarBlock(n)); return n.getFirstChild(); }"
      }
    ]
  },
  {
    "id": 437,
    "file_path": "src/com/google/javascript/jscomp/FoldConstants.java",
    "start-bug-line": 1483,
    "end-bug-line": 1483,
    "bug": "if (sb.length() > 0) {",
    "fix": "if (sb == null) { sb = new StringBuilder(); } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.List; import java.util.regex.Pattern; class FoldConstants extends AbstractPostOrderCallback implements CompilerPass { static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error( \"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"); static final DiagnosticType INVALID_GETELEM_INDEX_ERROR ="
      },
      {
        "txt": "DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error( \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\","
      },
      {
        "txt": "\"Can't negate non-numeric value: {0}\"); static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error( \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\", \"Invalid flags to RegExp constructor: {0}\"); static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\"); private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND); private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR); private final AbstractCompiler compiler; FoldConstants(AbstractCompiler compiler) { this.compiler = compiler;"
      },
      {
        "txt": "} public void process(Node externs, Node jsRoot) { NodeTraversal.traverse(compiler, jsRoot, this); } public void visit(NodeTraversal t, Node n, Node parent) { int type = n.getType(); if (type == Token.BLOCK) { tryFoldBlock(t, n, parent); return; }"
      },
      {
        "txt": "Node left = n.getFirstChild(); if (left == null) { return; } if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) { String newValue = null; switch (left.getType()) { case Token.STRING: newValue = \"string\"; break;"
      },
      {
        "txt": "case Token.NUMBER: newValue = \"number\"; break; case Token.TRUE: case Token.FALSE: newValue = \"boolean\"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT:"
      },
      {
        "txt": "newValue = \"object\"; break; case Token.NAME: if (\"undefined\".equals(left.getString())) { newValue = \"undefined\"; } break; } if (newValue != null) { parent.replaceChild(n, Node.newString(newValue));"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } return; } if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) { Preconditions.checkState(n.hasOneChild()); if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild());"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return; } if (type == Token.NOT && tryMinimizeNot(t, n, parent)) { return; } if (!NodeUtil.isLiteralValue(left)) { return; } switch (type) {"
      },
      {
        "txt": "case Token.NOT: int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE; parent.replaceChild(n, new Node(result)); t.getCompiler().reportCodeChange(); break; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) {"
      },
      {
        "txt": "return; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left); t.getCompiler().reportCodeChange(); return; } } double negNum = -left.getDouble(); parent.replaceChild(n, Node.newNumber(negNum));"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val;"
      },
      {
        "txt": "if (intVal == val) { parent.replaceChild(n, Node.newNumber(~intVal)); t.getCompiler().reportCodeChange(); } else { error(t, FRACTIONAL_BITWISE_OPERAND, left); } } else { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); } } catch (UnsupportedOperationException ex) {"
      },
      {
        "txt": "error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; } return; } else if (type == Token.NEW) { if (Token.NAME == left.getType()) { String className = left.getString(); if (\"RegExp\".equals(className)) { tryFoldRegularExpressionConstructor(t, n, parent);"
      },
      {
        "txt": "} else if (left.getNext() == null) { if (\"Array\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.ARRAYLIT); } else if (\"Object\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.OBJECTLIT); } } }"
      },
      {
        "txt": "} if (type == Token.EXPR_RESULT) { tryMinimizeCondition(t, left, n); return; } if (type == Token.RETURN) { tryReduceReturn(t, n); return; } Node right = left.getNext();"
      },
      {
        "txt": "if (right == null) { return; } if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) { if (NodeUtil.isImmutableValue(left)) { parent.replaceChild(n, new Node(Token.FALSE)); t.getCompiler().reportCodeChange(); return;"
      },
      {
        "txt": "} if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { parent.replaceChild(n, new Node(Token.TRUE)); t.getCompiler().reportCodeChange(); return; } } if (type == Token.IF || type == Token.HOOK) { tryMinimizeCondition(t, n.getFirstChild(), n);"
      },
      {
        "txt": "boolean changes = tryFoldHookIf(t, n, parent); if (type == Token.IF && !changes) { tryMinimizeIf(t, n, parent); } return; } if (type == Token.DO) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldDo(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.WHILE) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldWhile(t, n, parent); return; } if (type == Token.FOR) { Node condition = NodeUtil.getConditionExpression(n); if (condition != null) { tryMinimizeCondition(t, condition, n);"
      },
      {
        "txt": "condition = NodeUtil.getConditionExpression(n); this.tryFoldForCondition(condition, n); } tryFoldFor(t, n, parent); return; } if (type == Token.AND || type == Token.OR) { tryFoldAndOr(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.BITOR || type == Token.BITAND) { tryFoldBitAndOr(t, n, left, right, parent); return; } if (type == Token.LSH || type == Token.RSH || type == Token.URSH) { tryFoldShift(t, n, left, right, parent);"
      },
      {
        "txt": "return; } if (type == Token.GETPROP) { tryFoldGetProp(t, n, left, right, parent); return; } if (type == Token.CALL) { tryFoldStringJoin(t, n, left, right, parent); tryFoldStringIndexOf(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.ASSIGN) { tryFoldAssign(t, n, left, right); } if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) { if (type == Token.ADD) tryFoldLeftChildAdd(t, n, left, right, parent); if (type == Token.LT || type == Token.GT) {"
      },
      {
        "txt": "tryFoldComparison(t, n, left, right, parent); } return; // The subsequent ops only work if the LHS & RHS are consts } if (type == Token.ADD) { tryFoldAdd(t, n, left, right, parent); return; } if (type == Token.SUB || type == Token.MUL ||"
      },
      {
        "txt": "type == Token.DIV) { tryFoldArithmetic(t, n, left, right, parent); return; } if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE ||"
      },
      {
        "txt": "type == Token.SHEQ || type == Token.SHNE) { tryFoldComparison(t, n, left, right, parent); return; } if (type == Token.GETELEM) { tryFoldGetElem(t, n, left, right, parent); return; } }"
      },
      {
        "txt": "private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) { t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString())); } private boolean consumesDanglingElse(Node n) { while (true) { switch (n.getType()) { case Token.IF: if (n.getChildCount() < 3) return true; n = n.getLastChild(); continue;"
      },
      {
        "txt": "case Token.WITH: case Token.WHILE: case Token.FOR: n = n.getLastChild(); continue; default: return false; } } }"
      },
      {
        "txt": "private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return; } if (NodeUtil.mayHaveSideEffects(left)) { return; } Node leftChild = right.getFirstChild();"
      },
      {
        "txt": "if (!compiler.areNodesEqualForInlining(left, leftChild)) { return; } int newType = -1; switch (right.getType()) { case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND;"
      },
      {
        "txt": "break; case Token.BITOR: newType = Token.ASSIGN_BITOR; break; case Token.BITXOR: newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break;"
      },
      {
        "txt": "case Token.LSH: newType = Token.ASSIGN_LSH; break; case Token.MOD: newType = Token.ASSIGN_MOD; break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH:"
      },
      {
        "txt": "newType = Token.ASSIGN_RSH; break; case Token.SUB: newType = Token.ASSIGN_SUB; break; case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return;"
      },
      {
        "txt": "} n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent())); t.getCompiler().reportCodeChange(); } void tryFoldBlock(NodeTraversal t, Node n, Node parent) { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // save c.next, since 'c' may be removed if (!NodeUtil.mayHaveSideEffects(c)) { n.removeChild(c); // lazy kids"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } c = next; } if (n.isSyntheticBlock() || parent == null) { return; } if (NodeUtil.tryMergeBlock(n)) { t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "} boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) { int type = n.getType(); Node cond = n.getFirstChild(); Node thenBody = cond.getNext(); Node elseBody = thenBody.getNext(); boolean changes = false; if (type == Token.IF) { if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) { n.removeChild(elseBody);"
      },
      {
        "txt": "elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) { n.removeChild(elseBody); n.replaceChild(thenBody, elseBody); Node notCond = new Node(Token.NOT); n.replaceChild(cond, notCond); notCond.addChildToFront(cond);"
      },
      {
        "txt": "cond = notCond; thenBody = cond.getNext(); elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) { if (NodeUtil.mayHaveSideEffects(cond)) { n.removeChild(cond); parent.replaceChild(n, NodeUtil.newExpr(cond));"
      },
      {
        "txt": "} else { NodeUtil.removeChild(parent, n); } t.getCompiler().reportCodeChange(); return true; // The if has been removed. There is nothing to do. } } else { Preconditions.checkState(type == Token.HOOK); if (NodeUtil.isExpressionNode(parent)) { if (!NodeUtil.mayHaveSideEffects(thenBody)) {"
      },
      {
        "txt": "Node ifNode = new Node(Token.IF); if (cond.getType() == Token.NOT) { Node expr = cond.getFirstChild(); cond.removeChild(expr); ifNode.addChildToBack(expr); } else { Node not = new Node(Token.NOT); n.removeChild(cond); not.addChildToBack(cond); ifNode.addChildToBack(not);"
      },
      {
        "txt": "} n.removeChild(elseBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))); parent.getParent().replaceChild(parent, ifNode); t.getCompiler().reportCodeChange(); return true; } else if (!NodeUtil.mayHaveSideEffects(elseBody)) { Node ifNode = new Node(Token.IF); n.removeChild(cond);"
      },
      {
        "txt": "ifNode.addChildToBack(cond); n.removeChild(thenBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))); parent.getParent().replaceChild(parent, ifNode); t.getCompiler().reportCodeChange(); return true; } } }"
      },
      {
        "txt": "if (!NodeUtil.isLiteralValue(cond)) { return changes; // We can't remove branches otherwise! } boolean condTrue = NodeUtil.getBooleanValue(cond); if (n.getChildCount() == 2) { Preconditions.checkState(type == Token.IF); if (condTrue) { Node thenStmt = n.getFirstChild().getNext(); n.removeChild(thenStmt); parent.replaceChild(n, thenStmt);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } else { NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } } else { Node firstBranch = n.getFirstChild().getNext(); Node secondBranch = firstBranch.getNext(); Node branch = condTrue ? firstBranch : secondBranch;"
      },
      {
        "txt": "Node notBranch = condTrue ? secondBranch : firstBranch; NodeUtil.redeclareVarsInsideBranch(notBranch); n.removeChild(branch); parent.replaceChild(n, branch); t.getCompiler().reportCodeChange(); } return true; } private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) { Node notChild = n.getFirstChild();"
      },
      {
        "txt": "int complementOperator; switch (notChild.getType()) { case Token.EQ: complementOperator = Token.NE; break; case Token.NE: complementOperator = Token.EQ; break; case Token.SHEQ: complementOperator = Token.SHNE;"
      },
      {
        "txt": "break; case Token.SHNE: complementOperator = Token.SHEQ; break; default: return false; } Node newOperator = n.removeFirstChild(); newOperator.setType(complementOperator); parent.replaceChild(n, newOperator);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } void tryMinimizeIf(NodeTraversal t, Node n, Node parent) { Node cond = n.getFirstChild(); Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch);"
      },
      {
        "txt": "if (isPropertyAssignmentInExpression(t, expr)) { return; } if (cond.getType() == Token.NOT) { if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) { return; } Node or = new Node(Token.OR, cond.removeFirstChild(),"
      },
      {
        "txt": "expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); return; } if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) { return;"
      },
      {
        "txt": "} n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); } return; } tryRemoveRepeatedStatements(t, n);"
      },
      {
        "txt": "if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); t.getCompiler().reportCodeChange(); return; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch);"
      },
      {
        "txt": "n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node returnNode = new Node(Token.RETURN, hookNode); parent.replaceChild(n, returnNode); t.getCompiler().reportCodeChange(); return; } boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);"
      },
      {
        "txt": "boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) { if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !NodeUtil.mayEffectMutableState(lhs)) { n.removeChild(cond);"
      },
      {
        "txt": "Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node assign = new Node(thenOp.getType(), assignName, hookNode); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } else if (NodeUtil.isCall(thenOp)) { n.removeChild(cond); thenOp.detachFromParent(); elseOp.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp); Node expr = NodeUtil.newExpr(hookNode); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } return; } boolean thenBranchIsVar = isVarBlock(thenBranch); boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) { Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild();"
      },
      {
        "txt": "Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) { Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent();"
      },
      {
        "txt": "name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } else if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild();"
      },
      {
        "txt": "if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren(); cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name2.addChildrenToBack(hookNode); parent.replaceChild(n, var);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } } private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) { Preconditions.checkState(n.getType() == Token.IF); Node parent = n.getParent(); if (!NodeUtil.isStatementBlock(parent)) { return; }"
      },
      {
        "txt": "Node cond = n.getFirstChild(); Node trueBranch = cond.getNext(); Node falseBranch = trueBranch.getNext(); Preconditions.checkNotNull(trueBranch); Preconditions.checkNotNull(falseBranch); while (true) { Node lastTrue = trueBranch.getLastChild(); Node lastFalse = falseBranch.getLastChild(); if (lastTrue == null || lastFalse == null || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) {"
      },
      {
        "txt": "break; } lastTrue.detachFromParent(); lastFalse.detachFromParent(); parent.addChildAfter(lastTrue, n); t.getCompiler().reportCodeChange(); } } private void tryReduceReturn(NodeTraversal t, Node n) { Node result = n.getFirstChild();"
      },
      {
        "txt": "if (result != null) { switch (result.getType()) { case Token.VOID: Node operand = result.getFirstChild(); if (!NodeUtil.mayHaveSideEffects(operand)) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); } return; case Token.NAME:"
      },
      {
        "txt": "String name = result.getString(); if (name.equals(\"undefined\")) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); } return; } } } private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) {"
      },
      {
        "txt": "final boolean[] found = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { found[0] |= (n.getType() == Token.GETPROP && parent.getType() == Token.ASSIGN); } }).traverse(n); return found[0]; } private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n,"
      },
      {
        "txt": "final int precedence) { final boolean[] lower = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { lower[0] |= NodeUtil.precedence(n.getType()) < precedence; } }).traverse(n); return lower[0]; } void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { Node result = null; int type = n.getType(); if (NodeUtil.isLiteralValue(left)) { boolean lval = NodeUtil.getBooleanValue(left); if (lval && type == Token.OR || !lval && type == Token.AND) { result = left; } else { result = right;"
      },
      {
        "txt": "} } else if (NodeUtil.isLiteralValue(right)) { int pt = parent.getType(); if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) { boolean rval = NodeUtil.getBooleanValue(right); if (type == Token.OR && !rval || type == Token.AND && rval) { result = left;"
      },
      {
        "txt": "} else { if (!NodeUtil.mayHaveSideEffects(left)) { result = right; } } } } if (result != null) { n.removeChild(result); parent.replaceChild(n, result);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) { Node ll = left.getFirstChild(); Node lr = ll.getNext();"
      },
      {
        "txt": "if (lr.getType() != Token.STRING) return; String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } } void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) {"
      },
      {
        "txt": "parent.replaceChild(n, Node.newString(leftString + rightString)); t.getCompiler().reportCodeChange(); } } else { tryFoldArithmetic(t, n, left, right, parent); } } void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER &&"
      },
      {
        "txt": "right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); switch (n.getType()) { case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval;"
      },
      {
        "txt": "break; case Token.MUL: result = lval * rval; break; case Token.DIV: if (rval == 0) { error(t, DIVIDE_BY_0_ERROR, right); return; } result = lval / rval;"
      },
      {
        "txt": "break; default: throw new Error(\"Unknown arithmetic operator\"); } if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1) { parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } }"
      },
      {
        "txt": "} void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {"
      },
      {
        "txt": "return; } int lvalInt = (int) lval; if (lvalInt != lval) { return; } int rvalInt = (int) rval; if (rvalInt != rval) { return; }"
      },
      {
        "txt": "switch (n.getType()) { case Token.BITAND: result = lvalInt & rvalInt; break; case Token.BITOR: result = lvalInt | rvalInt; break; default: throw new Error(\"Unknown bitwise operator\"); }"
      },
      {
        "txt": "parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } void tryFoldShift(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble();"
      },
      {
        "txt": "double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); return; } if (!(rval >= 0 && rval < 32)) { error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return; } int lvalInt = (int) lval;"
      },
      {
        "txt": "if (lvalInt != lval) { error(t, FRACTIONAL_BITWISE_OPERAND, left); return; } int rvalInt = (int) rval; if (rvalInt != rval) { error(t, FRACTIONAL_BITWISE_OPERAND, right); return; } switch (n.getType()) {"
      },
      {
        "txt": "case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: result = lvalInt >>> rvalInt; break; default:"
      },
      {
        "txt": "throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } @SuppressWarnings(\"fallthrough\") void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild()))); switch (left.getType()) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild())) {"
      },
      {
        "txt": "return; } else if (!rightLiteral) { return; } else { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent; break;"
      },
      {
        "txt": "case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break; case Token.SHNE: result = !undefinedRight; break; case Token.LT:"
      },
      {
        "txt": "case Token.GT: case Token.LE: case Token.GE: result = false; break; default: return; } } break;"
      },
      {
        "txt": "case Token.NULL: if (undefinedRight) { result = (op == Token.EQ); break; } case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = false; break;"
      },
      {
        "txt": "} case Token.THIS: int tt = right.getType(); if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL) return; switch (op) { case Token.EQ:"
      },
      {
        "txt": "result = left.getType() == right.getType(); break; case Token.NE: result = left.getType() != right.getType(); break; default: return; // we only handle == and != here } break; case Token.STRING:"
      },
      {
        "txt": "if (undefinedRight) { result = false; break; } if (Token.STRING != right.getType()) { return; // Only eval if they are the same type } switch (op) { case Token.EQ: result = left.getString().equals(right.getString());"
      },
      {
        "txt": "break; case Token.NE: result = !left.getString().equals(right.getString()); break; default: return; // we only handle == and != here } break; case Token.NUMBER: if (undefinedRight) {"
      },
      {
        "txt": "result = false; break; } if (Token.NUMBER != right.getType()) { return; // Only eval if they are the same type } double lv = left.getDouble(); double rv = right.getDouble(); switch (op) { case Token.EQ: result = lv == rv; break;"
      },
      {
        "txt": "case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break; default: return; // don't handle that op } break; case Token.NAME:"
      },
      {
        "txt": "if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent; break; case Token.NE:"
      },
      {
        "txt": "result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break; case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT:"
      },
      {
        "txt": "case Token.LE: case Token.GE: result = false; break; default: return; } break; } }"
      },
      {
        "txt": "if (Token.NAME != right.getType()) { return; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return; // Not the same value name. } switch (op) { case Token.LT:"
      },
      {
        "txt": "case Token.GT: result = false; break; default: return; // don't handle that op } break; default: return; }"
      },
      {
        "txt": "parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE)); t.getCompiler().reportCodeChange(); } void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node lstringNode = left.getFirstChild();"
      },
      {
        "txt": "Node functionName = lstringNode.getNext(); if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(\"indexOf\") && !functionName.getString().equals(\"lastIndexOf\"))) { return; } String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.getString().equals(\"indexOf\"); Node firstArg = right; Node secondArg = right.getNext();"
      },
      {
        "txt": "String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return; } int fromIndex = isIndexOf ? 0 : lstring.length(); if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return; } else {"
      },
      {
        "txt": "fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex); Node newNode = Node.newNumber(indexVal); parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node arrayNode = left.getFirstChild(); Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return; }"
      },
      {
        "txt": "List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { <extra_id_0> sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { foldedSize += sb.length() + 2;"
      },
      {
        "txt": "if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); }"
      },
      {
        "txt": "if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); } foldedSize += arrayFoldedChildren.size() - 1; int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\"); parent.replaceChild(n, emptyStringNode);"
      },
      {
        "txt": "break; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return; } arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) { Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);"
      },
      {
        "txt": "foldedStringNode = replacement; } parent.replaceChild(n, foldedStringNode); break; default: if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead;"
      },
      {
        "txt": "foldedSize += InlineCostEstimator.getCost(right); if (foldedSize > originalSize) { return; } arrayNode.detachChildren(); for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); } break; }"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.ARRAYLIT) { if (right.getType() != Token.NUMBER) { return; } double index = right.getDouble(); int intIndex = (int) index;"
      },
      {
        "txt": "if (intIndex != index) { t.getCompiler().report(JSError.make(t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf(index))); return; } if (intIndex < 0) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; }"
      },
      {
        "txt": "Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } left.removeChild(elem);"
      },
      {
        "txt": "parent.replaceChild(n, elem); t.getCompiler().reportCodeChange(); } } void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) {"
      },
      {
        "txt": "case Token.ARRAYLIT: if (NodeUtil.mayHaveSideEffects(left)) { return; } knownLength = left.getChildCount(); break; case Token.STRING: knownLength = left.getString().length(); break; default:"
      },
      {
        "txt": "return; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); parent.replaceChild(n, lengthNode); t.getCompiler().reportCodeChange(); } } void tryFoldRegularExpressionConstructor( NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "Node constructor = n.getFirstChild(); Node pattern = constructor.getNext(); // e.g. ^foobar$ Node flags = null != pattern ? pattern.getNext() : null; // e.g. gi if (null == pattern || (null != flags && null != flags.getNext())) { return; } if (// is pattern folded pattern.getType() == Token.STRING && !\"\".equals(pattern.getString()) && pattern.getString().length() < 100"
      },
      {
        "txt": "&& (null == flags || flags.getType() == Token.STRING) && !containsUnicodeEscape(pattern.getString())) { pattern = makeForwardSlashBracketSafe(pattern); Node regexLiteral; if (null == flags || \"\".equals(flags.getString())) { regexLiteral = new Node(Token.REGEXP, pattern); } else { if (!areValidRegexpFlags(flags.getString())) { error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags); return;"
      },
      {
        "txt": "} if (!areSafeFlagsToFold(flags.getString())) { return; } n.removeChild(flags); regexLiteral = new Node(Token.REGEXP, pattern, flags); } parent.replaceChild(n, regexLiteral); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "} private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\"); private static boolean areValidRegexpFlags(String flags) { return REGEXP_FLAGS_RE.matcher(flags).matches(); } private static boolean areSafeFlagsToFold(String flags) { return flags.indexOf('g') < 0; } private static Node makeForwardSlashBracketSafe(Node n) { String s = n.getString();"
      },
      {
        "txt": "StringBuilder sb = null; int pos = 0; for (int i = 0; i < s.length(); ++i) { switch (s.charAt(i)) { case '\\\\': // skip over the next char after a '\\\\'. ++i; break; case '/': // escape it if (null == sb) { sb = new StringBuilder(s.length() + 16); } sb.append(s, pos, i).append('\\\\');"
      },
      {
        "txt": "pos = i; break; } } if (null == sb) { return n.cloneTree(); } sb.append(s, pos, s.length()); return Node.newString(sb.toString()); } void tryFoldLiteralConstructor( NodeTraversal t, Node n, Node parent, String className, int type) {"
      },
      {
        "txt": "Scope.Var var = t.getScope().getVar(className); if (var != null && var.isLocal()) { return; } Node literalNode = new Node(type); parent.replaceChild(n, literalNode); t.getCompiler().reportCodeChange(); } static boolean containsUnicodeEscape(String s) { String esc = CodeGenerator.regexpEscape(s);"
      },
      {
        "txt": "for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) { int nSlashes = 0; while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) { ++nSlashes; } if (0 == (nSlashes & 1)) { return true; } } return false; } void tryFoldWhile(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "Preconditions.checkArgument(n.getType() == Token.WHILE); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; } NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldFor(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "Preconditions.checkArgument(n.getType() == Token.FOR); if (n.getChildCount() != 4) return; if (n.getFirstChild().getType() != Token.EMPTY) return; Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; } NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} void tryFoldDo(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.DO); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; } if (hasBreakOrContinue(n)) { return; }"
      },
      {
        "txt": "Preconditions.checkState( NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); Node block = n.removeFirstChild(); parent.replaceChild(n, block); t.getCompiler().reportCodeChange(); } boolean hasBreakOrContinue(Node n) { return NodeUtil.has( n, Predicates.<Node>or("
      },
      {
        "txt": "new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NOT: Node first = n.getFirstChild(); switch (first.getType()) { case Token.NOT: {"
      },
      {
        "txt": "Node newRoot = first.removeFirstChild(); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); tryMinimizeCondition(t, n, parent); return; } case Token.AND: case Token.OR: { Node leftParent = first.getFirstChild();"
      },
      {
        "txt": "Node rightParent = first.getLastChild(); if (leftParent.getType() != Token.NOT || rightParent.getType() != Token.NOT) { break; } Node left = leftParent.removeFirstChild(); Node right = rightParent.removeFirstChild(); int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND; Node newRoot = new Node(newOp, left, right); parent.replaceChild(n, newRoot);"
      },
      {
        "txt": "n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); } break; } break; case Token.OR: case Token.AND: break; default:"
      },
      {
        "txt": "if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); int equivalentResult = result ? 1 : 0; maybeReplaceChildWithNumber(t, n, parent, equivalentResult); } return; } for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // c may be removed. tryMinimizeCondition(t, c, n);"
      },
      {
        "txt": "c = next; } } private void tryFoldForCondition(Node n, Node parent) { if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); if (result) { parent.replaceChild(n, new Node(Token.EMPTY)); compiler.reportCodeChange(); }"
      },
      {
        "txt": "} } private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if(!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } }"
      },
      {
        "txt": "private boolean isExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { return NodeUtil.isExpressionNode(n.getFirstChild()); } } return false; } private Node getBlockExpression(Node n) { Preconditions.checkState(isExpressBlock(n));"
      },
      {
        "txt": "return n.getFirstChild(); } private boolean isReturnExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node first = n.getFirstChild(); if (first.getType() == Token.RETURN) { return first.hasOneChild(); } }"
      },
      {
        "txt": "} return false; } private Node getBlockReturnExpression(Node n) { Preconditions.checkState(isReturnExpressBlock(n)); return n.getFirstChild().getFirstChild(); } private boolean isVarBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) {"
      },
      {
        "txt": "Node first = n.getFirstChild(); if (first.getType() == Token.VAR) { return first.hasOneChild(); } } } return false; } private Node getBlockVar(Node n) { Preconditions.checkState(isVarBlock(n));"
      },
      {
        "txt": "return n.getFirstChild(); }"
      }
    ]
  },
  {
    "id": 438,
    "file_path": "src/com/google/javascript/jscomp/FoldConstants.java",
    "start-bug-line": 1488,
    "end-bug-line": 1488,
    "bug": "if (sb.length() > 0) {",
    "fix": "if (sb != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.List; import java.util.regex.Pattern; class FoldConstants extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error( \"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"); static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\", \"Can't negate non-numeric value: {0}\"); static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error( \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\", \"Invalid flags to RegExp constructor: {0}\");"
      },
      {
        "txt": "static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\");"
      },
      {
        "txt": "private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND); private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR); private final AbstractCompiler compiler; FoldConstants(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node jsRoot) { NodeTraversal.traverse(compiler, jsRoot, this); } public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "int type = n.getType(); if (type == Token.BLOCK) { tryFoldBlock(t, n, parent); return; } Node left = n.getFirstChild(); if (left == null) { return; } if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {"
      },
      {
        "txt": "String newValue = null; switch (left.getType()) { case Token.STRING: newValue = \"string\"; break; case Token.NUMBER: newValue = \"number\"; break; case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "newValue = \"boolean\"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: newValue = \"object\"; break; case Token.NAME: if (\"undefined\".equals(left.getString())) { newValue = \"undefined\";"
      },
      {
        "txt": "} break; } if (newValue != null) { parent.replaceChild(n, Node.newString(newValue)); t.getCompiler().reportCodeChange(); } return; } if (type == Token.NOT ||"
      },
      {
        "txt": "type == Token.NEG || type == Token.BITNOT) { Preconditions.checkState(n.hasOneChild()); if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild()); t.getCompiler().reportCodeChange(); return; } if (type == Token.NOT && tryMinimizeNot(t, n, parent)) { return;"
      },
      {
        "txt": "} if (!NodeUtil.isLiteralValue(left)) { return; } switch (type) { case Token.NOT: int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE; parent.replaceChild(n, new Node(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "break; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) { return; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } } double negNum = -left.getDouble(); parent.replaceChild(n, Node.newNumber(negNum)); t.getCompiler().reportCodeChange(); } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break;"
      },
      {
        "txt": "case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { parent.replaceChild(n, Node.newNumber(~intVal)); t.getCompiler().reportCodeChange(); } else { error(t, FRACTIONAL_BITWISE_OPERAND, left);"
      },
      {
        "txt": "} } else { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); } } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; } return;"
      },
      {
        "txt": "} else if (type == Token.NEW) { if (Token.NAME == left.getType()) { String className = left.getString(); if (\"RegExp\".equals(className)) { tryFoldRegularExpressionConstructor(t, n, parent); } else if (left.getNext() == null) { if (\"Array\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.ARRAYLIT); } else if (\"Object\".equals(className)) {"
      },
      {
        "txt": "tryFoldLiteralConstructor( t, n, parent, className, Token.OBJECTLIT); } } } } if (type == Token.EXPR_RESULT) { tryMinimizeCondition(t, left, n); return; }"
      },
      {
        "txt": "if (type == Token.RETURN) { tryReduceReturn(t, n); return; } Node right = left.getNext(); if (right == null) { return; } if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left)"
      },
      {
        "txt": "&& !NodeUtil.mayHaveSideEffects(right)) { if (NodeUtil.isImmutableValue(left)) { parent.replaceChild(n, new Node(Token.FALSE)); t.getCompiler().reportCodeChange(); return; } if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { parent.replaceChild(n, new Node(Token.TRUE)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } } if (type == Token.IF || type == Token.HOOK) { tryMinimizeCondition(t, n.getFirstChild(), n); boolean changes = tryFoldHookIf(t, n, parent); if (type == Token.IF && !changes) { tryMinimizeIf(t, n, parent); } return;"
      },
      {
        "txt": "} if (type == Token.DO) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldDo(t, n, parent); return; } if (type == Token.WHILE) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldWhile(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.FOR) { Node condition = NodeUtil.getConditionExpression(n); if (condition != null) { tryMinimizeCondition(t, condition, n); condition = NodeUtil.getConditionExpression(n); this.tryFoldForCondition(condition, n); } tryFoldFor(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.AND || type == Token.OR) { tryFoldAndOr(t, n, left, right, parent); return; } if (type == Token.BITOR || type == Token.BITAND) { tryFoldBitAndOr(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.LSH || type == Token.RSH || type == Token.URSH) { tryFoldShift(t, n, left, right, parent); return; } if (type == Token.GETPROP) { tryFoldGetProp(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.CALL) { tryFoldStringJoin(t, n, left, right, parent); tryFoldStringIndexOf(t, n, left, right, parent); return; } if (type == Token.ASSIGN) { tryFoldAssign(t, n, left, right); } if (!NodeUtil.isLiteralValue(left) ||"
      },
      {
        "txt": "!NodeUtil.isLiteralValue(right)) { if (type == Token.ADD) tryFoldLeftChildAdd(t, n, left, right, parent); if (type == Token.LT || type == Token.GT) { tryFoldComparison(t, n, left, right, parent); } return; // The subsequent ops only work if the LHS & RHS are consts } if (type == Token.ADD) {"
      },
      {
        "txt": "tryFoldAdd(t, n, left, right, parent); return; } if (type == Token.SUB || type == Token.MUL || type == Token.DIV) { tryFoldArithmetic(t, n, left, right, parent); return; } if (type == Token.LT ||"
      },
      {
        "txt": "type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) { tryFoldComparison(t, n, left, right, parent); return; }"
      },
      {
        "txt": "if (type == Token.GETELEM) { tryFoldGetElem(t, n, left, right, parent); return; } } private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) { t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString())); } private boolean consumesDanglingElse(Node n) { while (true) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.IF: if (n.getChildCount() < 3) return true; n = n.getLastChild(); continue; case Token.WITH: case Token.WHILE: case Token.FOR: n = n.getLastChild(); continue;"
      },
      {
        "txt": "default: return false; } } } private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return;"
      },
      {
        "txt": "} if (NodeUtil.mayHaveSideEffects(left)) { return; } Node leftChild = right.getFirstChild(); if (!compiler.areNodesEqualForInlining(left, leftChild)) { return; } int newType = -1; switch (right.getType()) {"
      },
      {
        "txt": "case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR: newType = Token.ASSIGN_BITOR; break; case Token.BITXOR:"
      },
      {
        "txt": "newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH; break; case Token.MOD: newType = Token.ASSIGN_MOD;"
      },
      {
        "txt": "break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH: newType = Token.ASSIGN_RSH; break; case Token.SUB: newType = Token.ASSIGN_SUB; break;"
      },
      {
        "txt": "case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return; } n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent())); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "void tryFoldBlock(NodeTraversal t, Node n, Node parent) { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // save c.next, since 'c' may be removed if (!NodeUtil.mayHaveSideEffects(c)) { n.removeChild(c); // lazy kids t.getCompiler().reportCodeChange(); } c = next; } if (n.isSyntheticBlock() || parent == null) {"
      },
      {
        "txt": "return; } if (NodeUtil.tryMergeBlock(n)) { t.getCompiler().reportCodeChange(); } } boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) { int type = n.getType(); Node cond = n.getFirstChild(); Node thenBody = cond.getNext();"
      },
      {
        "txt": "Node elseBody = thenBody.getNext(); boolean changes = false; if (type == Token.IF) { if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) { n.removeChild(elseBody); elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {"
      },
      {
        "txt": "n.removeChild(elseBody); n.replaceChild(thenBody, elseBody); Node notCond = new Node(Token.NOT); n.replaceChild(cond, notCond); notCond.addChildToFront(cond); cond = notCond; thenBody = cond.getNext(); elseBody = null; t.getCompiler().reportCodeChange(); changes = true;"
      },
      {
        "txt": "} if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) { if (NodeUtil.mayHaveSideEffects(cond)) { n.removeChild(cond); parent.replaceChild(n, NodeUtil.newExpr(cond)); } else { NodeUtil.removeChild(parent, n); } t.getCompiler().reportCodeChange(); return true; // The if has been removed. There is nothing to do."
      },
      {
        "txt": "} } else { Preconditions.checkState(type == Token.HOOK); if (NodeUtil.isExpressionNode(parent)) { if (!NodeUtil.mayHaveSideEffects(thenBody)) { Node ifNode = new Node(Token.IF); if (cond.getType() == Token.NOT) { Node expr = cond.getFirstChild(); cond.removeChild(expr); ifNode.addChildToBack(expr);"
      },
      {
        "txt": "} else { Node not = new Node(Token.NOT); n.removeChild(cond); not.addChildToBack(cond); ifNode.addChildToBack(not); } n.removeChild(elseBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))); parent.getParent().replaceChild(parent, ifNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } else if (!NodeUtil.mayHaveSideEffects(elseBody)) { Node ifNode = new Node(Token.IF); n.removeChild(cond); ifNode.addChildToBack(cond); n.removeChild(thenBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))); parent.getParent().replaceChild(parent, ifNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } } } if (!NodeUtil.isLiteralValue(cond)) { return changes; // We can't remove branches otherwise! } boolean condTrue = NodeUtil.getBooleanValue(cond); if (n.getChildCount() == 2) {"
      },
      {
        "txt": "Preconditions.checkState(type == Token.IF); if (condTrue) { Node thenStmt = n.getFirstChild().getNext(); n.removeChild(thenStmt); parent.replaceChild(n, thenStmt); t.getCompiler().reportCodeChange(); } else { NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } else { Node firstBranch = n.getFirstChild().getNext(); Node secondBranch = firstBranch.getNext(); Node branch = condTrue ? firstBranch : secondBranch; Node notBranch = condTrue ? secondBranch : firstBranch; NodeUtil.redeclareVarsInsideBranch(notBranch); n.removeChild(branch); parent.replaceChild(n, branch); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} return true; } private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) { Node notChild = n.getFirstChild(); int complementOperator; switch (notChild.getType()) { case Token.EQ: complementOperator = Token.NE; break;"
      },
      {
        "txt": "case Token.NE: complementOperator = Token.EQ; break; case Token.SHEQ: complementOperator = Token.SHNE; break; case Token.SHNE: complementOperator = Token.SHEQ; break; default:"
      },
      {
        "txt": "return false; } Node newOperator = n.removeFirstChild(); newOperator.setType(complementOperator); parent.replaceChild(n, newOperator); t.getCompiler().reportCodeChange(); return true; } void tryMinimizeIf(NodeTraversal t, Node n, Node parent) { Node cond = n.getFirstChild();"
      },
      {
        "txt": "Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(t, expr)) { return; } if (cond.getType() == Token.NOT) { if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) &&"
      },
      {
        "txt": "isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) { return; } Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); return;"
      },
      {
        "txt": "} if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) { return; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } return; } tryRemoveRepeatedStatements(t, n); if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node returnNode = new Node(Token.RETURN, hookNode);"
      },
      {
        "txt": "parent.replaceChild(n, returnNode); t.getCompiler().reportCodeChange(); return; } boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {"
      },
      {
        "txt": "if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !NodeUtil.mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = new Node(Token.HOOK, cond, thenExpr,"
      },
      {
        "txt": "elseExpr); Node assign = new Node(thenOp.getType(), assignName, hookNode); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } else if (NodeUtil.isCall(thenOp)) { n.removeChild(cond); thenOp.detachFromParent();"
      },
      {
        "txt": "elseOp.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp); Node expr = NodeUtil.newExpr(hookNode); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } return; } boolean thenBranchIsVar = isVarBlock(thenBranch);"
      },
      {
        "txt": "boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) { Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {"
      },
      {
        "txt": "Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&"
      },
      {
        "txt": "NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild(); if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren();"
      },
      {
        "txt": "cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name2.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } } private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.IF); Node parent = n.getParent(); if (!NodeUtil.isStatementBlock(parent)) { return; } Node cond = n.getFirstChild(); Node trueBranch = cond.getNext(); Node falseBranch = trueBranch.getNext(); Preconditions.checkNotNull(trueBranch); Preconditions.checkNotNull(falseBranch);"
      },
      {
        "txt": "while (true) { Node lastTrue = trueBranch.getLastChild(); Node lastFalse = falseBranch.getLastChild(); if (lastTrue == null || lastFalse == null || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) { break; } lastTrue.detachFromParent(); lastFalse.detachFromParent(); parent.addChildAfter(lastTrue, n);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } private void tryReduceReturn(NodeTraversal t, Node n) { Node result = n.getFirstChild(); if (result != null) { switch (result.getType()) { case Token.VOID: Node operand = result.getFirstChild(); if (!NodeUtil.mayHaveSideEffects(operand)) {"
      },
      {
        "txt": "n.removeFirstChild(); t.getCompiler().reportCodeChange(); } return; case Token.NAME: String name = result.getString(); if (name.equals(\"undefined\")) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "return; } } } private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) { final boolean[] found = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { found[0] |= (n.getType() == Token.GETPROP && parent.getType() == Token.ASSIGN);"
      },
      {
        "txt": "} }).traverse(n); return found[0]; } private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n, final int precedence) { final boolean[] lower = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { lower[0] |= NodeUtil.precedence(n.getType()) < precedence;"
      },
      {
        "txt": "} }).traverse(n); return lower[0]; } void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { Node result = null; int type = n.getType(); if (NodeUtil.isLiteralValue(left)) { boolean lval = NodeUtil.getBooleanValue(left);"
      },
      {
        "txt": "if (lval && type == Token.OR || !lval && type == Token.AND) { result = left; } else { result = right; } } else if (NodeUtil.isLiteralValue(right)) { int pt = parent.getType(); if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||"
      },
      {
        "txt": "(pt == Token.HOOK && parent.getFirstChild() == n)) { boolean rval = NodeUtil.getBooleanValue(right); if (type == Token.OR && !rval || type == Token.AND && rval) { result = left; } else { if (!NodeUtil.mayHaveSideEffects(left)) { result = right; } }"
      },
      {
        "txt": "} } if (result != null) { n.removeChild(result); parent.replaceChild(n, result); t.getCompiler().reportCodeChange(); } } void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) { Node ll = left.getFirstChild(); Node lr = ll.getNext(); if (lr.getType() != Token.STRING) return; String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) {"
      },
      {
        "txt": "left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { parent.replaceChild(n, Node.newString(leftString + rightString)); t.getCompiler().reportCodeChange(); } } else { tryFoldArithmetic(t, n, left, right, parent);"
      },
      {
        "txt": "} } void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); switch (n.getType()) {"
      },
      {
        "txt": "case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval; break; case Token.MUL: result = lval * rval; break; case Token.DIV:"
      },
      {
        "txt": "if (rval == 0) { error(t, DIVIDE_BY_0_ERROR, right); return; } result = lval / rval; break; default: throw new Error(\"Unknown arithmetic operator\"); } if (String.valueOf(result).length() <="
      },
      {
        "txt": "String.valueOf(lval).length() + String.valueOf(rval).length() + 1) { parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {"
      },
      {
        "txt": "double result; double lval = left.getDouble(); double rval = right.getDouble(); if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) { return; } int lvalInt = (int) lval; if (lvalInt != lval) { return;"
      },
      {
        "txt": "} int rvalInt = (int) rval; if (rvalInt != rval) { return; } switch (n.getType()) { case Token.BITAND: result = lvalInt & rvalInt; break; case Token.BITOR:"
      },
      {
        "txt": "result = lvalInt | rvalInt; break; default: throw new Error(\"Unknown bitwise operator\"); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } void tryFoldShift(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); return; }"
      },
      {
        "txt": "if (!(rval >= 0 && rval < 32)) { error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return; } int lvalInt = (int) lval; if (lvalInt != lval) { error(t, FRACTIONAL_BITWISE_OPERAND, left); return; } int rvalInt = (int) rval;"
      },
      {
        "txt": "if (rvalInt != rval) { error(t, FRACTIONAL_BITWISE_OPERAND, right); return; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt;"
      },
      {
        "txt": "break; case Token.URSH: result = lvalInt >>> rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } @SuppressWarnings(\"fallthrough\") void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) { int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\"))"
      },
      {
        "txt": "|| (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild()))); switch (left.getType()) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild())) { return; } else if (!rightLiteral) { return; } else { boolean nullRight = (Token.NULL == right.getType());"
      },
      {
        "txt": "boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight;"
      },
      {
        "txt": "break; case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break;"
      },
      {
        "txt": "default: return; } } break; case Token.NULL: if (undefinedRight) { result = (op == Token.EQ); break; }"
      },
      {
        "txt": "case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = false; break; } case Token.THIS: int tt = right.getType(); if (tt != Token.THIS && tt != Token.TRUE &&"
      },
      {
        "txt": "tt != Token.FALSE && tt != Token.NULL) return; switch (op) { case Token.EQ: result = left.getType() == right.getType(); break; case Token.NE: result = left.getType() != right.getType(); break;"
      },
      {
        "txt": "default: return; // we only handle == and != here } break; case Token.STRING: if (undefinedRight) { result = false; break; } if (Token.STRING != right.getType()) {"
      },
      {
        "txt": "return; // Only eval if they are the same type } switch (op) { case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.NE: result = !left.getString().equals(right.getString()); break; default:"
      },
      {
        "txt": "return; // we only handle == and != here } break; case Token.NUMBER: if (undefinedRight) { result = false; break; } if (Token.NUMBER != right.getType()) { return; // Only eval if they are the same type"
      },
      {
        "txt": "} double lv = left.getDouble(); double rv = right.getDouble(); switch (op) { case Token.EQ: result = lv == rv; break; case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break;"
      },
      {
        "txt": "default: return; // don't handle that op } break; case Token.NAME: if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight;"
      },
      {
        "txt": "switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break;"
      },
      {
        "txt": "case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break; default:"
      },
      {
        "txt": "return; } break; } } if (Token.NAME != right.getType()) { return; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString();"
      },
      {
        "txt": "if (!ln.equals(rn)) { return; // Not the same value name. } switch (op) { case Token.LT: case Token.GT: result = false; break; default: return; // don't handle that op"
      },
      {
        "txt": "} break; default: return; } parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE)); t.getCompiler().reportCodeChange(); } void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node lstringNode = left.getFirstChild(); Node functionName = lstringNode.getNext(); if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(\"indexOf\") && !functionName.getString().equals(\"lastIndexOf\"))) { return;"
      },
      {
        "txt": "} String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.getString().equals(\"indexOf\"); Node firstArg = right; Node secondArg = right.getNext(); String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return; } int fromIndex = isIndexOf ? 0 : lstring.length();"
      },
      {
        "txt": "if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return; } else { fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex);"
      },
      {
        "txt": "Node newNode = Node.newNumber(indexVal); parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node arrayNode = left.getFirstChild();"
      },
      {
        "txt": "Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return; } String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild();"
      },
      {
        "txt": "if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { <extra_id_0> foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem);"
      },
      {
        "txt": "foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); } foldedSize += arrayFoldedChildren.size() - 1;"
      },
      {
        "txt": "int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\"); parent.replaceChild(n, emptyStringNode); break; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return;"
      },
      {
        "txt": "} arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) { Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode); foldedStringNode = replacement; } parent.replaceChild(n, foldedStringNode); break; default:"
      },
      {
        "txt": "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead; foldedSize += InlineCostEstimator.getCost(right); if (foldedSize > originalSize) { return; } arrayNode.detachChildren();"
      },
      {
        "txt": "for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); } break; } t.getCompiler().reportCodeChange(); } void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.ARRAYLIT) {"
      },
      {
        "txt": "if (right.getType() != Token.NUMBER) { return; } double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) { t.getCompiler().report(JSError.make(t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf(index))); return; }"
      },
      {
        "txt": "if (intIndex < 0) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) {"
      },
      {
        "txt": "t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } left.removeChild(elem); parent.replaceChild(n, elem); t.getCompiler().reportCodeChange(); } } void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) { case Token.ARRAYLIT: if (NodeUtil.mayHaveSideEffects(left)) { return; } knownLength = left.getChildCount();"
      },
      {
        "txt": "break; case Token.STRING: knownLength = left.getString().length(); break; default: return; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); parent.replaceChild(n, lengthNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } void tryFoldRegularExpressionConstructor( NodeTraversal t, Node n, Node parent) { Node constructor = n.getFirstChild(); Node pattern = constructor.getNext(); // e.g. ^foobar$ Node flags = null != pattern ? pattern.getNext() : null; // e.g. gi if (null == pattern || (null != flags && null != flags.getNext())) { return;"
      },
      {
        "txt": "} if (// is pattern folded pattern.getType() == Token.STRING && !\"\".equals(pattern.getString()) && pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && !containsUnicodeEscape(pattern.getString())) { pattern = makeForwardSlashBracketSafe(pattern); Node regexLiteral; if (null == flags || \"\".equals(flags.getString())) {"
      },
      {
        "txt": "regexLiteral = new Node(Token.REGEXP, pattern); } else { if (!areValidRegexpFlags(flags.getString())) { error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags); return; } if (!areSafeFlagsToFold(flags.getString())) { return; } n.removeChild(flags);"
      },
      {
        "txt": "regexLiteral = new Node(Token.REGEXP, pattern, flags); } parent.replaceChild(n, regexLiteral); t.getCompiler().reportCodeChange(); } } private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\"); private static boolean areValidRegexpFlags(String flags) { return REGEXP_FLAGS_RE.matcher(flags).matches(); }"
      },
      {
        "txt": "private static boolean areSafeFlagsToFold(String flags) { return flags.indexOf('g') < 0; } private static Node makeForwardSlashBracketSafe(Node n) { String s = n.getString(); StringBuilder sb = null; int pos = 0; for (int i = 0; i < s.length(); ++i) { switch (s.charAt(i)) { case '\\\\': // skip over the next char after a '\\\\'."
      },
      {
        "txt": "++i; break; case '/': // escape it if (null == sb) { sb = new StringBuilder(s.length() + 16); } sb.append(s, pos, i).append('\\\\'); pos = i; break; } } if (null == sb) { return n.cloneTree(); }"
      },
      {
        "txt": "sb.append(s, pos, s.length()); return Node.newString(sb.toString()); } void tryFoldLiteralConstructor( NodeTraversal t, Node n, Node parent, String className, int type) { Scope.Var var = t.getScope().getVar(className); if (var != null && var.isLocal()) { return; } Node literalNode = new Node(type);"
      },
      {
        "txt": "parent.replaceChild(n, literalNode); t.getCompiler().reportCodeChange(); } static boolean containsUnicodeEscape(String s) { String esc = CodeGenerator.regexpEscape(s); for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) { int nSlashes = 0; while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) { ++nSlashes; }"
      },
      {
        "txt": "if (0 == (nSlashes & 1)) { return true; } } return false; } void tryFoldWhile(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.WHILE); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; }"
      },
      {
        "txt": "NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldFor(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.FOR); if (n.getChildCount() != 4) return; if (n.getFirstChild().getType() != Token.EMPTY) return; Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {"
      },
      {
        "txt": "return; } NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldDo(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.DO); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {"
      },
      {
        "txt": "return; } if (hasBreakOrContinue(n)) { return; } Preconditions.checkState( NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); Node block = n.removeFirstChild(); parent.replaceChild(n, block); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} boolean hasBreakOrContinue(Node n) { return NodeUtil.has( n, Predicates.<Node>or( new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.NOT: Node first = n.getFirstChild(); switch (first.getType()) { case Token.NOT: { Node newRoot = first.removeFirstChild(); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); tryMinimizeCondition(t, n, parent);"
      },
      {
        "txt": "return; } case Token.AND: case Token.OR: { Node leftParent = first.getFirstChild(); Node rightParent = first.getLastChild(); if (leftParent.getType() != Token.NOT || rightParent.getType() != Token.NOT) { break; }"
      },
      {
        "txt": "Node left = leftParent.removeFirstChild(); Node right = rightParent.removeFirstChild(); int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND; Node newRoot = new Node(newOp, left, right); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); } break; }"
      },
      {
        "txt": "break; case Token.OR: case Token.AND: break; default: if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); int equivalentResult = result ? 1 : 0; maybeReplaceChildWithNumber(t, n, parent, equivalentResult); }"
      },
      {
        "txt": "return; } for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // c may be removed. tryMinimizeCondition(t, c, n); c = next; } } private void tryFoldForCondition(Node n, Node parent) { if (NodeUtil.isLiteralValue(n)) {"
      },
      {
        "txt": "boolean result = NodeUtil.getBooleanValue(n); if (result) { parent.replaceChild(n, new Node(Token.EMPTY)); compiler.reportCodeChange(); } } } private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent, int num) { Node newNode = Node.newNumber(num);"
      },
      {
        "txt": "if(!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } } private boolean isExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { return NodeUtil.isExpressionNode(n.getFirstChild()); }"
      },
      {
        "txt": "} return false; } private Node getBlockExpression(Node n) { Preconditions.checkState(isExpressBlock(n)); return n.getFirstChild(); } private boolean isReturnExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) {"
      },
      {
        "txt": "Node first = n.getFirstChild(); if (first.getType() == Token.RETURN) { return first.hasOneChild(); } } } return false; } private Node getBlockReturnExpression(Node n) { Preconditions.checkState(isReturnExpressBlock(n));"
      },
      {
        "txt": "return n.getFirstChild().getFirstChild(); } private boolean isVarBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node first = n.getFirstChild(); if (first.getType() == Token.VAR) { return first.hasOneChild(); } }"
      },
      {
        "txt": "} return false; } private Node getBlockVar(Node n) { Preconditions.checkState(isVarBlock(n)); return n.getFirstChild(); }"
      }
    ]
  },
  {
    "id": 439,
    "file_path": "src/com/google/javascript/jscomp/FoldConstants.java",
    "start-bug-line": 1492,
    "end-bug-line": 1492,
    "bug": "sb = new StringBuilder();",
    "fix": "sb = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.List; import java.util.regex.Pattern; class FoldConstants extends AbstractPostOrderCallback implements CompilerPass { static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error( \"JSC_DIVIDE_BY_0_ERROR\","
      },
      {
        "txt": "\"Divide by 0\"); static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error( \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR ="
      },
      {
        "txt": "DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\", \"Can't negate non-numeric value: {0}\"); static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error( \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\", \"Invalid flags to RegExp constructor: {0}\"); static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\","
      },
      {
        "txt": "\"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\"); private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND); private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR); private final AbstractCompiler compiler;"
      },
      {
        "txt": "FoldConstants(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node jsRoot) { NodeTraversal.traverse(compiler, jsRoot, this); } public void visit(NodeTraversal t, Node n, Node parent) { int type = n.getType(); if (type == Token.BLOCK) { tryFoldBlock(t, n, parent);"
      },
      {
        "txt": "return; } Node left = n.getFirstChild(); if (left == null) { return; } if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) { String newValue = null; switch (left.getType()) { case Token.STRING:"
      },
      {
        "txt": "newValue = \"string\"; break; case Token.NUMBER: newValue = \"number\"; break; case Token.TRUE: case Token.FALSE: newValue = \"boolean\"; break; case Token.NULL:"
      },
      {
        "txt": "case Token.OBJECTLIT: case Token.ARRAYLIT: newValue = \"object\"; break; case Token.NAME: if (\"undefined\".equals(left.getString())) { newValue = \"undefined\"; } break; }"
      },
      {
        "txt": "if (newValue != null) { parent.replaceChild(n, Node.newString(newValue)); t.getCompiler().reportCodeChange(); } return; } if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) { Preconditions.checkState(n.hasOneChild());"
      },
      {
        "txt": "if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild()); t.getCompiler().reportCodeChange(); return; } if (type == Token.NOT && tryMinimizeNot(t, n, parent)) { return; } if (!NodeUtil.isLiteralValue(left)) { return;"
      },
      {
        "txt": "} switch (type) { case Token.NOT: int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE; parent.replaceChild(n, new Node(result)); t.getCompiler().reportCodeChange(); break; case Token.NEG: try {"
      },
      {
        "txt": "if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) { return; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left); t.getCompiler().reportCodeChange(); return; } }"
      },
      {
        "txt": "double negNum = -left.getDouble(); parent.replaceChild(n, Node.newNumber(negNum)); t.getCompiler().reportCodeChange(); } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; case Token.BITNOT: try { double val = left.getDouble();"
      },
      {
        "txt": "if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { parent.replaceChild(n, Node.newNumber(~intVal)); t.getCompiler().reportCodeChange(); } else { error(t, FRACTIONAL_BITWISE_OPERAND, left); } } else { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);"
      },
      {
        "txt": "} } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; } return; } else if (type == Token.NEW) { if (Token.NAME == left.getType()) { String className = left.getString();"
      },
      {
        "txt": "if (\"RegExp\".equals(className)) { tryFoldRegularExpressionConstructor(t, n, parent); } else if (left.getNext() == null) { if (\"Array\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.ARRAYLIT); } else if (\"Object\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.OBJECTLIT); }"
      },
      {
        "txt": "} } } if (type == Token.EXPR_RESULT) { tryMinimizeCondition(t, left, n); return; } if (type == Token.RETURN) { tryReduceReturn(t, n); return;"
      },
      {
        "txt": "} Node right = left.getNext(); if (right == null) { return; } if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) { if (NodeUtil.isImmutableValue(left)) { parent.replaceChild(n, new Node(Token.FALSE));"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return; } if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { parent.replaceChild(n, new Node(Token.TRUE)); t.getCompiler().reportCodeChange(); return; } }"
      },
      {
        "txt": "if (type == Token.IF || type == Token.HOOK) { tryMinimizeCondition(t, n.getFirstChild(), n); boolean changes = tryFoldHookIf(t, n, parent); if (type == Token.IF && !changes) { tryMinimizeIf(t, n, parent); } return; } if (type == Token.DO) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);"
      },
      {
        "txt": "tryFoldDo(t, n, parent); return; } if (type == Token.WHILE) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldWhile(t, n, parent); return; } if (type == Token.FOR) { Node condition = NodeUtil.getConditionExpression(n);"
      },
      {
        "txt": "if (condition != null) { tryMinimizeCondition(t, condition, n); condition = NodeUtil.getConditionExpression(n); this.tryFoldForCondition(condition, n); } tryFoldFor(t, n, parent); return; } if (type == Token.AND || type == Token.OR) {"
      },
      {
        "txt": "tryFoldAndOr(t, n, left, right, parent); return; } if (type == Token.BITOR || type == Token.BITAND) { tryFoldBitAndOr(t, n, left, right, parent); return; } if (type == Token.LSH || type == Token.RSH ||"
      },
      {
        "txt": "type == Token.URSH) { tryFoldShift(t, n, left, right, parent); return; } if (type == Token.GETPROP) { tryFoldGetProp(t, n, left, right, parent); return; } if (type == Token.CALL) { tryFoldStringJoin(t, n, left, right, parent);"
      },
      {
        "txt": "tryFoldStringIndexOf(t, n, left, right, parent); return; } if (type == Token.ASSIGN) { tryFoldAssign(t, n, left, right); } if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) { if (type == Token.ADD) tryFoldLeftChildAdd(t, n, left, right, parent);"
      },
      {
        "txt": "if (type == Token.LT || type == Token.GT) { tryFoldComparison(t, n, left, right, parent); } return; // The subsequent ops only work if the LHS & RHS are consts } if (type == Token.ADD) { tryFoldAdd(t, n, left, right, parent); return; }"
      },
      {
        "txt": "if (type == Token.SUB || type == Token.MUL || type == Token.DIV) { tryFoldArithmetic(t, n, left, right, parent); return; } if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||"
      },
      {
        "txt": "type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) { tryFoldComparison(t, n, left, right, parent); return; } if (type == Token.GETELEM) { tryFoldGetElem(t, n, left, right, parent); return;"
      },
      {
        "txt": "} } private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) { t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString())); } private boolean consumesDanglingElse(Node n) { while (true) { switch (n.getType()) { case Token.IF: if (n.getChildCount() < 3) return true;"
      },
      {
        "txt": "n = n.getLastChild(); continue; case Token.WITH: case Token.WHILE: case Token.FOR: n = n.getLastChild(); continue; default: return false; }"
      },
      {
        "txt": "} } private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return; } if (NodeUtil.mayHaveSideEffects(left)) { return;"
      },
      {
        "txt": "} Node leftChild = right.getFirstChild(); if (!compiler.areNodesEqualForInlining(left, leftChild)) { return; } int newType = -1; switch (right.getType()) { case Token.ADD: newType = Token.ASSIGN_ADD; break;"
      },
      {
        "txt": "case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR: newType = Token.ASSIGN_BITOR; break; case Token.BITXOR: newType = Token.ASSIGN_BITXOR; break; case Token.DIV:"
      },
      {
        "txt": "newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH; break; case Token.MOD: newType = Token.ASSIGN_MOD; break; case Token.MUL: newType = Token.ASSIGN_MUL;"
      },
      {
        "txt": "break; case Token.RSH: newType = Token.ASSIGN_RSH; break; case Token.SUB: newType = Token.ASSIGN_SUB; break; case Token.URSH: newType = Token.ASSIGN_URSH; break;"
      },
      {
        "txt": "default: return; } n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent())); t.getCompiler().reportCodeChange(); } void tryFoldBlock(NodeTraversal t, Node n, Node parent) { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // save c.next, since 'c' may be removed"
      },
      {
        "txt": "if (!NodeUtil.mayHaveSideEffects(c)) { n.removeChild(c); // lazy kids t.getCompiler().reportCodeChange(); } c = next; } if (n.isSyntheticBlock() || parent == null) { return; } if (NodeUtil.tryMergeBlock(n)) {"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) { int type = n.getType(); Node cond = n.getFirstChild(); Node thenBody = cond.getNext(); Node elseBody = thenBody.getNext(); boolean changes = false; if (type == Token.IF) {"
      },
      {
        "txt": "if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) { n.removeChild(elseBody); elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) { n.removeChild(elseBody); n.replaceChild(thenBody, elseBody); Node notCond = new Node(Token.NOT);"
      },
      {
        "txt": "n.replaceChild(cond, notCond); notCond.addChildToFront(cond); cond = notCond; thenBody = cond.getNext(); elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) { if (NodeUtil.mayHaveSideEffects(cond)) {"
      },
      {
        "txt": "n.removeChild(cond); parent.replaceChild(n, NodeUtil.newExpr(cond)); } else { NodeUtil.removeChild(parent, n); } t.getCompiler().reportCodeChange(); return true; // The if has been removed. There is nothing to do. } } else { Preconditions.checkState(type == Token.HOOK);"
      },
      {
        "txt": "if (NodeUtil.isExpressionNode(parent)) { if (!NodeUtil.mayHaveSideEffects(thenBody)) { Node ifNode = new Node(Token.IF); if (cond.getType() == Token.NOT) { Node expr = cond.getFirstChild(); cond.removeChild(expr); ifNode.addChildToBack(expr); } else { Node not = new Node(Token.NOT); n.removeChild(cond);"
      },
      {
        "txt": "not.addChildToBack(cond); ifNode.addChildToBack(not); } n.removeChild(elseBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))); parent.getParent().replaceChild(parent, ifNode); t.getCompiler().reportCodeChange(); return true; } else if (!NodeUtil.mayHaveSideEffects(elseBody)) {"
      },
      {
        "txt": "Node ifNode = new Node(Token.IF); n.removeChild(cond); ifNode.addChildToBack(cond); n.removeChild(thenBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))); parent.getParent().replaceChild(parent, ifNode); t.getCompiler().reportCodeChange(); return true; }"
      },
      {
        "txt": "} } if (!NodeUtil.isLiteralValue(cond)) { return changes; // We can't remove branches otherwise! } boolean condTrue = NodeUtil.getBooleanValue(cond); if (n.getChildCount() == 2) { Preconditions.checkState(type == Token.IF); if (condTrue) { Node thenStmt = n.getFirstChild().getNext();"
      },
      {
        "txt": "n.removeChild(thenStmt); parent.replaceChild(n, thenStmt); t.getCompiler().reportCodeChange(); } else { NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } } else { Node firstBranch = n.getFirstChild().getNext();"
      },
      {
        "txt": "Node secondBranch = firstBranch.getNext(); Node branch = condTrue ? firstBranch : secondBranch; Node notBranch = condTrue ? secondBranch : firstBranch; NodeUtil.redeclareVarsInsideBranch(notBranch); n.removeChild(branch); parent.replaceChild(n, branch); t.getCompiler().reportCodeChange(); } return true; }"
      },
      {
        "txt": "private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) { Node notChild = n.getFirstChild(); int complementOperator; switch (notChild.getType()) { case Token.EQ: complementOperator = Token.NE; break; case Token.NE: complementOperator = Token.EQ; break;"
      },
      {
        "txt": "case Token.SHEQ: complementOperator = Token.SHNE; break; case Token.SHNE: complementOperator = Token.SHEQ; break; default: return false; } Node newOperator = n.removeFirstChild();"
      },
      {
        "txt": "newOperator.setType(complementOperator); parent.replaceChild(n, newOperator); t.getCompiler().reportCodeChange(); return true; } void tryMinimizeIf(NodeTraversal t, Node n, Node parent) { Node cond = n.getFirstChild(); Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) {"
      },
      {
        "txt": "if (isExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(t, expr)) { return; } if (cond.getType() == Token.NOT) { if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) { return;"
      },
      {
        "txt": "} Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); return; } if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(),"
      },
      {
        "txt": "AND_PRECEDENCE)) { return; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); } return;"
      },
      {
        "txt": "} tryRemoveRepeatedStatements(t, n); if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); t.getCompiler().reportCodeChange(); return; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {"
      },
      {
        "txt": "Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node returnNode = new Node(Token.RETURN, hookNode); parent.replaceChild(n, returnNode); t.getCompiler().reportCodeChange(); return;"
      },
      {
        "txt": "} boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) { if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&"
      },
      {
        "txt": "!NodeUtil.mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node assign = new Node(thenOp.getType(), assignName, hookNode);"
      },
      {
        "txt": "Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } else if (NodeUtil.isCall(thenOp)) { n.removeChild(cond); thenOp.detachFromParent(); elseOp.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp); Node expr = NodeUtil.newExpr(hookNode);"
      },
      {
        "txt": "parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } return; } boolean thenBranchIsVar = isVarBlock(thenBranch); boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {"
      },
      {
        "txt": "Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) { Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent();"
      },
      {
        "txt": "Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } else if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild();"
      },
      {
        "txt": "Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild(); if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren(); cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent();"
      },
      {
        "txt": "name2.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } } private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) { Preconditions.checkState(n.getType() == Token.IF); Node parent = n.getParent(); if (!NodeUtil.isStatementBlock(parent)) {"
      },
      {
        "txt": "return; } Node cond = n.getFirstChild(); Node trueBranch = cond.getNext(); Node falseBranch = trueBranch.getNext(); Preconditions.checkNotNull(trueBranch); Preconditions.checkNotNull(falseBranch); while (true) { Node lastTrue = trueBranch.getLastChild(); Node lastFalse = falseBranch.getLastChild();"
      },
      {
        "txt": "if (lastTrue == null || lastFalse == null || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) { break; } lastTrue.detachFromParent(); lastFalse.detachFromParent(); parent.addChildAfter(lastTrue, n); t.getCompiler().reportCodeChange(); } }"
      },
      {
        "txt": "private void tryReduceReturn(NodeTraversal t, Node n) { Node result = n.getFirstChild(); if (result != null) { switch (result.getType()) { case Token.VOID: Node operand = result.getFirstChild(); if (!NodeUtil.mayHaveSideEffects(operand)) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "return; case Token.NAME: String name = result.getString(); if (name.equals(\"undefined\")) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); } return; } }"
      },
      {
        "txt": "} private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) { final boolean[] found = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { found[0] |= (n.getType() == Token.GETPROP && parent.getType() == Token.ASSIGN); } }).traverse(n); return found[0];"
      },
      {
        "txt": "} private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n, final int precedence) { final boolean[] lower = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { lower[0] |= NodeUtil.precedence(n.getType()) < precedence; } }).traverse(n); return lower[0];"
      },
      {
        "txt": "} void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { Node result = null; int type = n.getType(); if (NodeUtil.isLiteralValue(left)) { boolean lval = NodeUtil.getBooleanValue(left); if (lval && type == Token.OR || !lval && type == Token.AND) { result = left;"
      },
      {
        "txt": "} else { result = right; } } else if (NodeUtil.isLiteralValue(right)) { int pt = parent.getType(); if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) || (pt == Token.HOOK && parent.getFirstChild() == n)) { boolean rval = NodeUtil.getBooleanValue(right); if (type == Token.OR && !rval ||"
      },
      {
        "txt": "type == Token.AND && rval) { result = left; } else { if (!NodeUtil.mayHaveSideEffects(left)) { result = right; } } } } if (result != null) {"
      },
      {
        "txt": "n.removeChild(result); parent.replaceChild(n, result); t.getCompiler().reportCodeChange(); } } void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) {"
      },
      {
        "txt": "Node ll = left.getFirstChild(); Node lr = ll.getNext(); if (lr.getType() != Token.STRING) return; String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll);"
      },
      {
        "txt": "n.replaceChild(right, Node.newString(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left);"
      },
      {
        "txt": "String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { parent.replaceChild(n, Node.newString(leftString + rightString)); t.getCompiler().reportCodeChange(); } } else { tryFoldArithmetic(t, n, left, right, parent); } } void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); switch (n.getType()) { case Token.ADD: result = lval + rval; break;"
      },
      {
        "txt": "case Token.SUB: result = lval - rval; break; case Token.MUL: result = lval * rval; break; case Token.DIV: if (rval == 0) { error(t, DIVIDE_BY_0_ERROR, right); return;"
      },
      {
        "txt": "} result = lval / rval; break; default: throw new Error(\"Unknown arithmetic operator\"); } if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1) { parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } } void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble();"
      },
      {
        "txt": "if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) { return; } int lvalInt = (int) lval; if (lvalInt != lval) { return; } int rvalInt = (int) rval; if (rvalInt != rval) {"
      },
      {
        "txt": "return; } switch (n.getType()) { case Token.BITAND: result = lvalInt & rvalInt; break; case Token.BITOR: result = lvalInt | rvalInt; break; default:"
      },
      {
        "txt": "throw new Error(\"Unknown bitwise operator\"); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } void tryFoldShift(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {"
      },
      {
        "txt": "double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); return; } if (!(rval >= 0 && rval < 32)) { error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return;"
      },
      {
        "txt": "} int lvalInt = (int) lval; if (lvalInt != lval) { error(t, FRACTIONAL_BITWISE_OPERAND, left); return; } int rvalInt = (int) rval; if (rvalInt != rval) { error(t, FRACTIONAL_BITWISE_OPERAND, right); return;"
      },
      {
        "txt": "} switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: result = lvalInt >>> rvalInt;"
      },
      {
        "txt": "break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } @SuppressWarnings(\"fallthrough\")"
      },
      {
        "txt": "void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) { int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild()))); switch (left.getType()) {"
      },
      {
        "txt": "case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild())) { return; } else if (!rightLiteral) { return; } else { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ:"
      },
      {
        "txt": "result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break; case Token.SHNE: result = !undefinedRight;"
      },
      {
        "txt": "break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break; default: return; }"
      },
      {
        "txt": "} break; case Token.NULL: if (undefinedRight) { result = (op == Token.EQ); break; } case Token.TRUE: case Token.FALSE: if (undefinedRight) {"
      },
      {
        "txt": "result = false; break; } case Token.THIS: int tt = right.getType(); if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL) return;"
      },
      {
        "txt": "switch (op) { case Token.EQ: result = left.getType() == right.getType(); break; case Token.NE: result = left.getType() != right.getType(); break; default: return; // we only handle == and != here }"
      },
      {
        "txt": "break; case Token.STRING: if (undefinedRight) { result = false; break; } if (Token.STRING != right.getType()) { return; // Only eval if they are the same type } switch (op) {"
      },
      {
        "txt": "case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.NE: result = !left.getString().equals(right.getString()); break; default: return; // we only handle == and != here } break;"
      },
      {
        "txt": "case Token.NUMBER: if (undefinedRight) { result = false; break; } if (Token.NUMBER != right.getType()) { return; // Only eval if they are the same type } double lv = left.getDouble(); double rv = right.getDouble();"
      },
      {
        "txt": "switch (op) { case Token.EQ: result = lv == rv; break; case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break; default: return; // don't handle that op }"
      },
      {
        "txt": "break; case Token.NAME: if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent;"
      },
      {
        "txt": "break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break; case Token.SHNE: result = !undefinedRight; break;"
      },
      {
        "txt": "case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break; default: return; } break;"
      },
      {
        "txt": "} } if (Token.NAME != right.getType()) { return; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString(); if (!ln.equals(rn)) { return; // Not the same value name. }"
      },
      {
        "txt": "switch (op) { case Token.LT: case Token.GT: result = false; break; default: return; // don't handle that op } break; default:"
      },
      {
        "txt": "return; } parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE)); t.getCompiler().reportCodeChange(); } void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return;"
      },
      {
        "txt": "} Node lstringNode = left.getFirstChild(); Node functionName = lstringNode.getNext(); if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(\"indexOf\") && !functionName.getString().equals(\"lastIndexOf\"))) { return; } String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.getString().equals(\"indexOf\");"
      },
      {
        "txt": "Node firstArg = right; Node secondArg = right.getNext(); String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return; } int fromIndex = isIndexOf ? 0 : lstring.length(); if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) {"
      },
      {
        "txt": "return; } else { fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex); Node newNode = Node.newNumber(indexVal); parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node arrayNode = left.getFirstChild(); Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {"
      },
      {
        "txt": "return; } String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) {"
      },
      {
        "txt": "} sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); <extra_id_0> } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); }"
      },
      {
        "txt": "elem = elem.getNext(); } if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); } foldedSize += arrayFoldedChildren.size() - 1; int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0:"
      },
      {
        "txt": "Node emptyStringNode = Node.newString(\"\"); parent.replaceChild(n, emptyStringNode); break; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return; } arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) {"
      },
      {
        "txt": "Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode); foldedStringNode = replacement; } parent.replaceChild(n, foldedStringNode); break; default: if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return; }"
      },
      {
        "txt": "int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead; foldedSize += InlineCostEstimator.getCost(right); if (foldedSize > originalSize) { return; } arrayNode.detachChildren(); for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); }"
      },
      {
        "txt": "break; } t.getCompiler().reportCodeChange(); } void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.ARRAYLIT) { if (right.getType() != Token.NUMBER) { return; }"
      },
      {
        "txt": "double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) { t.getCompiler().report(JSError.make(t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf(index))); return; } if (intIndex < 0) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex)));"
      },
      {
        "txt": "return; } Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return;"
      },
      {
        "txt": "} left.removeChild(elem); parent.replaceChild(n, elem); t.getCompiler().reportCodeChange(); } } void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (right.getType() == Token.STRING && right.getString().equals(\"length\")) {"
      },
      {
        "txt": "int knownLength = -1; switch (left.getType()) { case Token.ARRAYLIT: if (NodeUtil.mayHaveSideEffects(left)) { return; } knownLength = left.getChildCount(); break; case Token.STRING: knownLength = left.getString().length();"
      },
      {
        "txt": "break; default: return; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); parent.replaceChild(n, lengthNode); t.getCompiler().reportCodeChange(); } }"
      },
      {
        "txt": "void tryFoldRegularExpressionConstructor( NodeTraversal t, Node n, Node parent) { Node constructor = n.getFirstChild(); Node pattern = constructor.getNext(); // e.g. ^foobar$ Node flags = null != pattern ? pattern.getNext() : null; // e.g. gi if (null == pattern || (null != flags && null != flags.getNext())) { return; } if (// is pattern folded pattern.getType() == Token.STRING"
      },
      {
        "txt": "&& !\"\".equals(pattern.getString()) && pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && !containsUnicodeEscape(pattern.getString())) { pattern = makeForwardSlashBracketSafe(pattern); Node regexLiteral; if (null == flags || \"\".equals(flags.getString())) { regexLiteral = new Node(Token.REGEXP, pattern); } else { if (!areValidRegexpFlags(flags.getString())) {"
      },
      {
        "txt": "error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags); return; } if (!areSafeFlagsToFold(flags.getString())) { return; } n.removeChild(flags); regexLiteral = new Node(Token.REGEXP, pattern, flags); } parent.replaceChild(n, regexLiteral);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\"); private static boolean areValidRegexpFlags(String flags) { return REGEXP_FLAGS_RE.matcher(flags).matches(); } private static boolean areSafeFlagsToFold(String flags) { return flags.indexOf('g') < 0; }"
      },
      {
        "txt": "private static Node makeForwardSlashBracketSafe(Node n) { String s = n.getString(); StringBuilder sb = null; int pos = 0; for (int i = 0; i < s.length(); ++i) { switch (s.charAt(i)) { case '\\\\': // skip over the next char after a '\\\\'. ++i; break; case '/': // escape it"
      },
      {
        "txt": "if (null == sb) { sb = new StringBuilder(s.length() + 16); } sb.append(s, pos, i).append('\\\\'); pos = i; break; } } if (null == sb) { return n.cloneTree(); } sb.append(s, pos, s.length()); return Node.newString(sb.toString()); }"
      },
      {
        "txt": "void tryFoldLiteralConstructor( NodeTraversal t, Node n, Node parent, String className, int type) { Scope.Var var = t.getScope().getVar(className); if (var != null && var.isLocal()) { return; } Node literalNode = new Node(type); parent.replaceChild(n, literalNode); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "static boolean containsUnicodeEscape(String s) { String esc = CodeGenerator.regexpEscape(s); for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) { int nSlashes = 0; while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) { ++nSlashes; } if (0 == (nSlashes & 1)) { return true; } } return false;"
      },
      {
        "txt": "} void tryFoldWhile(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.WHILE); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; } NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} void tryFoldFor(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.FOR); if (n.getChildCount() != 4) return; if (n.getFirstChild().getType() != Token.EMPTY) return; Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; } NodeUtil.redeclareVarsInsideBranch(n);"
      },
      {
        "txt": "NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldDo(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.DO); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; } if (hasBreakOrContinue(n)) {"
      },
      {
        "txt": "return; } Preconditions.checkState( NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); Node block = n.removeFirstChild(); parent.replaceChild(n, block); t.getCompiler().reportCodeChange(); } boolean hasBreakOrContinue(Node n) { return NodeUtil.has("
      },
      {
        "txt": "n, Predicates.<Node>or( new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) { switch (n.getType()) { case Token.NOT: Node first = n.getFirstChild();"
      },
      {
        "txt": "switch (first.getType()) { case Token.NOT: { Node newRoot = first.removeFirstChild(); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); tryMinimizeCondition(t, n, parent); return; } case Token.AND:"
      },
      {
        "txt": "case Token.OR: { Node leftParent = first.getFirstChild(); Node rightParent = first.getLastChild(); if (leftParent.getType() != Token.NOT || rightParent.getType() != Token.NOT) { break; } Node left = leftParent.removeFirstChild(); Node right = rightParent.removeFirstChild(); int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;"
      },
      {
        "txt": "Node newRoot = new Node(newOp, left, right); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); } break; } break; case Token.OR: case Token.AND:"
      },
      {
        "txt": "break; default: if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); int equivalentResult = result ? 1 : 0; maybeReplaceChildWithNumber(t, n, parent, equivalentResult); } return; } for (Node c = n.getFirstChild(); c != null; ) {"
      },
      {
        "txt": "Node next = c.getNext(); // c may be removed. tryMinimizeCondition(t, c, n); c = next; } } private void tryFoldForCondition(Node n, Node parent) { if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); if (result) { parent.replaceChild(n, new Node(Token.EMPTY));"
      },
      {
        "txt": "compiler.reportCodeChange(); } } } private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent, int num) { Node newNode = Node.newNumber(num); if(!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } private boolean isExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { return NodeUtil.isExpressionNode(n.getFirstChild()); } } return false; }"
      },
      {
        "txt": "private Node getBlockExpression(Node n) { Preconditions.checkState(isExpressBlock(n)); return n.getFirstChild(); } private boolean isReturnExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node first = n.getFirstChild(); if (first.getType() == Token.RETURN) { return first.hasOneChild();"
      },
      {
        "txt": "} } } return false; } private Node getBlockReturnExpression(Node n) { Preconditions.checkState(isReturnExpressBlock(n)); return n.getFirstChild().getFirstChild(); } private boolean isVarBlock(Node n) {"
      },
      {
        "txt": "if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node first = n.getFirstChild(); if (first.getType() == Token.VAR) { return first.hasOneChild(); } } } return false; }"
      },
      {
        "txt": "private Node getBlockVar(Node n) { Preconditions.checkState(isVarBlock(n)); return n.getFirstChild(); }"
      }
    ]
  },
  {
    "id": 440,
    "file_path": "src/com/google/javascript/jscomp/FoldConstants.java",
    "start-bug-line": 1500,
    "end-bug-line": 1500,
    "bug": "if (sb.length() > 0) {",
    "fix": "if (sb != null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.List; import java.util.regex.Pattern; class FoldConstants extends AbstractPostOrderCallback"
      },
      {
        "txt": "implements CompilerPass { static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error( \"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"); static final DiagnosticType INVALID_GETELEM_INDEX_ERROR = DiagnosticType.error( \"JSC_INVALID_GETELEM_INDEX_ERROR\", \"Array index not integer: {0}\"); static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_INDEX_OUT_OF_BOUNDS_ERROR\", \"Array index out of bounds: {0}\"); static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR = DiagnosticType.error( \"JSC_NEGATING_A_NON_NUMBER_ERROR\", \"Can't negate non-numeric value: {0}\"); static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS = DiagnosticType.error( \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\", \"Invalid flags to RegExp constructor: {0}\");"
      },
      {
        "txt": "static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE = DiagnosticType.error( \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\", \"Operand out of range, bitwise operation will lose information: {0}\"); static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error( \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\", \"Shift amount out of bounds: {0}\"); static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error( \"JSC_FRACTIONAL_BITWISE_OPERAND\", \"Fractional bitwise operand: {0}\");"
      },
      {
        "txt": "private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND); private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR); private final AbstractCompiler compiler; FoldConstants(AbstractCompiler compiler) { this.compiler = compiler; } public void process(Node externs, Node jsRoot) { NodeTraversal.traverse(compiler, jsRoot, this); } public void visit(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "int type = n.getType(); if (type == Token.BLOCK) { tryFoldBlock(t, n, parent); return; } Node left = n.getFirstChild(); if (left == null) { return; } if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {"
      },
      {
        "txt": "String newValue = null; switch (left.getType()) { case Token.STRING: newValue = \"string\"; break; case Token.NUMBER: newValue = \"number\"; break; case Token.TRUE: case Token.FALSE:"
      },
      {
        "txt": "newValue = \"boolean\"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: newValue = \"object\"; break; case Token.NAME: if (\"undefined\".equals(left.getString())) { newValue = \"undefined\";"
      },
      {
        "txt": "} break; } if (newValue != null) { parent.replaceChild(n, Node.newString(newValue)); t.getCompiler().reportCodeChange(); } return; } if (type == Token.NOT ||"
      },
      {
        "txt": "type == Token.NEG || type == Token.BITNOT) { Preconditions.checkState(n.hasOneChild()); if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, n.removeFirstChild()); t.getCompiler().reportCodeChange(); return; } if (type == Token.NOT && tryMinimizeNot(t, n, parent)) { return;"
      },
      {
        "txt": "} if (!NodeUtil.isLiteralValue(left)) { return; } switch (type) { case Token.NOT: int result = NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE; parent.replaceChild(n, new Node(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "break; case Token.NEG: try { if (left.getType() == Token.NAME) { if (left.getString().equals(\"Infinity\")) { return; } else if (left.getString().equals(\"NaN\")) { n.removeChild(left); parent.replaceChild(n, left); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } } double negNum = -left.getDouble(); parent.replaceChild(n, Node.newNumber(negNum)); t.getCompiler().reportCodeChange(); } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break;"
      },
      {
        "txt": "case Token.BITNOT: try { double val = left.getDouble(); if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { int intVal = (int) val; if (intVal == val) { parent.replaceChild(n, Node.newNumber(~intVal)); t.getCompiler().reportCodeChange(); } else { error(t, FRACTIONAL_BITWISE_OPERAND, left);"
      },
      {
        "txt": "} } else { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); } } catch (UnsupportedOperationException ex) { error(t, NEGATING_A_NON_NUMBER_ERROR, left); } break; } return;"
      },
      {
        "txt": "} else if (type == Token.NEW) { if (Token.NAME == left.getType()) { String className = left.getString(); if (\"RegExp\".equals(className)) { tryFoldRegularExpressionConstructor(t, n, parent); } else if (left.getNext() == null) { if (\"Array\".equals(className)) { tryFoldLiteralConstructor( t, n, parent, className, Token.ARRAYLIT); } else if (\"Object\".equals(className)) {"
      },
      {
        "txt": "tryFoldLiteralConstructor( t, n, parent, className, Token.OBJECTLIT); } } } } if (type == Token.EXPR_RESULT) { tryMinimizeCondition(t, left, n); return; }"
      },
      {
        "txt": "if (type == Token.RETURN) { tryReduceReturn(t, n); return; } Node right = left.getNext(); if (right == null) { return; } if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left)"
      },
      {
        "txt": "&& !NodeUtil.mayHaveSideEffects(right)) { if (NodeUtil.isImmutableValue(left)) { parent.replaceChild(n, new Node(Token.FALSE)); t.getCompiler().reportCodeChange(); return; } if (right.getType() == Token.NAME && \"Object\".equals(right.getString())) { parent.replaceChild(n, new Node(Token.TRUE)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } } if (type == Token.IF || type == Token.HOOK) { tryMinimizeCondition(t, n.getFirstChild(), n); boolean changes = tryFoldHookIf(t, n, parent); if (type == Token.IF && !changes) { tryMinimizeIf(t, n, parent); } return;"
      },
      {
        "txt": "} if (type == Token.DO) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldDo(t, n, parent); return; } if (type == Token.WHILE) { tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n); tryFoldWhile(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.FOR) { Node condition = NodeUtil.getConditionExpression(n); if (condition != null) { tryMinimizeCondition(t, condition, n); condition = NodeUtil.getConditionExpression(n); this.tryFoldForCondition(condition, n); } tryFoldFor(t, n, parent); return;"
      },
      {
        "txt": "} if (type == Token.AND || type == Token.OR) { tryFoldAndOr(t, n, left, right, parent); return; } if (type == Token.BITOR || type == Token.BITAND) { tryFoldBitAndOr(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.LSH || type == Token.RSH || type == Token.URSH) { tryFoldShift(t, n, left, right, parent); return; } if (type == Token.GETPROP) { tryFoldGetProp(t, n, left, right, parent); return;"
      },
      {
        "txt": "} if (type == Token.CALL) { tryFoldStringJoin(t, n, left, right, parent); tryFoldStringIndexOf(t, n, left, right, parent); return; } if (type == Token.ASSIGN) { tryFoldAssign(t, n, left, right); } if (!NodeUtil.isLiteralValue(left) ||"
      },
      {
        "txt": "!NodeUtil.isLiteralValue(right)) { if (type == Token.ADD) tryFoldLeftChildAdd(t, n, left, right, parent); if (type == Token.LT || type == Token.GT) { tryFoldComparison(t, n, left, right, parent); } return; // The subsequent ops only work if the LHS & RHS are consts } if (type == Token.ADD) {"
      },
      {
        "txt": "tryFoldAdd(t, n, left, right, parent); return; } if (type == Token.SUB || type == Token.MUL || type == Token.DIV) { tryFoldArithmetic(t, n, left, right, parent); return; } if (type == Token.LT ||"
      },
      {
        "txt": "type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) { tryFoldComparison(t, n, left, right, parent); return; }"
      },
      {
        "txt": "if (type == Token.GETELEM) { tryFoldGetElem(t, n, left, right, parent); return; } } private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) { t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString())); } private boolean consumesDanglingElse(Node n) { while (true) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.IF: if (n.getChildCount() < 3) return true; n = n.getLastChild(); continue; case Token.WITH: case Token.WHILE: case Token.FOR: n = n.getLastChild(); continue;"
      },
      {
        "txt": "default: return false; } } } private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) { Preconditions.checkArgument(n.getType() == Token.ASSIGN); if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { return;"
      },
      {
        "txt": "} if (NodeUtil.mayHaveSideEffects(left)) { return; } Node leftChild = right.getFirstChild(); if (!compiler.areNodesEqualForInlining(left, leftChild)) { return; } int newType = -1; switch (right.getType()) {"
      },
      {
        "txt": "case Token.ADD: newType = Token.ASSIGN_ADD; break; case Token.BITAND: newType = Token.ASSIGN_BITAND; break; case Token.BITOR: newType = Token.ASSIGN_BITOR; break; case Token.BITXOR:"
      },
      {
        "txt": "newType = Token.ASSIGN_BITXOR; break; case Token.DIV: newType = Token.ASSIGN_DIV; break; case Token.LSH: newType = Token.ASSIGN_LSH; break; case Token.MOD: newType = Token.ASSIGN_MOD;"
      },
      {
        "txt": "break; case Token.MUL: newType = Token.ASSIGN_MUL; break; case Token.RSH: newType = Token.ASSIGN_RSH; break; case Token.SUB: newType = Token.ASSIGN_SUB; break;"
      },
      {
        "txt": "case Token.URSH: newType = Token.ASSIGN_URSH; break; default: return; } n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent())); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "void tryFoldBlock(NodeTraversal t, Node n, Node parent) { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // save c.next, since 'c' may be removed if (!NodeUtil.mayHaveSideEffects(c)) { n.removeChild(c); // lazy kids t.getCompiler().reportCodeChange(); } c = next; } if (n.isSyntheticBlock() || parent == null) {"
      },
      {
        "txt": "return; } if (NodeUtil.tryMergeBlock(n)) { t.getCompiler().reportCodeChange(); } } boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) { int type = n.getType(); Node cond = n.getFirstChild(); Node thenBody = cond.getNext();"
      },
      {
        "txt": "Node elseBody = thenBody.getNext(); boolean changes = false; if (type == Token.IF) { if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) { n.removeChild(elseBody); elseBody = null; t.getCompiler().reportCodeChange(); changes = true; } if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {"
      },
      {
        "txt": "n.removeChild(elseBody); n.replaceChild(thenBody, elseBody); Node notCond = new Node(Token.NOT); n.replaceChild(cond, notCond); notCond.addChildToFront(cond); cond = notCond; thenBody = cond.getNext(); elseBody = null; t.getCompiler().reportCodeChange(); changes = true;"
      },
      {
        "txt": "} if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) { if (NodeUtil.mayHaveSideEffects(cond)) { n.removeChild(cond); parent.replaceChild(n, NodeUtil.newExpr(cond)); } else { NodeUtil.removeChild(parent, n); } t.getCompiler().reportCodeChange(); return true; // The if has been removed. There is nothing to do."
      },
      {
        "txt": "} } else { Preconditions.checkState(type == Token.HOOK); if (NodeUtil.isExpressionNode(parent)) { if (!NodeUtil.mayHaveSideEffects(thenBody)) { Node ifNode = new Node(Token.IF); if (cond.getType() == Token.NOT) { Node expr = cond.getFirstChild(); cond.removeChild(expr); ifNode.addChildToBack(expr);"
      },
      {
        "txt": "} else { Node not = new Node(Token.NOT); n.removeChild(cond); not.addChildToBack(cond); ifNode.addChildToBack(not); } n.removeChild(elseBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))); parent.getParent().replaceChild(parent, ifNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } else if (!NodeUtil.mayHaveSideEffects(elseBody)) { Node ifNode = new Node(Token.IF); n.removeChild(cond); ifNode.addChildToBack(cond); n.removeChild(thenBody); ifNode.addChildToBack( new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))); parent.getParent().replaceChild(parent, ifNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); return true; } } } if (!NodeUtil.isLiteralValue(cond)) { return changes; // We can't remove branches otherwise! } boolean condTrue = NodeUtil.getBooleanValue(cond); if (n.getChildCount() == 2) {"
      },
      {
        "txt": "Preconditions.checkState(type == Token.IF); if (condTrue) { Node thenStmt = n.getFirstChild().getNext(); n.removeChild(thenStmt); parent.replaceChild(n, thenStmt); t.getCompiler().reportCodeChange(); } else { NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } else { Node firstBranch = n.getFirstChild().getNext(); Node secondBranch = firstBranch.getNext(); Node branch = condTrue ? firstBranch : secondBranch; Node notBranch = condTrue ? secondBranch : firstBranch; NodeUtil.redeclareVarsInsideBranch(notBranch); n.removeChild(branch); parent.replaceChild(n, branch); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} return true; } private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) { Node notChild = n.getFirstChild(); int complementOperator; switch (notChild.getType()) { case Token.EQ: complementOperator = Token.NE; break;"
      },
      {
        "txt": "case Token.NE: complementOperator = Token.EQ; break; case Token.SHEQ: complementOperator = Token.SHNE; break; case Token.SHNE: complementOperator = Token.SHEQ; break; default:"
      },
      {
        "txt": "return false; } Node newOperator = n.removeFirstChild(); newOperator.setType(complementOperator); parent.replaceChild(n, newOperator); t.getCompiler().reportCodeChange(); return true; } void tryMinimizeIf(NodeTraversal t, Node n, Node parent) { Node cond = n.getFirstChild();"
      },
      {
        "txt": "Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (isPropertyAssignmentInExpression(t, expr)) { return; } if (cond.getType() == Token.NOT) { if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) &&"
      },
      {
        "txt": "isLowerPrecedenceInExpression(t, expr.getFirstChild(), OR_PRECEDENCE)) { return; } Node or = new Node(Token.OR, cond.removeFirstChild(), expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); t.getCompiler().reportCodeChange(); return;"
      },
      {
        "txt": "} if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) || isLowerPrecedenceInExpression(t, expr.getFirstChild(), AND_PRECEDENCE)) { return; } n.removeChild(cond); Node and = new Node(Token.AND, cond, expr.removeFirstChild()); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } return; } tryRemoveRepeatedStatements(t, n); if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "return; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); Node returnNode = new Node(Token.RETURN, hookNode);"
      },
      {
        "txt": "parent.replaceChild(n, returnNode); t.getCompiler().reportCodeChange(); return; } boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) {"
      },
      {
        "txt": "if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !NodeUtil.mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = new Node(Token.HOOK, cond, thenExpr,"
      },
      {
        "txt": "elseExpr); Node assign = new Node(thenOp.getType(), assignName, hookNode); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } else if (NodeUtil.isCall(thenOp)) { n.removeChild(cond); thenOp.detachFromParent();"
      },
      {
        "txt": "elseOp.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp); Node expr = NodeUtil.newExpr(hookNode); parent.replaceChild(n, expr); t.getCompiler().reportCodeChange(); } } return; } boolean thenBranchIsVar = isVarBlock(thenBranch);"
      },
      {
        "txt": "boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) { Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {"
      },
      {
        "txt": "Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&"
      },
      {
        "txt": "NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild(); if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren();"
      },
      {
        "txt": "cond.detachFromParent(); Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr); var.detachFromParent(); name2.addChildrenToBack(hookNode); parent.replaceChild(n, var); t.getCompiler().reportCodeChange(); } } } private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) {"
      },
      {
        "txt": "Preconditions.checkState(n.getType() == Token.IF); Node parent = n.getParent(); if (!NodeUtil.isStatementBlock(parent)) { return; } Node cond = n.getFirstChild(); Node trueBranch = cond.getNext(); Node falseBranch = trueBranch.getNext(); Preconditions.checkNotNull(trueBranch); Preconditions.checkNotNull(falseBranch);"
      },
      {
        "txt": "while (true) { Node lastTrue = trueBranch.getLastChild(); Node lastFalse = falseBranch.getLastChild(); if (lastTrue == null || lastFalse == null || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) { break; } lastTrue.detachFromParent(); lastFalse.detachFromParent(); parent.addChildAfter(lastTrue, n);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } private void tryReduceReturn(NodeTraversal t, Node n) { Node result = n.getFirstChild(); if (result != null) { switch (result.getType()) { case Token.VOID: Node operand = result.getFirstChild(); if (!NodeUtil.mayHaveSideEffects(operand)) {"
      },
      {
        "txt": "n.removeFirstChild(); t.getCompiler().reportCodeChange(); } return; case Token.NAME: String name = result.getString(); if (name.equals(\"undefined\")) { n.removeFirstChild(); t.getCompiler().reportCodeChange(); }"
      },
      {
        "txt": "return; } } } private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) { final boolean[] found = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { found[0] |= (n.getType() == Token.GETPROP && parent.getType() == Token.ASSIGN);"
      },
      {
        "txt": "} }).traverse(n); return found[0]; } private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n, final int precedence) { final boolean[] lower = { false }; new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() { public void visit(NodeTraversal t, Node n, Node parent) { lower[0] |= NodeUtil.precedence(n.getType()) < precedence;"
      },
      {
        "txt": "} }).traverse(n); return lower[0]; } void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { Node result = null; int type = n.getType(); if (NodeUtil.isLiteralValue(left)) { boolean lval = NodeUtil.getBooleanValue(left);"
      },
      {
        "txt": "if (lval && type == Token.OR || !lval && type == Token.AND) { result = left; } else { result = right; } } else if (NodeUtil.isLiteralValue(right)) { int pt = parent.getType(); if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO || (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||"
      },
      {
        "txt": "(pt == Token.HOOK && parent.getFirstChild() == n)) { boolean rval = NodeUtil.getBooleanValue(right); if (type == Token.OR && !rval || type == Token.AND && rval) { result = left; } else { if (!NodeUtil.mayHaveSideEffects(left)) { result = right; } }"
      },
      {
        "txt": "} } if (result != null) { n.removeChild(result); parent.replaceChild(n, result); t.getCompiler().reportCodeChange(); } } void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) { Node ll = left.getFirstChild(); Node lr = ll.getNext(); if (lr.getType() != Token.STRING) return; String leftString = NodeUtil.getStringValue(lr); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) {"
      },
      {
        "txt": "left.removeChild(ll); String result = leftString + rightString; n.replaceChild(left, ll); n.replaceChild(right, Node.newString(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right, Node parent) {"
      },
      {
        "txt": "if (left.getType() == Token.STRING || right.getType() == Token.STRING) { String leftString = NodeUtil.getStringValue(left); String rightString = NodeUtil.getStringValue(right); if (leftString != null && rightString != null) { parent.replaceChild(n, Node.newString(leftString + rightString)); t.getCompiler().reportCodeChange(); } } else { tryFoldArithmetic(t, n, left, right, parent);"
      },
      {
        "txt": "} } void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); switch (n.getType()) {"
      },
      {
        "txt": "case Token.ADD: result = lval + rval; break; case Token.SUB: result = lval - rval; break; case Token.MUL: result = lval * rval; break; case Token.DIV:"
      },
      {
        "txt": "if (rval == 0) { error(t, DIVIDE_BY_0_ERROR, right); return; } result = lval / rval; break; default: throw new Error(\"Unknown arithmetic operator\"); } if (String.valueOf(result).length() <="
      },
      {
        "txt": "String.valueOf(lval).length() + String.valueOf(rval).length() + 1) { parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } } void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {"
      },
      {
        "txt": "double result; double lval = left.getDouble(); double rval = right.getDouble(); if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) { return; } int lvalInt = (int) lval; if (lvalInt != lval) { return;"
      },
      {
        "txt": "} int rvalInt = (int) rval; if (rvalInt != rval) { return; } switch (n.getType()) { case Token.BITAND: result = lvalInt & rvalInt; break; case Token.BITOR:"
      },
      {
        "txt": "result = lvalInt | rvalInt; break; default: throw new Error(\"Unknown bitwise operator\"); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange(); } } void tryFoldShift(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(t, BITWISE_OPERAND_OUT_OF_RANGE, left); return; }"
      },
      {
        "txt": "if (!(rval >= 0 && rval < 32)) { error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return; } int lvalInt = (int) lval; if (lvalInt != lval) { error(t, FRACTIONAL_BITWISE_OPERAND, left); return; } int rvalInt = (int) rval;"
      },
      {
        "txt": "if (rvalInt != rval) { error(t, FRACTIONAL_BITWISE_OPERAND, right); return; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt;"
      },
      {
        "txt": "break; case Token.URSH: result = lvalInt >>> rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } parent.replaceChild(n, Node.newNumber(result)); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} } @SuppressWarnings(\"fallthrough\") void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right, Node parent) { int op = n.getType(); boolean result; boolean rightLiteral = NodeUtil.isLiteralValue(right); boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\"))"
      },
      {
        "txt": "|| (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild()))); switch (left.getType()) { case Token.VOID: if (!NodeUtil.isLiteralValue(left.getFirstChild())) { return; } else if (!rightLiteral) { return; } else { boolean nullRight = (Token.NULL == right.getType());"
      },
      {
        "txt": "boolean equivalent = undefinedRight || nullRight; switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight;"
      },
      {
        "txt": "break; case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break;"
      },
      {
        "txt": "default: return; } } break; case Token.NULL: if (undefinedRight) { result = (op == Token.EQ); break; }"
      },
      {
        "txt": "case Token.TRUE: case Token.FALSE: if (undefinedRight) { result = false; break; } case Token.THIS: int tt = right.getType(); if (tt != Token.THIS && tt != Token.TRUE &&"
      },
      {
        "txt": "tt != Token.FALSE && tt != Token.NULL) return; switch (op) { case Token.EQ: result = left.getType() == right.getType(); break; case Token.NE: result = left.getType() != right.getType(); break;"
      },
      {
        "txt": "default: return; // we only handle == and != here } break; case Token.STRING: if (undefinedRight) { result = false; break; } if (Token.STRING != right.getType()) {"
      },
      {
        "txt": "return; // Only eval if they are the same type } switch (op) { case Token.EQ: result = left.getString().equals(right.getString()); break; case Token.NE: result = !left.getString().equals(right.getString()); break; default:"
      },
      {
        "txt": "return; // we only handle == and != here } break; case Token.NUMBER: if (undefinedRight) { result = false; break; } if (Token.NUMBER != right.getType()) { return; // Only eval if they are the same type"
      },
      {
        "txt": "} double lv = left.getDouble(); double rv = right.getDouble(); switch (op) { case Token.EQ: result = lv == rv; break; case Token.NE: result = lv != rv; break; case Token.LE: result = lv <= rv; break; case Token.LT: result = lv < rv; break; case Token.GE: result = lv >= rv; break; case Token.GT: result = lv > rv; break;"
      },
      {
        "txt": "default: return; // don't handle that op } break; case Token.NAME: if (rightLiteral) { boolean undefinedLeft = (left.getString().equals(\"undefined\")); if (undefinedLeft) { boolean nullRight = (Token.NULL == right.getType()); boolean equivalent = undefinedRight || nullRight;"
      },
      {
        "txt": "switch (op) { case Token.EQ: result = equivalent; break; case Token.NE: result = !equivalent; break; case Token.SHEQ: result = undefinedRight; break;"
      },
      {
        "txt": "case Token.SHNE: result = !undefinedRight; break; case Token.LT: case Token.GT: case Token.LE: case Token.GE: result = false; break; default:"
      },
      {
        "txt": "return; } break; } } if (Token.NAME != right.getType()) { return; // Only eval if they are the same type } String ln = left.getString(); String rn = right.getString();"
      },
      {
        "txt": "if (!ln.equals(rn)) { return; // Not the same value name. } switch (op) { case Token.LT: case Token.GT: result = false; break; default: return; // don't handle that op"
      },
      {
        "txt": "} break; default: return; } parent.replaceChild(n, new Node(result ? Token.TRUE : Token.FALSE)); t.getCompiler().reportCodeChange(); } void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node lstringNode = left.getFirstChild(); Node functionName = lstringNode.getNext(); if ((lstringNode.getType() != Token.STRING) || (!functionName.getString().equals(\"indexOf\") && !functionName.getString().equals(\"lastIndexOf\"))) { return;"
      },
      {
        "txt": "} String lstring = NodeUtil.getStringValue(lstringNode); boolean isIndexOf = functionName.getString().equals(\"indexOf\"); Node firstArg = right; Node secondArg = right.getNext(); String searchValue = NodeUtil.getStringValue(firstArg); if (searchValue == null) { return; } int fromIndex = isIndexOf ? 0 : lstring.length();"
      },
      {
        "txt": "if (secondArg != null) { if ((secondArg.getNext() != null) || (secondArg.getType() != Token.NUMBER)) { return; } else { fromIndex = (int) secondArg.getDouble(); } } int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex);"
      },
      {
        "txt": "Node newNode = Node.newNumber(indexVal); parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) { return; } Node arrayNode = left.getFirstChild();"
      },
      {
        "txt": "Node functionName = arrayNode.getNext(); if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) { return; } String joinString = NodeUtil.getStringValue(right); List<Node> arrayFoldedChildren = Lists.newLinkedList(); StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild();"
      },
      {
        "txt": "while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString()));"
      },
      {
        "txt": "} foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } <extra_id_0> foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); } foldedSize += arrayFoldedChildren.size() - 1; int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) {"
      },
      {
        "txt": "int originalSize = InlineCostEstimator.getCost(n); switch (arrayFoldedChildren.size()) { case 0: Node emptyStringNode = Node.newString(\"\"); parent.replaceChild(n, emptyStringNode); break; case 1: Node foldedStringNode = arrayFoldedChildren.remove(0); if (foldedSize > originalSize) { return;"
      },
      {
        "txt": "} arrayNode.detachChildren(); if (foldedStringNode.getType() != Token.STRING) { Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode); foldedStringNode = replacement; } parent.replaceChild(n, foldedStringNode); break; default:"
      },
      {
        "txt": "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { return; } int kJoinOverhead = \"[].join()\".length(); foldedSize += kJoinOverhead; foldedSize += InlineCostEstimator.getCost(right); if (foldedSize > originalSize) { return; } arrayNode.detachChildren();"
      },
      {
        "txt": "for (Node node : arrayFoldedChildren) { arrayNode.addChildToBack(node); } break; } t.getCompiler().reportCodeChange(); } void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right, Node parent) { if (left.getType() == Token.ARRAYLIT) {"
      },
      {
        "txt": "if (right.getType() != Token.NUMBER) { return; } double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) { t.getCompiler().report(JSError.make(t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf(index))); return; }"
      },
      {
        "txt": "if (intIndex < 0) { t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } Node elem = left.getFirstChild(); for (int i = 0; elem != null && i < intIndex; i++) { elem = elem.getNext(); } if (elem == null) {"
      },
      {
        "txt": "t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf(intIndex))); return; } left.removeChild(elem); parent.replaceChild(n, elem); t.getCompiler().reportCodeChange(); } } void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,"
      },
      {
        "txt": "Node parent) { if (right.getType() == Token.STRING && right.getString().equals(\"length\")) { int knownLength = -1; switch (left.getType()) { case Token.ARRAYLIT: if (NodeUtil.mayHaveSideEffects(left)) { return; } knownLength = left.getChildCount();"
      },
      {
        "txt": "break; case Token.STRING: knownLength = left.getString().length(); break; default: return; } Preconditions.checkState(knownLength != -1); Node lengthNode = Node.newNumber(knownLength); parent.replaceChild(n, lengthNode);"
      },
      {
        "txt": "t.getCompiler().reportCodeChange(); } } void tryFoldRegularExpressionConstructor( NodeTraversal t, Node n, Node parent) { Node constructor = n.getFirstChild(); Node pattern = constructor.getNext(); // e.g. ^foobar$ Node flags = null != pattern ? pattern.getNext() : null; // e.g. gi if (null == pattern || (null != flags && null != flags.getNext())) { return;"
      },
      {
        "txt": "} if (// is pattern folded pattern.getType() == Token.STRING && !\"\".equals(pattern.getString()) && pattern.getString().length() < 100 && (null == flags || flags.getType() == Token.STRING) && !containsUnicodeEscape(pattern.getString())) { pattern = makeForwardSlashBracketSafe(pattern); Node regexLiteral; if (null == flags || \"\".equals(flags.getString())) {"
      },
      {
        "txt": "regexLiteral = new Node(Token.REGEXP, pattern); } else { if (!areValidRegexpFlags(flags.getString())) { error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags); return; } if (!areSafeFlagsToFold(flags.getString())) { return; } n.removeChild(flags);"
      },
      {
        "txt": "regexLiteral = new Node(Token.REGEXP, pattern, flags); } parent.replaceChild(n, regexLiteral); t.getCompiler().reportCodeChange(); } } private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\"); private static boolean areValidRegexpFlags(String flags) { return REGEXP_FLAGS_RE.matcher(flags).matches(); }"
      },
      {
        "txt": "private static boolean areSafeFlagsToFold(String flags) { return flags.indexOf('g') < 0; } private static Node makeForwardSlashBracketSafe(Node n) { String s = n.getString(); StringBuilder sb = null; int pos = 0; for (int i = 0; i < s.length(); ++i) { switch (s.charAt(i)) { case '\\\\': // skip over the next char after a '\\\\'."
      },
      {
        "txt": "++i; break; case '/': // escape it if (null == sb) { sb = new StringBuilder(s.length() + 16); } sb.append(s, pos, i).append('\\\\'); pos = i; break; } } if (null == sb) { return n.cloneTree(); }"
      },
      {
        "txt": "sb.append(s, pos, s.length()); return Node.newString(sb.toString()); } void tryFoldLiteralConstructor( NodeTraversal t, Node n, Node parent, String className, int type) { Scope.Var var = t.getScope().getVar(className); if (var != null && var.isLocal()) { return; } Node literalNode = new Node(type);"
      },
      {
        "txt": "parent.replaceChild(n, literalNode); t.getCompiler().reportCodeChange(); } static boolean containsUnicodeEscape(String s) { String esc = CodeGenerator.regexpEscape(s); for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) { int nSlashes = 0; while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) { ++nSlashes; }"
      },
      {
        "txt": "if (0 == (nSlashes & 1)) { return true; } } return false; } void tryFoldWhile(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.WHILE); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) { return; }"
      },
      {
        "txt": "NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldFor(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.FOR); if (n.getChildCount() != 4) return; if (n.getFirstChild().getType() != Token.EMPTY) return; Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {"
      },
      {
        "txt": "return; } NodeUtil.redeclareVarsInsideBranch(n); NodeUtil.removeChild(parent, n); t.getCompiler().reportCodeChange(); } void tryFoldDo(NodeTraversal t, Node n, Node parent) { Preconditions.checkArgument(n.getType() == Token.DO); Node cond = NodeUtil.getConditionExpression(n); if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {"
      },
      {
        "txt": "return; } if (hasBreakOrContinue(n)) { return; } Preconditions.checkState( NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); Node block = n.removeFirstChild(); parent.replaceChild(n, block); t.getCompiler().reportCodeChange();"
      },
      {
        "txt": "} boolean hasBreakOrContinue(Node n) { return NodeUtil.has( n, Predicates.<Node>or( new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.NOT: Node first = n.getFirstChild(); switch (first.getType()) { case Token.NOT: { Node newRoot = first.removeFirstChild(); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); tryMinimizeCondition(t, n, parent);"
      },
      {
        "txt": "return; } case Token.AND: case Token.OR: { Node leftParent = first.getFirstChild(); Node rightParent = first.getLastChild(); if (leftParent.getType() != Token.NOT || rightParent.getType() != Token.NOT) { break; }"
      },
      {
        "txt": "Node left = leftParent.removeFirstChild(); Node right = rightParent.removeFirstChild(); int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND; Node newRoot = new Node(newOp, left, right); parent.replaceChild(n, newRoot); n = newRoot; // continue from here. t.getCompiler().reportCodeChange(); } break; }"
      },
      {
        "txt": "break; case Token.OR: case Token.AND: break; default: if (NodeUtil.isLiteralValue(n)) { boolean result = NodeUtil.getBooleanValue(n); int equivalentResult = result ? 1 : 0; maybeReplaceChildWithNumber(t, n, parent, equivalentResult); }"
      },
      {
        "txt": "return; } for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); // c may be removed. tryMinimizeCondition(t, c, n); c = next; } } private void tryFoldForCondition(Node n, Node parent) { if (NodeUtil.isLiteralValue(n)) {"
      },
      {
        "txt": "boolean result = NodeUtil.getBooleanValue(n); if (result) { parent.replaceChild(n, new Node(Token.EMPTY)); compiler.reportCodeChange(); } } } private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent, int num) { Node newNode = Node.newNumber(num);"
      },
      {
        "txt": "if(!newNode.isEquivalentTo(n)) { parent.replaceChild(n, newNode); t.getCompiler().reportCodeChange(); } } private boolean isExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { return NodeUtil.isExpressionNode(n.getFirstChild()); }"
      },
      {
        "txt": "} return false; } private Node getBlockExpression(Node n) { Preconditions.checkState(isExpressBlock(n)); return n.getFirstChild(); } private boolean isReturnExpressBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) {"
      },
      {
        "txt": "Node first = n.getFirstChild(); if (first.getType() == Token.RETURN) { return first.hasOneChild(); } } } return false; } private Node getBlockReturnExpression(Node n) { Preconditions.checkState(isReturnExpressBlock(n));"
      },
      {
        "txt": "return n.getFirstChild().getFirstChild(); } private boolean isVarBlock(Node n) { if (n.getType() == Token.BLOCK) { if (n.hasOneChild()) { Node first = n.getFirstChild(); if (first.getType() == Token.VAR) { return first.hasOneChild(); } }"
      },
      {
        "txt": "} return false; } private Node getBlockVar(Node n) { Preconditions.checkState(isVarBlock(n)); return n.getFirstChild(); }"
      }
    ]
  }
]