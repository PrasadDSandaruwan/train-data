[
  {
    "id": 493,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 2401,
    "end-bug-line": 2401,
    "bug": "",
    "fix": "unreadToken = NO_UNREAD_TOKEN;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.base.Splitter;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ErrorReporter; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.StaticSourceFile; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class JsDocInfoParser {"
      },
      {
        "txt": "private final JsDocTokenStream stream; private final JSDocInfoBuilder jsdocBuilder; private final StaticSourceFile sourceFile; private final Node associatedNode; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private final Node templateNode; private class ErrorReporterParser { void addParserWarning(String messageId, String messageArg, int lineno, int charno) {"
      },
      {
        "txt": "errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addParserWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning("
      },
      {
        "txt": "\"Bad type annotation. \" + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); } void addTypeWarning(String messageId, int lineno, int charno) { errorReporter.warning( \"Bad type annotation. \" + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); }"
      },
      {
        "txt": "} private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private final Set<String> suppressionNames; static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of(\"this\", \"arguments\"); private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {"
      },
      {
        "txt": "this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION }"
      },
      {
        "txt": "JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { this.stream = stream; this.associatedNode = associatedNode; this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);"
      },
      {
        "txt": "if (commentNode != null) { this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); } this.annotationNames = config.annotationNames; this.suppressionNames = config.suppressionNames; this.errorReporter = errorReporter; this.templateNode = this.createTemplateNode(); } private String getSourceName() { return sourceFile == null ? null : sourceFile.getName();"
      },
      {
        "txt": "} public JSDocInfo parseInlineTypeDoc() { Node typeAst = parseAndRecordTypeNode(next()); JSTypeExpression expr = createJSTypeExpression(typeAst); if (expr != null) { jsdocBuilder.recordType(expr); return retrieveAndResetParsedJSDocInfo(); } return null; }"
      },
      {
        "txt": "public static Node parseTypeString(String typeString) { Config config = new Config( Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString), null,"
      },
      {
        "txt": "null, config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } @SuppressWarnings(\"incomplete-switch\") boolean parse() { int lineno; int charno; JSTypeExpression type;"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); }"
      },
      {
        "txt": "} else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\"\"); } } retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) {"
      },
      {
        "txt": "state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno);"
      },
      {
        "txt": "switch (annotation) { case NG_INJECT: if (jsdocBuilder.isNgInjectRecorded()) { parser.addParserWarning(\"msg.jsdoc.nginject.extra\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.recordNgInject(true); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); }"
      },
      {
        "txt": "token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case STRUCT: if (!jsdocBuilder.recordStruct()) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case DICT: if (!jsdocBuilder.recordDict()) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) {"
      },
      {
        "txt": "if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason);"
      },
      {
        "txt": "} token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW:"
      },
      {
        "txt": "String fileOverview = \"\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "if (!jsdocBuilder.recordFileOverview(fileOverview)) { parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);"
      },
      {
        "txt": "String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next();"
      },
      {
        "txt": "lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); }"
      },
      {
        "txt": "if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\"msg.jsdoc.javadispatch\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "typeNode = wrapNode(Token.BANG, typeNode); type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\","
      },
      {
        "txt": "lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL &&"
      },
      {
        "txt": "token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN:"
      },
      {
        "txt": "if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) {"
      },
      {
        "txt": "token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno()); } } else {"
      },
      {
        "txt": "parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING:"
      },
      {
        "txt": "ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS:"
      },
      {
        "txt": "if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token));"
      },
      {
        "txt": "if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM:"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) {"
      },
      {
        "txt": "token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) {"
      },
      {
        "txt": "token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); }"
      },
      {
        "txt": "} if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);"
      },
      {
        "txt": "} } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); }"
      },
      {
        "txt": "continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) {"
      },
      {
        "txt": "parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case STABLEIDGENERATOR: if (!jsdocBuilder.recordStableIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.stableidgen\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: { ExtractionInfo templateInfo = extractSingleLineBlock(); List<String> names = Lists.newArrayList("
      },
      {
        "txt": "Splitter.on(',') .trimResults() .split(templateInfo.string)); if (names.size() == 0 || names.get(0).length() == 0) { parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeNames(names)) { parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = templateInfo.token; continue retry; } case CLASS_TEMPLATE: { ExtractionInfo classTemplateInfo = extractSingleLineBlock(); List<String> names = Lists.newArrayList( Splitter.on(',') .trimResults() .split(classTemplateInfo.string)); if (names.size() == 0 || names.get(0).length() == 0) {"
      },
      {
        "txt": "parser.addTypeWarning( \"msg.jsdoc.classtemplate.missing.type.name\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) { parser.addTypeWarning( \"msg.jsdoc.classtemplate.at.most.once\", stream.getLineno(), stream.getCharno()); } token = classTemplateInfo.token; continue retry;"
      },
      {
        "txt": "} case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock();"
      },
      {
        "txt": "String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "token = versionInfo.token; continue retry; case CONSTANT: case DEFINE: case RETURN: case PRIVATE: case PROTECTED: case PUBLIC: case THIS: case TYPE:"
      },
      {
        "txt": "case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; boolean hasType = lookAheadForTypeAnnotation(); boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);"
      },
      {
        "txt": "boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN); type = null; if (hasType || !canSkipTypeAnnotation) { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode);"
      },
      {
        "txt": "} type = createJSTypeExpression(typeNode); } boolean hasError = type == null && !canSkipTypeAnnotation; if (!hasError) { if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) { if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "} } switch (annotation) { case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } break; case DEFINE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno); } break; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning( \"msg.jsdoc.visibility.private\", lineno, charno);"
      },
      {
        "txt": "} break; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning( \"msg.jsdoc.visibility.protected\", lineno, charno); } break; case PUBLIC:"
      },
      {
        "txt": "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning( \"msg.jsdoc.visibility.public\", lineno, charno); } break; case RETURN: if (type == null) { type = createJSTypeExpression(newNode(Token.QMARK)); }"
      },
      {
        "txt": "if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string;"
      },
      {
        "txt": "if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS:"
      },
      {
        "txt": "if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "break; } } token = eatTokensUntilEOL(); continue retry; } } } break; case EOC:"
      },
      {
        "txt": "if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes);"
      },
      {
        "txt": "return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next();"
      },
      {
        "txt": "continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
      },
      {
        "txt": "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { for (ExtendedTypeInfo typeInfo : extendedTypes) { if (jsdocBuilder.isInterfaceRecorded()) { if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { parser.addParserWarning(\"msg.jsdoc.extends.duplicate\", typeInfo.lineno, typeInfo.charno); } } else { if (!jsdocBuilder.recordBaseType(typeInfo.type)) { parser.addTypeWarning(\"msg.jsdoc.incompat.type\","
      },
      {
        "txt": "typeInfo.lineno, typeInfo.charno); } } } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "String name = stream.getString(); if (!suppressionNames.contains(name)) { parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name, stream.getLineno(), stream.getCharno()); } suppressions.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "return token; } if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.suppress\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } else { token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token;"
      },
      {
        "txt": "} private JsDocToken parseModifiesTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> modifies = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { String name = stream.getString(); if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,"
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } modifies.add(stream.getString()); token = next(); } else { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addParserWarning(\"msg.jsdoc.modifies\", stream.getLineno(), stream.getCharno()); } else { token = next();"
      },
      {
        "txt": "if (!jsdocBuilder.recordModifies(modifies)) { parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC);"
      },
      {
        "txt": "} private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) {"
      },
      {
        "txt": "Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); }"
      },
      {
        "txt": "return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else {"
      },
      {
        "txt": "typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null) { int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode( typeNode, lineno, startCharno, endLineno, endCharno, matchingLC); } return typeNode; }"
      },
      {
        "txt": "private String toString(JsDocToken token) { switch (token) { case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\"; case COLON: return \":\";"
      },
      {
        "txt": "case GT: return \">\"; case LB: return \"[\"; case LC: return \"{\"; case LP: return \"(\"; case LT: return \".<\";"
      },
      {
        "txt": "case QMARK: return \"?\"; case PIPE: return \"|\"; case RB: return \"]\"; case RC: return \"}\"; case RP: return \")\";"
      },
      {
        "txt": "case STAR: return \"*\"; case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString());"
      },
      {
        "txt": "} } JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, getSourceName()); } private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) {"
      },
      {
        "txt": "this.string = string; this.token = token; } } private static class ExtendedTypeInfo { final JSTypeExpression type; final int lineno; final int charno; public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { this.type = type;"
      },
      {
        "txt": "this.lineno = lineno; this.charno = charno; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = getRemainingJSDocLine().trim(); if (line.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE,"
      },
      {
        "txt": "TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); }"
      },
      {
        "txt": "stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION;"
      },
      {
        "txt": "token = next(); boolean ignoreStar = false; int lineStartChar = -1; do { switch (token) { case STAR: if (ignoreStar) { lineStartChar = stream.getCharno() + 1; } else { if (builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); }"
      },
      {
        "txt": "ignoreStar = true; lineStartChar = 0; token = next(); continue; default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; boolean isEOC = token == JsDocToken.EOC; if (!isEOC) { if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {"
      },
      {
        "txt": "int numSpaces = stream.getCharno() - lineStartChar; for (int i = 0; i < numSpaces; i++) { builder.append(' '); } lineStartChar = -1; } else if (builder.length() > 0) { builder.append(' '); } } if (token == JsDocToken.EOC ||"
      },
      {
        "txt": "token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); } builder.append(toString(token)); line = getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); }"
      },
      {
        "txt": "builder.append(line); token = next(); } } while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: case EOC: case EOF: return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*');"
      },
      {
        "txt": "} token = next(); continue; case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } ignoreStar = false; builder.append(toString(token)); String line = getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true);"
      },
      {
        "txt": "} private static String trimEnd(String s) { int trimCount = 0; while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; }"
      },
      {
        "txt": "} if (trimCount == 0) { return s; } return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next());"
      },
      {
        "txt": "if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else {"
      },
      {
        "txt": "return parseTypeExpression(token); } } private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next();"
      },
      {
        "txt": "if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, IR.empty()); } restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode);"
      },
      {
        "txt": "} else if (match(JsDocToken.EQUALS)) { next(); skipEOLs(); typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); }"
      },
      {
        "txt": "} return typeNode; } private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeName(token); } }"
      },
      {
        "txt": "private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) { if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next();"
      },
      {
        "txt": "return parseUnionTypeWithAlternate(token, typeExpr); } } return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; }"
      },
      {
        "txt": "Node typeList = IR.block(); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) { next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr);"
      },
      {
        "txt": "} return typeList; } private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { token = next(); if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC ||"
      },
      {
        "txt": "token == JsDocToken.RP || token == JsDocToken.PIPE || token == JsDocToken.GT) { restoreLookAhead(token); return newNode(Token.QMARK); } return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else {"
      },
      {
        "txt": "Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next(); return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } }"
      },
      {
        "txt": "return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) {"
      },
      {
        "txt": "skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next());"
      },
      {
        "txt": "} else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } restoreLookAhead(token); return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) {"
      },
      {
        "txt": "if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } String typeName = stream.getString(); int lineno = stream.getLineno(); int charno = stream.getCharno(); while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { skipEOLs(); if (match(JsDocToken.STRING)) {"
      },
      {
        "txt": "next(); typeName += stream.getString(); } } Node typeNameNode = newStringNode(typeName, lineno, charno); if (match(JsDocToken.LT)) { next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) {"
      },
      {
        "txt": "typeNameNode.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next(); } } return typeNameNode; }"
      },
      {
        "txt": "private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { restoreLookAhead(token); return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next();"
      },
      {
        "txt": "boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \"this\".equals(tokenStr); boolean isNew = \"new\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode("
      },
      {
        "txt": "isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "next(); skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token);"
      },
      {
        "txt": "if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType;"
      },
      {
        "txt": "} private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.PARAM_LIST); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");"
      },
      {
        "txt": "} next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next();"
      },
      {
        "txt": "} isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } }"
      },
      {
        "txt": "if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; } private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next();"
      },
      {
        "txt": "skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID); } else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null);"
      },
      {
        "txt": "} private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) { union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs();"
      },
      {
        "txt": "token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE; if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); }"
      },
      {
        "txt": "expr = parseTypeExpression(token); if (expr == null) { return null; } union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");"
      },
      {
        "txt": "} next(); } return union; } private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do {"
      },
      {
        "txt": "if (arg != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token);"
      },
      {
        "txt": "} if (arg == null) { return null; } array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA));"
      },
      {
        "txt": "if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next(); return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) {"
      },
      {
        "txt": "return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; }"
      },
      {
        "txt": "private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token); if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "break; } next(); skipEOLs(); token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token);"
      },
      {
        "txt": "if (fieldName == null) { return null; } skipEOLs(); if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next());"
      },
      {
        "txt": "if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON); fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) {"
      },
      {
        "txt": "case STRING: String string = stream.getString(); return newStringNode(string); default: return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(),"
      },
      {
        "txt": "stream.getCharno()).clonePropsFrom(templateNode); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); } private Node newStringNode(String s) { return newStringNode(s, stream.getLineno(), stream.getCharno()); } private Node newStringNode(String s, int lineno, int charno) {"
      },
      {
        "txt": "Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); n.setLength(s.length()); return n; } private Node createTemplateNode() { Node templateNode = IR.script(); templateNode.setStaticSourceFile( this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null);"
      },
      {
        "txt": "return templateNode; } private Node reportTypeSyntaxWarning(String warning) { parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); } private JsDocToken eatTokensUntilEOL() {"
      },
      {
        "txt": "return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; } token = next();"
      },
      {
        "txt": "} while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private void restoreLookAhead(JsDocToken token) { unreadToken = token; } private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token;"
      },
      {
        "txt": "} private boolean match(JsDocToken token1, JsDocToken token2) { unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current();"
      },
      {
        "txt": "} } private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next();"
      },
      {
        "txt": "next(); } } } private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); <extra_id_0> } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated();"
      },
      {
        "txt": "boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() { return jsdocBuilder.build(associatedNode); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; } private boolean lookAheadForTypeAnnotation() {"
      },
      {
        "txt": "boolean matchedLc = false; int c; while (true) { c = stream.getChar(); if (c == ' ') { continue; } else if (c == '{') { matchedLc = true; break; } else {"
      },
      {
        "txt": "break; } } stream.ungetChar(c); return matchedLc; }"
      }
    ]
  }
]