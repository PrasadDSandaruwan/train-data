[
  {
    "id": 682,
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java",
    "start-bug-line": 185,
    "end-bug-line": 191,
    "bug": "static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\");",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;"
      },
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.Iterator; public class TypeCheck implements NodeTraversal.Callback, CompilerPass { static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error( \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\", \"Internal Error: Don't know how to handle {0}\"); static final DiagnosticType BAD_DELETE = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_BAD_DELETE_OPERAND\", \"delete operator needs a reference operand\"); protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT = \"overriding prototype with non-object\"; static final DiagnosticType DETERMINISTIC_TEST = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST\", \"condition always evaluates to {2}\\n\" + \"left : {0}\\n\" + \"right: {1}\");"
      },
      {
        "txt": "static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST_NO_RESULT\", \"condition always evaluates to the same value\\n\" + \"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType INEXISTENT_ENUM_ELEMENT = DiagnosticType.warning( \"JSC_INEXISTENT_ENUM_ELEMENT\", \"element {0} does not exist on this enum\");"
      },
      {
        "txt": "static final DiagnosticType INEXISTENT_PROPERTY = DiagnosticType.disabled( \"JSC_INEXISTENT_PROPERTY\", \"Property {0} never defined on {1}\"); protected static final DiagnosticType NOT_A_CONSTRUCTOR = DiagnosticType.warning( \"JSC_NOT_A_CONSTRUCTOR\", \"cannot instantiate non-constructor\"); static final DiagnosticType BIT_OPERATION = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_BAD_TYPE_FOR_BIT_OPERATION\", \"operator {0} cannot be applied to {1}\"); static final DiagnosticType NOT_CALLABLE = DiagnosticType.warning( \"JSC_NOT_FUNCTION_TYPE\", \"{0} expressions are not callable\"); static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE = DiagnosticType.warning( \"JSC_CONSTRUCTOR_NOT_CALLABLE\", \"Constructor {0} should be called with the \\\"new\\\" keyword\");"
      },
      {
        "txt": "static final DiagnosticType FUNCTION_MASKS_VARIABLE = DiagnosticType.warning( \"JSC_FUNCTION_MASKS_VARIABLE\", \"function {0} masks variable (IE bug)\"); static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning( \"JSC_MULTIPLE_VAR_DEF\", \"declaration of multiple variables with shared type information\"); static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\", \"enum element {0} already defined\"); static final DiagnosticType ENUM_NOT_CONSTANT ="
      },
      {
        "txt": "DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\", \"enum key {0} must be a syntactic constant\"); static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION = DiagnosticType.warning( \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\", \"interface members can only be empty property declarations,\" + \" empty functions{0}\"); static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY = DiagnosticType.warning( \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\","
      },
      {
        "txt": "\"interface member functions must have an empty body\"); static final DiagnosticType CONFLICTING_EXTENDED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_EXTENDED_TYPE\", \"{0} cannot extend this type; \" + \"a constructor can only extend objects \" + \"and an interface can only extend interfaces\"); static final DiagnosticType BAD_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_IMPLEMENTS_NON_INTERFACE\","
      },
      {
        "txt": "\"can only implement interfaces\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_SUPERCLASS_PROPERTY\", \"property {0} already defined on superclass {1}; \" + \"use @override to override it\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY\", \"property {0} already defined on interface {1}; \" +"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); <extra_id_0> static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( \"JSC_UNKNOWN_OVERRIDE\", \"property {0} not defined on any superclass of {1}\"); static final DiagnosticType INTERFACE_METHOD_OVERRIDE = DiagnosticType.warning("
      },
      {
        "txt": "static final DiagnosticType INTERFACE_METHOD_OVERRIDE = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_OVERRIDE\", \"property {0} is already defined by the {1} extended interface\"); static final DiagnosticType UNKNOWN_EXPR_TYPE = DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\", \"could not determine the type of this expression\"); static final DiagnosticType UNRESOLVED_TYPE = DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\", \"could not resolve the name {0} to a type\");"
      },
      {
        "txt": "static final DiagnosticType WRONG_ARGUMENT_COUNT = DiagnosticType.warning( \"JSC_WRONG_ARGUMENT_COUNT\", \"Function {0}: called with {1} argument(s). \" + \"Function requires at least {2} argument(s){3}.\"); static final DiagnosticType ILLEGAL_IMPLICIT_CAST = DiagnosticType.warning( \"JSC_ILLEGAL_IMPLICIT_CAST\", \"Illegal annotation on {0}. @implicitCast may only be used in \" + \"externs.\");"
      },
      {
        "txt": "static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( DETERMINISTIC_TEST, DETERMINISTIC_TEST_NO_RESULT, INEXISTENT_ENUM_ELEMENT, INEXISTENT_PROPERTY, NOT_A_CONSTRUCTOR, BIT_OPERATION, NOT_CALLABLE, CONSTRUCTOR_NOT_CALLABLE, FUNCTION_MASKS_VARIABLE,"
      },
      {
        "txt": "MULTIPLE_VAR_DEF, ENUM_DUP, ENUM_NOT_CONSTANT, INVALID_INTERFACE_MEMBER_DECLARATION, INTERFACE_FUNCTION_NOT_EMPTY, CONFLICTING_EXTENDED_TYPE, BAD_IMPLEMENTED_TYPE, HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,"
      },
      {
        "txt": "HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE, UNRESOLVED_TYPE, WRONG_ARGUMENT_COUNT, ILLEGAL_IMPLICIT_CAST, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER,"
      },
      {
        "txt": "TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT); private final AbstractCompiler compiler; private final TypeValidator validator; private final ReverseAbstractInterpreter reverseInterpreter; private final JSTypeRegistry typeRegistry; private Scope topScope; private ScopeCreator scopeCreator; private final CheckLevel reportMissingOverride; private final CheckLevel reportUnknownTypes;"
      },
      {
        "txt": "private boolean reportMissingProperties = true; private InferJSDocInfo inferJSDocInfo = null; private int typedCount = 0; private int nullCount = 0; private int unknownCount = 0; private boolean inExterns; private int noTypeCheckSection = 0; public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry,"
      },
      {
        "txt": "Scope topScope, ScopeCreator scopeCreator, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { this.compiler = compiler; this.validator = compiler.getTypeValidator(); this.reverseInterpreter = reverseInterpreter; this.typeRegistry = typeRegistry; this.topScope = topScope; this.scopeCreator = scopeCreator;"
      },
      {
        "txt": "this.reportMissingOverride = reportMissingOverride; this.reportUnknownTypes = reportUnknownTypes; this.inferJSDocInfo = new InferJSDocInfo(compiler); } public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { this(compiler, reverseInterpreter, typeRegistry, null, null,"
      },
      {
        "txt": "reportMissingOverride, reportUnknownTypes); } TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry) { this(compiler, reverseInterpreter, typeRegistry, null, null, CheckLevel.WARNING, CheckLevel.OFF); } TypeCheck reportMissingProperties(boolean report) { reportMissingProperties = report;"
      },
      {
        "txt": "return this; } public void process(Node externsRoot, Node jsRoot) { Preconditions.checkNotNull(scopeCreator); Preconditions.checkNotNull(topScope); Node externsAndJs = jsRoot.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState( externsRoot == null || externsAndJs.hasChild(externsRoot)); if (externsRoot != null) {"
      },
      {
        "txt": "check(externsRoot, true); } check(jsRoot, false); } public Scope processForTesting(Node externsRoot, Node jsRoot) { Preconditions.checkState(scopeCreator == null); Preconditions.checkState(topScope == null); Preconditions.checkState(jsRoot.getParent() != null); Node externsAndJsRoot = jsRoot.getParent(); scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));"
      },
      {
        "txt": "topScope = scopeCreator.createScope(externsAndJsRoot, null); TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator); inference.process(externsRoot, jsRoot); process(externsRoot, jsRoot); return topScope; } public void check(Node node, boolean externs) { Preconditions.checkNotNull(node); NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);"
      },
      {
        "txt": "inExterns = externs; t.traverseWithScope(node, topScope); if (externs) { inferJSDocInfo.process(node, null); } else { inferJSDocInfo.process(null, node); } } private void checkNoTypeCheckSection(Node n, boolean enterSection) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.SCRIPT: case Token.BLOCK: case Token.VAR: case Token.FUNCTION: case Token.ASSIGN: JSDocInfo info = n.getJSDocInfo(); if (info != null && info.isNoTypeCheck()) { if (enterSection) { noTypeCheckSection++; } else {"
      },
      {
        "txt": "noTypeCheckSection--; } } validator.setShouldReport(noTypeCheckSection == 0); break; } } private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments) { if (noTypeCheckSection == 0) {"
      },
      {
        "txt": "t.report(n, diagnosticType, arguments); } } public boolean shouldTraverse( NodeTraversal t, Node n, Node parent) { checkNoTypeCheckSection(n, true); switch (n.getType()) { case Token.FUNCTION: final TypeCheck outerThis = this; final Scope outerScope = t.getScope();"
      },
      {
        "txt": "final FunctionType functionType = (FunctionType) n.getJSType(); final String functionPrivateName = n.getFirstChild().getString(); if (functionPrivateName != null && functionPrivateName.length() > 0 && outerScope.isDeclared(functionPrivateName, false) && !(outerScope.getVar( functionPrivateName).getType() instanceof FunctionType)) { report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName); } break; }"
      },
      {
        "txt": "return true; } public void visit(NodeTraversal t, Node n, Node parent) { JSType childType; JSType leftType, rightType; Node left, right; boolean typeable = true; switch (n.getType()) { case Token.NAME: typeable = visitName(t, n, parent);"
      },
      {
        "txt": "break; case Token.LP: if (parent.getType() != Token.FUNCTION) { ensureTyped(t, n, getJSType(n.getFirstChild())); } else { typeable = false; } break; case Token.COMMA: ensureTyped(t, n, getJSType(n.getLastChild()));"
      },
      {
        "txt": "break; case Token.TRUE: case Token.FALSE: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.THIS: ensureTyped(t, n, t.getScope().getTypeOfThis()); break; case Token.REF_SPECIAL: ensureTyped(t, n);"
      },
      {
        "txt": "break; case Token.GET_REF: ensureTyped(t, n, getJSType(n.getFirstChild())); break; case Token.NULL: ensureTyped(t, n, NULL_TYPE); break; case Token.NUMBER: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, NUMBER_TYPE);"
      },
      {
        "txt": "} break; case Token.STRING: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); } break; case Token.GET: case Token.SET: break;"
      },
      {
        "txt": "case Token.ARRAYLIT: ensureTyped(t, n, ARRAY_TYPE); break; case Token.REGEXP: ensureTyped(t, n, REGEXP_TYPE); break; case Token.GETPROP: visitGetProp(t, n, parent); typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);"
      },
      {
        "txt": "break; case Token.GETELEM: visitGetElem(t, n); typeable = false; break; case Token.VAR: visitVar(t, n); typeable = false; break; case Token.NEW:"
      },
      {
        "txt": "visitNew(t, n); typeable = true; break; case Token.CALL: visitCall(t, n); typeable = !NodeUtil.isExpressionNode(parent); break; case Token.RETURN: visitReturn(t, n); typeable = false;"
      },
      {
        "txt": "break; case Token.DEC: case Token.INC: left = n.getFirstChild(); validator.expectNumber( t, left, getJSType(left), \"increment/decrement\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.NOT: ensureTyped(t, n, BOOLEAN_TYPE);"
      },
      {
        "txt": "break; case Token.VOID: ensureTyped(t, n, VOID_TYPE); break; case Token.TYPEOF: ensureTyped(t, n, STRING_TYPE); break; case Token.BITNOT: childType = getJSType(n.getFirstChild()); if (!childType.matchesInt32Context()) {"
      },
      {
        "txt": "report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString()); } ensureTyped(t, n, NUMBER_TYPE); break; case Token.POS: case Token.NEG: left = n.getFirstChild(); validator.expectNumber(t, left, getJSType(left), \"sign operator\"); ensureTyped(t, n, NUMBER_TYPE);"
      },
      {
        "txt": "break; case Token.EQ: case Token.NE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted); if (result != TernaryValue.UNKNOWN) {"
      },
      {
        "txt": "if (n.getType() == Token.NE) { result = result.not(); } report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString()); } ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.SHEQ:"
      },
      {
        "txt": "case Token.SHNE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); if (!leftTypeRestricted.canTestForShallowEqualityWith( rightTypeRestricted)) { report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString()); }"
      },
      {
        "txt": "ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.LT: case Token.LE: case Token.GT: case Token.GE: leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); if (rightType.isNumber()) {"
      },
      {
        "txt": "validator.expectNumber( t, n, leftType, \"left side of numeric comparison\"); } else if (leftType.isNumber()) { validator.expectNumber( t, n, rightType, \"right side of numeric comparison\"); } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) { } else { String message = \"left side of comparison\"; validator.expectString(t, n, leftType, message);"
      },
      {
        "txt": "validator.expectNotNullOrUndefined( t, n, leftType, message, getNativeType(STRING_TYPE)); message = \"right side of comparison\"; validator.expectString(t, n, rightType, message); validator.expectNotNullOrUndefined( t, n, rightType, message, getNativeType(STRING_TYPE)); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.IN:"
      },
      {
        "txt": "left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right); validator.expectObject(t, n, rightType, \"'in' requires an object\"); validator.expectString(t, left, leftType, \"left side of 'in'\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.INSTANCEOF: left = n.getFirstChild();"
      },
      {
        "txt": "right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right).restrictByNotNullOrUndefined(); validator.expectAnyObject( t, left, leftType, \"deterministic instanceof yields false\"); validator.expectActualObject( t, right, rightType, \"instanceof requires an object\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.ASSIGN:"
      },
      {
        "txt": "visitAssign(t, n); typeable = false; break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR:"
      },
      {
        "txt": "case Token.ASSIGN_BITAND: case Token.ASSIGN_SUB: case Token.ASSIGN_ADD: case Token.ASSIGN_MUL: case Token.LSH: case Token.RSH: case Token.URSH: case Token.DIV: case Token.MOD: case Token.BITOR:"
      },
      {
        "txt": "case Token.BITXOR: case Token.BITAND: case Token.SUB: case Token.ADD: case Token.MUL: visitBinaryOperator(n.getType(), t, n); break; case Token.DELPROP: if (!isReference(n.getFirstChild())) { report(t, n, BAD_DELETE);"
      },
      {
        "txt": "} ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.CASE: JSType switchType = getJSType(parent.getFirstChild()); JSType caseType = getJSType(n.getFirstChild()); validator.expectSwitchMatchesCase(t, n, switchType, caseType); typeable = false; break; case Token.WITH: {"
      },
      {
        "txt": "Node child = n.getFirstChild(); childType = getJSType(child); validator.expectObject( t, child, childType, \"with requires an object\"); typeable = false; break; } case Token.FUNCTION: visitFunction(t, n); break;"
      },
      {
        "txt": "case Token.LABEL: case Token.LABEL_NAME: case Token.SWITCH: case Token.BREAK: case Token.CATCH: case Token.TRY: case Token.SCRIPT: case Token.EXPR_RESULT: case Token.BLOCK: case Token.EMPTY:"
      },
      {
        "txt": "case Token.DEFAULT: case Token.CONTINUE: case Token.DEBUGGER: case Token.THROW: typeable = false; break; case Token.DO: case Token.FOR: case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "typeable = false; break; case Token.AND: case Token.HOOK: case Token.OBJECTLIT: case Token.OR: if (n.getJSType() != null) { // If we didn't run type inference. ensureTyped(t, n); } else { if ((n.getType() == Token.OBJECTLIT)"
      },
      {
        "txt": "&& (parent.getJSType() instanceof EnumType)) { ensureTyped(t, n, parent.getJSType()); } else { ensureTyped(t, n); } } if (n.getType() == Token.OBJECTLIT) { for (Node key : n.children()) { visitObjLitKey(t, key, n); }"
      },
      {
        "txt": "} break; default: report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType())); ensureTyped(t, n); break; } typeable = typeable && !inExterns; if (typeable) { doPercentTypedAccounting(t, n);"
      },
      {
        "txt": "} checkNoTypeCheckSection(n, false); } private void doPercentTypedAccounting(NodeTraversal t, Node n) { JSType type = n.getJSType(); if (type == null) { nullCount++; } else if (type.isUnknownType()) { if (reportUnknownTypes.isOn()) { compiler.report("
      },
      {
        "txt": "t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE)); } unknownCount++; } else { typedCount++; } } private void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild();"
      },
      {
        "txt": "Node rvalue = assign.getLastChild(); if (lvalue.getType() == Token.GETPROP) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); String property = lvalue.getLastChild().getString(); if (object.getType() == Token.GETPROP) { JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\"prototype\")) { visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);"
      },
      {
        "txt": "} } if (info != null && info.hasType()) { visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue); return; } if (info != null && info.hasEnumParameterType()) { checkEnumInitializer("
      },
      {
        "txt": "t, rvalue, info.getEnumParameterType().evaluate( t.getScope(), typeRegistry)); return; } if (property.equals(\"prototype\")) { if (objectJsType instanceof FunctionType) { FunctionType functionType = (FunctionType) objectJsType; if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType,"
      },
      {
        "txt": "OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); } } else { } return; } if (object.getType() == Token.GETPROP) { Node object2 = object.getFirstChild(); String property2 = NodeUtil.getStringValue(object.getLastChild()); if (\"prototype\".equals(property2)) {"
      },
      {
        "txt": "JSType jsType = object2.getJSType(); if (jsType instanceof FunctionType) { FunctionType functionType = (FunctionType) jsType; if (functionType.isConstructor() || functionType.isInterface()) { checkDeclaredPropertyInheritance( t, assign, functionType, property, info, getJSType(rvalue)); } } else { } return;"
      },
      {
        "txt": "} } ObjectType type = ObjectType.cast( objectJsType.restrictByNotNullOrUndefined()); if (type != null) { if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf( t, assign, getJSType(rvalue),"
      },
      {
        "txt": "type.getPropertyType(property), object, property); } return; } } else if (lvalue.getType() == Token.NAME) { JSType rvalueType = getJSType(assign.getLastChild()); Var var = t.getScope().getVar(lvalue.getString()); if (var != null) { if (var.isTypeInferred()) { return;"
      },
      {
        "txt": "} } } JSType leftType = getJSType(lvalue); Node rightChild = assign.getLastChild(); JSType rightType = getJSType(rightChild); if (validator.expectCanAssignTo( t, assign, rightType, leftType, \"assignment\")) { ensureTyped(t, assign, rightType); } else {"
      },
      {
        "txt": "ensureTyped(t, assign); } } private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) { Node rvalue = key.getFirstChild(); JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType( key, getJSType(rvalue)); if (rightType == null) { rightType = getNativeType(UNKNOWN_TYPE); }"
      },
      {
        "txt": "Node owner = objlit; JSType keyType = getJSType(key); boolean valid = validator.expectCanAssignToPropertyOf(t, key, rightType, keyType, owner, NodeUtil.getObjectLitKeyName(key)); if (valid) { ensureTyped(t, key, rightType); } else { ensureTyped(t, key); }"
      },
      {
        "txt": "JSType objlitType = getJSType(objlit); ObjectType type = ObjectType.cast( objlitType.restrictByNotNullOrUndefined()); if (type != null) { String property = NodeUtil.getObjectLitKeyName(key); if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf( t, key, keyType,"
      },
      {
        "txt": "type.getPropertyType(property), owner, property); } return; } } private boolean propertyIsImplicitCast(ObjectType type, String prop) { for (; type != null; type = type.getImplicitPrototype()) { JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop); if (docInfo != null && docInfo.isImplicitCast()) { return true;"
      },
      {
        "txt": "} } return false; } private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) { if (hasUnknownOrEmptySupertype(ctorType)) { return; }"
      },
      {
        "txt": "FunctionType superClass = ctorType.getSuperClassConstructor(); boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName); boolean declaredOverride = info != null && info.isOverride(); boolean foundInterfaceProperty = false; if (ctorType.isConstructor()) { for (JSType implementedInterface : ctorType.getImplementedInterfaces()) { if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) { continue;"
      },
      {
        "txt": "} FunctionType interfaceType = implementedInterface.toObjectType().getConstructor(); Preconditions.checkNotNull(interfaceType); boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName); foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty; if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) { compiler.report(t.makeError(n, reportMissingOverride,"
      },
      {
        "txt": "HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } if (interfaceHasProperty) { JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(),"
      },
      {
        "txt": "interfacePropType.toString(), propertyType.toString())); } } } } if (!declaredOverride && !superClassHasProperty) { return; } JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;"
      },
      {
        "txt": "if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString())); } if (!declaredOverride) { return; } if (superClassHasProperty) {"
      },
      {
        "txt": "JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(superClassPropType)) { compiler.report( t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString())); } } else if (!foundInterfaceProperty) { compiler.report("
      },
      {
        "txt": "t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString())); } } private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) { Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface()); Preconditions.checkArgument(!ctor.isUnknownType()); while (true) { ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();"
      },
      {
        "txt": "if (maybeSuperInstanceType == null) { return false; } if (maybeSuperInstanceType.isUnknownType() || maybeSuperInstanceType.isEmptyType()) { return true; } ctor = maybeSuperInstanceType.getConstructor(); if (ctor == null) { return false;"
      },
      {
        "txt": "} Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); } } private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue) { JSType rvalueType = getJSType(rvalue); String abstractMethodName = compiler.getCodingConvention().getAbstractMethodName(); if (!rvalueType.isOrdinaryFunction() &&"
      },
      {
        "txt": "!(rvalue.isQualifiedName() && rvalue.getQualifiedName().equals(abstractMethodName))) { String abstractMethodMessage = (abstractMethodName != null) ? \", or \" + abstractMethodName : \"\"; compiler.report( t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION, abstractMethodMessage)); } if (assign.getLastChild().getType() == Token.FUNCTION"
      },
      {
        "txt": "&& !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) { compiler.report( t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY, abstractMethodName)); } } private void visitAnnotatedAssignGetprop(NodeTraversal t, Node assign, JSType type, Node object, String property, Node rvalue) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type, object, property);"
      },
      {
        "txt": "} boolean visitName(NodeTraversal t, Node n, Node parent) { int parentNodeType = parent.getType(); if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.LP || parentNodeType == Token.VAR) { return false; } JSType type = n.getJSType();"
      },
      {
        "txt": "if (type == null) { type = getNativeType(UNKNOWN_TYPE); Var var = t.getScope().getVar(n.getString()); if (var != null) { JSType varType = var.getType(); if (varType != null) { type = varType; } } }"
      },
      {
        "txt": "ensureTyped(t, n, type); return true; } private void visitGetProp(NodeTraversal t, Node n, Node parent) { if (n.getJSType() != null && parent.getType() == Token.ASSIGN) { return; } Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode);"
      },
      {
        "txt": "if (!validator.expectNotNullOrUndefined(t, n, childType, childType + \" has no properties\", getNativeType(OBJECT_TYPE))) { ensureTyped(t, n); return; } checkPropertyAccess(childType, property.getString(), t, n); ensureTyped(t, n); } private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n) {"
      },
      {
        "txt": "ObjectType objectType = childType.dereference(); if (objectType != null) { JSType propType = getJSType(n); if ((!objectType.hasProperty(propName) || objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) && propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) { if (objectType instanceof EnumType) { report(t, n, INEXISTENT_ENUM_ELEMENT, propName); } else if (!objectType.isEmptyType() && reportMissingProperties && !isPropertyTest(n)) {"
      },
      {
        "txt": "if (!typeRegistry.canPropertyBeDefined(objectType, propName)) { report(t, n, INEXISTENT_PROPERTY, propName, validator.getReadableJSTypeName(n.getFirstChild(), true)); } } } } else { } } private boolean isPropertyTest(Node getProp) {"
      },
      {
        "txt": "Node parent = getProp.getParent(); switch (parent.getType()) { case Token.CALL: return parent.getFirstChild() != getProp && compiler.getCodingConvention().isPropertyTestFunction(parent); case Token.IF: case Token.WHILE: case Token.DO: case Token.FOR: return NodeUtil.getConditionExpression(parent) == getProp;"
      },
      {
        "txt": "case Token.INSTANCEOF: case Token.TYPEOF: return true; case Token.AND: case Token.HOOK: return parent.getFirstChild() == getProp; case Token.NOT: return parent.getParent().getType() == Token.OR && parent.getParent().getFirstChild() == parent; }"
      },
      {
        "txt": "return false; } private void visitGetElem(NodeTraversal t, Node n) { Node left = n.getFirstChild(); Node right = n.getLastChild(); validator.expectIndexMatch(t, n, getJSType(left), getJSType(right)); ensureTyped(t, n); } private void visitVar(NodeTraversal t, Node n) { JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;"
      },
      {
        "txt": "for (Node name : n.children()) { Node value = name.getFirstChild(); Var var = t.getScope().getVar(name.getString()); if (value != null) { JSType valueType = getJSType(value); JSType nameType = var.getType(); nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType; JSDocInfo info = name.getJSDocInfo(); if (info == null) { info = varInfo;"
      },
      {
        "txt": "} if (info != null && info.hasEnumParameterType()) { checkEnumInitializer( t, value, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry)); } else if (var.isTypeInferred()) { ensureTyped(t, name, valueType); } else { validator.expectCanAssignTo( t, value, valueType, nameType, \"initializing variable\");"
      },
      {
        "txt": "} } } } private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); FunctionType type = getFunctionType(constructor); if (type != null && type.isConstructor()) { visitParameterList(t, n, type); ensureTyped(t, n, type.getInstanceType());"
      },
      {
        "txt": "} else { if (constructor.getType() != Token.GETPROP) { Node line; if (constructor.getLineno() < 0 || constructor.getCharno() < 0) { line = n; } else { line = constructor; } report(t, line, NOT_A_CONSTRUCTOR); }"
      },
      {
        "txt": "ensureTyped(t, n); } } private void visitFunction(NodeTraversal t, Node n) { JSDocInfo info = n.getJSDocInfo(); FunctionType functionType = (FunctionType) n.getJSType(); String functionPrivateName = n.getFirstChild().getString(); if (functionType.isInterface() || functionType.isConstructor()) { FunctionType baseConstructor = functionType. getPrototype().getImplicitPrototype().getConstructor();"
      },
      {
        "txt": "if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isConstructor() && functionType.isInterface() || baseConstructor.isInterface() && functionType.isConstructor())) { compiler.report( t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName)); } for (JSType baseInterface : functionType.getImplementedInterfaces()) { boolean badImplementedType = false; ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);"
      },
      {
        "txt": "if (baseInterfaceObj != null) { FunctionType interfaceConstructor = baseInterfaceObj.getConstructor(); if (interfaceConstructor != null && !interfaceConstructor.isInterface()) { badImplementedType = true; } } else { badImplementedType = true; }"
      },
      {
        "txt": "if (badImplementedType) { report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName); } } if (functionType.isConstructor()) { validator.expectAllInterfaceProperties(t, n, functionType); } } } private void visitCall(NodeTraversal t, Node n) {"
      },
      {
        "txt": "Node child = n.getFirstChild(); JSType childType = getJSType(child).restrictByNotNullOrUndefined(); if (!childType.canBeCalled()) { report(t, n, NOT_CALLABLE, childType.toString()); ensureTyped(t, n); return; } if (childType instanceof FunctionType) { FunctionType functionType = (FunctionType) childType; if (functionType.isConstructor() &&"
      },
      {
        "txt": "!functionType.isNativeObjectType()) { report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); } visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType()); } else { ensureTyped(t, n); } } private void visitParameterList(NodeTraversal t, Node call,"
      },
      {
        "txt": "FunctionType functionType) { Iterator<Node> arguments = call.children().iterator(); arguments.next(); // skip the function name Iterator<Node> parameters = functionType.getParameters().iterator(); int ordinal = 0; Node parameter = null; Node argument = null; while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) {"
      },
      {
        "txt": "if (parameters.hasNext()) { parameter = parameters.next(); } argument = arguments.next(); ordinal++; validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal); } int numArgs = call.getChildCount() - 1; int minArgs = functionType.getMinArguments();"
      },
      {
        "txt": "int maxArgs = functionType.getMaxArguments(); if (minArgs > numArgs || maxArgs < numArgs) { report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\"); } } private void visitReturn(NodeTraversal t, Node n) {"
      },
      {
        "txt": "Node function = t.getEnclosingFunction(); if (function == null) { return; } JSType jsType = getJSType(function); if (jsType instanceof FunctionType) { FunctionType functionType = (FunctionType) jsType; JSType returnType = functionType.getReturnType(); if (returnType == null) { returnType = getNativeType(VOID_TYPE);"
      },
      {
        "txt": "} Node valueNode = n.getFirstChild(); JSType actualReturnType; if (valueNode == null) { actualReturnType = getNativeType(VOID_TYPE); valueNode = n; } else { actualReturnType = getJSType(valueNode); } validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,"
      },
      {
        "txt": "\"inconsistent return type\"); } } private void visitBinaryOperator(int op, NodeTraversal t, Node n) { Node left = n.getFirstChild(); JSType leftType = getJSType(left); Node right = n.getLastChild(); JSType rightType = getJSType(right); switch (op) { case Token.ASSIGN_LSH:"
      },
      {
        "txt": "case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: if (!leftType.matchesInt32Context()) { report(t, left, BIT_OPERATION, NodeUtil.opToStr(n.getType()), leftType.toString()); } if (!rightType.matchesUint32Context()) {"
      },
      {
        "txt": "report(t, right, BIT_OPERATION, NodeUtil.opToStr(n.getType()), rightType.toString()); } break; case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD:"
      },
      {
        "txt": "case Token.MUL: case Token.SUB: validator.expectNumber(t, left, leftType, \"left operand\"); validator.expectNumber(t, right, rightType, \"right operand\"); break; case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.BITAND: case Token.BITXOR:"
      },
      {
        "txt": "case Token.BITOR: validator.expectBitwiseable(t, left, leftType, \"bad left operand to bitwise operator\"); validator.expectBitwiseable(t, right, rightType, \"bad right operand to bitwise operator\"); break; case Token.ASSIGN_ADD: case Token.ADD: break; default:"
      },
      {
        "txt": "report(t, n, UNEXPECTED_TOKEN, Node.tokenToName(op)); } ensureTyped(t, n); } private void checkEnumInitializer( NodeTraversal t, Node value, JSType primitiveType) { if (value.getType() == Token.OBJECTLIT) { for (Node key = value.getFirstChild(); key != null; key = key.getNext()) { Node propValue = key.getFirstChild();"
      },
      {
        "txt": "validator.expectCanAssignTo( t, propValue, getJSType(propValue), primitiveType, \"element type must match enum's type\"); } } else if (value.getJSType() instanceof EnumType) { EnumType valueEnumType = (EnumType) value.getJSType(); JSType valueEnumPrimitiveType = valueEnumType.getElementsType().getPrimitiveType(); validator.expectCanAssignTo(t, value, valueEnumPrimitiveType, primitiveType, \"incompatible enum element types\");"
      },
      {
        "txt": "} else { } } private static boolean isReference(Node n) { switch (n.getType()) { case Token.GETELEM: case Token.GETPROP: case Token.NAME: return true; default:"
      },
      {
        "txt": "return false; } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; }"
      },
      {
        "txt": "} private FunctionType getFunctionType(Node n) { JSType type = getJSType(n).restrictByNotNullOrUndefined(); if (type.isUnknownType()) { return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE); } else if (type instanceof FunctionType) { return (FunctionType) type; } else { return null; }"
      },
      {
        "txt": "} private void ensureTyped(NodeTraversal t, Node n) { ensureTyped(t, n, getNativeType(UNKNOWN_TYPE)); } private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) { ensureTyped(t, n, getNativeType(type)); } private void ensureTyped(NodeTraversal t, Node n, JSType type) { Preconditions.checkState(n.getType() != Token.FUNCTION || type instanceof FunctionType ||"
      },
      {
        "txt": "type.isUnknownType()); JSDocInfo info = n.getJSDocInfo(); if (info != null) { if (info.hasType()) { JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry); validator.expectCanCast(t, n, infoType, type); type = infoType; } if (info.isImplicitCast() && !inExterns) { String propName = n.getType() == Token.GETPROP ?"
      },
      {
        "txt": "n.getLastChild().getString() : \"(missing)\"; compiler.report( t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName)); } } if (n.getJSType() == null) { n.setJSType(type); } } double getTypedPercent() {"
      },
      {
        "txt": "int total = nullCount + unknownCount + typedCount; if (total == 0) { return 0.0; } else { return (100.0 * typedCount) / total; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 683,
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java",
    "start-bug-line": 242,
    "end-bug-line": 242,
    "bug": "HIDDEN_INTERFACE_PROPERTY_MISMATCH,",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.Iterator; public class TypeCheck implements NodeTraversal.Callback, CompilerPass { static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error( \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\", \"Internal Error: Don't know how to handle {0}\"); static final DiagnosticType BAD_DELETE = DiagnosticType.warning( \"JSC_BAD_DELETE_OPERAND\","
      },
      {
        "txt": "\"delete operator needs a reference operand\"); protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT = \"overriding prototype with non-object\"; static final DiagnosticType DETERMINISTIC_TEST = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST\", \"condition always evaluates to {2}\\n\" + \"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST_NO_RESULT\", \"condition always evaluates to the same value\\n\" + \"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType INEXISTENT_ENUM_ELEMENT = DiagnosticType.warning( \"JSC_INEXISTENT_ENUM_ELEMENT\", \"element {0} does not exist on this enum\"); static final DiagnosticType INEXISTENT_PROPERTY ="
      },
      {
        "txt": "DiagnosticType.disabled( \"JSC_INEXISTENT_PROPERTY\", \"Property {0} never defined on {1}\"); protected static final DiagnosticType NOT_A_CONSTRUCTOR = DiagnosticType.warning( \"JSC_NOT_A_CONSTRUCTOR\", \"cannot instantiate non-constructor\"); static final DiagnosticType BIT_OPERATION = DiagnosticType.warning( \"JSC_BAD_TYPE_FOR_BIT_OPERATION\","
      },
      {
        "txt": "\"operator {0} cannot be applied to {1}\"); static final DiagnosticType NOT_CALLABLE = DiagnosticType.warning( \"JSC_NOT_FUNCTION_TYPE\", \"{0} expressions are not callable\"); static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE = DiagnosticType.warning( \"JSC_CONSTRUCTOR_NOT_CALLABLE\", \"Constructor {0} should be called with the \\\"new\\\" keyword\"); static final DiagnosticType FUNCTION_MASKS_VARIABLE ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_FUNCTION_MASKS_VARIABLE\", \"function {0} masks variable (IE bug)\"); static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning( \"JSC_MULTIPLE_VAR_DEF\", \"declaration of multiple variables with shared type information\"); static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\", \"enum element {0} already defined\"); static final DiagnosticType ENUM_NOT_CONSTANT = DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\","
      },
      {
        "txt": "\"enum key {0} must be a syntactic constant\"); static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION = DiagnosticType.warning( \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\", \"interface members can only be empty property declarations,\" + \" empty functions{0}\"); static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY = DiagnosticType.warning( \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\", \"interface member functions must have an empty body\");"
      },
      {
        "txt": "static final DiagnosticType CONFLICTING_EXTENDED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_EXTENDED_TYPE\", \"{0} cannot extend this type; \" + \"a constructor can only extend objects \" + \"and an interface can only extend interfaces\"); static final DiagnosticType BAD_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_IMPLEMENTS_NON_INTERFACE\", \"can only implement interfaces\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_SUPERCLASS_PROPERTY\", \"property {0} already defined on superclass {1}; \" + \"use @override to override it\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY\", \"property {0} already defined on interface {1}; \" + \"use @override to override it\");"
      },
      {
        "txt": "static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" +"
      },
      {
        "txt": "\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( \"JSC_UNKNOWN_OVERRIDE\", \"property {0} not defined on any superclass of {1}\"); static final DiagnosticType INTERFACE_METHOD_OVERRIDE = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_OVERRIDE\","
      },
      {
        "txt": "\"property {0} is already defined by the {1} extended interface\"); static final DiagnosticType UNKNOWN_EXPR_TYPE = DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\", \"could not determine the type of this expression\"); static final DiagnosticType UNRESOLVED_TYPE = DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\", \"could not resolve the name {0} to a type\"); static final DiagnosticType WRONG_ARGUMENT_COUNT = DiagnosticType.warning( \"JSC_WRONG_ARGUMENT_COUNT\","
      },
      {
        "txt": "\"Function {0}: called with {1} argument(s). \" + \"Function requires at least {2} argument(s){3}.\"); static final DiagnosticType ILLEGAL_IMPLICIT_CAST = DiagnosticType.warning( \"JSC_ILLEGAL_IMPLICIT_CAST\", \"Illegal annotation on {0}. @implicitCast may only be used in \" + \"externs.\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( DETERMINISTIC_TEST, DETERMINISTIC_TEST_NO_RESULT,"
      },
      {
        "txt": "INEXISTENT_ENUM_ELEMENT, INEXISTENT_PROPERTY, NOT_A_CONSTRUCTOR, BIT_OPERATION, NOT_CALLABLE, CONSTRUCTOR_NOT_CALLABLE, FUNCTION_MASKS_VARIABLE, MULTIPLE_VAR_DEF, ENUM_DUP, ENUM_NOT_CONSTANT,"
      },
      {
        "txt": "INTERFACE_FUNCTION_NOT_EMPTY, CONFLICTING_EXTENDED_TYPE, BAD_IMPLEMENTED_TYPE, HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, <extra_id_0> UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE, UNRESOLVED_TYPE, WRONG_ARGUMENT_COUNT, ILLEGAL_IMPLICIT_CAST,"
      },
      {
        "txt": "WRONG_ARGUMENT_COUNT, ILLEGAL_IMPLICIT_CAST, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER, TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT); private final AbstractCompiler compiler; private final TypeValidator validator; private final ReverseAbstractInterpreter reverseInterpreter;"
      },
      {
        "txt": "private final JSTypeRegistry typeRegistry; private Scope topScope; private ScopeCreator scopeCreator; private final CheckLevel reportMissingOverride; private final CheckLevel reportUnknownTypes; private boolean reportMissingProperties = true; private InferJSDocInfo inferJSDocInfo = null; private int typedCount = 0; private int nullCount = 0; private int unknownCount = 0;"
      },
      {
        "txt": "private boolean inExterns; private int noTypeCheckSection = 0; public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, Scope topScope, ScopeCreator scopeCreator, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { this.compiler = compiler;"
      },
      {
        "txt": "this.validator = compiler.getTypeValidator(); this.reverseInterpreter = reverseInterpreter; this.typeRegistry = typeRegistry; this.topScope = topScope; this.scopeCreator = scopeCreator; this.reportMissingOverride = reportMissingOverride; this.reportUnknownTypes = reportUnknownTypes; this.inferJSDocInfo = new InferJSDocInfo(compiler); } public TypeCheck(AbstractCompiler compiler,"
      },
      {
        "txt": "ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { this(compiler, reverseInterpreter, typeRegistry, null, null, reportMissingOverride, reportUnknownTypes); } TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry) {"
      },
      {
        "txt": "this(compiler, reverseInterpreter, typeRegistry, null, null, CheckLevel.WARNING, CheckLevel.OFF); } TypeCheck reportMissingProperties(boolean report) { reportMissingProperties = report; return this; } public void process(Node externsRoot, Node jsRoot) { Preconditions.checkNotNull(scopeCreator); Preconditions.checkNotNull(topScope);"
      },
      {
        "txt": "Node externsAndJs = jsRoot.getParent(); Preconditions.checkState(externsAndJs != null); Preconditions.checkState( externsRoot == null || externsAndJs.hasChild(externsRoot)); if (externsRoot != null) { check(externsRoot, true); } check(jsRoot, false); } public Scope processForTesting(Node externsRoot, Node jsRoot) {"
      },
      {
        "txt": "Preconditions.checkState(scopeCreator == null); Preconditions.checkState(topScope == null); Preconditions.checkState(jsRoot.getParent() != null); Node externsAndJsRoot = jsRoot.getParent(); scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); topScope = scopeCreator.createScope(externsAndJsRoot, null); TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator); inference.process(externsRoot, jsRoot); process(externsRoot, jsRoot);"
      },
      {
        "txt": "return topScope; } public void check(Node node, boolean externs) { Preconditions.checkNotNull(node); NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator); inExterns = externs; t.traverseWithScope(node, topScope); if (externs) { inferJSDocInfo.process(node, null); } else {"
      },
      {
        "txt": "inferJSDocInfo.process(null, node); } } private void checkNoTypeCheckSection(Node n, boolean enterSection) { switch (n.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.VAR: case Token.FUNCTION: case Token.ASSIGN:"
      },
      {
        "txt": "JSDocInfo info = n.getJSDocInfo(); if (info != null && info.isNoTypeCheck()) { if (enterSection) { noTypeCheckSection++; } else { noTypeCheckSection--; } } validator.setShouldReport(noTypeCheckSection == 0); break;"
      },
      {
        "txt": "} } private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments) { if (noTypeCheckSection == 0) { t.report(n, diagnosticType, arguments); } } public boolean shouldTraverse( NodeTraversal t, Node n, Node parent) {"
      },
      {
        "txt": "checkNoTypeCheckSection(n, true); switch (n.getType()) { case Token.FUNCTION: final TypeCheck outerThis = this; final Scope outerScope = t.getScope(); final FunctionType functionType = (FunctionType) n.getJSType(); final String functionPrivateName = n.getFirstChild().getString(); if (functionPrivateName != null && functionPrivateName.length() > 0 && outerScope.isDeclared(functionPrivateName, false) && !(outerScope.getVar("
      },
      {
        "txt": "functionPrivateName).getType() instanceof FunctionType)) { report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName); } break; } return true; } public void visit(NodeTraversal t, Node n, Node parent) { JSType childType; JSType leftType, rightType;"
      },
      {
        "txt": "Node left, right; boolean typeable = true; switch (n.getType()) { case Token.NAME: typeable = visitName(t, n, parent); break; case Token.LP: if (parent.getType() != Token.FUNCTION) { ensureTyped(t, n, getJSType(n.getFirstChild())); } else {"
      },
      {
        "txt": "typeable = false; } break; case Token.COMMA: ensureTyped(t, n, getJSType(n.getLastChild())); break; case Token.TRUE: case Token.FALSE: ensureTyped(t, n, BOOLEAN_TYPE); break;"
      },
      {
        "txt": "case Token.THIS: ensureTyped(t, n, t.getScope().getTypeOfThis()); break; case Token.REF_SPECIAL: ensureTyped(t, n); break; case Token.GET_REF: ensureTyped(t, n, getJSType(n.getFirstChild())); break; case Token.NULL:"
      },
      {
        "txt": "ensureTyped(t, n, NULL_TYPE); break; case Token.NUMBER: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, NUMBER_TYPE); } break; case Token.STRING: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE);"
      },
      {
        "txt": "} break; case Token.GET: case Token.SET: break; case Token.ARRAYLIT: ensureTyped(t, n, ARRAY_TYPE); break; case Token.REGEXP: ensureTyped(t, n, REGEXP_TYPE);"
      },
      {
        "txt": "break; case Token.GETPROP: visitGetProp(t, n, parent); typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n); break; case Token.GETELEM: visitGetElem(t, n); typeable = false; break;"
      },
      {
        "txt": "case Token.VAR: visitVar(t, n); typeable = false; break; case Token.NEW: visitNew(t, n); typeable = true; break; case Token.CALL: visitCall(t, n);"
      },
      {
        "txt": "typeable = !NodeUtil.isExpressionNode(parent); break; case Token.RETURN: visitReturn(t, n); typeable = false; break; case Token.DEC: case Token.INC: left = n.getFirstChild(); validator.expectNumber("
      },
      {
        "txt": "t, left, getJSType(left), \"increment/decrement\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.NOT: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.VOID: ensureTyped(t, n, VOID_TYPE); break; case Token.TYPEOF:"
      },
      {
        "txt": "ensureTyped(t, n, STRING_TYPE); break; case Token.BITNOT: childType = getJSType(n.getFirstChild()); if (!childType.matchesInt32Context()) { report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString()); } ensureTyped(t, n, NUMBER_TYPE); break;"
      },
      {
        "txt": "case Token.POS: case Token.NEG: left = n.getFirstChild(); validator.expectNumber(t, left, getJSType(left), \"sign operator\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.EQ: case Token.NE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild());"
      },
      {
        "txt": "JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted); if (result != TernaryValue.UNKNOWN) { if (n.getType() == Token.NE) { result = result.not(); } report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());"
      },
      {
        "txt": "} ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.SHEQ: case Token.SHNE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (!leftTypeRestricted.canTestForShallowEqualityWith( rightTypeRestricted)) { report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString()); } ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.LT: case Token.LE:"
      },
      {
        "txt": "case Token.GT: case Token.GE: leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); if (rightType.isNumber()) { validator.expectNumber( t, n, leftType, \"left side of numeric comparison\"); } else if (leftType.isNumber()) { validator.expectNumber( t, n, rightType, \"right side of numeric comparison\");"
      },
      {
        "txt": "} else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) { } else { String message = \"left side of comparison\"; validator.expectString(t, n, leftType, message); validator.expectNotNullOrUndefined( t, n, leftType, message, getNativeType(STRING_TYPE)); message = \"right side of comparison\"; validator.expectString(t, n, rightType, message); validator.expectNotNullOrUndefined("
      },
      {
        "txt": "t, n, rightType, message, getNativeType(STRING_TYPE)); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.IN: left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right); validator.expectObject(t, n, rightType, \"'in' requires an object\");"
      },
      {
        "txt": "validator.expectString(t, left, leftType, \"left side of 'in'\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.INSTANCEOF: left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right).restrictByNotNullOrUndefined(); validator.expectAnyObject( t, left, leftType, \"deterministic instanceof yields false\");"
      },
      {
        "txt": "validator.expectActualObject( t, right, rightType, \"instanceof requires an object\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.ASSIGN: visitAssign(t, n); typeable = false; break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH:"
      },
      {
        "txt": "case Token.ASSIGN_URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_SUB: case Token.ASSIGN_ADD: case Token.ASSIGN_MUL: case Token.LSH:"
      },
      {
        "txt": "case Token.RSH: case Token.URSH: case Token.DIV: case Token.MOD: case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.SUB: case Token.ADD: case Token.MUL:"
      },
      {
        "txt": "visitBinaryOperator(n.getType(), t, n); break; case Token.DELPROP: if (!isReference(n.getFirstChild())) { report(t, n, BAD_DELETE); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.CASE: JSType switchType = getJSType(parent.getFirstChild());"
      },
      {
        "txt": "JSType caseType = getJSType(n.getFirstChild()); validator.expectSwitchMatchesCase(t, n, switchType, caseType); typeable = false; break; case Token.WITH: { Node child = n.getFirstChild(); childType = getJSType(child); validator.expectObject( t, child, childType, \"with requires an object\"); typeable = false;"
      },
      {
        "txt": "break; } case Token.FUNCTION: visitFunction(t, n); break; case Token.LABEL: case Token.LABEL_NAME: case Token.SWITCH: case Token.BREAK: case Token.CATCH:"
      },
      {
        "txt": "case Token.TRY: case Token.SCRIPT: case Token.EXPR_RESULT: case Token.BLOCK: case Token.EMPTY: case Token.DEFAULT: case Token.CONTINUE: case Token.DEBUGGER: case Token.THROW: typeable = false;"
      },
      {
        "txt": "break; case Token.DO: case Token.FOR: case Token.IF: case Token.WHILE: typeable = false; break; case Token.AND: case Token.HOOK: case Token.OBJECTLIT:"
      },
      {
        "txt": "case Token.OR: if (n.getJSType() != null) { // If we didn't run type inference. ensureTyped(t, n); } else { if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) { ensureTyped(t, n, parent.getJSType()); } else { ensureTyped(t, n); }"
      },
      {
        "txt": "} if (n.getType() == Token.OBJECTLIT) { for (Node key : n.children()) { visitObjLitKey(t, key, n); } } break; default: report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType())); ensureTyped(t, n);"
      },
      {
        "txt": "break; } typeable = typeable && !inExterns; if (typeable) { doPercentTypedAccounting(t, n); } checkNoTypeCheckSection(n, false); } private void doPercentTypedAccounting(NodeTraversal t, Node n) { JSType type = n.getJSType();"
      },
      {
        "txt": "if (type == null) { nullCount++; } else if (type.isUnknownType()) { if (reportUnknownTypes.isOn()) { compiler.report( t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE)); } unknownCount++; } else { typedCount++;"
      },
      {
        "txt": "} } private void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild(); Node rvalue = assign.getLastChild(); if (lvalue.getType() == Token.GETPROP) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); String property = lvalue.getLastChild().getString();"
      },
      {
        "txt": "if (object.getType() == Token.GETPROP) { JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\"prototype\")) { visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue); } } if (info != null && info.hasType()) { visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object,"
      },
      {
        "txt": "property, rvalue); return; } if (info != null && info.hasEnumParameterType()) { checkEnumInitializer( t, rvalue, info.getEnumParameterType().evaluate( t.getScope(), typeRegistry)); return; } if (property.equals(\"prototype\")) {"
      },
      {
        "txt": "if (objectJsType instanceof FunctionType) { FunctionType functionType = (FunctionType) objectJsType; if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); } } else { } return;"
      },
      {
        "txt": "} if (object.getType() == Token.GETPROP) { Node object2 = object.getFirstChild(); String property2 = NodeUtil.getStringValue(object.getLastChild()); if (\"prototype\".equals(property2)) { JSType jsType = object2.getJSType(); if (jsType instanceof FunctionType) { FunctionType functionType = (FunctionType) jsType; if (functionType.isConstructor() || functionType.isInterface()) { checkDeclaredPropertyInheritance("
      },
      {
        "txt": "t, assign, functionType, property, info, getJSType(rvalue)); } } else { } return; } } ObjectType type = ObjectType.cast( objectJsType.restrictByNotNullOrUndefined()); if (type != null) {"
      },
      {
        "txt": "if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf( t, assign, getJSType(rvalue), type.getPropertyType(property), object, property); } return; } } else if (lvalue.getType() == Token.NAME) {"
      },
      {
        "txt": "JSType rvalueType = getJSType(assign.getLastChild()); Var var = t.getScope().getVar(lvalue.getString()); if (var != null) { if (var.isTypeInferred()) { return; } } } JSType leftType = getJSType(lvalue); Node rightChild = assign.getLastChild();"
      },
      {
        "txt": "JSType rightType = getJSType(rightChild); if (validator.expectCanAssignTo( t, assign, rightType, leftType, \"assignment\")) { ensureTyped(t, assign, rightType); } else { ensureTyped(t, assign); } } private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) { Node rvalue = key.getFirstChild();"
      },
      {
        "txt": "JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType( key, getJSType(rvalue)); if (rightType == null) { rightType = getNativeType(UNKNOWN_TYPE); } Node owner = objlit; JSType keyType = getJSType(key); boolean valid = validator.expectCanAssignToPropertyOf(t, key, rightType, keyType, owner, NodeUtil.getObjectLitKeyName(key));"
      },
      {
        "txt": "if (valid) { ensureTyped(t, key, rightType); } else { ensureTyped(t, key); } JSType objlitType = getJSType(objlit); ObjectType type = ObjectType.cast( objlitType.restrictByNotNullOrUndefined()); if (type != null) { String property = NodeUtil.getObjectLitKeyName(key);"
      },
      {
        "txt": "if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf( t, key, keyType, type.getPropertyType(property), owner, property); } return; } }"
      },
      {
        "txt": "private boolean propertyIsImplicitCast(ObjectType type, String prop) { for (; type != null; type = type.getImplicitPrototype()) { JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop); if (docInfo != null && docInfo.isImplicitCast()) { return true; } } return false; } private void checkDeclaredPropertyInheritance("
      },
      {
        "txt": "NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) { if (hasUnknownOrEmptySupertype(ctorType)) { return; } FunctionType superClass = ctorType.getSuperClassConstructor(); boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName); boolean declaredOverride = info != null && info.isOverride(); boolean foundInterfaceProperty = false;"
      },
      {
        "txt": "if (ctorType.isConstructor()) { for (JSType implementedInterface : ctorType.getImplementedInterfaces()) { if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) { continue; } FunctionType interfaceType = implementedInterface.toObjectType().getConstructor(); Preconditions.checkNotNull(interfaceType); boolean interfaceHasProperty ="
      },
      {
        "txt": "interfaceType.getPrototype().hasProperty(propertyName); foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty; if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } if (interfaceHasProperty) { JSType interfacePropType ="
      },
      {
        "txt": "interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString())); } } } }"
      },
      {
        "txt": "if (!declaredOverride && !superClassHasProperty) { return; } JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null; if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));"
      },
      {
        "txt": "} if (!declaredOverride) { return; } if (superClassHasProperty) { JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(superClassPropType)) { compiler.report( t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,"
      },
      {
        "txt": "propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString())); } } else if (!foundInterfaceProperty) { compiler.report( t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString())); } } private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {"
      },
      {
        "txt": "Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface()); Preconditions.checkArgument(!ctor.isUnknownType()); while (true) { ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return false; } if (maybeSuperInstanceType.isUnknownType() || maybeSuperInstanceType.isEmptyType()) {"
      },
      {
        "txt": "return true; } ctor = maybeSuperInstanceType.getConstructor(); if (ctor == null) { return false; } Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); } } private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object,"
      },
      {
        "txt": "String property, Node lvalue, Node rvalue) { JSType rvalueType = getJSType(rvalue); String abstractMethodName = compiler.getCodingConvention().getAbstractMethodName(); if (!rvalueType.isOrdinaryFunction() && !(rvalue.isQualifiedName() && rvalue.getQualifiedName().equals(abstractMethodName))) { String abstractMethodMessage = (abstractMethodName != null) ? \", or \" + abstractMethodName : \"\";"
      },
      {
        "txt": "compiler.report( t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION, abstractMethodMessage)); } if (assign.getLastChild().getType() == Token.FUNCTION && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) { compiler.report( t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY, abstractMethodName)); }"
      },
      {
        "txt": "} private void visitAnnotatedAssignGetprop(NodeTraversal t, Node assign, JSType type, Node object, String property, Node rvalue) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type, object, property); } boolean visitName(NodeTraversal t, Node n, Node parent) { int parentNodeType = parent.getType(); if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH ||"
      },
      {
        "txt": "parentNodeType == Token.LP || parentNodeType == Token.VAR) { return false; } JSType type = n.getJSType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); Var var = t.getScope().getVar(n.getString()); if (var != null) { JSType varType = var.getType();"
      },
      {
        "txt": "if (varType != null) { type = varType; } } } ensureTyped(t, n, type); return true; } private void visitGetProp(NodeTraversal t, Node n, Node parent) { if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {"
      },
      {
        "txt": "return; } Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (!validator.expectNotNullOrUndefined(t, n, childType, childType + \" has no properties\", getNativeType(OBJECT_TYPE))) { ensureTyped(t, n); return; }"
      },
      {
        "txt": "checkPropertyAccess(childType, property.getString(), t, n); ensureTyped(t, n); } private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n) { ObjectType objectType = childType.dereference(); if (objectType != null) { JSType propType = getJSType(n); if ((!objectType.hasProperty(propName) || objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&"
      },
      {
        "txt": "propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) { if (objectType instanceof EnumType) { report(t, n, INEXISTENT_ENUM_ELEMENT, propName); } else if (!objectType.isEmptyType() && reportMissingProperties && !isPropertyTest(n)) { if (!typeRegistry.canPropertyBeDefined(objectType, propName)) { report(t, n, INEXISTENT_PROPERTY, propName, validator.getReadableJSTypeName(n.getFirstChild(), true)); } }"
      },
      {
        "txt": "} } else { } } private boolean isPropertyTest(Node getProp) { Node parent = getProp.getParent(); switch (parent.getType()) { case Token.CALL: return parent.getFirstChild() != getProp && compiler.getCodingConvention().isPropertyTestFunction(parent);"
      },
      {
        "txt": "case Token.IF: case Token.WHILE: case Token.DO: case Token.FOR: return NodeUtil.getConditionExpression(parent) == getProp; case Token.INSTANCEOF: case Token.TYPEOF: return true; case Token.AND: case Token.HOOK:"
      },
      {
        "txt": "return parent.getFirstChild() == getProp; case Token.NOT: return parent.getParent().getType() == Token.OR && parent.getParent().getFirstChild() == parent; } return false; } private void visitGetElem(NodeTraversal t, Node n) { Node left = n.getFirstChild(); Node right = n.getLastChild();"
      },
      {
        "txt": "validator.expectIndexMatch(t, n, getJSType(left), getJSType(right)); ensureTyped(t, n); } private void visitVar(NodeTraversal t, Node n) { JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null; for (Node name : n.children()) { Node value = name.getFirstChild(); Var var = t.getScope().getVar(name.getString()); if (value != null) { JSType valueType = getJSType(value);"
      },
      {
        "txt": "JSType nameType = var.getType(); nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType; JSDocInfo info = name.getJSDocInfo(); if (info == null) { info = varInfo; } if (info != null && info.hasEnumParameterType()) { checkEnumInitializer( t, value, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));"
      },
      {
        "txt": "} else if (var.isTypeInferred()) { ensureTyped(t, name, valueType); } else { validator.expectCanAssignTo( t, value, valueType, nameType, \"initializing variable\"); } } } } private void visitNew(NodeTraversal t, Node n) {"
      },
      {
        "txt": "Node constructor = n.getFirstChild(); FunctionType type = getFunctionType(constructor); if (type != null && type.isConstructor()) { visitParameterList(t, n, type); ensureTyped(t, n, type.getInstanceType()); } else { if (constructor.getType() != Token.GETPROP) { Node line; if (constructor.getLineno() < 0 || constructor.getCharno() < 0) { line = n;"
      },
      {
        "txt": "} else { line = constructor; } report(t, line, NOT_A_CONSTRUCTOR); } ensureTyped(t, n); } } private void visitFunction(NodeTraversal t, Node n) { JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "FunctionType functionType = (FunctionType) n.getJSType(); String functionPrivateName = n.getFirstChild().getString(); if (functionType.isInterface() || functionType.isConstructor()) { FunctionType baseConstructor = functionType. getPrototype().getImplicitPrototype().getConstructor(); if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isConstructor() && functionType.isInterface() || baseConstructor.isInterface() && functionType.isConstructor())) { compiler.report("
      },
      {
        "txt": "t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName)); } for (JSType baseInterface : functionType.getImplementedInterfaces()) { boolean badImplementedType = false; ObjectType baseInterfaceObj = ObjectType.cast(baseInterface); if (baseInterfaceObj != null) { FunctionType interfaceConstructor = baseInterfaceObj.getConstructor(); if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {"
      },
      {
        "txt": "badImplementedType = true; } } else { badImplementedType = true; } if (badImplementedType) { report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName); } } if (functionType.isConstructor()) {"
      },
      {
        "txt": "validator.expectAllInterfaceProperties(t, n, functionType); } } } private void visitCall(NodeTraversal t, Node n) { Node child = n.getFirstChild(); JSType childType = getJSType(child).restrictByNotNullOrUndefined(); if (!childType.canBeCalled()) { report(t, n, NOT_CALLABLE, childType.toString()); ensureTyped(t, n);"
      },
      {
        "txt": "return; } if (childType instanceof FunctionType) { FunctionType functionType = (FunctionType) childType; if (functionType.isConstructor() && !functionType.isNativeObjectType()) { report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); } visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType());"
      },
      {
        "txt": "} else { ensureTyped(t, n); } } private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) { Iterator<Node> arguments = call.children().iterator(); arguments.next(); // skip the function name Iterator<Node> parameters = functionType.getParameters().iterator(); int ordinal = 0;"
      },
      {
        "txt": "Node parameter = null; Node argument = null; while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) { if (parameters.hasNext()) { parameter = parameters.next(); } argument = arguments.next(); ordinal++;"
      },
      {
        "txt": "validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal); } int numArgs = call.getChildCount() - 1; int minArgs = functionType.getMinArguments(); int maxArgs = functionType.getMaxArguments(); if (minArgs > numArgs || maxArgs < numArgs) { report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs),"
      },
      {
        "txt": "maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\"); } } private void visitReturn(NodeTraversal t, Node n) { Node function = t.getEnclosingFunction(); if (function == null) { return; } JSType jsType = getJSType(function);"
      },
      {
        "txt": "if (jsType instanceof FunctionType) { FunctionType functionType = (FunctionType) jsType; JSType returnType = functionType.getReturnType(); if (returnType == null) { returnType = getNativeType(VOID_TYPE); } Node valueNode = n.getFirstChild(); JSType actualReturnType; if (valueNode == null) { actualReturnType = getNativeType(VOID_TYPE);"
      },
      {
        "txt": "valueNode = n; } else { actualReturnType = getJSType(valueNode); } validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType, \"inconsistent return type\"); } } private void visitBinaryOperator(int op, NodeTraversal t, Node n) { Node left = n.getFirstChild();"
      },
      {
        "txt": "JSType leftType = getJSType(left); Node right = n.getLastChild(); JSType rightType = getJSType(right); switch (op) { case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH:"
      },
      {
        "txt": "if (!leftType.matchesInt32Context()) { report(t, left, BIT_OPERATION, NodeUtil.opToStr(n.getType()), leftType.toString()); } if (!rightType.matchesUint32Context()) { report(t, right, BIT_OPERATION, NodeUtil.opToStr(n.getType()), rightType.toString()); } break; case Token.ASSIGN_DIV:"
      },
      {
        "txt": "case Token.ASSIGN_MOD: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD: case Token.MUL: case Token.SUB: validator.expectNumber(t, left, leftType, \"left operand\"); validator.expectNumber(t, right, rightType, \"right operand\"); break;"
      },
      {
        "txt": "case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.BITAND: case Token.BITXOR: case Token.BITOR: validator.expectBitwiseable(t, left, leftType, \"bad left operand to bitwise operator\"); validator.expectBitwiseable(t, right, rightType, \"bad right operand to bitwise operator\");"
      },
      {
        "txt": "break; case Token.ASSIGN_ADD: case Token.ADD: break; default: report(t, n, UNEXPECTED_TOKEN, Node.tokenToName(op)); } ensureTyped(t, n); } private void checkEnumInitializer("
      },
      {
        "txt": "NodeTraversal t, Node value, JSType primitiveType) { if (value.getType() == Token.OBJECTLIT) { for (Node key = value.getFirstChild(); key != null; key = key.getNext()) { Node propValue = key.getFirstChild(); validator.expectCanAssignTo( t, propValue, getJSType(propValue), primitiveType, \"element type must match enum's type\"); } } else if (value.getJSType() instanceof EnumType) {"
      },
      {
        "txt": "EnumType valueEnumType = (EnumType) value.getJSType(); JSType valueEnumPrimitiveType = valueEnumType.getElementsType().getPrimitiveType(); validator.expectCanAssignTo(t, value, valueEnumPrimitiveType, primitiveType, \"incompatible enum element types\"); } else { } } private static boolean isReference(Node n) { switch (n.getType()) {"
      },
      {
        "txt": "case Token.GETELEM: case Token.GETPROP: case Token.NAME: return true; default: return false; } } private JSType getJSType(Node n) { JSType jsType = n.getJSType();"
      },
      {
        "txt": "if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private FunctionType getFunctionType(Node n) { JSType type = getJSType(n).restrictByNotNullOrUndefined(); if (type.isUnknownType()) { return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE);"
      },
      {
        "txt": "} else if (type instanceof FunctionType) { return (FunctionType) type; } else { return null; } } private void ensureTyped(NodeTraversal t, Node n) { ensureTyped(t, n, getNativeType(UNKNOWN_TYPE)); } private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {"
      },
      {
        "txt": "ensureTyped(t, n, getNativeType(type)); } private void ensureTyped(NodeTraversal t, Node n, JSType type) { Preconditions.checkState(n.getType() != Token.FUNCTION || type instanceof FunctionType || type.isUnknownType()); JSDocInfo info = n.getJSDocInfo(); if (info != null) { if (info.hasType()) { JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);"
      },
      {
        "txt": "validator.expectCanCast(t, n, infoType, type); type = infoType; } if (info.isImplicitCast() && !inExterns) { String propName = n.getType() == Token.GETPROP ? n.getLastChild().getString() : \"(missing)\"; compiler.report( t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName)); } }"
      },
      {
        "txt": "if (n.getJSType() == null) { n.setJSType(type); } } double getTypedPercent() { int total = nullCount + unknownCount + typedCount; if (total == 0) { return 0.0; } else { return (100.0 * typedCount) / total;"
      },
      {
        "txt": "} } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 684,
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java",
    "start-bug-line": 1049,
    "end-bug-line": 1058,
    "bug": "if (interfaceHasProperty) { JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(interfacePropType)) { compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString())); } }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.TernaryValue; import java.util.Iterator;"
      },
      {
        "txt": "public class TypeCheck implements NodeTraversal.Callback, CompilerPass { static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error( \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\", \"Internal Error: Don't know how to handle {0}\"); static final DiagnosticType BAD_DELETE = DiagnosticType.warning( \"JSC_BAD_DELETE_OPERAND\", \"delete operator needs a reference operand\"); protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT = \"overriding prototype with non-object\";"
      },
      {
        "txt": "static final DiagnosticType DETERMINISTIC_TEST = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST\", \"condition always evaluates to {2}\\n\" + \"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT = DiagnosticType.warning( \"JSC_DETERMINISTIC_TEST_NO_RESULT\", \"condition always evaluates to the same value\\n\" +"
      },
      {
        "txt": "\"left : {0}\\n\" + \"right: {1}\"); static final DiagnosticType INEXISTENT_ENUM_ELEMENT = DiagnosticType.warning( \"JSC_INEXISTENT_ENUM_ELEMENT\", \"element {0} does not exist on this enum\"); static final DiagnosticType INEXISTENT_PROPERTY = DiagnosticType.disabled( \"JSC_INEXISTENT_PROPERTY\", \"Property {0} never defined on {1}\");"
      },
      {
        "txt": "protected static final DiagnosticType NOT_A_CONSTRUCTOR = DiagnosticType.warning( \"JSC_NOT_A_CONSTRUCTOR\", \"cannot instantiate non-constructor\"); static final DiagnosticType BIT_OPERATION = DiagnosticType.warning( \"JSC_BAD_TYPE_FOR_BIT_OPERATION\", \"operator {0} cannot be applied to {1}\"); static final DiagnosticType NOT_CALLABLE = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_NOT_FUNCTION_TYPE\", \"{0} expressions are not callable\"); static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE = DiagnosticType.warning( \"JSC_CONSTRUCTOR_NOT_CALLABLE\", \"Constructor {0} should be called with the \\\"new\\\" keyword\"); static final DiagnosticType FUNCTION_MASKS_VARIABLE = DiagnosticType.warning( \"JSC_FUNCTION_MASKS_VARIABLE\", \"function {0} masks variable (IE bug)\");"
      },
      {
        "txt": "static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning( \"JSC_MULTIPLE_VAR_DEF\", \"declaration of multiple variables with shared type information\"); static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\", \"enum element {0} already defined\"); static final DiagnosticType ENUM_NOT_CONSTANT = DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\", \"enum key {0} must be a syntactic constant\"); static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\", \"interface members can only be empty property declarations,\" + \" empty functions{0}\"); static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY = DiagnosticType.warning( \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\", \"interface member functions must have an empty body\"); static final DiagnosticType CONFLICTING_EXTENDED_TYPE = DiagnosticType.warning( \"JSC_CONFLICTING_EXTENDED_TYPE\","
      },
      {
        "txt": "\"{0} cannot extend this type; \" + \"a constructor can only extend objects \" + \"and an interface can only extend interfaces\"); static final DiagnosticType BAD_IMPLEMENTED_TYPE = DiagnosticType.warning( \"JSC_IMPLEMENTS_NON_INTERFACE\", \"can only implement interfaces\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_SUPERCLASS_PROPERTY\","
      },
      {
        "txt": "\"property {0} already defined on superclass {1}; \" + \"use @override to override it\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY\", \"property {0} already defined on interface {1}; \" + \"use @override to override it\"); static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" +"
      },
      {
        "txt": "\"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\");"
      },
      {
        "txt": "static final DiagnosticType UNKNOWN_OVERRIDE = DiagnosticType.warning( \"JSC_UNKNOWN_OVERRIDE\", \"property {0} not defined on any superclass of {1}\"); static final DiagnosticType INTERFACE_METHOD_OVERRIDE = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_OVERRIDE\", \"property {0} is already defined by the {1} extended interface\"); static final DiagnosticType UNKNOWN_EXPR_TYPE = DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\","
      },
      {
        "txt": "\"could not determine the type of this expression\"); static final DiagnosticType UNRESOLVED_TYPE = DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\", \"could not resolve the name {0} to a type\"); static final DiagnosticType WRONG_ARGUMENT_COUNT = DiagnosticType.warning( \"JSC_WRONG_ARGUMENT_COUNT\", \"Function {0}: called with {1} argument(s). \" + \"Function requires at least {2} argument(s){3}.\"); static final DiagnosticType ILLEGAL_IMPLICIT_CAST ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_ILLEGAL_IMPLICIT_CAST\", \"Illegal annotation on {0}. @implicitCast may only be used in \" + \"externs.\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( DETERMINISTIC_TEST, DETERMINISTIC_TEST_NO_RESULT, INEXISTENT_ENUM_ELEMENT, INEXISTENT_PROPERTY, NOT_A_CONSTRUCTOR,"
      },
      {
        "txt": "BIT_OPERATION, NOT_CALLABLE, CONSTRUCTOR_NOT_CALLABLE, FUNCTION_MASKS_VARIABLE, MULTIPLE_VAR_DEF, ENUM_DUP, ENUM_NOT_CONSTANT, INVALID_INTERFACE_MEMBER_DECLARATION, INTERFACE_FUNCTION_NOT_EMPTY, CONFLICTING_EXTENDED_TYPE,"
      },
      {
        "txt": "BAD_IMPLEMENTED_TYPE, HIDDEN_SUPERCLASS_PROPERTY, HIDDEN_INTERFACE_PROPERTY, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, HIDDEN_INTERFACE_PROPERTY_MISMATCH, UNKNOWN_OVERRIDE, INTERFACE_METHOD_OVERRIDE, UNKNOWN_EXPR_TYPE, UNRESOLVED_TYPE, WRONG_ARGUMENT_COUNT,"
      },
      {
        "txt": "ILLEGAL_IMPLICIT_CAST, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER, TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT); private final AbstractCompiler compiler; private final TypeValidator validator; private final ReverseAbstractInterpreter reverseInterpreter; private final JSTypeRegistry typeRegistry;"
      },
      {
        "txt": "private Scope topScope; private ScopeCreator scopeCreator; private final CheckLevel reportMissingOverride; private final CheckLevel reportUnknownTypes; private boolean reportMissingProperties = true; private InferJSDocInfo inferJSDocInfo = null; private int typedCount = 0; private int nullCount = 0; private int unknownCount = 0; private boolean inExterns;"
      },
      {
        "txt": "private int noTypeCheckSection = 0; public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, Scope topScope, ScopeCreator scopeCreator, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { this.compiler = compiler; this.validator = compiler.getTypeValidator();"
      },
      {
        "txt": "this.reverseInterpreter = reverseInterpreter; this.typeRegistry = typeRegistry; this.topScope = topScope; this.scopeCreator = scopeCreator; this.reportMissingOverride = reportMissingOverride; this.reportUnknownTypes = reportUnknownTypes; this.inferJSDocInfo = new InferJSDocInfo(compiler); } public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter,"
      },
      {
        "txt": "JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { this(compiler, reverseInterpreter, typeRegistry, null, null, reportMissingOverride, reportUnknownTypes); } TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry) { this(compiler, reverseInterpreter, typeRegistry, null, null,"
      },
      {
        "txt": "CheckLevel.WARNING, CheckLevel.OFF); } TypeCheck reportMissingProperties(boolean report) { reportMissingProperties = report; return this; } public void process(Node externsRoot, Node jsRoot) { Preconditions.checkNotNull(scopeCreator); Preconditions.checkNotNull(topScope); Node externsAndJs = jsRoot.getParent();"
      },
      {
        "txt": "Preconditions.checkState(externsAndJs != null); Preconditions.checkState( externsRoot == null || externsAndJs.hasChild(externsRoot)); if (externsRoot != null) { check(externsRoot, true); } check(jsRoot, false); } public Scope processForTesting(Node externsRoot, Node jsRoot) { Preconditions.checkState(scopeCreator == null);"
      },
      {
        "txt": "Preconditions.checkState(topScope == null); Preconditions.checkState(jsRoot.getParent() != null); Node externsAndJsRoot = jsRoot.getParent(); scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); topScope = scopeCreator.createScope(externsAndJsRoot, null); TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator); inference.process(externsRoot, jsRoot); process(externsRoot, jsRoot); return topScope;"
      },
      {
        "txt": "} public void check(Node node, boolean externs) { Preconditions.checkNotNull(node); NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator); inExterns = externs; t.traverseWithScope(node, topScope); if (externs) { inferJSDocInfo.process(node, null); } else { inferJSDocInfo.process(null, node);"
      },
      {
        "txt": "} } private void checkNoTypeCheckSection(Node n, boolean enterSection) { switch (n.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.VAR: case Token.FUNCTION: case Token.ASSIGN: JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info != null && info.isNoTypeCheck()) { if (enterSection) { noTypeCheckSection++; } else { noTypeCheckSection--; } } validator.setShouldReport(noTypeCheckSection == 0); break; }"
      },
      {
        "txt": "} private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments) { if (noTypeCheckSection == 0) { t.report(n, diagnosticType, arguments); } } public boolean shouldTraverse( NodeTraversal t, Node n, Node parent) { checkNoTypeCheckSection(n, true);"
      },
      {
        "txt": "switch (n.getType()) { case Token.FUNCTION: final TypeCheck outerThis = this; final Scope outerScope = t.getScope(); final FunctionType functionType = (FunctionType) n.getJSType(); final String functionPrivateName = n.getFirstChild().getString(); if (functionPrivateName != null && functionPrivateName.length() > 0 && outerScope.isDeclared(functionPrivateName, false) && !(outerScope.getVar( functionPrivateName).getType() instanceof FunctionType)) {"
      },
      {
        "txt": "report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName); } break; } return true; } public void visit(NodeTraversal t, Node n, Node parent) { JSType childType; JSType leftType, rightType; Node left, right;"
      },
      {
        "txt": "boolean typeable = true; switch (n.getType()) { case Token.NAME: typeable = visitName(t, n, parent); break; case Token.LP: if (parent.getType() != Token.FUNCTION) { ensureTyped(t, n, getJSType(n.getFirstChild())); } else { typeable = false;"
      },
      {
        "txt": "} break; case Token.COMMA: ensureTyped(t, n, getJSType(n.getLastChild())); break; case Token.TRUE: case Token.FALSE: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.THIS:"
      },
      {
        "txt": "ensureTyped(t, n, t.getScope().getTypeOfThis()); break; case Token.REF_SPECIAL: ensureTyped(t, n); break; case Token.GET_REF: ensureTyped(t, n, getJSType(n.getFirstChild())); break; case Token.NULL: ensureTyped(t, n, NULL_TYPE);"
      },
      {
        "txt": "break; case Token.NUMBER: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, NUMBER_TYPE); } break; case Token.STRING: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); }"
      },
      {
        "txt": "break; case Token.GET: case Token.SET: break; case Token.ARRAYLIT: ensureTyped(t, n, ARRAY_TYPE); break; case Token.REGEXP: ensureTyped(t, n, REGEXP_TYPE); break;"
      },
      {
        "txt": "case Token.GETPROP: visitGetProp(t, n, parent); typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n); break; case Token.GETELEM: visitGetElem(t, n); typeable = false; break; case Token.VAR:"
      },
      {
        "txt": "visitVar(t, n); typeable = false; break; case Token.NEW: visitNew(t, n); typeable = true; break; case Token.CALL: visitCall(t, n); typeable = !NodeUtil.isExpressionNode(parent);"
      },
      {
        "txt": "break; case Token.RETURN: visitReturn(t, n); typeable = false; break; case Token.DEC: case Token.INC: left = n.getFirstChild(); validator.expectNumber( t, left, getJSType(left), \"increment/decrement\");"
      },
      {
        "txt": "ensureTyped(t, n, NUMBER_TYPE); break; case Token.NOT: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.VOID: ensureTyped(t, n, VOID_TYPE); break; case Token.TYPEOF: ensureTyped(t, n, STRING_TYPE);"
      },
      {
        "txt": "break; case Token.BITNOT: childType = getJSType(n.getFirstChild()); if (!childType.matchesInt32Context()) { report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString()); } ensureTyped(t, n, NUMBER_TYPE); break; case Token.POS:"
      },
      {
        "txt": "case Token.NEG: left = n.getFirstChild(); validator.expectNumber(t, left, getJSType(left), \"sign operator\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.EQ: case Token.NE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted); if (result != TernaryValue.UNKNOWN) { if (n.getType() == Token.NE) { result = result.not(); } report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString()); }"
      },
      {
        "txt": "ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.SHEQ: case Token.SHNE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); if (!leftTypeRestricted.canTestForShallowEqualityWith("
      },
      {
        "txt": "rightTypeRestricted)) { report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString()); } ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.LT: case Token.LE: case Token.GT:"
      },
      {
        "txt": "case Token.GE: leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); if (rightType.isNumber()) { validator.expectNumber( t, n, leftType, \"left side of numeric comparison\"); } else if (leftType.isNumber()) { validator.expectNumber( t, n, rightType, \"right side of numeric comparison\"); } else if (leftType.matchesNumberContext() &&"
      },
      {
        "txt": "rightType.matchesNumberContext()) { } else { String message = \"left side of comparison\"; validator.expectString(t, n, leftType, message); validator.expectNotNullOrUndefined( t, n, leftType, message, getNativeType(STRING_TYPE)); message = \"right side of comparison\"; validator.expectString(t, n, rightType, message); validator.expectNotNullOrUndefined( t, n, rightType, message, getNativeType(STRING_TYPE));"
      },
      {
        "txt": "} ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.IN: left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right); validator.expectObject(t, n, rightType, \"'in' requires an object\"); validator.expectString(t, left, leftType, \"left side of 'in'\");"
      },
      {
        "txt": "ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.INSTANCEOF: left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right).restrictByNotNullOrUndefined(); validator.expectAnyObject( t, left, leftType, \"deterministic instanceof yields false\"); validator.expectActualObject("
      },
      {
        "txt": "t, right, rightType, \"instanceof requires an object\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.ASSIGN: visitAssign(t, n); typeable = false; break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH:"
      },
      {
        "txt": "case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_SUB: case Token.ASSIGN_ADD: case Token.ASSIGN_MUL: case Token.LSH: case Token.RSH:"
      },
      {
        "txt": "case Token.URSH: case Token.DIV: case Token.MOD: case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.SUB: case Token.ADD: case Token.MUL: visitBinaryOperator(n.getType(), t, n);"
      },
      {
        "txt": "break; case Token.DELPROP: if (!isReference(n.getFirstChild())) { report(t, n, BAD_DELETE); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.CASE: JSType switchType = getJSType(parent.getFirstChild()); JSType caseType = getJSType(n.getFirstChild());"
      },
      {
        "txt": "validator.expectSwitchMatchesCase(t, n, switchType, caseType); typeable = false; break; case Token.WITH: { Node child = n.getFirstChild(); childType = getJSType(child); validator.expectObject( t, child, childType, \"with requires an object\"); typeable = false; break;"
      },
      {
        "txt": "} case Token.FUNCTION: visitFunction(t, n); break; case Token.LABEL: case Token.LABEL_NAME: case Token.SWITCH: case Token.BREAK: case Token.CATCH: case Token.TRY:"
      },
      {
        "txt": "case Token.SCRIPT: case Token.EXPR_RESULT: case Token.BLOCK: case Token.EMPTY: case Token.DEFAULT: case Token.CONTINUE: case Token.DEBUGGER: case Token.THROW: typeable = false; break;"
      },
      {
        "txt": "case Token.DO: case Token.FOR: case Token.IF: case Token.WHILE: typeable = false; break; case Token.AND: case Token.HOOK: case Token.OBJECTLIT: case Token.OR:"
      },
      {
        "txt": "if (n.getJSType() != null) { // If we didn't run type inference. ensureTyped(t, n); } else { if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) { ensureTyped(t, n, parent.getJSType()); } else { ensureTyped(t, n); } }"
      },
      {
        "txt": "if (n.getType() == Token.OBJECTLIT) { for (Node key : n.children()) { visitObjLitKey(t, key, n); } } break; default: report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType())); ensureTyped(t, n); break;"
      },
      {
        "txt": "} typeable = typeable && !inExterns; if (typeable) { doPercentTypedAccounting(t, n); } checkNoTypeCheckSection(n, false); } private void doPercentTypedAccounting(NodeTraversal t, Node n) { JSType type = n.getJSType(); if (type == null) {"
      },
      {
        "txt": "nullCount++; } else if (type.isUnknownType()) { if (reportUnknownTypes.isOn()) { compiler.report( t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE)); } unknownCount++; } else { typedCount++; }"
      },
      {
        "txt": "} private void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild(); Node rvalue = assign.getLastChild(); if (lvalue.getType() == Token.GETPROP) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); String property = lvalue.getLastChild().getString(); if (object.getType() == Token.GETPROP) {"
      },
      {
        "txt": "JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\"prototype\")) { visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue); } } if (info != null && info.hasType()) { visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);"
      },
      {
        "txt": "return; } if (info != null && info.hasEnumParameterType()) { checkEnumInitializer( t, rvalue, info.getEnumParameterType().evaluate( t.getScope(), typeRegistry)); return; } if (property.equals(\"prototype\")) { if (objectJsType instanceof FunctionType) {"
      },
      {
        "txt": "FunctionType functionType = (FunctionType) objectJsType; if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); } } else { } return; }"
      },
      {
        "txt": "if (object.getType() == Token.GETPROP) { Node object2 = object.getFirstChild(); String property2 = NodeUtil.getStringValue(object.getLastChild()); if (\"prototype\".equals(property2)) { JSType jsType = object2.getJSType(); if (jsType instanceof FunctionType) { FunctionType functionType = (FunctionType) jsType; if (functionType.isConstructor() || functionType.isInterface()) { checkDeclaredPropertyInheritance( t, assign, functionType, property, info, getJSType(rvalue));"
      },
      {
        "txt": "} } else { } return; } } ObjectType type = ObjectType.cast( objectJsType.restrictByNotNullOrUndefined()); if (type != null) { if (type.hasProperty(property) &&"
      },
      {
        "txt": "!type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf( t, assign, getJSType(rvalue), type.getPropertyType(property), object, property); } return; } } else if (lvalue.getType() == Token.NAME) { JSType rvalueType = getJSType(assign.getLastChild());"
      },
      {
        "txt": "Var var = t.getScope().getVar(lvalue.getString()); if (var != null) { if (var.isTypeInferred()) { return; } } } JSType leftType = getJSType(lvalue); Node rightChild = assign.getLastChild(); JSType rightType = getJSType(rightChild);"
      },
      {
        "txt": "if (validator.expectCanAssignTo( t, assign, rightType, leftType, \"assignment\")) { ensureTyped(t, assign, rightType); } else { ensureTyped(t, assign); } } private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) { Node rvalue = key.getFirstChild(); JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType("
      },
      {
        "txt": "key, getJSType(rvalue)); if (rightType == null) { rightType = getNativeType(UNKNOWN_TYPE); } Node owner = objlit; JSType keyType = getJSType(key); boolean valid = validator.expectCanAssignToPropertyOf(t, key, rightType, keyType, owner, NodeUtil.getObjectLitKeyName(key)); if (valid) {"
      },
      {
        "txt": "ensureTyped(t, key, rightType); } else { ensureTyped(t, key); } JSType objlitType = getJSType(objlit); ObjectType type = ObjectType.cast( objlitType.restrictByNotNullOrUndefined()); if (type != null) { String property = NodeUtil.getObjectLitKeyName(key); if (type.hasProperty(property) &&"
      },
      {
        "txt": "!type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf( t, key, keyType, type.getPropertyType(property), owner, property); } return; } } private boolean propertyIsImplicitCast(ObjectType type, String prop) {"
      },
      {
        "txt": "for (; type != null; type = type.getImplicitPrototype()) { JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop); if (docInfo != null && docInfo.isImplicitCast()) { return true; } } return false; } private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName,"
      },
      {
        "txt": "JSDocInfo info, JSType propertyType) { if (hasUnknownOrEmptySupertype(ctorType)) { return; } FunctionType superClass = ctorType.getSuperClassConstructor(); boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName); boolean declaredOverride = info != null && info.isOverride(); boolean foundInterfaceProperty = false; if (ctorType.isConstructor()) {"
      },
      {
        "txt": "for (JSType implementedInterface : ctorType.getImplementedInterfaces()) { if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) { continue; } FunctionType interfaceType = implementedInterface.toObjectType().getConstructor(); Preconditions.checkNotNull(interfaceType); boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);"
      },
      {
        "txt": "if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } <extra_id_0> } } if (!declaredOverride && !superClassHasProperty) { return; } JSType topInstanceType = superClassHasProperty ?"
      },
      {
        "txt": "} JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null; if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString())); } if (!declaredOverride) {"
      },
      {
        "txt": "return; } if (superClassHasProperty) { JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(superClassPropType)) { compiler.report( t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));"
      },
      {
        "txt": "} } else if (!foundInterfaceProperty) { compiler.report( t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString())); } } private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) { Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface()); Preconditions.checkArgument(!ctor.isUnknownType());"
      },
      {
        "txt": "while (true) { ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype(); if (maybeSuperInstanceType == null) { return false; } if (maybeSuperInstanceType.isUnknownType() || maybeSuperInstanceType.isEmptyType()) { return true; }"
      },
      {
        "txt": "ctor = maybeSuperInstanceType.getConstructor(); if (ctor == null) { return false; } Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); } } private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue) { JSType rvalueType = getJSType(rvalue);"
      },
      {
        "txt": "String abstractMethodName = compiler.getCodingConvention().getAbstractMethodName(); if (!rvalueType.isOrdinaryFunction() && !(rvalue.isQualifiedName() && rvalue.getQualifiedName().equals(abstractMethodName))) { String abstractMethodMessage = (abstractMethodName != null) ? \", or \" + abstractMethodName : \"\"; compiler.report( t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION,"
      },
      {
        "txt": "abstractMethodMessage)); } if (assign.getLastChild().getType() == Token.FUNCTION && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) { compiler.report( t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY, abstractMethodName)); } } private void visitAnnotatedAssignGetprop(NodeTraversal t,"
      },
      {
        "txt": "Node assign, JSType type, Node object, String property, Node rvalue) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type, object, property); } boolean visitName(NodeTraversal t, Node n, Node parent) { int parentNodeType = parent.getType(); if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.LP || parentNodeType == Token.VAR) {"
      },
      {
        "txt": "return false; } JSType type = n.getJSType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); Var var = t.getScope().getVar(n.getString()); if (var != null) { JSType varType = var.getType(); if (varType != null) { type = varType;"
      },
      {
        "txt": "} } } ensureTyped(t, n, type); return true; } private void visitGetProp(NodeTraversal t, Node n, Node parent) { if (n.getJSType() != null && parent.getType() == Token.ASSIGN) { return; }"
      },
      {
        "txt": "Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (!validator.expectNotNullOrUndefined(t, n, childType, childType + \" has no properties\", getNativeType(OBJECT_TYPE))) { ensureTyped(t, n); return; } checkPropertyAccess(childType, property.getString(), t, n); ensureTyped(t, n);"
      },
      {
        "txt": "} private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n) { ObjectType objectType = childType.dereference(); if (objectType != null) { JSType propType = getJSType(n); if ((!objectType.hasProperty(propName) || objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) && propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) { if (objectType instanceof EnumType) {"
      },
      {
        "txt": "report(t, n, INEXISTENT_ENUM_ELEMENT, propName); } else if (!objectType.isEmptyType() && reportMissingProperties && !isPropertyTest(n)) { if (!typeRegistry.canPropertyBeDefined(objectType, propName)) { report(t, n, INEXISTENT_PROPERTY, propName, validator.getReadableJSTypeName(n.getFirstChild(), true)); } } } } else {"
      },
      {
        "txt": "} } private boolean isPropertyTest(Node getProp) { Node parent = getProp.getParent(); switch (parent.getType()) { case Token.CALL: return parent.getFirstChild() != getProp && compiler.getCodingConvention().isPropertyTestFunction(parent); case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "case Token.DO: case Token.FOR: return NodeUtil.getConditionExpression(parent) == getProp; case Token.INSTANCEOF: case Token.TYPEOF: return true; case Token.AND: case Token.HOOK: return parent.getFirstChild() == getProp; case Token.NOT:"
      },
      {
        "txt": "return parent.getParent().getType() == Token.OR && parent.getParent().getFirstChild() == parent; } return false; } private void visitGetElem(NodeTraversal t, Node n) { Node left = n.getFirstChild(); Node right = n.getLastChild(); validator.expectIndexMatch(t, n, getJSType(left), getJSType(right)); ensureTyped(t, n);"
      },
      {
        "txt": "} private void visitVar(NodeTraversal t, Node n) { JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null; for (Node name : n.children()) { Node value = name.getFirstChild(); Var var = t.getScope().getVar(name.getString()); if (value != null) { JSType valueType = getJSType(value); JSType nameType = var.getType(); nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;"
      },
      {
        "txt": "JSDocInfo info = name.getJSDocInfo(); if (info == null) { info = varInfo; } if (info != null && info.hasEnumParameterType()) { checkEnumInitializer( t, value, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry)); } else if (var.isTypeInferred()) { ensureTyped(t, name, valueType);"
      },
      {
        "txt": "} else { validator.expectCanAssignTo( t, value, valueType, nameType, \"initializing variable\"); } } } } private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); FunctionType type = getFunctionType(constructor);"
      },
      {
        "txt": "if (type != null && type.isConstructor()) { visitParameterList(t, n, type); ensureTyped(t, n, type.getInstanceType()); } else { if (constructor.getType() != Token.GETPROP) { Node line; if (constructor.getLineno() < 0 || constructor.getCharno() < 0) { line = n; } else { line = constructor;"
      },
      {
        "txt": "} report(t, line, NOT_A_CONSTRUCTOR); } ensureTyped(t, n); } } private void visitFunction(NodeTraversal t, Node n) { JSDocInfo info = n.getJSDocInfo(); FunctionType functionType = (FunctionType) n.getJSType(); String functionPrivateName = n.getFirstChild().getString();"
      },
      {
        "txt": "if (functionType.isInterface() || functionType.isConstructor()) { FunctionType baseConstructor = functionType. getPrototype().getImplicitPrototype().getConstructor(); if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isConstructor() && functionType.isInterface() || baseConstructor.isInterface() && functionType.isConstructor())) { compiler.report( t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName)); }"
      },
      {
        "txt": "for (JSType baseInterface : functionType.getImplementedInterfaces()) { boolean badImplementedType = false; ObjectType baseInterfaceObj = ObjectType.cast(baseInterface); if (baseInterfaceObj != null) { FunctionType interfaceConstructor = baseInterfaceObj.getConstructor(); if (interfaceConstructor != null && !interfaceConstructor.isInterface()) { badImplementedType = true; }"
      },
      {
        "txt": "} else { badImplementedType = true; } if (badImplementedType) { report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName); } } if (functionType.isConstructor()) { validator.expectAllInterfaceProperties(t, n, functionType); }"
      },
      {
        "txt": "} } private void visitCall(NodeTraversal t, Node n) { Node child = n.getFirstChild(); JSType childType = getJSType(child).restrictByNotNullOrUndefined(); if (!childType.canBeCalled()) { report(t, n, NOT_CALLABLE, childType.toString()); ensureTyped(t, n); return; }"
      },
      {
        "txt": "if (childType instanceof FunctionType) { FunctionType functionType = (FunctionType) childType; if (functionType.isConstructor() && !functionType.isNativeObjectType()) { report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); } visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType()); } else { ensureTyped(t, n);"
      },
      {
        "txt": "} } private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) { Iterator<Node> arguments = call.children().iterator(); arguments.next(); // skip the function name Iterator<Node> parameters = functionType.getParameters().iterator(); int ordinal = 0; Node parameter = null; Node argument = null;"
      },
      {
        "txt": "while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) { if (parameters.hasNext()) { parameter = parameters.next(); } argument = arguments.next(); ordinal++; validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);"
      },
      {
        "txt": "} int numArgs = call.getChildCount() - 1; int minArgs = functionType.getMinArguments(); int maxArgs = functionType.getMaxArguments(); if (minArgs > numArgs || maxArgs < numArgs) { report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");"
      },
      {
        "txt": "} } private void visitReturn(NodeTraversal t, Node n) { Node function = t.getEnclosingFunction(); if (function == null) { return; } JSType jsType = getJSType(function); if (jsType instanceof FunctionType) { FunctionType functionType = (FunctionType) jsType;"
      },
      {
        "txt": "JSType returnType = functionType.getReturnType(); if (returnType == null) { returnType = getNativeType(VOID_TYPE); } Node valueNode = n.getFirstChild(); JSType actualReturnType; if (valueNode == null) { actualReturnType = getNativeType(VOID_TYPE); valueNode = n; } else {"
      },
      {
        "txt": "actualReturnType = getJSType(valueNode); } validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType, \"inconsistent return type\"); } } private void visitBinaryOperator(int op, NodeTraversal t, Node n) { Node left = n.getFirstChild(); JSType leftType = getJSType(left); Node right = n.getLastChild();"
      },
      {
        "txt": "JSType rightType = getJSType(right); switch (op) { case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: if (!leftType.matchesInt32Context()) { report(t, left, BIT_OPERATION,"
      },
      {
        "txt": "NodeUtil.opToStr(n.getType()), leftType.toString()); } if (!rightType.matchesUint32Context()) { report(t, right, BIT_OPERATION, NodeUtil.opToStr(n.getType()), rightType.toString()); } break; case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_MUL:"
      },
      {
        "txt": "case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD: case Token.MUL: case Token.SUB: validator.expectNumber(t, left, leftType, \"left operand\"); validator.expectNumber(t, right, rightType, \"right operand\"); break; case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR:"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: case Token.BITAND: case Token.BITXOR: case Token.BITOR: validator.expectBitwiseable(t, left, leftType, \"bad left operand to bitwise operator\"); validator.expectBitwiseable(t, right, rightType, \"bad right operand to bitwise operator\"); break; case Token.ASSIGN_ADD:"
      },
      {
        "txt": "case Token.ADD: break; default: report(t, n, UNEXPECTED_TOKEN, Node.tokenToName(op)); } ensureTyped(t, n); } private void checkEnumInitializer( NodeTraversal t, Node value, JSType primitiveType) { if (value.getType() == Token.OBJECTLIT) {"
      },
      {
        "txt": "for (Node key = value.getFirstChild(); key != null; key = key.getNext()) { Node propValue = key.getFirstChild(); validator.expectCanAssignTo( t, propValue, getJSType(propValue), primitiveType, \"element type must match enum's type\"); } } else if (value.getJSType() instanceof EnumType) { EnumType valueEnumType = (EnumType) value.getJSType(); JSType valueEnumPrimitiveType ="
      },
      {
        "txt": "valueEnumType.getElementsType().getPrimitiveType(); validator.expectCanAssignTo(t, value, valueEnumPrimitiveType, primitiveType, \"incompatible enum element types\"); } else { } } private static boolean isReference(Node n) { switch (n.getType()) { case Token.GETELEM: case Token.GETPROP:"
      },
      {
        "txt": "case Token.NAME: return true; default: return false; } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} else { return jsType; } } private FunctionType getFunctionType(Node n) { JSType type = getJSType(n).restrictByNotNullOrUndefined(); if (type.isUnknownType()) { return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE); } else if (type instanceof FunctionType) { return (FunctionType) type;"
      },
      {
        "txt": "} else { return null; } } private void ensureTyped(NodeTraversal t, Node n) { ensureTyped(t, n, getNativeType(UNKNOWN_TYPE)); } private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) { ensureTyped(t, n, getNativeType(type)); }"
      },
      {
        "txt": "private void ensureTyped(NodeTraversal t, Node n, JSType type) { Preconditions.checkState(n.getType() != Token.FUNCTION || type instanceof FunctionType || type.isUnknownType()); JSDocInfo info = n.getJSDocInfo(); if (info != null) { if (info.hasType()) { JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry); validator.expectCanCast(t, n, infoType, type); type = infoType;"
      },
      {
        "txt": "} if (info.isImplicitCast() && !inExterns) { String propName = n.getType() == Token.GETPROP ? n.getLastChild().getString() : \"(missing)\"; compiler.report( t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName)); } } if (n.getJSType() == null) { n.setJSType(type);"
      },
      {
        "txt": "} } double getTypedPercent() { int total = nullCount + unknownCount + typedCount; if (total == 0) { return 0.0; } else { return (100.0 * typedCount) / total; } }"
      },
      {
        "txt": "private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 685,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 110,
    "end-bug-line": 110,
    "bug": "",
    "fix": "static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = DiagnosticType.warning( \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.UnionType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\";"
      },
      {
        "txt": "static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" +"
      },
      {
        "txt": "\"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\"); <extra_id_0> static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH,"
      },
      {
        "txt": "DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, INTERFACE_METHOD_NOT_IMPLEMENTED); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE);"
      },
      {
        "txt": "} Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE);"
      },
      {
        "txt": "return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); } } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE); } }"
      },
      {
        "txt": "void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes); } }"
      },
      {
        "txt": "void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) &&"
      },
      {
        "txt": "!containsForwardDeclaredUnresolvedName(type)) { if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; } return true; }"
      },
      {
        "txt": "private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type instanceof UnionType) { for (JSType alt : ((UnionType) type).getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } } return type.isNoResolvedType(); }"
      },
      {
        "txt": "void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType); } }"
      },
      {
        "txt": "void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { if (objType.isUnknownType()) { expectStringOrNumber(t, n, indexType, \"property access\"); } else if (objType.toObjectType() != null && objType.toObjectType().getIndexType() != null) { expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(), \"restricted index type\"); } else if (objType.isArrayType()) { expectNumber(t, n, indexType, \"array access\");"
      },
      {
        "txt": "} else if (objType.matchesObjectContext()) { expectString(t, n, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } } boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {"
      },
      {
        "txt": "if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType); } else { mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); } return false; }"
      },
      {
        "txt": "return true; } boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType); } else { mismatch(t, n, msg, rightType, leftType); }"
      },
      {
        "txt": "return false; } return true; } private boolean bothIntrinsics(JSType rightType, JSType leftType) { return (leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()); } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {"
      },
      {
        "txt": "if (!argType.canAssignTo(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) {"
      },
      {
        "txt": "if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType); if (shouldReport) { compiler.report( t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString())); } } }"
      },
      {
        "txt": "void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype(); if (!declaredSuper.equals(superObject)) { if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) { if (shouldReport) { compiler.report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING,"
      },
      {
        "txt": "subObject.toString())); } registerMismatch(superObject, declaredSuper); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject);"
      },
      {
        "txt": "} } } void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) { if (shouldReport) { compiler.report( t.makeError(n, INVALID_CAST,"
      },
      {
        "txt": "castType.toString(), type.toString())); } registerMismatch(type, castType); } } void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) { boolean allowDupe = false; if (n.getType() == Token.GETPROP) { JSDocInfo info = n.getJSDocInfo();"
      },
      {
        "txt": "if (info == null) { info = parent.getJSDocInfo(); } allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null &&"
      },
      {
        "txt": "newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { n.setJSType(varType); if (parent.getType() == Token.VAR) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.getType() == Token.FUNCTION); parent.setJSType(varType);"
      },
      {
        "txt": "} } else { if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) { if (shouldReport) { compiler.report( JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()),"
      },
      {
        "txt": "varType.toString())); } } } } } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) {"
      },
      {
        "txt": "if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) {"
      },
      {
        "txt": "if (!instance.hasProperty(prop)) { String sourceName = (String) n.getProp(Node.SOURCENAME_PROP); sourceName = sourceName == null ? \"\" : sourceName; if (shouldReport) { compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); }"
      },
      {
        "txt": "} private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n,"
      },
      {
        "txt": "String msg, JSType found, JSType required) { registerMismatch(found, required); if (shouldReport) { compiler.report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required))); } } private void registerMismatch(JSType found, JSType required) { found = found.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; } mismatches.add(new TypeMismatch(found, required)); if (found instanceof FunctionType && required instanceof FunctionType) { FunctionType fnTypeA = ((FunctionType) found); FunctionType fnTypeB = ((FunctionType) required); Iterator<Node> paramItA = fnTypeA.getParameters().iterator();"
      },
      {
        "txt": "Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType()); } registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType()); } } private void registerIfMismatch(JSType found, JSType required) { if (found != null && required != null &&"
      },
      {
        "txt": "!found.canAssignTo(required)) { registerMismatch(found, required); } } private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.getType() == Token.GETPROP) {"
      },
      {
        "txt": "ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName;"
      },
      {
        "txt": "} } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } }"
      },
      {
        "txt": "String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName; } else if (type instanceof FunctionType) { return \"function\"; } else {"
      },
      {
        "txt": "return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; }"
      },
      {
        "txt": "} private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } static class TypeMismatch { final JSType typeA; final JSType typeB; TypeMismatch(JSType a, JSType b) { this.typeA = a; this.typeB = b;"
      },
      {
        "txt": "} @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB)) || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB)); } return false; } @Override public int hashCode() {"
      },
      {
        "txt": "return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 686,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 117,
    "end-bug-line": 117,
    "bug": "INTERFACE_METHOD_NOT_IMPLEMENTED);",
    "fix": "INTERFACE_METHOD_NOT_IMPLEMENTED, HIDDEN_INTERFACE_PROPERTY_MISMATCH);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.UnionType;"
      },
      {
        "txt": "import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes; private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList();"
      },
      {
        "txt": "private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + \"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\"); static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" +"
      },
      {
        "txt": "\"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\"); static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\","
      },
      {
        "txt": "static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH, <extra_id_0> TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType("
      },
      {
        "txt": "STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); } Iterable<TypeMismatch> getMismatches() { return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; }"
      },
      {
        "txt": "boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; } return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE);"
      },
      {
        "txt": "} } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, STRING_TYPE); } } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) { mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, allValueTypes); } } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined("
      },
      {
        "txt": "NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false;"
      },
      {
        "txt": "} return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type instanceof UnionType) { for (JSType alt : ((UnionType) type).getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } }"
      },
      {
        "txt": "} return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\","
      },
      {
        "txt": "caseType, switchType); } } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { if (objType.isUnknownType()) { expectStringOrNumber(t, n, indexType, \"property access\"); } else if (objType.toObjectType() != null && objType.toObjectType().getIndexType() != null) { expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(),"
      },
      {
        "txt": "\"restricted index type\"); } else if (objType.isArrayType()) { expectNumber(t, n, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, n, indexType, \"property access\"); } else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } }"
      },
      {
        "txt": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType); } else { mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);"
      },
      {
        "txt": "} return false; } return true; } boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType);"
      },
      {
        "txt": "} else { mismatch(t, n, msg, rightType, leftType); } return false; } return true; } private boolean bothIntrinsics(JSType rightType, JSType leftType) { return (leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType());"
      },
      {
        "txt": "} void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n, String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); }"
      },
      {
        "txt": "} void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType); if (shouldReport) { compiler.report( t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()));"
      },
      {
        "txt": "} } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype(); if (!declaredSuper.equals(superObject)) { if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {"
      },
      {
        "txt": "if (shouldReport) { compiler.report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())); } registerMismatch(superObject, declaredSuper); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper);"
      },
      {
        "txt": "} if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject); } } } void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {"
      },
      {
        "txt": "if (shouldReport) { compiler.report( t.makeError(n, INVALID_CAST, castType.toString(), type.toString())); } registerMismatch(type, castType); } } void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {"
      },
      {
        "txt": "boolean allowDupe = false; if (n.getType() == Token.GETPROP) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo(); } allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType();"
      },
      {
        "txt": "if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) { n.setJSType(varType); if (parent.getType() == Token.VAR) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); }"
      },
      {
        "txt": "} else { Preconditions.checkState(parent.getType() == Token.FUNCTION); parent.setJSType(varType); } } else { if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) { if (shouldReport) { compiler.report("
      },
      {
        "txt": "JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); } } } } } void expectAllInterfaceProperties(NodeTraversal t, Node n,"
      },
      {
        "txt": "FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } }"
      },
      {
        "txt": "} private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { if (!instance.hasProperty(prop)) { String sourceName = (String) n.getProp(Node.SOURCENAME_PROP); sourceName = sourceName == null ? \"\" : sourceName; if (shouldReport) { compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));"
      },
      {
        "txt": "} registerMismatch(instance, implementedInterface); } } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) {"
      },
      {
        "txt": "mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required); if (shouldReport) { compiler.report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required))); }"
      },
      {
        "txt": "} private void registerMismatch(JSType found, JSType required) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; } mismatches.add(new TypeMismatch(found, required)); if (found instanceof FunctionType && required instanceof FunctionType) {"
      },
      {
        "txt": "FunctionType fnTypeA = ((FunctionType) found); FunctionType fnTypeB = ((FunctionType) required); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType()); } registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType()); }"
      },
      {
        "txt": "} private void registerIfMismatch(JSType found, JSType required) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required); } } private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required);"
      },
      {
        "txt": "} String getReadableJSTypeName(Node n, boolean dereference) { if (n.getType() == Token.GETPROP) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } if (objectType != null &&"
      },
      {
        "txt": "(objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } } JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) {"
      },
      {
        "txt": "type = dereferenced; } } String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName;"
      },
      {
        "txt": "} else if (type instanceof FunctionType) { return \"function\"; } else { return type.toString(); } } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); } static class TypeMismatch { final JSType typeA; final JSType typeB;"
      },
      {
        "txt": "TypeMismatch(JSType a, JSType b) { this.typeA = a; this.typeB = b; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object; return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB)) || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB)); }"
      },
      {
        "txt": "return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 687,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 588,
    "end-bug-line": 588,
    "bug": "",
    "fix": "} else { JSType found = instance.getPropertyType(prop); JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (!found.canAssignTo(required)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;"
      },
      {
        "txt": "import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.UnionType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes;"
      },
      {
        "txt": "private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" +"
      },
      {
        "txt": "\"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\");"
      },
      {
        "txt": "static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\");"
      },
      {
        "txt": "static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH,"
      },
      {
        "txt": "INTERFACE_METHOD_NOT_IMPLEMENTED); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); } Iterable<TypeMismatch> getMismatches() {"
      },
      {
        "txt": "return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; }"
      },
      {
        "txt": "return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); } } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE); } } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes); } } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.getType() == Token.GETPROP &&"
      },
      {
        "txt": "!t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; } return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type instanceof UnionType) {"
      },
      {
        "txt": "for (JSType alt : ((UnionType) type).getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } } return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) {"
      },
      {
        "txt": "if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType); } } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) {"
      },
      {
        "txt": "if (objType.isUnknownType()) { expectStringOrNumber(t, n, indexType, \"property access\"); } else if (objType.toObjectType() != null && objType.toObjectType().getIndexType() != null) { expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(), \"restricted index type\"); } else if (objType.isArrayType()) { expectNumber(t, n, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, n, indexType, \"property access\");"
      },
      {
        "txt": "} else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } } boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType);"
      },
      {
        "txt": "} else { mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true; }"
      },
      {
        "txt": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType); } else { mismatch(t, n, msg, rightType, leftType); } return false; }"
      },
      {
        "txt": "return true; } private boolean bothIntrinsics(JSType rightType, JSType leftType) { return (leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()); } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n,"
      },
      {
        "txt": "String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType);"
      },
      {
        "txt": "if (shouldReport) { compiler.report( t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString())); } } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {"
      },
      {
        "txt": "FunctionType subCtor = subObject.getConstructor(); ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype(); if (!declaredSuper.equals(superObject)) { if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) { if (shouldReport) { compiler.report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())); }"
      },
      {
        "txt": "registerMismatch(superObject, declaredSuper); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject); } }"
      },
      {
        "txt": "} void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) { if (shouldReport) { compiler.report( t.makeError(n, INVALID_CAST, castType.toString(), type.toString())); }"
      },
      {
        "txt": "registerMismatch(type, castType); } } void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) { boolean allowDupe = false; if (n.getType() == Token.GETPROP) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo();"
      },
      {
        "txt": "} allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) {"
      },
      {
        "txt": "n.setJSType(varType); if (parent.getType() == Token.VAR) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.getType() == Token.FUNCTION); parent.setJSType(varType); } } else {"
      },
      {
        "txt": "if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) { if (shouldReport) { compiler.report( JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); }"
      },
      {
        "txt": "} } } } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop :"
      },
      {
        "txt": "implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { if (!instance.hasProperty(prop)) { String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);"
      },
      {
        "txt": "if (shouldReport) { compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); <extra_id_0> } } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); }"
      },
      {
        "txt": "mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required); if (shouldReport) {"
      },
      {
        "txt": "compiler.report( JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required))); } } private void registerMismatch(JSType found, JSType required) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return;"
      },
      {
        "txt": "} mismatches.add(new TypeMismatch(found, required)); if (found instanceof FunctionType && required instanceof FunctionType) { FunctionType fnTypeA = ((FunctionType) found); FunctionType fnTypeB = ((FunctionType) required); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(),"
      },
      {
        "txt": "paramItB.next().getJSType()); } registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType()); } } private void registerIfMismatch(JSType found, JSType required) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required); }"
      },
      {
        "txt": "} private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.getType() == Token.GETPROP) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString();"
      },
      {
        "txt": "while (objectType != null && !objectType.hasOwnProperty(propName)) { objectType = objectType.getImplicitPrototype(); } if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } }"
      },
      {
        "txt": "JSType type = getJSType(n); if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null &&"
      },
      {
        "txt": "type.toObjectType().getConstructor() != null)) { return type.toString(); } else if (qualifiedName != null) { return qualifiedName; } else if (type instanceof FunctionType) { return \"function\"; } else { return type.toString(); } }"
      },
      {
        "txt": "private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId);"
      },
      {
        "txt": "} static class TypeMismatch { final JSType typeA; final JSType typeB; TypeMismatch(JSType a, JSType b) { this.typeA = a; this.typeB = b; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) {"
      },
      {
        "txt": "TypeMismatch that = (TypeMismatch) object; return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB)) || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB)); } return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() {"
      },
      {
        "txt": "return \"(\" + typeA + \", \" + typeB + \")\"; } }"
      }
    ]
  },
  {
    "id": 688,
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java",
    "start-bug-line": 589,
    "end-bug-line": 589,
    "bug": "",
    "fix": "if (shouldReport) { FunctionType constructor = implementedInterface.toObjectType().getConstructor(); compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())); } registerMismatch(found, required); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;"
      },
      {
        "txt": "import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.UnionType; import java.text.MessageFormat; import java.util.Iterator; import java.util.List; class TypeValidator { private final AbstractCompiler compiler; private final JSTypeRegistry typeRegistry; private final JSType allValueTypes;"
      },
      {
        "txt": "private boolean shouldReport = true; private final JSType nullOrUndefined; private final List<TypeMismatch> mismatches = Lists.newArrayList(); private static final String FOUND_REQUIRED = \"{0}\\n\" + \"found : {1}\\n\" + \"required: {2}\"; static final DiagnosticType INVALID_CAST = DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" +"
      },
      {
        "txt": "\"from: {0}\\n\" + \"to : {1}\"); static final DiagnosticType TYPE_MISMATCH_WARNING = DiagnosticType.warning( \"JSC_TYPE_MISMATCH\", \"{0}\"); static final DiagnosticType MISSING_EXTENDS_TAG_WARNING = DiagnosticType.warning( \"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\");"
      },
      {
        "txt": "static final DiagnosticType DUP_VAR_DECLARATION = DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\"); static final DiagnosticType HIDDEN_PROPERTY_MISMATCH = DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + \"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\" + \"override: {3}\");"
      },
      {
        "txt": "static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = DiagnosticType.warning( \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\"); static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup( INVALID_CAST, TYPE_MISMATCH_WARNING, MISSING_EXTENDS_TAG_WARNING, DUP_VAR_DECLARATION, HIDDEN_PROPERTY_MISMATCH,"
      },
      {
        "txt": "INTERFACE_METHOD_NOT_IMPLEMENTED); TypeValidator(AbstractCompiler compiler) { this.compiler = compiler; this.typeRegistry = compiler.getTypeRegistry(); this.allValueTypes = typeRegistry.createUnionType( STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); this.nullOrUndefined = typeRegistry.createUnionType( NULL_TYPE, VOID_TYPE); } Iterable<TypeMismatch> getMismatches() {"
      },
      {
        "txt": "return mismatches; } void setShouldReport(boolean report) { this.shouldReport = report; } boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesObjectContext()) { mismatch(t, n, msg, type, OBJECT_TYPE); return false; }"
      },
      {
        "txt": "return true; } void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { if (!type.isObject()) { mismatch(t, n, msg, type, OBJECT_TYPE); } } void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, anyObjectType); } } void expectString(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesStringContext()) { mismatch(t, n, msg, type, STRING_TYPE); } } void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext()) {"
      },
      {
        "txt": "mismatch(t, n, msg, type, NUMBER_TYPE); } } void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { mismatch(t, n, msg, type, allValueTypes); } } void expectStringOrNumber( NodeTraversal t, Node n, JSType type, String msg) {"
      },
      {
        "txt": "if (!type.matchesNumberContext() && !type.matchesStringContext()) { mismatch(t, n, msg, type, NUMBER_STRING); } } boolean expectNotNullOrUndefined( NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { if (n.getType() == Token.GETPROP &&"
      },
      {
        "txt": "!t.inGlobalScope() && type.isNullType()) { return true; } mismatch(t, n, msg, type, expectedType); return false; } return true; } private boolean containsForwardDeclaredUnresolvedName(JSType type) { if (type instanceof UnionType) {"
      },
      {
        "txt": "for (JSType alt : ((UnionType) type).getAlternates()) { if (containsForwardDeclaredUnresolvedName(alt)) { return true; } } } return type.isNoResolvedType(); } void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) {"
      },
      {
        "txt": "if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType); } } void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) {"
      },
      {
        "txt": "if (objType.isUnknownType()) { expectStringOrNumber(t, n, indexType, \"property access\"); } else if (objType.toObjectType() != null && objType.toObjectType().getIndexType() != null) { expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(), \"restricted index type\"); } else if (objType.isArrayType()) { expectNumber(t, n, indexType, \"array access\"); } else if (objType.matchesObjectContext()) { expectString(t, n, indexType, \"property access\");"
      },
      {
        "txt": "} else { mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } } boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType);"
      },
      {
        "txt": "} else { mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true; }"
      },
      {
        "txt": "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if (bothIntrinsics(rightType, leftType)) { registerMismatch(rightType, leftType); } else { mismatch(t, n, msg, rightType, leftType); } return false; }"
      },
      {
        "txt": "return true; } private boolean bothIntrinsics(JSType rightType, JSType leftType) { return (leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()); } void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { if (!argType.canAssignTo(paramType)) { mismatch(t, n,"
      },
      {
        "txt": "String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); } } void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { if (!overridingType.canAssignTo(hiddenType)) { registerMismatch(overridingType, hiddenType);"
      },
      {
        "txt": "if (shouldReport) { compiler.report( t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString())); } } } void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {"
      },
      {
        "txt": "FunctionType subCtor = subObject.getConstructor(); ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype(); if (!declaredSuper.equals(superObject)) { if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) { if (shouldReport) { compiler.report( t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())); }"
      },
      {
        "txt": "registerMismatch(superObject, declaredSuper); } else { mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject); } }"
      },
      {
        "txt": "} void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) { castType = castType.restrictByNotNullOrUndefined(); type = type.restrictByNotNullOrUndefined(); if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) { if (shouldReport) { compiler.report( t.makeError(n, INVALID_CAST, castType.toString(), type.toString())); }"
      },
      {
        "txt": "registerMismatch(type, castType); } } void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) { boolean allowDupe = false; if (n.getType() == Token.GETPROP) { JSDocInfo info = n.getJSDocInfo(); if (info == null) { info = parent.getJSDocInfo();"
      },
      {
        "txt": "} allowDupe = info != null && info.getSuppressions().contains(\"duplicate\"); } JSType varType = var.getType(); if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { if (var.input == null) {"
      },
      {
        "txt": "n.setJSType(varType); if (parent.getType() == Token.VAR) { if (n.getFirstChild() != null) { n.getFirstChild().setJSType(varType); } } else { Preconditions.checkState(parent.getType() == Token.FUNCTION); parent.setJSType(varType); } } else {"
      },
      {
        "txt": "if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) { if (shouldReport) { compiler.report( JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); }"
      },
      {
        "txt": "} } } } void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { ObjectType instance = type.getInstanceType(); for (ObjectType implemented : type.getAllImplementedInterfaces()) { if (implemented.getImplicitPrototype() != null) { for (String prop :"
      },
      {
        "txt": "implemented.getImplicitPrototype().getOwnPropertyNames()) { expectInterfaceProperty(t, n, instance, implemented, prop); } } } } private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { if (!instance.hasProperty(prop)) { String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);"
      },
      {
        "txt": "if (shouldReport) { compiler.report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString())); } registerMismatch(instance, implementedInterface); <extra_id_0> } private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { mismatch(t.getSourceName(), n, msg, found, required); } private void mismatch(NodeTraversal t, Node n,"
      },
      {
        "txt": "} private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { mismatch(t, n, msg, found, getNativeType(required)); } private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { registerMismatch(found, required); if (shouldReport) { compiler.report("
      },
      {
        "txt": "JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required))); } } private void registerMismatch(JSType found, JSType required) { found = found.restrictByNotNullOrUndefined(); required = required.restrictByNotNullOrUndefined(); if (found.canAssignTo(required) || required.canAssignTo(found)) { return; }"
      },
      {
        "txt": "mismatches.add(new TypeMismatch(found, required)); if (found instanceof FunctionType && required instanceof FunctionType) { FunctionType fnTypeA = ((FunctionType) found); FunctionType fnTypeB = ((FunctionType) required); Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); while (paramItA.hasNext() && paramItB.hasNext()) { registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType());"
      },
      {
        "txt": "} registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType()); } } private void registerIfMismatch(JSType found, JSType required) { if (found != null && required != null && !found.canAssignTo(required)) { registerMismatch(found, required); } }"
      },
      {
        "txt": "private String formatFoundRequired(String description, JSType found, JSType required) { return MessageFormat.format(FOUND_REQUIRED, description, found, required); } String getReadableJSTypeName(Node n, boolean dereference) { if (n.getType() == Token.GETPROP) { ObjectType objectType = getJSType(n.getFirstChild()).dereference(); if (objectType != null) { String propName = n.getLastChild().getString(); while (objectType != null && !objectType.hasOwnProperty(propName)) {"
      },
      {
        "txt": "objectType = objectType.getImplicitPrototype(); } if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { return objectType.toString() + \".\" + propName; } } } JSType type = getJSType(n);"
      },
      {
        "txt": "if (dereference) { ObjectType dereferenced = type.dereference(); if (dereferenced != null) { type = dereferenced; } } String qualifiedName = n.getQualifiedName(); if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {"
      },
      {
        "txt": "return type.toString(); } else if (qualifiedName != null) { return qualifiedName; } else if (type instanceof FunctionType) { return \"function\"; } else { return type.toString(); } } private JSType getJSType(Node n) {"
      },
      {
        "txt": "JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return typeRegistry.getNativeType(typeId); }"
      },
      {
        "txt": "static class TypeMismatch { final JSType typeA; final JSType typeB; TypeMismatch(JSType a, JSType b) { this.typeA = a; this.typeB = b; } @Override public boolean equals(Object object) { if (object instanceof TypeMismatch) { TypeMismatch that = (TypeMismatch) object;"
      },
      {
        "txt": "return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB)) || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB)); } return false; } @Override public int hashCode() { return Objects.hashCode(typeA, typeB); } @Override public String toString() { return \"(\" + typeA + \", \" + typeB + \")\";"
      },
      {
        "txt": "} }"
      }
    ]
  }
]