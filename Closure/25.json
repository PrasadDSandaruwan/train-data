[
  {
    "id": 248,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 1036,
    "end-bug-line": 1036,
    "bug": "",
    "fix": "scope = traverseChildren(n, scope);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;"
      },
      {
        "txt": "import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.List; import java.util.Map; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {"
      },
      {
        "txt": "static final DiagnosticType TEMPLATE_TYPE_NOT_OBJECT_TYPE = DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\", \"The template type must be an object type.\\nActual: {0}\"); static final DiagnosticType TEMPLATE_TYPE_OF_THIS_EXPECTED = DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED\", \"A function type with the template type as the type of this must be a \" + \"parameter type\"); static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;"
      },
      {
        "txt": "TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.syntacticScope = functionScope; this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);"
      },
      {
        "txt": "this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE));"
      },
      {
        "txt": "} this.bottomScope = LinkedFlowScope.createEntryLattice( new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis())); } @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() {"
      },
      {
        "txt": "return functionScope; } @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output;"
      },
      {
        "txt": "} @Override @SuppressWarnings(\"fallthrough\") List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());"
      },
      {
        "txt": "for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) {"
      },
      {
        "txt": "item = item.getFirstChild(); } if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getIndexType(); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);"
      },
      {
        "txt": "if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE:"
      },
      {
        "txt": "if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } }"
      },
      {
        "txt": "if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "condition, conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope ="
      },
      {
        "txt": "reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result; }"
      },
      {
        "txt": "private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope);"
      },
      {
        "txt": "break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK:"
      },
      {
        "txt": "scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope);"
      },
      {
        "txt": "break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break;"
      },
      {
        "txt": "case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH:"
      },
      {
        "txt": "case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV:"
      },
      {
        "txt": "case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope);"
      },
      {
        "txt": "n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break;"
      },
      {
        "txt": "case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT:"
      },
      {
        "txt": "case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM:"
      },
      {
        "txt": "scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope);"
      },
      {
        "txt": "break; case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope);"
      },
      {
        "txt": "break; } if (!n.isFunction()) { JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { JSType castType = info.getType().evaluate(syntacticScope, registry); if (n.isQualifiedName() && n.getParent().isExprResult()) { updateScopeForTypeChange(scope, n, n.getJSType(), castType); }"
      },
      {
        "txt": "n.setJSType(castType); } } return scope; } private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType();"
      },
      {
        "txt": "if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType()); } } } return scope; }"
      },
      {
        "txt": "private FlowScope traverseCatch(Node n, FlowScope scope) { Node name = n.getFirstChild(); JSType type = getNativeType(JSTypeNative.UNKNOWN_TYPE); name.setJSType(type); redeclareSimpleVar(scope, name, type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = n.getLastChild();"
      },
      {
        "txt": "scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType);"
      },
      {
        "txt": "switch (left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); if (!isVarDeclaration || var == null || var.isTypeInferred()) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null);"
      },
      {
        "txt": "if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) { scope.inferQualifiedSlot(left, qualifiedName,"
      },
      {
        "txt": "leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) { String propName = getprop.getLastChild().getString();"
      },
      {
        "txt": "JSType nodeType = getJSType(getprop.getFirstChild()); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else { if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) {"
      },
      {
        "txt": "if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty( propName, rightType, getprop); } else { objectType.defineInferredProperty( propName, rightType, getprop); } } else {"
      },
      {
        "txt": "if (getprop.getFirstChild().isThis() && getJSType(syntacticScope.getRootNode()).isConstructor()) { objectType.defineInferredProperty( propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType); } } } }"
      },
      {
        "txt": "} private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); } } private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) {"
      },
      {
        "txt": "String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty("
      },
      {
        "txt": "propName, var.getType(), getprop); } } } return false; } private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType();"
      },
      {
        "txt": "if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred &&"
      },
      {
        "txt": "isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); }"
      },
      {
        "txt": "} } } n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope;"
      },
      {
        "txt": "} private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope;"
      },
      {
        "txt": "} boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {"
      },
      {
        "txt": "Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = getNativeType(UNKNOWN_TYPE); } objectType.defineInferredProperty(memberName, valueType, name);"
      },
      {
        "txt": "if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType,"
      },
      {
        "txt": "valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } } return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild();"
      },
      {
        "txt": "Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = getNativeType(UNKNOWN_TYPE); if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE); } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); }"
      },
      {
        "txt": "} n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; } private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE));"
      },
      {
        "txt": "} private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter."
      },
      {
        "txt": "getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null);"
      },
      {
        "txt": "} return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType != null) { if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType();"
      },
      {
        "txt": "n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } } scope = tightenTypesAfterAssertions(scope, n); return scope; } private FlowScope tightenTypesAfterAssertions(FlowScope scope,"
      },
      {
        "txt": "Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) {"
      },
      {
        "txt": "return scope; } JSTypeNative assertedType = assertionFunctionSpec.getAssertedType(); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else {"
      },
      {
        "txt": "JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(getNativeType(assertedType)); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } if (getJSType(callNode).differsFrom(narrowed)) { callNode.setJSType(narrowed); } return scope;"
      },
      {
        "txt": "} private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed); } else {"
      },
      {
        "txt": "redeclareSimpleVar(scope, node, narrowed); } return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { updateTypeOfParameters(n, fnType); updateTypeOfThisOnClosure(n, fnType); updateBind(n, fnType); } private void updateBind(Node n, FunctionType fnType) {"
      },
      {
        "txt": "CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; }"
      },
      {
        "txt": "n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return;"
      },
      {
        "txt": "} JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); if (iParameterType.isFunctionType()) { FunctionType iParameterFnType = iParameterType.toMaybeFunctionType(); if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) {"
      },
      {
        "txt": "iArgument.setJSType(iParameterFnType); } } i++; } } private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) { if (fnType.getTemplateTypeName() == null) { return; }"
      },
      {
        "txt": "int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { JSType iParameterType = getJSType(iParameter).restrictByNotNullOrUndefined(); if (iParameterType.isTemplateType()) { ObjectType iArgumentType = null; if (i + 1 < childCount) { Node iArgument = n.getChildAtIndex(i + 1); iArgumentType = getJSType(iArgument)"
      },
      {
        "txt": ".restrictByNotNullOrUndefined() .collapseUnion() .toObjectType(); if (iArgumentType == null) { compiler.report( JSError.make(NodeUtil.getSourceName(iArgument), iArgument, TEMPLATE_TYPE_NOT_OBJECT_TYPE, getJSType(iArgument).toString())); return; }"
      },
      {
        "txt": "} boolean foundTemplateTypeOfThisParameter = false; int j = 0; for (Node jParameter : fnType.getParameters()) { JSType jParameterType = getJSType(jParameter).restrictByNotNullOrUndefined(); if (jParameterType.isFunctionType()) { FunctionType jParameterFnType = jParameterType.toMaybeFunctionType(); if (jParameterFnType.getTypeOfThis().equals(iParameterType)) { foundTemplateTypeOfThisParameter = true;"
      },
      {
        "txt": "if (j + 1 >= childCount) { return; } Node jArgument = n.getChildAtIndex(j + 1); JSType jArgumentType = getJSType(jArgument); if (jArgument.isFunction() && jArgumentType.isFunctionType()) { if (iArgumentType != null && !iArgumentType.isNoType()) { FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType();"
      },
      {
        "txt": "if (jArgumentFnType.getTypeOfThis().isUnknownType()) { jArgument.setJSType( registry.createFunctionTypeWithNewThisType( jArgumentFnType, iArgumentType)); } } else { if (NodeUtil.referencesThis( NodeUtil.getFunctionBody(jArgument))) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, FUNCTION_LITERAL_UNDEFINED_THIS));"
      },
      {
        "txt": "} } } } } j++; } if (!foundTemplateTypeOfThisParameter) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, TEMPLATE_TYPE_OF_THIS_EXPECTED));"
      },
      {
        "txt": "} } i++; } } private FlowScope traverseNew(Node n, FlowScope scope) { <extra_id_0> Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) {"
      },
      {
        "txt": "type = ct.getInstanceType(); } } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; }"
      },
      {
        "txt": "private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; } private FlowScope traverseGetElem(Node n, FlowScope scope) {"
      },
      {
        "txt": "scope = traverseChildren(n, scope); ObjectType objType = ObjectType.cast( getJSType(n.getFirstChild()).restrictByNotNullOrUndefined()); if (objType != null) { JSType type = objType.getParameterType(); if (type != null) { n.setJSType(type); } } return dereferencePointer(n.getFirstChild(), scope);"
      },
      {
        "txt": "} private FlowScope traverseGetProp(Node n, FlowScope scope) { Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); }"
      },
      {
        "txt": "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null) { type.matchConstraint(constraintObj); }"
      },
      {
        "txt": "} private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) { scope = narrowScope(scope, n, narrowed); } } return scope;"
      },
      {
        "txt": "} private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { if (varType.equals(getNativeType(UNKNOWN_TYPE)) && var != syntacticScope.getSlot(qualifiedName)) {"
      },
      {
        "txt": "return getNativeType(CHECKED_UNKNOWN_TYPE); } else { return varType; } } } JSType propertyType = null; if (objType != null) { propertyType = objType.findPropertyType(propName); }"
      },
      {
        "txt": "if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor(); } } return propertyType; } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) {"
      },
      {
        "txt": "return traverseShortCircuitingBinOp(n, scope, false); } private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType();"
      },
      {
        "txt": "FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals;"
      },
      {
        "txt": "if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else { type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition);"
      },
      {
        "txt": "} if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); } } } else { type = null;"
      },
      {
        "txt": "literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.AND: return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); } }"
      },
      {
        "txt": "BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {"
      },
      {
        "txt": "return right.union(left.intersection(BooleanLiteralSet.get(!condition))); } private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues,"
      },
      {
        "txt": "FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes; this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope;"
      },
      {
        "txt": "} else { joinedScope = join(leftScope, rightScope); } } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope;"
      },
      {
        "txt": "} else { return getJoinedFlowScope(); } } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope);"
      },
      {
        "txt": "} return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString();"
      },
      {
        "txt": "if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); } if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() &&"
      },
      {
        "txt": "v.getScope() == syntacticScope; } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } }"
      },
      {
        "txt": "private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 249,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 1038,
    "end-bug-line": 1038,
    "bug": "scope = traverse(constructor, scope);",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch;"
      },
      {
        "txt": "import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.List; import java.util.Map; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType TEMPLATE_TYPE_NOT_OBJECT_TYPE ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\", \"The template type must be an object type.\\nActual: {0}\"); static final DiagnosticType TEMPLATE_TYPE_OF_THIS_EXPECTED = DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED\", \"A function type with the template type as the type of this must be a \" + \"parameter type\"); static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning("
      },
      {
        "txt": "\"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,"
      },
      {
        "txt": "ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.syntacticScope = functionScope; this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap;"
      },
      {
        "txt": "Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE)); }"
      },
      {
        "txt": "this.bottomScope = LinkedFlowScope.createEntryLattice( new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis())); } @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() { return functionScope;"
      },
      {
        "txt": "} @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output; }"
      },
      {
        "txt": "@Override @SuppressWarnings(\"fallthrough\") List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {"
      },
      {
        "txt": "Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild();"
      },
      {
        "txt": "} if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getIndexType(); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) {"
      },
      {
        "txt": "iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE: if (condition == null) {"
      },
      {
        "txt": "condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } } if (condition != null) {"
      },
      {
        "txt": "if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition,"
      },
      {
        "txt": "conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result; } private FlowScope traverse(Node n, FlowScope scope) {"
      },
      {
        "txt": "switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope); break;"
      },
      {
        "txt": "case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope);"
      },
      {
        "txt": "break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break;"
      },
      {
        "txt": "case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.ARRAYLIT:"
      },
      {
        "txt": "scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH:"
      },
      {
        "txt": "case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD:"
      },
      {
        "txt": "case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE));"
      },
      {
        "txt": "break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break; case Token.TYPEOF:"
      },
      {
        "txt": "scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT: case Token.EQ:"
      },
      {
        "txt": "case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM: scope = traverseGetElem(n, scope);"
      },
      {
        "txt": "break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope); break;"
      },
      {
        "txt": "case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope); break;"
      },
      {
        "txt": "} if (!n.isFunction()) { JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { JSType castType = info.getType().evaluate(syntacticScope, registry); if (n.isQualifiedName() && n.getParent().isExprResult()) { updateScopeForTypeChange(scope, n, n.getJSType(), castType); } n.setJSType(castType);"
      },
      {
        "txt": "} } return scope; } private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) {"
      },
      {
        "txt": "FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType()); } } } return scope; } private FlowScope traverseCatch(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node name = n.getFirstChild(); JSType type = getNativeType(JSTypeNative.UNKNOWN_TYPE); name.setJSType(type); redeclareSimpleVar(scope, name, type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = n.getLastChild(); scope = traverseChildren(n, scope);"
      },
      {
        "txt": "JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType); switch (left.getType()) {"
      },
      {
        "txt": "case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); if (!isVarDeclaration || var == null || var.isTypeInferred()) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) {"
      },
      {
        "txt": "JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) { scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,"
      },
      {
        "txt": "resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) { String propName = getprop.getLastChild().getString(); JSType nodeType = getJSType(getprop.getFirstChild());"
      },
      {
        "txt": "ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else { if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) { if (objectType.hasProperty(propName) ||"
      },
      {
        "txt": "!objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty( propName, rightType, getprop); } else { objectType.defineInferredProperty( propName, rightType, getprop); } } else { if (getprop.getFirstChild().isThis() &&"
      },
      {
        "txt": "getJSType(syntacticScope.getRootNode()).isConstructor()) { objectType.defineInferredProperty( propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType); } } } } }"
      },
      {
        "txt": "private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); } } private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString();"
      },
      {
        "txt": "String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty( propName, var.getType(), getprop);"
      },
      {
        "txt": "} } } return false; } private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType(); if (value != null) {"
      },
      {
        "txt": "scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName));"
      },
      {
        "txt": "boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); } }"
      },
      {
        "txt": "} } n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope; }"
      },
      {
        "txt": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; }"
      },
      {
        "txt": "boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild();"
      },
      {
        "txt": "String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = getNativeType(UNKNOWN_TYPE); } objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) {"
      },
      {
        "txt": "String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType);"
      },
      {
        "txt": "} } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } } return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = left.getNext();"
      },
      {
        "txt": "scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = getNativeType(UNKNOWN_TYPE); if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE); } else if ((!leftIsUnknown && leftType.isString()) ||"
      },
      {
        "txt": "(!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE); } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); } }"
      },
      {
        "txt": "n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; } private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); }"
      },
      {
        "txt": "private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null); }"
      },
      {
        "txt": "return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType != null) { if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType());"
      },
      {
        "txt": "backwardsInferenceFromCallSite(n, fnType); } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } } scope = tightenTypesAfterAssertions(scope, n); return scope; } private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {"
      },
      {
        "txt": "Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope;"
      },
      {
        "txt": "} JSTypeNative assertedType = assertionFunctionSpec.getAssertedType(); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else { JSType type = getJSType(assertedNode);"
      },
      {
        "txt": "narrowed = type.getGreatestSubtype(getNativeType(assertedType)); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } if (getJSType(callNode).differsFrom(narrowed)) { callNode.setJSType(narrowed); } return scope; }"
      },
      {
        "txt": "private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed); } else { redeclareSimpleVar(scope, node, narrowed);"
      },
      {
        "txt": "} return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { updateTypeOfParameters(n, fnType); updateTypeOfThisOnClosure(n, fnType); updateBind(n, fnType); } private void updateBind(Node n, FunctionType fnType) { CodingConvention.Bind bind ="
      },
      {
        "txt": "compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; } n.setJSType("
      },
      {
        "txt": "callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return; }"
      },
      {
        "txt": "JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); if (iParameterType.isFunctionType()) { FunctionType iParameterFnType = iParameterType.toMaybeFunctionType(); if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { iArgument.setJSType(iParameterFnType);"
      },
      {
        "txt": "} } i++; } } private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) { if (fnType.getTemplateTypeName() == null) { return; } int i = 0;"
      },
      {
        "txt": "int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { JSType iParameterType = getJSType(iParameter).restrictByNotNullOrUndefined(); if (iParameterType.isTemplateType()) { ObjectType iArgumentType = null; if (i + 1 < childCount) { Node iArgument = n.getChildAtIndex(i + 1); iArgumentType = getJSType(iArgument) .restrictByNotNullOrUndefined()"
      },
      {
        "txt": ".collapseUnion() .toObjectType(); if (iArgumentType == null) { compiler.report( JSError.make(NodeUtil.getSourceName(iArgument), iArgument, TEMPLATE_TYPE_NOT_OBJECT_TYPE, getJSType(iArgument).toString())); return; } }"
      },
      {
        "txt": "boolean foundTemplateTypeOfThisParameter = false; int j = 0; for (Node jParameter : fnType.getParameters()) { JSType jParameterType = getJSType(jParameter).restrictByNotNullOrUndefined(); if (jParameterType.isFunctionType()) { FunctionType jParameterFnType = jParameterType.toMaybeFunctionType(); if (jParameterFnType.getTypeOfThis().equals(iParameterType)) { foundTemplateTypeOfThisParameter = true; if (j + 1 >= childCount) {"
      },
      {
        "txt": "return; } Node jArgument = n.getChildAtIndex(j + 1); JSType jArgumentType = getJSType(jArgument); if (jArgument.isFunction() && jArgumentType.isFunctionType()) { if (iArgumentType != null && !iArgumentType.isNoType()) { FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType(); if (jArgumentFnType.getTypeOfThis().isUnknownType()) {"
      },
      {
        "txt": "jArgument.setJSType( registry.createFunctionTypeWithNewThisType( jArgumentFnType, iArgumentType)); } } else { if (NodeUtil.referencesThis( NodeUtil.getFunctionBody(jArgument))) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, FUNCTION_LITERAL_UNDEFINED_THIS)); }"
      },
      {
        "txt": "} } } } j++; } if (!foundTemplateTypeOfThisParameter) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, TEMPLATE_TYPE_OF_THIS_EXPECTED)); return;"
      },
      {
        "txt": "} i++; } } private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); <extra_id_0> JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); }"
      },
      {
        "txt": "} } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); } return scope; } private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true);"
      },
      {
        "txt": "} private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; } private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); ObjectType objType = ObjectType.cast("
      },
      {
        "txt": "getJSType(n.getFirstChild()).restrictByNotNullOrUndefined()); if (objType != null) { JSType type = objType.getParameterType(); if (type != null) { n.setJSType(type); } } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) {"
      },
      {
        "txt": "if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null) { type.matchConstraint(constraintObj); } } private FlowScope dereferencePointer(Node n, FlowScope scope) {"
      },
      {
        "txt": "if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) { scope = narrowScope(scope, n, narrowed); } } return scope; } private JSType getPropertyType(JSType objType, String propName,"
      },
      {
        "txt": "Node n, FlowScope scope) { String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { if (varType.equals(getNativeType(UNKNOWN_TYPE)) && var != syntacticScope.getSlot(qualifiedName)) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else {"
      },
      {
        "txt": "return varType; } } } JSType propertyType = null; if (objType != null) { propertyType = objType.findPropertyType(propName); } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) {"
      },
      {
        "txt": "ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor(); } } return propertyType; } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); }"
      },
      {
        "txt": "private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition);"
      },
      {
        "txt": "if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else { type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY &&"
      },
      {
        "txt": "getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); } } } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH,"
      },
      {
        "txt": "leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND:"
      },
      {
        "txt": "return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) {"
      },
      {
        "txt": "return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); }"
      },
      {
        "txt": "private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes;"
      },
      {
        "txt": "this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope);"
      },
      {
        "txt": "} } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope();"
      },
      {
        "txt": "} } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(),"
      },
      {
        "txt": "registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; }"
      },
      {
        "txt": "private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId);"
      }
    ]
  },
  {
    "id": 250,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 1055,
    "end-bug-line": 1055,
    "bug": "",
    "fix": "backwardsInferenceFromCallSite(n, ct);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Map; class TypeInference extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType TEMPLATE_TYPE_NOT_OBJECT_TYPE = DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\", \"The template type must be an object type.\\nActual: {0}\"); static final DiagnosticType TEMPLATE_TYPE_OF_THIS_EXPECTED ="
      },
      {
        "txt": "DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED\", \"A function type with the template type as the type of this must be a \" + \"parameter type\"); static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry;"
      },
      {
        "txt": "private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope; private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp());"
      },
      {
        "txt": "this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.syntacticScope = functionScope; this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next();"
      },
      {
        "txt": "if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType( var.getName(), getNativeType(VOID_TYPE)); } this.bottomScope = LinkedFlowScope.createEntryLattice( new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis())); } @Override"
      },
      {
        "txt": "FlowScope createInitialEstimateLattice() { return bottomScope; } @Override FlowScope createEntryLattice() { return functionScope; } @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) {"
      },
      {
        "txt": "return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output); return output; } @Override @SuppressWarnings(\"fallthrough\") List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input);"
      },
      {
        "txt": "Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE:"
      },
      {
        "txt": "if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild(); } if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference();"
      },
      {
        "txt": "JSType objIndexType = objType == null ? null : objType.getIndexType(); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType);"
      },
      {
        "txt": "} newScope = informed; break; } case ON_FALSE: if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) {"
      },
      {
        "txt": "conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } } } if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ?"
      },
      {
        "txt": "traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else {"
      },
      {
        "txt": "if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break;"
      },
      {
        "txt": "} result.add(newScope.optimize()); } return result; } private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break;"
      },
      {
        "txt": "case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope); break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break;"
      },
      {
        "txt": "case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break;"
      },
      {
        "txt": "case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break;"
      },
      {
        "txt": "case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis());"
      },
      {
        "txt": "break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND:"
      },
      {
        "txt": "case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL:"
      },
      {
        "txt": "case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild()));"
      },
      {
        "txt": "break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break; case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP:"
      },
      {
        "txt": "case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF:"
      },
      {
        "txt": "case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM: scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) {"
      },
      {
        "txt": "ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope); break; case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR:"
      },
      {
        "txt": "case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope); break; } if (!n.isFunction()) { JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) {"
      },
      {
        "txt": "JSType castType = info.getType().evaluate(syntacticScope, registry); if (n.isQualifiedName() && n.getParent().isExprResult()) { updateScopeForTypeChange(scope, n, n.getJSType(), castType); } n.setJSType(castType); } } return scope; }"
      },
      {
        "txt": "private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) { JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType());"
      },
      {
        "txt": "} } } return scope; } private FlowScope traverseCatch(Node n, FlowScope scope) { Node name = n.getFirstChild(); JSType type = getNativeType(JSTypeNative.UNKNOWN_TYPE); name.setJSType(type); redeclareSimpleVar(scope, name, type);"
      },
      {
        "txt": "return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = n.getLastChild(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType);"
      },
      {
        "txt": "return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType); switch (left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren();"
      },
      {
        "txt": "if (!isVarDeclaration || var == null || var.isTypeInferred()) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); }"
      },
      {
        "txt": "break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) { scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType);"
      },
      {
        "txt": "break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) { String propName = getprop.getLastChild().getString(); JSType nodeType = getJSType(getprop.getFirstChild()); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType);"
      },
      {
        "txt": "} else { if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; } if (!objectType.isPropertyTypeDeclared(propName)) { if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty( propName, rightType, getprop);"
      },
      {
        "txt": "} else { objectType.defineInferredProperty( propName, rightType, getprop); } } else { if (getprop.getFirstChild().isThis() && getJSType(syntacticScope.getRootNode()).isConstructor()) { objectType.defineInferredProperty( propName, rightType, getprop); } else {"
      },
      {
        "txt": "registry.registerPropertyOnType(propName, objectType); } } } } } private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) {"
      },
      {
        "txt": "ensurePropertyDeclaredHelper(getprop, ownerType); } } private boolean ensurePropertyDeclaredHelper( Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) {"
      },
      {
        "txt": "if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { return objectType.defineDeclaredProperty( propName, var.getType(), getprop); } } } return false;"
      },
      {
        "txt": "} private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild(); JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope;"
      },
      {
        "txt": "} else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred(); boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName);"
      },
      {
        "txt": "if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE); } } } } n.setJSType(type); return scope;"
      },
      {
        "txt": "} private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE)); return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {"
      },
      {
        "txt": "scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null) { return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope;"
      },
      {
        "txt": "} String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType("
      },
      {
        "txt": "name, rawValueType); if (valueType == null) { valueType = getNativeType(UNKNOWN_TYPE); } objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) {"
      },
      {
        "txt": "var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName, oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); }"
      },
      {
        "txt": "} return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) { Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE); } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); } } n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); }"
      },
      {
        "txt": "return scope; } private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild();"
      },
      {
        "txt": "scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true); FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType();"
      },
      {
        "txt": "JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else { n.setJSType(null); } return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope);"
      },
      {
        "txt": "Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType != null) { if (functionType.isFunctionType()) { FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); }"
      },
      {
        "txt": "} scope = tightenTypesAfterAssertions(scope, n); return scope; } private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName());"
      },
      {
        "txt": "if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope; } JSTypeNative assertedType = assertionFunctionSpec.getAssertedType(); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed;"
      },
      {
        "txt": "if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); } else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(getNativeType(assertedType)); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); }"
      },
      {
        "txt": "} if (getJSType(callNode).differsFrom(narrowed)) { callNode.setJSType(narrowed); } return scope; } private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; }"
      },
      {
        "txt": "scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed); } else { redeclareSimpleVar(scope, node, narrowed); } return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {"
      },
      {
        "txt": "updateTypeOfParameters(n, fnType); updateTypeOfThisOnClosure(n, fnType); updateBind(n, fnType); } private void updateBind(Node n, FunctionType fnType) { CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; }"
      },
      {
        "txt": "FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return; } n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) {"
      },
      {
        "txt": "int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) { return; } JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);"
      },
      {
        "txt": "if (iParameterType.isFunctionType()) { FunctionType iParameterFnType = iParameterType.toMaybeFunctionType(); if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { iArgument.setJSType(iParameterFnType); } } i++; }"
      },
      {
        "txt": "} private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) { if (fnType.getTemplateTypeName() == null) { return; } int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { JSType iParameterType = getJSType(iParameter).restrictByNotNullOrUndefined();"
      },
      {
        "txt": "if (iParameterType.isTemplateType()) { ObjectType iArgumentType = null; if (i + 1 < childCount) { Node iArgument = n.getChildAtIndex(i + 1); iArgumentType = getJSType(iArgument) .restrictByNotNullOrUndefined() .collapseUnion() .toObjectType(); if (iArgumentType == null) { compiler.report("
      },
      {
        "txt": "JSError.make(NodeUtil.getSourceName(iArgument), iArgument, TEMPLATE_TYPE_NOT_OBJECT_TYPE, getJSType(iArgument).toString())); return; } } boolean foundTemplateTypeOfThisParameter = false; int j = 0; for (Node jParameter : fnType.getParameters()) { JSType jParameterType ="
      },
      {
        "txt": "getJSType(jParameter).restrictByNotNullOrUndefined(); if (jParameterType.isFunctionType()) { FunctionType jParameterFnType = jParameterType.toMaybeFunctionType(); if (jParameterFnType.getTypeOfThis().equals(iParameterType)) { foundTemplateTypeOfThisParameter = true; if (j + 1 >= childCount) { return; } Node jArgument = n.getChildAtIndex(j + 1); JSType jArgumentType = getJSType(jArgument);"
      },
      {
        "txt": "if (jArgument.isFunction() && jArgumentType.isFunctionType()) { if (iArgumentType != null && !iArgumentType.isNoType()) { FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType(); if (jArgumentFnType.getTypeOfThis().isUnknownType()) { jArgument.setJSType( registry.createFunctionTypeWithNewThisType( jArgumentFnType, iArgumentType)); }"
      },
      {
        "txt": "} else { if (NodeUtil.referencesThis( NodeUtil.getFunctionBody(jArgument))) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, FUNCTION_LITERAL_UNDEFINED_THIS)); } } } } }"
      },
      {
        "txt": "j++; } if (!foundTemplateTypeOfThisParameter) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, TEMPLATE_TYPE_OF_THIS_EXPECTED)); return; } } i++; }"
      },
      {
        "txt": "} private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope); JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType; } if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); <extra_id_0> } } n.setJSType(type); for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); }"
      },
      {
        "txt": "scope = traverse(arg, scope); } return scope; } private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope);"
      },
      {
        "txt": "} return scope; } private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); ObjectType objType = ObjectType.cast( getJSType(n.getFirstChild()).restrictByNotNullOrUndefined()); if (objType != null) { JSType type = objType.getParameterType(); if (type != null) {"
      },
      {
        "txt": "n.setJSType(type); } } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) { Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType("
      },
      {
        "txt": "getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj ="
      },
      {
        "txt": "ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null) { type.matchConstraint(constraintObj); } } private FlowScope dereferencePointer(Node n, FlowScope scope) { if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) {"
      },
      {
        "txt": "scope = narrowScope(scope, n, narrowed); } } return scope; } private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) {"
      },
      {
        "txt": "JSType varType = var.getType(); if (varType != null) { if (varType.equals(getNativeType(UNKNOWN_TYPE)) && var != syntacticScope.getSlot(qualifiedName)) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else { return varType; } } }"
      },
      {
        "txt": "JSType propertyType = null; if (objType != null) { propertyType = objType.findPropertyType(propName); } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor(); }"
      },
      {
        "txt": "} return propertyType; } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); } private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild();"
      },
      {
        "txt": "BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp("
      },
      {
        "txt": "right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals;"
      },
      {
        "txt": "} else { type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE));"
      },
      {
        "txt": "} } } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type);"
      },
      {
        "txt": "return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND: return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default:"
      },
      {
        "txt": "scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition),"
      },
      {
        "txt": "left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); } private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope;"
      },
      {
        "txt": "final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes; this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; }"
      },
      {
        "txt": "FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope); } } return joinedScope; }"
      },
      {
        "txt": "FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope(); } } } private BooleanOutcomePair newBooleanOutcomePair("
      },
      {
        "txt": "JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); }"
      },
      {
        "txt": "private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); } if (isUnflowable(syntacticScope.getVar(varName))) { return; }"
      },
      {
        "txt": "scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; } private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); }"
      }
    ]
  },
  {
    "id": 251,
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java",
    "start-bug-line": 1059,
    "end-bug-line": 1061,
    "bug": "for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) { scope = traverse(arg, scope); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE;"
      },
      {
        "txt": "import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.BooleanLiteralSet;"
      },
      {
        "txt": "import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import java.util.Iterator; import java.util.List; import java.util.Map; class TypeInference"
      },
      {
        "txt": "extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> { static final DiagnosticType TEMPLATE_TYPE_NOT_OBJECT_TYPE = DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\", \"The template type must be an object type.\\nActual: {0}\"); static final DiagnosticType TEMPLATE_TYPE_OF_THIS_EXPECTED = DiagnosticType.warning( \"JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED\", \"A function type with the template type as the type of this must be a \" + \"parameter type\");"
      },
      {
        "txt": "static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS = DiagnosticType.warning( \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\", \"Function literal argument refers to undefined this argument\"); private final AbstractCompiler compiler; private final JSTypeRegistry registry; private final ReverseAbstractInterpreter reverseInterpreter; private final Scope syntacticScope; private final FlowScope functionScope; private final FlowScope bottomScope;"
      },
      {
        "txt": "private final Map<String, AssertionFunctionSpec> assertionFunctionsMap; TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); this.compiler = compiler; this.registry = compiler.getTypeRegistry(); this.reverseInterpreter = reverseInterpreter; this.syntacticScope = functionScope;"
      },
      {
        "txt": "this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); this.assertionFunctionsMap = assertionFunctionsMap; Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); while (varIt.hasNext()) { Var var = varIt.next(); if (isUnflowable(var)) { continue; } this.functionScope.inferSlotType("
      },
      {
        "txt": "var.getName(), getNativeType(VOID_TYPE)); } this.bottomScope = LinkedFlowScope.createEntryLattice( new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis())); } @Override FlowScope createInitialEstimateLattice() { return bottomScope; } @Override"
      },
      {
        "txt": "FlowScope createEntryLattice() { return functionScope; } @Override FlowScope flowThrough(Node n, FlowScope input) { if (input == bottomScope) { return input; } FlowScope output = input.createChildFlowScope(); output = traverse(n, output);"
      },
      {
        "txt": "return output; } @Override @SuppressWarnings(\"fallthrough\") List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);"
      },
      {
        "txt": "List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch (branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope());"
      },
      {
        "txt": "if (item.isVar()) { item = item.getFirstChild(); } if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getIndexType(); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType ="
      },
      {
        "txt": "iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; }"
      },
      {
        "txt": "case ON_FALSE: if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse( condition.getFirstChild(), output.createChildFlowScope()); } }"
      },
      {
        "txt": "} if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope ="
      },
      {
        "txt": "reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionOutcomes.getOutcomeFlowScope( condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); }"
      },
      {
        "txt": "newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result;"
      },
      {
        "txt": "} private FlowScope traverse(Node n, FlowScope scope) { switch (n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP:"
      },
      {
        "txt": "scope = traverseGetProp(n, scope); break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope() .createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope() .createChildFlowScope(); break;"
      },
      {
        "txt": "case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW:"
      },
      {
        "txt": "scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); // Find types. n.setJSType(getNativeType(NUMBER_TYPE));"
      },
      {
        "txt": "break; case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH:"
      },
      {
        "txt": "case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB:"
      },
      {
        "txt": "case Token.DIV: case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT:"
      },
      {
        "txt": "scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.PARAM_LIST: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild()));"
      },
      {
        "txt": "break; case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE:"
      },
      {
        "txt": "case Token.NOT: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break;"
      },
      {
        "txt": "case Token.GETELEM: scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().isGetProp()) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH:"
      },
      {
        "txt": "scope = traverse(n.getFirstChild(), scope); break; case Token.RETURN: scope = traverseReturn(n, scope); break; case Token.VAR: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH:"
      },
      {
        "txt": "scope = traverseCatch(n, scope); break; } if (!n.isFunction()) { JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { JSType castType = info.getType().evaluate(syntacticScope, registry); if (n.isQualifiedName() && n.getParent().isExprResult()) { updateScopeForTypeChange(scope, n, n.getJSType(), castType);"
      },
      {
        "txt": "} n.setJSType(castType); } } return scope; } private FlowScope traverseReturn(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node retValue = n.getFirstChild(); if (retValue != null) {"
      },
      {
        "txt": "JSType type = functionScope.getRootNode().getJSType(); if (type != null) { FunctionType fnType = type.toMaybeFunctionType(); if (fnType != null) { inferPropertyTypesToMatchConstraint( retValue.getJSType(), fnType.getReturnType()); } } } return scope;"
      },
      {
        "txt": "} private FlowScope traverseCatch(Node n, FlowScope scope) { Node name = n.getFirstChild(); JSType type = getNativeType(JSTypeNative.UNKNOWN_TYPE); name.setJSType(type); redeclareSimpleVar(scope, name, type); return scope; } private FlowScope traverseAssign(Node n, FlowScope scope) { Node left = n.getFirstChild();"
      },
      {
        "txt": "Node right = n.getLastChild(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = getJSType(right); n.setJSType(rightType); updateScopeForTypeChange(scope, left, leftType, rightType); return scope; } private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType) {"
      },
      {
        "txt": "Preconditions.checkNotNull(resultType); switch (left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); boolean isVarDeclaration = left.hasChildren(); if (!isVarDeclaration || var == null || var.isTypeInferred()) { redeclareSimpleVar(scope, left, resultType); } left.setJSType(isVarDeclaration || leftType == null ?"
      },
      {
        "txt": "resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) {"
      },
      {
        "txt": "scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } } private void ensurePropertyDefined(Node getprop, JSType rightType) {"
      },
      {
        "txt": "String propName = getprop.getLastChild().getString(); JSType nodeType = getJSType(getprop.getFirstChild()); ObjectType objectType = ObjectType.cast( nodeType.restrictByNotNullOrUndefined()); if (objectType == null) { registry.registerPropertyOnType(propName, nodeType); } else { if (ensurePropertyDeclaredHelper(getprop, objectType)) { return; }"
      },
      {
        "txt": "if (!objectType.isPropertyTypeDeclared(propName)) { if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { if (\"prototype\".equals(propName)) { objectType.defineDeclaredProperty( propName, rightType, getprop); } else { objectType.defineInferredProperty( propName, rightType, getprop); }"
      },
      {
        "txt": "} else { if (getprop.getFirstChild().isThis() && getJSType(syntacticScope.getRootNode()).isConstructor()) { objectType.defineInferredProperty( propName, rightType, getprop); } else { registry.registerPropertyOnType(propName, objectType); } } }"
      },
      {
        "txt": "} } private void ensurePropertyDeclared(Node getprop) { ObjectType ownerType = ObjectType.cast( getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); if (ownerType != null) { ensurePropertyDeclaredHelper(getprop, ownerType); } } private boolean ensurePropertyDeclaredHelper("
      },
      {
        "txt": "Node getprop, ObjectType objectType) { String propName = getprop.getLastChild().getString(); String qName = getprop.getQualifiedName(); if (qName != null) { Var var = syntacticScope.getVar(qName); if (var != null && !var.isTypeInferred()) { if (propName.equals(\"prototype\") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) {"
      },
      {
        "txt": "return objectType.defineDeclaredProperty( propName, var.getType(), getprop); } } } return false; } private FlowScope traverseName(Node n, FlowScope scope) { String varName = n.getString(); Node value = n.getFirstChild();"
      },
      {
        "txt": "JSType type = n.getJSType(); if (value != null) { scope = traverse(value, scope); updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */, getJSType(value)); return scope; } else { StaticSlot<JSType> var = scope.getSlot(varName); if (var != null) { boolean isInferred = var.isTypeInferred();"
      },
      {
        "txt": "boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); boolean nonLocalInferredSlot = isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName); if (!unflowable && !nonLocalInferredSlot) { type = var.getType(); if (type == null) { type = getNativeType(UNKNOWN_TYPE);"
      },
      {
        "txt": "} } } } n.setJSType(type); return scope; } private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { scope = traverseChildren(n, scope); n.setJSType(getNativeType(ARRAY_TYPE));"
      },
      {
        "txt": "return scope; } private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { JSType type = n.getJSType(); Preconditions.checkNotNull(type); for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { scope = traverse(name.getFirstChild(), scope); } ObjectType objectType = ObjectType.cast(type); if (objectType == null) {"
      },
      {
        "txt": "return scope; } boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; if (objectType.hasReferenceName() && !hasLendsName) { return scope; } String qObjName = NodeUtil.getBestLValueName( NodeUtil.getBestLValue(n)); for (Node name = n.getFirstChild(); name != null;"
      },
      {
        "txt": "name = name.getNext()) { Node value = name.getFirstChild(); String memberName = NodeUtil.getObjectLitKeyName(name); if (memberName != null) { JSType rawValueType = name.getFirstChild().getJSType(); JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType( name, rawValueType); if (valueType == null) { valueType = getNativeType(UNKNOWN_TYPE); }"
      },
      {
        "txt": "objectType.defineInferredProperty(memberName, valueType, name); if (qObjName != null && name.isStringKey()) { String qKeyName = qObjName + \".\" + memberName; Var var = syntacticScope.getVar(qKeyName); JSType oldType = var == null ? null : var.getType(); if (var != null && var.isTypeInferred()) { var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); } scope.inferQualifiedSlot(name, qKeyName,"
      },
      {
        "txt": "oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType, valueType); } } else { n.setJSType(getNativeType(UNKNOWN_TYPE)); } } return scope; } private FlowScope traverseAdd(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node left = n.getFirstChild(); Node right = left.getNext(); scope = traverseChildren(n, scope); JSType leftType = left.getJSType(); JSType rightType = right.getJSType(); JSType type = getNativeType(UNKNOWN_TYPE); if (leftType != null && rightType != null) { boolean leftIsUnknown = leftType.isUnknownType(); boolean rightIsUnknown = rightType.isUnknownType(); if (leftIsUnknown && rightIsUnknown) {"
      },
      {
        "txt": "type = getNativeType(UNKNOWN_TYPE); } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { type = getNativeType(STRING_TYPE); } else if (leftIsUnknown || rightIsUnknown) { type = getNativeType(UNKNOWN_TYPE); } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { type = getNativeType(NUMBER_TYPE); } else { type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE);"
      },
      {
        "txt": "} } n.setJSType(type); if (n.isAssignAdd()) { updateScopeForTypeChange(scope, left, leftType, type); } return scope; } private boolean isAddedAsNumber(JSType type) { return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE,"
      },
      {
        "txt": "NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); } private FlowScope traverseHook(Node n, FlowScope scope) { Node condition = n.getFirstChild(); Node trueNode = condition.getNext(); Node falseNode = n.getLastChild(); scope = traverse(condition, scope); FlowScope trueScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, true);"
      },
      {
        "txt": "FlowScope falseScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome( condition, scope, false); traverse(trueNode, trueScope.createChildFlowScope()); traverse(falseNode, falseScope.createChildFlowScope()); JSType trueType = trueNode.getJSType(); JSType falseType = falseNode.getJSType(); if (trueType != null && falseType != null) { n.setJSType(trueType.getLeastSupertype(falseType)); } else {"
      },
      {
        "txt": "n.setJSType(null); } return scope.createChildFlowScope(); } private FlowScope traverseCall(Node n, FlowScope scope) { scope = traverseChildren(n, scope); Node left = n.getFirstChild(); JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); if (functionType != null) { if (functionType.isFunctionType()) {"
      },
      {
        "txt": "FunctionType fnType = functionType.toMaybeFunctionType(); n.setJSType(fnType.getReturnType()); backwardsInferenceFromCallSite(n, fnType); } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) { n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); } } scope = tightenTypesAfterAssertions(scope, n); return scope; }"
      },
      {
        "txt": "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);"
      },
      {
        "txt": "if (assertedNode == null) { return scope; } JSTypeNative assertedType = assertionFunctionSpec.getAssertedType(); String assertedNodeName = assertedNode.getQualifiedName(); JSType narrowed; if (assertedType == null) { scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome( assertedNode, scope, true); narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined();"
      },
      {
        "txt": "} else { JSType type = getJSType(assertedNode); narrowed = type.getGreatestSubtype(getNativeType(assertedType)); if (assertedNodeName != null && type.differsFrom(narrowed)) { scope = narrowScope(scope, assertedNode, narrowed); } } if (getJSType(callNode).differsFrom(narrowed)) { callNode.setJSType(narrowed); }"
      },
      {
        "txt": "return scope; } private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { if (node.isThis()) { return scope; } scope = scope.createChildFlowScope(); if (node.isGetProp()) { scope.inferQualifiedSlot( node, node.getQualifiedName(), getJSType(node), narrowed);"
      },
      {
        "txt": "} else { redeclareSimpleVar(scope, node, narrowed); } return scope; } private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { updateTypeOfParameters(n, fnType); updateTypeOfThisOnClosure(n, fnType); updateBind(n, fnType); }"
      },
      {
        "txt": "private void updateBind(Node n, FunctionType fnType) { CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); if (bind == null) { return; } FunctionType callTargetFn = getJSType(bind.target) .restrictByNotNullOrUndefined().toMaybeFunctionType(); if (callTargetFn == null) { return;"
      },
      {
        "txt": "} n.setJSType( callTargetFn.getBindReturnType( bind.getBoundParameterCount() + 1)); } private void updateTypeOfParameters(Node n, FunctionType fnType) { int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { if (i + 1 >= childCount) {"
      },
      {
        "txt": "return; } JSType iParameterType = getJSType(iParameter); Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); if (iParameterType.isFunctionType()) { FunctionType iParameterFnType = iParameterType.toMaybeFunctionType(); if (iArgument.isFunction() && iArgumentType.isFunctionType() &&"
      },
      {
        "txt": "iArgument.getJSDocInfo() == null) { iArgument.setJSType(iParameterFnType); } } i++; } } private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) { if (fnType.getTemplateTypeName() == null) { return;"
      },
      {
        "txt": "} int i = 0; int childCount = n.getChildCount(); for (Node iParameter : fnType.getParameters()) { JSType iParameterType = getJSType(iParameter).restrictByNotNullOrUndefined(); if (iParameterType.isTemplateType()) { ObjectType iArgumentType = null; if (i + 1 < childCount) { Node iArgument = n.getChildAtIndex(i + 1);"
      },
      {
        "txt": "iArgumentType = getJSType(iArgument) .restrictByNotNullOrUndefined() .collapseUnion() .toObjectType(); if (iArgumentType == null) { compiler.report( JSError.make(NodeUtil.getSourceName(iArgument), iArgument, TEMPLATE_TYPE_NOT_OBJECT_TYPE, getJSType(iArgument).toString())); return;"
      },
      {
        "txt": "} } boolean foundTemplateTypeOfThisParameter = false; int j = 0; for (Node jParameter : fnType.getParameters()) { JSType jParameterType = getJSType(jParameter).restrictByNotNullOrUndefined(); if (jParameterType.isFunctionType()) { FunctionType jParameterFnType = jParameterType.toMaybeFunctionType(); if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {"
      },
      {
        "txt": "foundTemplateTypeOfThisParameter = true; if (j + 1 >= childCount) { return; } Node jArgument = n.getChildAtIndex(j + 1); JSType jArgumentType = getJSType(jArgument); if (jArgument.isFunction() && jArgumentType.isFunctionType()) { if (iArgumentType != null && !iArgumentType.isNoType()) {"
      },
      {
        "txt": "FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType(); if (jArgumentFnType.getTypeOfThis().isUnknownType()) { jArgument.setJSType( registry.createFunctionTypeWithNewThisType( jArgumentFnType, iArgumentType)); } } else { if (NodeUtil.referencesThis( NodeUtil.getFunctionBody(jArgument))) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n,"
      },
      {
        "txt": "FUNCTION_LITERAL_UNDEFINED_THIS)); } } } } } j++; } if (!foundTemplateTypeOfThisParameter) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n,"
      },
      {
        "txt": "TEMPLATE_TYPE_OF_THIS_EXPECTED)); return; } } i++; } } private FlowScope traverseNew(Node n, FlowScope scope) { Node constructor = n.getFirstChild(); scope = traverse(constructor, scope);"
      },
      {
        "txt": "JSType constructorType = constructor.getJSType(); JSType type = null; if (constructorType != null) { constructorType = constructorType.restrictByNotNullOrUndefined(); if (constructorType.isUnknownType()) { type = getNativeType(UNKNOWN_TYPE); } else { FunctionType ct = constructorType.toMaybeFunctionType(); if (ct == null && constructorType instanceof FunctionType) { ct = (FunctionType) constructorType;"
      },
      {
        "txt": "if (ct != null && ct.isConstructor()) { type = ct.getInstanceType(); } } } n.setJSType(type); <extra_id_0> return scope; } private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, true); } private FlowScope traverseChildren(Node n, FlowScope scope) {"
      },
      {
        "txt": "} private FlowScope traverseChildren(Node n, FlowScope scope) { for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { scope = traverse(el, scope); } return scope; } private FlowScope traverseGetElem(Node n, FlowScope scope) { scope = traverseChildren(n, scope); ObjectType objType = ObjectType.cast("
      },
      {
        "txt": "getJSType(n.getFirstChild()).restrictByNotNullOrUndefined()); if (objType != null) { JSType type = objType.getParameterType(); if (type != null) { n.setJSType(type); } } return dereferencePointer(n.getFirstChild(), scope); } private FlowScope traverseGetProp(Node n, FlowScope scope) {"
      },
      {
        "txt": "Node objNode = n.getFirstChild(); Node property = n.getLastChild(); scope = traverseChildren(n, scope); n.setJSType( getPropertyType( objNode.getJSType(), property.getString(), n, scope)); return dereferencePointer(n.getFirstChild(), scope); } private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) {"
      },
      {
        "txt": "if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); if (constraintObj != null) { type.matchConstraint(constraintObj); } } private FlowScope dereferencePointer(Node n, FlowScope scope) {"
      },
      {
        "txt": "if (n.isQualifiedName()) { JSType type = getJSType(n); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) { scope = narrowScope(scope, n, narrowed); } } return scope; } private JSType getPropertyType(JSType objType, String propName,"
      },
      {
        "txt": "Node n, FlowScope scope) { String qualifiedName = n.getQualifiedName(); StaticSlot<JSType> var = scope.getSlot(qualifiedName); if (var != null) { JSType varType = var.getType(); if (varType != null) { if (varType.equals(getNativeType(UNKNOWN_TYPE)) && var != syntacticScope.getSlot(qualifiedName)) { return getNativeType(CHECKED_UNKNOWN_TYPE); } else {"
      },
      {
        "txt": "return varType; } } } JSType propertyType = null; if (objType != null) { propertyType = objType.findPropertyType(propName); } if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) {"
      },
      {
        "txt": "ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); if (regType != null) { propertyType = regType.getConstructor(); } } return propertyType; } private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { return traverseShortCircuitingBinOp(n, scope, false); }"
      },
      {
        "txt": "private BooleanOutcomePair traverseShortCircuitingBinOp( Node n, FlowScope scope, boolean condition) { Node left = n.getFirstChild(); Node right = n.getLastChild(); BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); JSType leftType = left.getJSType(); FlowScope rightScope = reverseInterpreter. getPreciserScopeKnowingConditionOutcome("
      },
      {
        "txt": "left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp( right, rightScope.createChildFlowScope()); JSType rightType = right.getJSType(); JSType type; BooleanOutcomePair literals; if (leftType != null && rightType != null) { leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition);"
      },
      {
        "txt": "if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { type = leftType; literals = leftLiterals; } else { type = leftType.getLeastSupertype(rightType); literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); } if (literals.booleanValues == BooleanLiteralSet.EMPTY &&"
      },
      {
        "txt": "getNativeType(BOOLEAN_TYPE).isSubtype(type)) { if (type.isUnionType()) { type = type.toMaybeUnionType().getRestrictedUnion( getNativeType(BOOLEAN_TYPE)); } } } else { type = null; literals = new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH,"
      },
      {
        "txt": "leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); } n.setJSType(type); return literals; } private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { switch (n.getType()) { case Token.AND:"
      },
      {
        "txt": "return traverseAnd(n, scope); case Token.OR: return traverseOr(n, scope); default: scope = traverse(n, scope); return newBooleanOutcomePair(n.getJSType(), scope); } } BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) {"
      },
      {
        "txt": "return new BooleanOutcomePair( getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope()); } static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { return right.union(left.intersection(BooleanLiteralSet.get(!condition))); }"
      },
      {
        "txt": "private final class BooleanOutcomePair { final BooleanLiteralSet toBooleanOutcomes; final BooleanLiteralSet booleanValues; final FlowScope leftScope; final FlowScope rightScope; FlowScope joinedScope = null; BooleanOutcomePair( BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { this.toBooleanOutcomes = toBooleanOutcomes;"
      },
      {
        "txt": "this.booleanValues = booleanValues; this.leftScope = leftScope; this.rightScope = rightScope; } FlowScope getJoinedFlowScope() { if (joinedScope == null) { if (leftScope == rightScope) { joinedScope = rightScope; } else { joinedScope = join(leftScope, rightScope);"
      },
      {
        "txt": "} } return joinedScope; } FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { return rightScope; } else { return getJoinedFlowScope();"
      },
      {
        "txt": "} } } private BooleanOutcomePair newBooleanOutcomePair( JSType jsType, FlowScope flowScope) { if (jsType == null) { return new BooleanOutcomePair( BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); } return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(),"
      },
      {
        "txt": "registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); } private void redeclareSimpleVar( FlowScope scope, Node nameNode, JSType varType) { Preconditions.checkState(nameNode.isName()); String varName = nameNode.getString(); if (varType == null) { varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);"
      },
      {
        "txt": "} if (isUnflowable(syntacticScope.getVar(varName))) { return; } scope.inferSlotType(varName, varType); } private boolean isUnflowable(Var v) { return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; }"
      },
      {
        "txt": "private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { return getNativeType(UNKNOWN_TYPE); } else { return jsType; } } private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId);"
      }
    ]
  }
]