[
  {
    "id": 559,
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
    "start-bug-line": 602,
    "end-bug-line": 602,
    "bug": "",
    "fix": "case Token.FUNCTION:",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.javascript.rhino.FunctionNode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.Arrays; import java.util.Collection; import java.util.Collections;"
      },
      {
        "txt": "import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class NodeUtil { private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS = new HashSet<String>(Arrays.asList( \"Array\", \"Date\", \"Error\","
      },
      {
        "txt": "\"Object\", \"RegExp\", \"XMLHttpRequest\")); public static final String CONSTANT_MARKER = \"$$constant\"; private NodeUtil() {} static boolean getBooleanValue(Node n) { switch (n.getType()) { case Token.STRING: return n.getString().length() > 0; case Token.NUMBER:"
      },
      {
        "txt": "return n.getDouble() != 0; case Token.NULL: case Token.FALSE: case Token.VOID: return false; case Token.NAME: String name = n.getString(); if (\"undefined\".equals(name) || \"NaN\".equals(name)) { return false;"
      },
      {
        "txt": "} else if (\"Infinity\".equals(name)) { return true; } break; case Token.TRUE: case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: return true; }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Non-literal value: \" + n); } static String getStringValue(Node n) { switch (n.getType()) { case Token.NAME: case Token.STRING: return n.getString(); case Token.NUMBER: double value = n.getDouble(); long longValue = (long) value;"
      },
      {
        "txt": "if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(n.getDouble()); } case Token.FALSE: case Token.TRUE: case Token.NULL: return Node.tokenToName(n.getType()); case Token.VOID:"
      },
      {
        "txt": "return \"undefined\"; } return null; } static String getFunctionName(Node n, Node parent) { String name = n.getFirstChild().getString(); switch (parent.getType()) { case Token.NAME: return parent.getString(); case Token.ASSIGN:"
      },
      {
        "txt": "return parent.getFirstChild().getQualifiedName(); default: return name != null && name.length() != 0 ? name : null; } } static boolean isImmutableValue(Node n) { switch (n.getType()) { case Token.STRING: case Token.NUMBER: case Token.NULL:"
      },
      {
        "txt": "case Token.TRUE: case Token.FALSE: case Token.VOID: return true; case Token.NEG: return isImmutableValue(n.getFirstChild()); case Token.NAME: String name = n.getString(); return \"undefined\".equals(name) || \"Infinity\".equals(name)"
      },
      {
        "txt": "|| \"NaN\".equals(name); } return false; } static boolean isLiteralValue(Node n) { switch (n.getType()) { case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: for (Node child = n.getFirstChild(); child != null;"
      },
      {
        "txt": "child = child.getNext()) { if (!isLiteralValue(child)) { return false; } } return true; default: return isImmutableValue(n); } }"
      },
      {
        "txt": "static boolean isValidDefineValue(Node val, Set<String> defines) { switch (val.getType()) { case Token.STRING: case Token.NUMBER: case Token.TRUE: case Token.FALSE: return true; case Token.BITAND: case Token.BITNOT: case Token.BITOR:"
      },
      {
        "txt": "case Token.BITXOR: case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); case Token.NAME: case Token.GETPROP: if (val.isQualifiedName()) { return defines.contains(val.getQualifiedName()); } }"
      },
      {
        "txt": "return false; } static boolean isEmptyBlock(Node block) { if (block.getType() != Token.BLOCK) { return false; } for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { if (n.getType() != Token.EMPTY) { return false; }"
      },
      {
        "txt": "} return true; } static boolean isSimpleOperatorType(int type) { switch (type) { case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR:"
      },
      {
        "txt": "case Token.COMMA: case Token.DIV: case Token.EQ: case Token.GE: case Token.GETELEM: case Token.GETPROP: case Token.GT: case Token.INSTANCEOF: case Token.LE: case Token.LSH:"
      },
      {
        "txt": "case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.NOT: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.TYPEOF:"
      },
      {
        "txt": "case Token.VOID: case Token.POS: case Token.NEG: case Token.URSH: return true; default: return false; } } public static Node newExpr(Node child) {"
      },
      {
        "txt": "Node expr = new Node(Token.EXPR_RESULT, child); expr.copyInformationFrom(child); return expr; } static boolean mayEffectMutableState(Node n) { return checkForStateChangeHelper(n, true); } static boolean mayHaveSideEffects(Node n) { return checkForStateChangeHelper(n, false); }"
      },
      {
        "txt": "private static boolean checkForStateChangeHelper( Node n, boolean checkForNewObjects) { switch (n.getType()) { case Token.AND: case Token.BLOCK: case Token.EXPR_RESULT: case Token.HOOK: case Token.IF: case Token.IN: case Token.LP:"
      },
      {
        "txt": "case Token.NUMBER: case Token.OR: case Token.THIS: case Token.TRUE: case Token.FALSE: case Token.NULL: case Token.STRING: case Token.SWITCH: case Token.TRY: case Token.EMPTY:"
      },
      {
        "txt": "break; case Token.THROW: return true; case Token.OBJECTLIT: case Token.ARRAYLIT: case Token.REGEXP: if (checkForNewObjects) { return true; } break;"
      },
      {
        "txt": "case Token.VAR: // empty var statement (no declaration) case Token.NAME: // variable by itself if (n.getFirstChild() != null) return true; break; case Token.FUNCTION: return !isFunctionAnonymous(n); case Token.NEW: { if (checkForNewObjects) {"
      },
      {
        "txt": "return true; } if (n.isNoSideEffectsCall()) { break; } Node constructor = n.getFirstChild(); if (Token.NAME == constructor.getType()) { String className = constructor.getString(); if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) { break;"
      },
      {
        "txt": "} } else { } } return true; case Token.CALL: if (n.isNoSideEffectsCall()) { break; } return true;"
      },
      {
        "txt": "default: if (isSimpleOperatorType(n.getType())) break; if (isAssignmentOp(n)) { if (checkForStateChangeHelper( n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper( n.getLastChild(), checkForNewObjects)) { return true; }"
      },
      {
        "txt": "Node current = n.getFirstChild(); for (; current.getType() == Token.GETPROP || current.getType() == Token.GETELEM; current = current.getFirstChild()) { } return !(isLiteralValue(current) || current.getType() == Token.FUNCTION); } return true; }"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (checkForStateChangeHelper(c, checkForNewObjects)) { return true; } } return false; } static boolean constructorCallHasSideEffects(Node callNode) { Preconditions.checkArgument( callNode.getType() == Token.NEW,"
      },
      {
        "txt": "\"Expected NEW node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { return false; } return true;"
      },
      {
        "txt": "} static boolean functionCallHasSideEffects(Node callNode) { Preconditions.checkArgument( callNode.getType() == Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME) {"
      },
      {
        "txt": "String name = nameNode.getString(); if (name.equals(\"String\")) { return false; } } if (nameNode.getType() == Token.GETPROP && nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false;"
      },
      {
        "txt": "} } return true; } static boolean nodeTypeMayHaveSideEffects(Node n) { if (NodeUtil.isAssignmentOp(n)) { return true; } switch(n.getType()) { case Token.CALL:"
      },
      {
        "txt": "case Token.DELPROP: case Token.NEW: case Token.DEC: case Token.INC: case Token.THROW: return true; case Token.NAME: return n.hasChildren(); default: return false;"
      },
      {
        "txt": "} } static boolean canBeSideEffected(Node n) { Set<String> emptySet = Collections.emptySet(); return canBeSideEffected(n, emptySet); } static boolean canBeSideEffected(Node n, Set<String> knownConstants) { switch (n.getType()) { case Token.CALL: case Token.NEW:"
      },
      {
        "txt": "case Token.NAME: return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString()); case Token.GETPROP: case Token.GETELEM: return true; <extra_id_0> } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (canBeSideEffected(c, knownConstants)) { return true; } }"
      },
      {
        "txt": "} } return false; } static int precedence(int type) { switch (type) { case Token.COMMA: return 0; case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND:"
      },
      {
        "txt": "case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN: return 1; case Token.HOOK: return 2; // ?: operator"
      },
      {
        "txt": "case Token.OR: return 3; case Token.AND: return 4; case Token.BITOR: return 5; case Token.BITXOR: return 6; case Token.BITAND: return 7; case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: return 8; case Token.LT:"
      },
      {
        "txt": "case Token.GT: case Token.LE: case Token.GE: case Token.INSTANCEOF: case Token.IN: return 9; case Token.LSH: case Token.RSH: case Token.URSH: return 10; case Token.SUB: case Token.ADD: return 11;"
      },
      {
        "txt": "case Token.MUL: case Token.MOD: case Token.DIV: return 12; case Token.INC: case Token.DEC: case Token.NEW: case Token.DELPROP: case Token.TYPEOF: case Token.VOID: case Token.NOT:"
      },
      {
        "txt": "case Token.BITNOT: case Token.POS: case Token.NEG: return 13; case Token.ARRAYLIT: case Token.CALL: case Token.EMPTY: case Token.FALSE: case Token.FUNCTION: case Token.GETELEM: case Token.GETPROP:"
      },
      {
        "txt": "case Token.GET_REF: case Token.IF: case Token.LP: case Token.NAME: case Token.NULL: case Token.NUMBER: case Token.OBJECTLIT: case Token.REGEXP: case Token.RETURN: case Token.STRING:"
      },
      {
        "txt": "case Token.THIS: case Token.TRUE: return 15; default: throw new Error(\"Unknown precedence for \" + Node.tokenToName(type) + \" (type \" + type + \")\"); } } static boolean isAssociative(int type) { switch (type) {"
      },
      {
        "txt": "case Token.MUL: case Token.AND: case Token.OR: case Token.BITOR: case Token.BITAND: return true; default: return false; } }"
      },
      {
        "txt": "static boolean isAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD:"
      },
      {
        "txt": "case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: return true; } return false; } static int getOpFromAssignmentOp(Node n) { switch (n.getType()){"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: return Token.BITOR; case Token.ASSIGN_BITXOR: return Token.BITXOR; case Token.ASSIGN_BITAND: return Token.BITAND; case Token.ASSIGN_LSH: return Token.LSH; case Token.ASSIGN_RSH: return Token.RSH;"
      },
      {
        "txt": "case Token.ASSIGN_URSH: return Token.URSH; case Token.ASSIGN_ADD: return Token.ADD; case Token.ASSIGN_SUB: return Token.SUB; case Token.ASSIGN_MUL: return Token.MUL; case Token.ASSIGN_DIV: return Token.DIV;"
      },
      {
        "txt": "case Token.ASSIGN_MOD: return Token.MOD; } throw new IllegalArgumentException(\"Not an assiment op\"); } static boolean isExpressionNode(Node n) { return n.getType() == Token.EXPR_RESULT; } static boolean containsFunctionDeclaration(Node n) { return containsType(n, Token.FUNCTION);"
      },
      {
        "txt": "} static boolean referencesThis(Node n) { return containsType(n, Token.THIS); } static boolean isGet(Node n) { return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM; } static boolean isGetProp(Node n) { return n.getType() == Token.GETPROP;"
      },
      {
        "txt": "} static boolean isName(Node n) { return n.getType() == Token.NAME; } static boolean isNew(Node n) { return n.getType() == Token.NEW; } static boolean isVar(Node n) { return n.getType() == Token.VAR; }"
      },
      {
        "txt": "static boolean isVarDeclaration(Node n) { return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR; } static Node getAssignedValue(Node n) { Preconditions.checkState(isName(n)); Node parent = n.getParent(); if (isVar(parent)) { return n.getFirstChild(); } else if (isAssign(parent) && parent.getFirstChild() == n) { return n.getNext();"
      },
      {
        "txt": "} else { return null; } } static boolean isString(Node n) { return n.getType() == Token.STRING; } static boolean isExprAssign(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN;"
      },
      {
        "txt": "} static boolean isAssign(Node n) { return n.getType() == Token.ASSIGN; } static boolean isExprCall(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL; } static boolean isForIn(Node n) { return n.getType() == Token.FOR"
      },
      {
        "txt": "&& n.getChildCount() == 3; } static boolean isLoopStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: return true; default: return false;"
      },
      {
        "txt": "} } static Node getLoopCodeBlock(Node n) { switch (n.getType()) { case Token.FOR: case Token.WHILE: return n.getLastChild(); case Token.DO: return n.getFirstChild(); default:"
      },
      {
        "txt": "return null; } } static boolean isControlStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: case Token.WITH: case Token.IF:"
      },
      {
        "txt": "case Token.LABEL: case Token.TRY: case Token.CATCH: case Token.SWITCH: case Token.CASE: case Token.DEFAULT: return true; default: return false; }"
      },
      {
        "txt": "} static boolean isControlStructureCodeBlock(Node parent, Node n) { switch (parent.getType()) { case Token.FOR: case Token.WHILE: case Token.LABEL: case Token.WITH: return parent.getLastChild() == n; case Token.DO: return parent.getFirstChild() == n;"
      },
      {
        "txt": "case Token.IF: return parent.getFirstChild() != n; case Token.TRY: return parent.getFirstChild() == n || parent.getLastChild() == n; case Token.CATCH: return parent.getLastChild() == n; case Token.SWITCH: case Token.CASE: return parent.getFirstChild() != n; case Token.DEFAULT:"
      },
      {
        "txt": "return true; default: Preconditions.checkState(isControlStructure(parent)); return false; } } static Node getConditionExpression(Node n) { switch (n.getType()) { case Token.IF: case Token.WHILE:"
      },
      {
        "txt": "return n.getFirstChild(); case Token.DO: return n.getLastChild(); case Token.FOR: switch (n.getChildCount()) { case 3: return null; case 4: return n.getFirstChild().getNext(); }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"malformed 'for' statement \" + n); case Token.CASE: return null; } throw new IllegalArgumentException(n + \" does not have a condition.\"); } static boolean isStatementBlock(Node n) { return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK; } static boolean isStatement(Node n) {"
      },
      {
        "txt": "Node parent = n.getParent(); Preconditions.checkState(parent != null); switch (parent.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.LABEL: return true; default: return false; }"
      },
      {
        "txt": "} static boolean isSwitchCase(Node n) { return n.getType() == Token.CASE || n.getType() == Token.DEFAULT; } static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); } static boolean isLabelName(Node n) { if (n != null && n.getType() == Token.NAME) { Node parent = n.getParent();"
      },
      {
        "txt": "switch (parent.getType()) { case Token.LABEL: case Token.BREAK: case Token.CONTINUE: if (n == parent.getFirstChild()) { return true; } } } return false;"
      },
      {
        "txt": "} static boolean isTryFinallyNode(Node parent, Node child) { return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild(); } static void removeChild(Node parent, Node node) { if (isStatementBlock(parent) || isSwitchCase(node) || isTryFinallyNode(parent, node)) { parent.removeChild(node);"
      },
      {
        "txt": "} else if (parent.getType() == Token.VAR) { if (parent.hasMoreThanOneChild()) { parent.removeChild(node); } else { parent.removeChild(node); removeChild(parent.getParent(), parent); } } else if (node.getType() == Token.BLOCK) { node.detachChildren(); } else if (parent.getType() == Token.LABEL"
      },
      {
        "txt": "&& node == parent.getLastChild()) { parent.removeChild(node); removeChild(parent.getParent(), parent); } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) { parent.replaceChild(node, new Node(Token.EMPTY)); } else { throw new IllegalStateException(\"Invalid attempt to remove node: \" + node.toString() + \" of \"+ parent.toString()); }"
      },
      {
        "txt": "} static boolean tryMergeBlock(Node block) { Preconditions.checkState(block.getType() == Token.BLOCK); Node parent = block.getParent(); if (NodeUtil.isStatementBlock(parent)) { Node previous = block; while (block.hasChildren()) { Node child = block.removeFirstChild(); parent.addChildAfter(child, previous); previous = child;"
      },
      {
        "txt": "} parent.removeChild(block); return true; } else if (parent.getType() == Token.LABEL && block.hasOneChild()) { parent.replaceChild(block, block.removeFirstChild()); return true; } else { return false; } }"
      },
      {
        "txt": "static boolean isCall(Node n) { return n.getType() == Token.CALL; } static boolean isFunction(Node n) { return n.getType() == Token.FUNCTION; } static Node getFunctionBody(Node fn) { Preconditions.checkArgument(isFunction(fn)); return fn.getLastChild(); }"
      },
      {
        "txt": "static boolean isThis(Node node) { return node.getType() == Token.THIS; } static boolean containsCall(Node n) { return containsType(n, Token.CALL); } static boolean isFunctionDeclaration(Node n) { return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n); } static boolean isHoistedFunctionDeclaration(Node n) {"
      },
      {
        "txt": "return NodeUtil.isFunctionDeclaration(n) && (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION); } static boolean isAnonymousFunction(Node n) { return n.getType() == Token.FUNCTION && isFunctionAnonymous(n); } static boolean isFunctionAnonymous(Node n) { return !isStatement(n); }"
      },
      {
        "txt": "static boolean isVarArgsFunction(Node function) { Preconditions.checkArgument(isFunction(function)); return NodeUtil.isNameReferenced( function.getLastChild(), \"arguments\", Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } static boolean isObjectCallMethod(Node callNode, String methodName) { if (callNode.getType() == Token.CALL) { Node functionIndentifyingExpression = callNode.getFirstChild();"
      },
      {
        "txt": "if (NodeUtil.isGet(functionIndentifyingExpression)) { Node last = functionIndentifyingExpression.getLastChild(); if (last != null && last.getType() == Token.STRING) { String propName = last.getString(); return (propName.equals(methodName)); } } } return false; }"
      },
      {
        "txt": "static boolean isFunctionObjectCall(Node callNode) { return isObjectCallMethod(callNode, \"call\"); } static boolean isFunctionObjectApply(Node callNode) { return isObjectCallMethod(callNode, \"apply\"); } static boolean isSimpleFunctionObjectCall(Node callNode) { if (isFunctionObjectCall(callNode)) { if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) { return true;"
      },
      {
        "txt": "} } return false; } static boolean isLhs(Node n, Node parent) { return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR; } static boolean isObjectLitKey(Node node, Node parent) { if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) {"
      },
      {
        "txt": "int index = 0; for (Node current = parent.getFirstChild(); current != null; current = current.getNext()) { if (current == node) { return index % 2 == 0; } index++; } }"
      },
      {
        "txt": "return false; } static String opToStr(int operator) { switch (operator) { case Token.BITOR: return \"|\"; case Token.OR: return \"||\"; case Token.BITXOR: return \"^\"; case Token.AND: return \"&&\"; case Token.BITAND: return \"&\"; case Token.SHEQ: return \"===\";"
      },
      {
        "txt": "case Token.EQ: return \"==\"; case Token.NOT: return \"!\"; case Token.NE: return \"!=\"; case Token.SHNE: return \"!==\"; case Token.LSH: return \"<<\"; case Token.IN: return \"in\"; case Token.LE: return \"<=\"; case Token.LT: return \"<\"; case Token.URSH: return \">>>\"; case Token.RSH: return \">>\";"
      },
      {
        "txt": "case Token.GE: return \">=\"; case Token.GT: return \">\"; case Token.MUL: return \"*\"; case Token.DIV: return \"/\"; case Token.MOD: return \"%\"; case Token.BITNOT: return \"~\"; case Token.ADD: return \"+\"; case Token.SUB: return \"-\"; case Token.POS: return \"+\"; case Token.NEG: return \"-\";"
      },
      {
        "txt": "case Token.ASSIGN: return \"=\"; case Token.ASSIGN_BITOR: return \"|=\"; case Token.ASSIGN_BITXOR: return \"^=\"; case Token.ASSIGN_BITAND: return \"&=\"; case Token.ASSIGN_LSH: return \"<<=\"; case Token.ASSIGN_RSH: return \">>=\"; case Token.ASSIGN_URSH: return \">>>=\"; case Token.ASSIGN_ADD: return \"+=\"; case Token.ASSIGN_SUB: return \"-=\"; case Token.ASSIGN_MUL: return \"*=\";"
      },
      {
        "txt": "case Token.ASSIGN_DIV: return \"/=\"; case Token.ASSIGN_MOD: return \"%=\"; case Token.VOID: return \"void\"; case Token.TYPEOF: return \"typeof\"; case Token.INSTANCEOF: return \"instanceof\"; default: return null; } } static String opToStrNoFail(int operator) { String res = opToStr(operator);"
      },
      {
        "txt": "if (res == null) { throw new Error(\"Unknown op \" + operator + \": \" + Token.name(operator)); } return res; } static boolean containsTypeInOuterScope(Node node, int type) { return containsType(node, type, Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); }"
      },
      {
        "txt": "static boolean containsType(Node node, int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static boolean containsType(Node node, int type) { return containsType(node, type, Predicates.<Node>alwaysTrue()); } static void redeclareVarsInsideBranch(Node branch) { Collection<Node> vars = getVarsDeclaredInBranch(branch);"
      },
      {
        "txt": "if (vars.isEmpty()) { return; } Node parent = getAddingRoot(branch); for (Node nameNode : vars) { Node var = new Node( Token.VAR, Node.newString(Token.NAME, nameNode.getString())); copyNameAnnotations(nameNode, var.getFirstChild()); parent.addChildToFront(var); }"
      },
      {
        "txt": "} static void copyNameAnnotations(Node source, Node destination) { if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } private static Node getAddingRoot(Node n) { Node addingRoot = null; Node ancestor = n; while (null != (ancestor = ancestor.getParent())) {"
      },
      {
        "txt": "int type = ancestor.getType(); if (type == Token.SCRIPT) { addingRoot = ancestor; break; } else if (type == Token.FUNCTION) { addingRoot = ancestor.getLastChild(); break; } } Preconditions.checkState(addingRoot.getType() == Token.BLOCK ||"
      },
      {
        "txt": "addingRoot.getType() == Token.SCRIPT); Preconditions.checkState(addingRoot.getFirstChild() == null || addingRoot.getFirstChild().getType() != Token.SCRIPT); return addingRoot; } public static FunctionNode newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) { Node parameterParen = new Node(Token.LP, lineno, charno); for (Node param : params) { parameterParen.addChildToBack(param);"
      },
      {
        "txt": "} FunctionNode function = new FunctionNode(name, lineno, charno); function.addChildrenToBack( Node.newString(Token.NAME, name, lineno, charno)); function.addChildToBack(parameterParen); function.addChildToBack(body); return function; } public static Node newQualifiedNameNode(String name, int lineno, int charno) { int endPos = name.indexOf('.');"
      },
      {
        "txt": "if (endPos == -1) { return Node.newString(Token.NAME, name, lineno, charno); } Node node = Node.newString(Token.NAME, name.substring(0, endPos), lineno, charno); int startPos; do { startPos = endPos + 1; endPos = name.indexOf('.', startPos); String part = (endPos == -1"
      },
      {
        "txt": "? name.substring(startPos) : name.substring(startPos, endPos)); node = new Node(Token.GETPROP, node, Node.newString(Token.STRING, part, lineno, charno), lineno, charno); } while (endPos != -1); return node; } static Node newQualifiedNameNode(String name, Node basisNode, String originalName) {"
      },
      {
        "txt": "Node node = newQualifiedNameNode(name, -1, -1); setDebugInformation(node, basisNode, originalName); return node; } static void setDebugInformation(Node node, Node basisNode, String originalName) { node.copyInformationFromForTree(basisNode); node.putProp(Node.ORIGINALNAME_PROP, originalName); } static Node newName(String name, Node basisNode) {"
      },
      {
        "txt": "Node nameNode = Node.newString(Token.NAME, name); nameNode.copyInformationFrom(basisNode); return nameNode; } static Node newName(String name, Node basisNode, String originalName) { Node nameNode = newName(name, basisNode); nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); return nameNode; } static boolean isLatin(String s) {"
      },
      {
        "txt": "char LARGEST_BASIC_LATIN = 0x7f; int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c > LARGEST_BASIC_LATIN) { return false; } } return true; }"
      },
      {
        "txt": "static boolean isValidPropertyName(String name) { return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && NodeUtil.isLatin(name); } private static class VarCollector implements Visitor { final Map<String, Node> vars = Maps.newLinkedHashMap(); public void visit(Node n) { if (n.getType() == Token.NAME) { Node parent = n.getParent();"
      },
      {
        "txt": "if (parent != null && parent.getType() == Token.VAR) { String name = n.getString(); if (!vars.containsKey(name)) { vars.put(name, n); } } } } } public static Collection<Node> getVarsDeclaredInBranch(Node root) {"
      },
      {
        "txt": "VarCollector collector = new VarCollector(); visitPreOrder( root, collector, Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); return collector.vars.values(); } static boolean isPrototypePropertyDeclaration(Node n) { if (!NodeUtil.isExprAssign(n)) { return false;"
      },
      {
        "txt": "} return isPrototypeProperty(n.getFirstChild().getFirstChild()); } static boolean isPrototypeProperty(Node n) { String lhsString = n.getQualifiedName(); if (lhsString == null) { return false; } int prototypeIdx = lhsString.indexOf(\".prototype.\"); return prototypeIdx != -1;"
      },
      {
        "txt": "} static Node getPrototypeClassName(Node qName) { Node cur = qName; while (isGetProp(cur)) { if (cur.getLastChild().getString().equals(\"prototype\")) { return cur.getFirstChild(); } else { cur = cur.getFirstChild(); } }"
      },
      {
        "txt": "return null; } static String getPrototypePropertyName(Node qName) { String qNameStr = qName.getQualifiedName(); int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\"); int memberIndex = prototypeIdx + \".prototype\".length() + 1; return qNameStr.substring(memberIndex); } static Node newUndefinedNode() { return new Node(Token.VOID, Node.newNumber(0));"
      },
      {
        "txt": "} static Node newVarNode(String name, Node value) { Node nodeName = Node.newString(Token.NAME, name); if (value != null) { nodeName.addChildrenToBack(value); } Node var = new Node(Token.VAR, nodeName); return var; } private static class MatchNameNode implements Predicate<Node>{"
      },
      {
        "txt": "final String name; MatchNameNode(String name){ this.name = name; } public boolean apply(Node n) { return n.getType() == Token.NAME && n.getString().equals(name); } } static class MatchNodeType implements Predicate<Node>{"
      },
      {
        "txt": "final int type; MatchNodeType(int type){ this.type = type; } public boolean apply(Node n) { return n.getType() == type; } } static boolean isNodeTypeReferenced(Node node, int type) { return isNodeTypeReferenced(node, type, Predicates.<Node>alwaysTrue());"
      },
      {
        "txt": "} static boolean isNodeTypeReferenced( Node node, int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static int getNodeTypeReferenceCount(Node node, int type) { return getCount(node, new MatchNodeType(type)); } static boolean isNameReferenced(Node node, String name,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { return has(node, new MatchNameNode(name), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name) { return isNameReferenced(node, name, Predicates.<Node>alwaysTrue()); } static int getNameReferenceCount(Node node, String name) { return getCount(node, new MatchNameNode(name) ); } static boolean has(Node node,"
      },
      {
        "txt": "Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { if (pred.apply(node)) { return true; } if (!traverseChildrenPred.apply(node)) { return false; } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { if (has(c, pred, traverseChildrenPred)) {"
      },
      {
        "txt": "return true; } } return false; } static int getCount(Node n, Predicate<Node> pred) { int total = 0; if (pred.apply(n)) { total++; }"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { total += getCount(c, pred); } return total; } static interface Visitor { void visit(Node node); } static void visitPreOrder(Node node, Visitor vistor,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { vistor.visit(node); if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPreOrder(c, vistor, traverseChildrenPred); } } } static void visitPostOrder(Node node, Visitor vistor,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPostOrder(c, vistor, traverseChildrenPred); } } vistor.visit(node); } static boolean hasFinally(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY);"
      },
      {
        "txt": "return n.getChildCount() == 3; } static Node getCatchBlock(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getFirstChild().getNext(); } static boolean hasCatchHandler(Node n) { Preconditions.checkArgument(n.getType() == Token.BLOCK); return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH; }"
      },
      {
        "txt": "static Node getFnParameters(Node fnNode) { Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } static boolean isConstantName(Node node) { return node.getBooleanProp(Node.IS_CONSTANT_NAME); } static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null; Node parent = null;"
      },
      {
        "txt": "if (nameNode != null) { info = nameNode.getJSDocInfo(); parent = nameNode.getParent(); } if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); } return info;"
      },
      {
        "txt": "} static String getSourceName(Node n) { String sourceName = null; while (sourceName == null && n != null) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); n = n.getParent(); } return sourceName; }"
      }
    ]
  },
  {
    "id": 560,
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java",
    "start-bug-line": 604,
    "end-bug-line": 604,
    "bug": "",
    "fix": "Preconditions.checkState(NodeUtil.isAnonymousFunction(n)); return false;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicate;"
      },
      {
        "txt": "import com.google.common.base.Predicates; import com.google.common.collect.Maps; import com.google.javascript.rhino.FunctionNode; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.TokenStream; import java.util.Arrays; import java.util.Collection; import java.util.Collections;"
      },
      {
        "txt": "import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; public final class NodeUtil { private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS = new HashSet<String>(Arrays.asList( \"Array\", \"Date\", \"Error\","
      },
      {
        "txt": "\"Object\", \"RegExp\", \"XMLHttpRequest\")); public static final String CONSTANT_MARKER = \"$$constant\"; private NodeUtil() {} static boolean getBooleanValue(Node n) { switch (n.getType()) { case Token.STRING: return n.getString().length() > 0; case Token.NUMBER:"
      },
      {
        "txt": "return n.getDouble() != 0; case Token.NULL: case Token.FALSE: case Token.VOID: return false; case Token.NAME: String name = n.getString(); if (\"undefined\".equals(name) || \"NaN\".equals(name)) { return false;"
      },
      {
        "txt": "} else if (\"Infinity\".equals(name)) { return true; } break; case Token.TRUE: case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: return true; }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Non-literal value: \" + n); } static String getStringValue(Node n) { switch (n.getType()) { case Token.NAME: case Token.STRING: return n.getString(); case Token.NUMBER: double value = n.getDouble(); long longValue = (long) value;"
      },
      {
        "txt": "if (longValue == value) { return Long.toString(longValue); } else { return Double.toString(n.getDouble()); } case Token.FALSE: case Token.TRUE: case Token.NULL: return Node.tokenToName(n.getType()); case Token.VOID:"
      },
      {
        "txt": "return \"undefined\"; } return null; } static String getFunctionName(Node n, Node parent) { String name = n.getFirstChild().getString(); switch (parent.getType()) { case Token.NAME: return parent.getString(); case Token.ASSIGN:"
      },
      {
        "txt": "return parent.getFirstChild().getQualifiedName(); default: return name != null && name.length() != 0 ? name : null; } } static boolean isImmutableValue(Node n) { switch (n.getType()) { case Token.STRING: case Token.NUMBER: case Token.NULL:"
      },
      {
        "txt": "case Token.TRUE: case Token.FALSE: case Token.VOID: return true; case Token.NEG: return isImmutableValue(n.getFirstChild()); case Token.NAME: String name = n.getString(); return \"undefined\".equals(name) || \"Infinity\".equals(name)"
      },
      {
        "txt": "|| \"NaN\".equals(name); } return false; } static boolean isLiteralValue(Node n) { switch (n.getType()) { case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: for (Node child = n.getFirstChild(); child != null;"
      },
      {
        "txt": "child = child.getNext()) { if (!isLiteralValue(child)) { return false; } } return true; default: return isImmutableValue(n); } }"
      },
      {
        "txt": "static boolean isValidDefineValue(Node val, Set<String> defines) { switch (val.getType()) { case Token.STRING: case Token.NUMBER: case Token.TRUE: case Token.FALSE: return true; case Token.BITAND: case Token.BITNOT: case Token.BITOR:"
      },
      {
        "txt": "case Token.BITXOR: case Token.NOT: case Token.NEG: return isValidDefineValue(val.getFirstChild(), defines); case Token.NAME: case Token.GETPROP: if (val.isQualifiedName()) { return defines.contains(val.getQualifiedName()); } }"
      },
      {
        "txt": "return false; } static boolean isEmptyBlock(Node block) { if (block.getType() != Token.BLOCK) { return false; } for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { if (n.getType() != Token.EMPTY) { return false; }"
      },
      {
        "txt": "} return true; } static boolean isSimpleOperatorType(int type) { switch (type) { case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR:"
      },
      {
        "txt": "case Token.COMMA: case Token.DIV: case Token.EQ: case Token.GE: case Token.GETELEM: case Token.GETPROP: case Token.GT: case Token.INSTANCEOF: case Token.LE: case Token.LSH:"
      },
      {
        "txt": "case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.NOT: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.TYPEOF:"
      },
      {
        "txt": "case Token.VOID: case Token.POS: case Token.NEG: case Token.URSH: return true; default: return false; } } public static Node newExpr(Node child) {"
      },
      {
        "txt": "Node expr = new Node(Token.EXPR_RESULT, child); expr.copyInformationFrom(child); return expr; } static boolean mayEffectMutableState(Node n) { return checkForStateChangeHelper(n, true); } static boolean mayHaveSideEffects(Node n) { return checkForStateChangeHelper(n, false); }"
      },
      {
        "txt": "private static boolean checkForStateChangeHelper( Node n, boolean checkForNewObjects) { switch (n.getType()) { case Token.AND: case Token.BLOCK: case Token.EXPR_RESULT: case Token.HOOK: case Token.IF: case Token.IN: case Token.LP:"
      },
      {
        "txt": "case Token.NUMBER: case Token.OR: case Token.THIS: case Token.TRUE: case Token.FALSE: case Token.NULL: case Token.STRING: case Token.SWITCH: case Token.TRY: case Token.EMPTY:"
      },
      {
        "txt": "break; case Token.THROW: return true; case Token.OBJECTLIT: case Token.ARRAYLIT: case Token.REGEXP: if (checkForNewObjects) { return true; } break;"
      },
      {
        "txt": "case Token.VAR: // empty var statement (no declaration) case Token.NAME: // variable by itself if (n.getFirstChild() != null) return true; break; case Token.FUNCTION: return !isFunctionAnonymous(n); case Token.NEW: { if (checkForNewObjects) {"
      },
      {
        "txt": "return true; } if (n.isNoSideEffectsCall()) { break; } Node constructor = n.getFirstChild(); if (Token.NAME == constructor.getType()) { String className = constructor.getString(); if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) { break;"
      },
      {
        "txt": "} } else { } } return true; case Token.CALL: if (n.isNoSideEffectsCall()) { break; } return true;"
      },
      {
        "txt": "default: if (isSimpleOperatorType(n.getType())) break; if (isAssignmentOp(n)) { if (checkForStateChangeHelper( n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper( n.getLastChild(), checkForNewObjects)) { return true; }"
      },
      {
        "txt": "Node current = n.getFirstChild(); for (; current.getType() == Token.GETPROP || current.getType() == Token.GETELEM; current = current.getFirstChild()) { } return !(isLiteralValue(current) || current.getType() == Token.FUNCTION); } return true; }"
      },
      {
        "txt": "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (checkForStateChangeHelper(c, checkForNewObjects)) { return true; } } return false; } static boolean constructorCallHasSideEffects(Node callNode) { Preconditions.checkArgument( callNode.getType() == Token.NEW,"
      },
      {
        "txt": "\"Expected NEW node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { return false; } return true;"
      },
      {
        "txt": "} static boolean functionCallHasSideEffects(Node callNode) { Preconditions.checkArgument( callNode.getType() == Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType())); if (callNode.isNoSideEffectsCall()) { return false; } Node nameNode = callNode.getFirstChild(); if (nameNode.getType() == Token.NAME) {"
      },
      {
        "txt": "String name = nameNode.getString(); if (name.equals(\"String\")) { return false; } } if (nameNode.getType() == Token.GETPROP && nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false;"
      },
      {
        "txt": "} } return true; } static boolean nodeTypeMayHaveSideEffects(Node n) { if (NodeUtil.isAssignmentOp(n)) { return true; } switch(n.getType()) { case Token.CALL:"
      },
      {
        "txt": "case Token.DELPROP: case Token.NEW: case Token.DEC: case Token.INC: case Token.THROW: return true; case Token.NAME: return n.hasChildren(); default: return false;"
      },
      {
        "txt": "} } static boolean canBeSideEffected(Node n) { Set<String> emptySet = Collections.emptySet(); return canBeSideEffected(n, emptySet); } static boolean canBeSideEffected(Node n, Set<String> knownConstants) { switch (n.getType()) { case Token.CALL: case Token.NEW:"
      },
      {
        "txt": "case Token.NAME: return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString()); case Token.GETPROP: case Token.GETELEM: return true; <extra_id_0> for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (canBeSideEffected(c, knownConstants)) { return true; } } return false;"
      },
      {
        "txt": "} return false; } static int precedence(int type) { switch (type) { case Token.COMMA: return 0; case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH:"
      },
      {
        "txt": "case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB: case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN: return 1; case Token.HOOK: return 2; // ?: operator case Token.OR: return 3;"
      },
      {
        "txt": "case Token.AND: return 4; case Token.BITOR: return 5; case Token.BITXOR: return 6; case Token.BITAND: return 7; case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: return 8; case Token.LT: case Token.GT:"
      },
      {
        "txt": "case Token.LE: case Token.GE: case Token.INSTANCEOF: case Token.IN: return 9; case Token.LSH: case Token.RSH: case Token.URSH: return 10; case Token.SUB: case Token.ADD: return 11; case Token.MUL:"
      },
      {
        "txt": "case Token.MOD: case Token.DIV: return 12; case Token.INC: case Token.DEC: case Token.NEW: case Token.DELPROP: case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT:"
      },
      {
        "txt": "case Token.POS: case Token.NEG: return 13; case Token.ARRAYLIT: case Token.CALL: case Token.EMPTY: case Token.FALSE: case Token.FUNCTION: case Token.GETELEM: case Token.GETPROP: case Token.GET_REF:"
      },
      {
        "txt": "case Token.IF: case Token.LP: case Token.NAME: case Token.NULL: case Token.NUMBER: case Token.OBJECTLIT: case Token.REGEXP: case Token.RETURN: case Token.STRING: case Token.THIS:"
      },
      {
        "txt": "case Token.TRUE: return 15; default: throw new Error(\"Unknown precedence for \" + Node.tokenToName(type) + \" (type \" + type + \")\"); } } static boolean isAssociative(int type) { switch (type) { case Token.MUL:"
      },
      {
        "txt": "case Token.AND: case Token.OR: case Token.BITOR: case Token.BITAND: return true; default: return false; } } static boolean isAssignmentOp(Node n) {"
      },
      {
        "txt": "switch (n.getType()){ case Token.ASSIGN: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_ADD: case Token.ASSIGN_SUB:"
      },
      {
        "txt": "case Token.ASSIGN_MUL: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: return true; } return false; } static int getOpFromAssignmentOp(Node n) { switch (n.getType()){ case Token.ASSIGN_BITOR:"
      },
      {
        "txt": "return Token.BITOR; case Token.ASSIGN_BITXOR: return Token.BITXOR; case Token.ASSIGN_BITAND: return Token.BITAND; case Token.ASSIGN_LSH: return Token.LSH; case Token.ASSIGN_RSH: return Token.RSH; case Token.ASSIGN_URSH:"
      },
      {
        "txt": "return Token.URSH; case Token.ASSIGN_ADD: return Token.ADD; case Token.ASSIGN_SUB: return Token.SUB; case Token.ASSIGN_MUL: return Token.MUL; case Token.ASSIGN_DIV: return Token.DIV; case Token.ASSIGN_MOD:"
      },
      {
        "txt": "return Token.MOD; } throw new IllegalArgumentException(\"Not an assiment op\"); } static boolean isExpressionNode(Node n) { return n.getType() == Token.EXPR_RESULT; } static boolean containsFunctionDeclaration(Node n) { return containsType(n, Token.FUNCTION); }"
      },
      {
        "txt": "static boolean referencesThis(Node n) { return containsType(n, Token.THIS); } static boolean isGet(Node n) { return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM; } static boolean isGetProp(Node n) { return n.getType() == Token.GETPROP; }"
      },
      {
        "txt": "static boolean isName(Node n) { return n.getType() == Token.NAME; } static boolean isNew(Node n) { return n.getType() == Token.NEW; } static boolean isVar(Node n) { return n.getType() == Token.VAR; } static boolean isVarDeclaration(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR; } static Node getAssignedValue(Node n) { Preconditions.checkState(isName(n)); Node parent = n.getParent(); if (isVar(parent)) { return n.getFirstChild(); } else if (isAssign(parent) && parent.getFirstChild() == n) { return n.getNext(); } else {"
      },
      {
        "txt": "return null; } } static boolean isString(Node n) { return n.getType() == Token.STRING; } static boolean isExprAssign(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN; }"
      },
      {
        "txt": "static boolean isAssign(Node n) { return n.getType() == Token.ASSIGN; } static boolean isExprCall(Node n) { return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL; } static boolean isForIn(Node n) { return n.getType() == Token.FOR && n.getChildCount() == 3;"
      },
      {
        "txt": "} static boolean isLoopStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: return true; default: return false; }"
      },
      {
        "txt": "} static Node getLoopCodeBlock(Node n) { switch (n.getType()) { case Token.FOR: case Token.WHILE: return n.getLastChild(); case Token.DO: return n.getFirstChild(); default: return null;"
      },
      {
        "txt": "} } static boolean isControlStructure(Node n) { switch (n.getType()) { case Token.FOR: case Token.DO: case Token.WHILE: case Token.WITH: case Token.IF: case Token.LABEL:"
      },
      {
        "txt": "case Token.TRY: case Token.CATCH: case Token.SWITCH: case Token.CASE: case Token.DEFAULT: return true; default: return false; } }"
      },
      {
        "txt": "static boolean isControlStructureCodeBlock(Node parent, Node n) { switch (parent.getType()) { case Token.FOR: case Token.WHILE: case Token.LABEL: case Token.WITH: return parent.getLastChild() == n; case Token.DO: return parent.getFirstChild() == n; case Token.IF:"
      },
      {
        "txt": "return parent.getFirstChild() != n; case Token.TRY: return parent.getFirstChild() == n || parent.getLastChild() == n; case Token.CATCH: return parent.getLastChild() == n; case Token.SWITCH: case Token.CASE: return parent.getFirstChild() != n; case Token.DEFAULT: return true;"
      },
      {
        "txt": "default: Preconditions.checkState(isControlStructure(parent)); return false; } } static Node getConditionExpression(Node n) { switch (n.getType()) { case Token.IF: case Token.WHILE: return n.getFirstChild();"
      },
      {
        "txt": "case Token.DO: return n.getLastChild(); case Token.FOR: switch (n.getChildCount()) { case 3: return null; case 4: return n.getFirstChild().getNext(); } throw new IllegalArgumentException(\"malformed 'for' statement \" + n);"
      },
      {
        "txt": "case Token.CASE: return null; } throw new IllegalArgumentException(n + \" does not have a condition.\"); } static boolean isStatementBlock(Node n) { return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK; } static boolean isStatement(Node n) { Node parent = n.getParent();"
      },
      {
        "txt": "Preconditions.checkState(parent != null); switch (parent.getType()) { case Token.SCRIPT: case Token.BLOCK: case Token.LABEL: return true; default: return false; } }"
      },
      {
        "txt": "static boolean isSwitchCase(Node n) { return n.getType() == Token.CASE || n.getType() == Token.DEFAULT; } static boolean isReferenceName(Node n) { return isName(n) && !n.getString().isEmpty() && !isLabelName(n); } static boolean isLabelName(Node n) { if (n != null && n.getType() == Token.NAME) { Node parent = n.getParent(); switch (parent.getType()) {"
      },
      {
        "txt": "case Token.LABEL: case Token.BREAK: case Token.CONTINUE: if (n == parent.getFirstChild()) { return true; } } } return false; }"
      },
      {
        "txt": "static boolean isTryFinallyNode(Node parent, Node child) { return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild(); } static void removeChild(Node parent, Node node) { if (isStatementBlock(parent) || isSwitchCase(node) || isTryFinallyNode(parent, node)) { parent.removeChild(node); } else if (parent.getType() == Token.VAR) {"
      },
      {
        "txt": "if (parent.hasMoreThanOneChild()) { parent.removeChild(node); } else { parent.removeChild(node); removeChild(parent.getParent(), parent); } } else if (node.getType() == Token.BLOCK) { node.detachChildren(); } else if (parent.getType() == Token.LABEL && node == parent.getLastChild()) {"
      },
      {
        "txt": "parent.removeChild(node); removeChild(parent.getParent(), parent); } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) { parent.replaceChild(node, new Node(Token.EMPTY)); } else { throw new IllegalStateException(\"Invalid attempt to remove node: \" + node.toString() + \" of \"+ parent.toString()); } }"
      },
      {
        "txt": "static boolean tryMergeBlock(Node block) { Preconditions.checkState(block.getType() == Token.BLOCK); Node parent = block.getParent(); if (NodeUtil.isStatementBlock(parent)) { Node previous = block; while (block.hasChildren()) { Node child = block.removeFirstChild(); parent.addChildAfter(child, previous); previous = child; }"
      },
      {
        "txt": "parent.removeChild(block); return true; } else if (parent.getType() == Token.LABEL && block.hasOneChild()) { parent.replaceChild(block, block.removeFirstChild()); return true; } else { return false; } } static boolean isCall(Node n) {"
      },
      {
        "txt": "return n.getType() == Token.CALL; } static boolean isFunction(Node n) { return n.getType() == Token.FUNCTION; } static Node getFunctionBody(Node fn) { Preconditions.checkArgument(isFunction(fn)); return fn.getLastChild(); } static boolean isThis(Node node) {"
      },
      {
        "txt": "return node.getType() == Token.THIS; } static boolean containsCall(Node n) { return containsType(n, Token.CALL); } static boolean isFunctionDeclaration(Node n) { return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n); } static boolean isHoistedFunctionDeclaration(Node n) { return NodeUtil.isFunctionDeclaration(n)"
      },
      {
        "txt": "&& (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION); } static boolean isAnonymousFunction(Node n) { return n.getType() == Token.FUNCTION && isFunctionAnonymous(n); } static boolean isFunctionAnonymous(Node n) { return !isStatement(n); } static boolean isVarArgsFunction(Node function) {"
      },
      {
        "txt": "Preconditions.checkArgument(isFunction(function)); return NodeUtil.isNameReferenced( function.getLastChild(), \"arguments\", Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } static boolean isObjectCallMethod(Node callNode, String methodName) { if (callNode.getType() == Token.CALL) { Node functionIndentifyingExpression = callNode.getFirstChild(); if (NodeUtil.isGet(functionIndentifyingExpression)) {"
      },
      {
        "txt": "Node last = functionIndentifyingExpression.getLastChild(); if (last != null && last.getType() == Token.STRING) { String propName = last.getString(); return (propName.equals(methodName)); } } } return false; } static boolean isFunctionObjectCall(Node callNode) {"
      },
      {
        "txt": "return isObjectCallMethod(callNode, \"call\"); } static boolean isFunctionObjectApply(Node callNode) { return isObjectCallMethod(callNode, \"apply\"); } static boolean isSimpleFunctionObjectCall(Node callNode) { if (isFunctionObjectCall(callNode)) { if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) { return true; }"
      },
      {
        "txt": "} return false; } static boolean isLhs(Node n, Node parent) { return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR; } static boolean isObjectLitKey(Node node, Node parent) { if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) { int index = 0;"
      },
      {
        "txt": "for (Node current = parent.getFirstChild(); current != null; current = current.getNext()) { if (current == node) { return index % 2 == 0; } index++; } } return false;"
      },
      {
        "txt": "} static String opToStr(int operator) { switch (operator) { case Token.BITOR: return \"|\"; case Token.OR: return \"||\"; case Token.BITXOR: return \"^\"; case Token.AND: return \"&&\"; case Token.BITAND: return \"&\"; case Token.SHEQ: return \"===\"; case Token.EQ: return \"==\";"
      },
      {
        "txt": "case Token.NOT: return \"!\"; case Token.NE: return \"!=\"; case Token.SHNE: return \"!==\"; case Token.LSH: return \"<<\"; case Token.IN: return \"in\"; case Token.LE: return \"<=\"; case Token.LT: return \"<\"; case Token.URSH: return \">>>\"; case Token.RSH: return \">>\"; case Token.GE: return \">=\";"
      },
      {
        "txt": "case Token.GT: return \">\"; case Token.MUL: return \"*\"; case Token.DIV: return \"/\"; case Token.MOD: return \"%\"; case Token.BITNOT: return \"~\"; case Token.ADD: return \"+\"; case Token.SUB: return \"-\"; case Token.POS: return \"+\"; case Token.NEG: return \"-\"; case Token.ASSIGN: return \"=\";"
      },
      {
        "txt": "case Token.ASSIGN_BITOR: return \"|=\"; case Token.ASSIGN_BITXOR: return \"^=\"; case Token.ASSIGN_BITAND: return \"&=\"; case Token.ASSIGN_LSH: return \"<<=\"; case Token.ASSIGN_RSH: return \">>=\"; case Token.ASSIGN_URSH: return \">>>=\"; case Token.ASSIGN_ADD: return \"+=\"; case Token.ASSIGN_SUB: return \"-=\"; case Token.ASSIGN_MUL: return \"*=\"; case Token.ASSIGN_DIV: return \"/=\";"
      },
      {
        "txt": "case Token.ASSIGN_MOD: return \"%=\"; case Token.VOID: return \"void\"; case Token.TYPEOF: return \"typeof\"; case Token.INSTANCEOF: return \"instanceof\"; default: return null; } } static String opToStrNoFail(int operator) { String res = opToStr(operator); if (res == null) {"
      },
      {
        "txt": "throw new Error(\"Unknown op \" + operator + \": \" + Token.name(operator)); } return res; } static boolean containsTypeInOuterScope(Node node, int type) { return containsType(node, type, Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); } static boolean containsType(Node node,"
      },
      {
        "txt": "int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static boolean containsType(Node node, int type) { return containsType(node, type, Predicates.<Node>alwaysTrue()); } static void redeclareVarsInsideBranch(Node branch) { Collection<Node> vars = getVarsDeclaredInBranch(branch); if (vars.isEmpty()) {"
      },
      {
        "txt": "return; } Node parent = getAddingRoot(branch); for (Node nameNode : vars) { Node var = new Node( Token.VAR, Node.newString(Token.NAME, nameNode.getString())); copyNameAnnotations(nameNode, var.getFirstChild()); parent.addChildToFront(var); } }"
      },
      {
        "txt": "static void copyNameAnnotations(Node source, Node destination) { if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } private static Node getAddingRoot(Node n) { Node addingRoot = null; Node ancestor = n; while (null != (ancestor = ancestor.getParent())) { int type = ancestor.getType();"
      },
      {
        "txt": "if (type == Token.SCRIPT) { addingRoot = ancestor; break; } else if (type == Token.FUNCTION) { addingRoot = ancestor.getLastChild(); break; } } Preconditions.checkState(addingRoot.getType() == Token.BLOCK || addingRoot.getType() == Token.SCRIPT);"
      },
      {
        "txt": "Preconditions.checkState(addingRoot.getFirstChild() == null || addingRoot.getFirstChild().getType() != Token.SCRIPT); return addingRoot; } public static FunctionNode newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) { Node parameterParen = new Node(Token.LP, lineno, charno); for (Node param : params) { parameterParen.addChildToBack(param); }"
      },
      {
        "txt": "FunctionNode function = new FunctionNode(name, lineno, charno); function.addChildrenToBack( Node.newString(Token.NAME, name, lineno, charno)); function.addChildToBack(parameterParen); function.addChildToBack(body); return function; } public static Node newQualifiedNameNode(String name, int lineno, int charno) { int endPos = name.indexOf('.'); if (endPos == -1) {"
      },
      {
        "txt": "return Node.newString(Token.NAME, name, lineno, charno); } Node node = Node.newString(Token.NAME, name.substring(0, endPos), lineno, charno); int startPos; do { startPos = endPos + 1; endPos = name.indexOf('.', startPos); String part = (endPos == -1 ? name.substring(startPos)"
      },
      {
        "txt": ": name.substring(startPos, endPos)); node = new Node(Token.GETPROP, node, Node.newString(Token.STRING, part, lineno, charno), lineno, charno); } while (endPos != -1); return node; } static Node newQualifiedNameNode(String name, Node basisNode, String originalName) { Node node = newQualifiedNameNode(name, -1, -1);"
      },
      {
        "txt": "setDebugInformation(node, basisNode, originalName); return node; } static void setDebugInformation(Node node, Node basisNode, String originalName) { node.copyInformationFromForTree(basisNode); node.putProp(Node.ORIGINALNAME_PROP, originalName); } static Node newName(String name, Node basisNode) { Node nameNode = Node.newString(Token.NAME, name);"
      },
      {
        "txt": "nameNode.copyInformationFrom(basisNode); return nameNode; } static Node newName(String name, Node basisNode, String originalName) { Node nameNode = newName(name, basisNode); nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); return nameNode; } static boolean isLatin(String s) { char LARGEST_BASIC_LATIN = 0x7f;"
      },
      {
        "txt": "int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c > LARGEST_BASIC_LATIN) { return false; } } return true; } static boolean isValidPropertyName(String name) {"
      },
      {
        "txt": "return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && NodeUtil.isLatin(name); } private static class VarCollector implements Visitor { final Map<String, Node> vars = Maps.newLinkedHashMap(); public void visit(Node n) { if (n.getType() == Token.NAME) { Node parent = n.getParent(); if (parent != null && parent.getType() == Token.VAR) {"
      },
      {
        "txt": "String name = n.getString(); if (!vars.containsKey(name)) { vars.put(name, n); } } } } } public static Collection<Node> getVarsDeclaredInBranch(Node root) { VarCollector collector = new VarCollector();"
      },
      {
        "txt": "visitPreOrder( root, collector, Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION))); return collector.vars.values(); } static boolean isPrototypePropertyDeclaration(Node n) { if (!NodeUtil.isExprAssign(n)) { return false; }"
      },
      {
        "txt": "return isPrototypeProperty(n.getFirstChild().getFirstChild()); } static boolean isPrototypeProperty(Node n) { String lhsString = n.getQualifiedName(); if (lhsString == null) { return false; } int prototypeIdx = lhsString.indexOf(\".prototype.\"); return prototypeIdx != -1; }"
      },
      {
        "txt": "static Node getPrototypeClassName(Node qName) { Node cur = qName; while (isGetProp(cur)) { if (cur.getLastChild().getString().equals(\"prototype\")) { return cur.getFirstChild(); } else { cur = cur.getFirstChild(); } } return null;"
      },
      {
        "txt": "} static String getPrototypePropertyName(Node qName) { String qNameStr = qName.getQualifiedName(); int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\"); int memberIndex = prototypeIdx + \".prototype\".length() + 1; return qNameStr.substring(memberIndex); } static Node newUndefinedNode() { return new Node(Token.VOID, Node.newNumber(0)); }"
      },
      {
        "txt": "static Node newVarNode(String name, Node value) { Node nodeName = Node.newString(Token.NAME, name); if (value != null) { nodeName.addChildrenToBack(value); } Node var = new Node(Token.VAR, nodeName); return var; } private static class MatchNameNode implements Predicate<Node>{ final String name;"
      },
      {
        "txt": "MatchNameNode(String name){ this.name = name; } public boolean apply(Node n) { return n.getType() == Token.NAME && n.getString().equals(name); } } static class MatchNodeType implements Predicate<Node>{ final int type;"
      },
      {
        "txt": "MatchNodeType(int type){ this.type = type; } public boolean apply(Node n) { return n.getType() == type; } } static boolean isNodeTypeReferenced(Node node, int type) { return isNodeTypeReferenced(node, type, Predicates.<Node>alwaysTrue()); }"
      },
      {
        "txt": "static boolean isNodeTypeReferenced( Node node, int type, Predicate<Node> traverseChildrenPred) { return has(node, new MatchNodeType(type), traverseChildrenPred); } static int getNodeTypeReferenceCount(Node node, int type) { return getCount(node, new MatchNodeType(type)); } static boolean isNameReferenced(Node node, String name, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "return has(node, new MatchNameNode(name), traverseChildrenPred); } static boolean isNameReferenced(Node node, String name) { return isNameReferenced(node, name, Predicates.<Node>alwaysTrue()); } static int getNameReferenceCount(Node node, String name) { return getCount(node, new MatchNameNode(name) ); } static boolean has(Node node, Predicate<Node> pred,"
      },
      {
        "txt": "Predicate<Node> traverseChildrenPred) { if (pred.apply(node)) { return true; } if (!traverseChildrenPred.apply(node)) { return false; } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { if (has(c, pred, traverseChildrenPred)) { return true;"
      },
      {
        "txt": "} } return false; } static int getCount(Node n, Predicate<Node> pred) { int total = 0; if (pred.apply(n)) { total++; } for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {"
      },
      {
        "txt": "total += getCount(c, pred); } return total; } static interface Visitor { void visit(Node node); } static void visitPreOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "vistor.visit(node); if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPreOrder(c, vistor, traverseChildrenPred); } } } static void visitPostOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {"
      },
      {
        "txt": "if (traverseChildrenPred.apply(node)) { for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { visitPostOrder(c, vistor, traverseChildrenPred); } } vistor.visit(node); } static boolean hasFinally(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getChildCount() == 3;"
      },
      {
        "txt": "} static Node getCatchBlock(Node n) { Preconditions.checkArgument(n.getType() == Token.TRY); return n.getFirstChild().getNext(); } static boolean hasCatchHandler(Node n) { Preconditions.checkArgument(n.getType() == Token.BLOCK); return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH; } static Node getFnParameters(Node fnNode) {"
      },
      {
        "txt": "Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION); return fnNode.getFirstChild().getNext(); } static boolean isConstantName(Node node) { return node.getBooleanProp(Node.IS_CONSTANT_NAME); } static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null; Node parent = null; if (nameNode != null) {"
      },
      {
        "txt": "info = nameNode.getJSDocInfo(); parent = nameNode.getParent(); } if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); } return info; }"
      },
      {
        "txt": "static String getSourceName(Node n) { String sourceName = null; while (sourceName == null && n != null) { sourceName = (String) n.getProp(Node.SOURCENAME_PROP); n = n.getParent(); } return sourceName; }"
      }
    ]
  },
  {
    "id": 561,
    "file_path": "src/com/google/javascript/jscomp/PureFunctionIdentifier.java",
    "start-bug-line": 177,
    "end-bug-line": 177,
    "bug": "",
    "fix": "if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.DefinitionsRemover.Definition; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.jscomp.graph.LinkedDirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; class PureFunctionIdentifier implements CompilerPass { static final DiagnosticType INVALID_NO_SIDE_EFFECT_ANNOTATION = DiagnosticType.error("
      },
      {
        "txt": "\"JSC_INVALID_NO_SIDE_EFFECT_ANNOTATION\", \"@nosideeffects may only appear in externs files.\"); private final AbstractCompiler compiler; private final DefinitionProvider definitionProvider; private final Map<Node, FunctionInformation> functionSideEffectMap; private final List<Node> allFunctionCalls; private Node externs; private Node root; public PureFunctionIdentifier(AbstractCompiler compiler, DefinitionProvider definitionProvider) {"
      },
      {
        "txt": "this.compiler = compiler; this.definitionProvider = definitionProvider; this.functionSideEffectMap = Maps.newHashMap(); this.allFunctionCalls = Lists.newArrayList(); this.externs = null; this.root = null; } @Override public void process(Node externsAst, Node srcAst) { if (externs != null || root != null) {"
      },
      {
        "txt": "throw new IllegalStateException( \"It is illegal to call PureFunctionIdentifier.process \" + \"twice the same instance. Please use a new \" + \"PureFunctionIdentifier instance each time.\"); } externs = externsAst; root = srcAst; NodeTraversal.traverse(compiler, externs, new FunctionAnalyzer(true)); NodeTraversal.traverse(compiler, root, new FunctionAnalyzer(false)); propagateSideEffects();"
      },
      {
        "txt": "markPureFunctionCalls(); } String getDebugReport() { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); StringBuilder sb = new StringBuilder(); FunctionNames functionNames = new FunctionNames(compiler); functionNames.process(null, externs); functionNames.process(null, root); sb.append(\"Pure functions:\\n\");"
      },
      {
        "txt": "for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { Node function = entry.getKey(); FunctionInformation functionInfo = entry.getValue(); boolean isPure = functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects(); if (isPure) { sb.append(\" \" + functionNames.getFunctionName(function) + \"\\n\"); } }"
      },
      {
        "txt": "sb.append(\"\\n\"); for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { Node function = entry.getKey(); FunctionInformation functionInfo = entry.getValue(); Set<String> depFunctionNames = Sets.newHashSet(); for (Node callSite : functionInfo.getCallsInFunctionBody()) { Collection<Definition> defs = getCallableDefinitions(definitionProvider, callSite.getFirstChild());"
      },
      {
        "txt": "if (defs == null) { depFunctionNames.add(\"<null def list>\"); continue; } for (Definition def : defs) { depFunctionNames.add( functionNames.getFunctionName(def.getRValue())); } } sb.append(functionNames.getFunctionName(function) + \" \" +"
      },
      {
        "txt": "\" Calls: \" + depFunctionNames + \"\\n\"); } return sb.toString(); } private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { <extra_id_0> if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; } Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) {"
      },
      {
        "txt": "definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) { return null; } for (Definition current : decls) { Node rValue = current.getRValue(); if ((rValue != null) && NodeUtil.isFunction(rValue)) { result.add(current); } else { return null;"
      },
      {
        "txt": "} } return result; } private void propagateSideEffects() { DiGraph<FunctionInformation, Node> sideEffectGraph = new LinkedDirectedGraph<FunctionInformation, Node>(); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { sideEffectGraph.createNode(functionInfo); }"
      },
      {
        "txt": "for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (!functionInfo.mayHaveSideEffects()) { continue; } for (Node callSite : functionInfo.getCallsInFunctionBody()) { Node callee = callSite.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, callee); if (defs == null) { functionInfo.setTaintsUnknown();"
      },
      {
        "txt": "break; } for (Definition def : defs) { Node defValue = def.getRValue(); FunctionInformation dep = functionSideEffectMap.get(defValue); Preconditions.checkNotNull(dep); sideEffectGraph.connect(dep, callSite, functionInfo); } } }"
      },
      {
        "txt": "FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback()) .computeFixedPoint(sideEffectGraph); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (functionInfo.mayBePure()) { functionInfo.setIsPure(); } } } private void markPureFunctionCalls() { for (Node callNode : allFunctionCalls) {"
      },
      {
        "txt": "Node name = callNode.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, name); if (defs == null) { continue; } boolean hasSideEffects = false; for (Definition def : defs) { FunctionInformation functionInfo = functionSideEffectMap.get(def.getRValue());"
      },
      {
        "txt": "Preconditions.checkNotNull(functionInfo); if ((NodeUtil.isCall(callNode) && functionInfo.mayHaveSideEffects()) || (NodeUtil.isNew(callNode) && (functionInfo.mutatesGlobalState() || functionInfo.functionThrows()))) { hasSideEffects = true; break; } } if (!hasSideEffects) { callNode.setIsNoSideEffectsCall();"
      },
      {
        "txt": "} } } private class FunctionAnalyzer implements Callback { private final boolean inExterns; FunctionAnalyzer(boolean inExterns) { this.inExterns = inExterns; } @Override public boolean shouldTraverse(NodeTraversal traversal,"
      },
      {
        "txt": "Node node, Node parent) { if (NodeUtil.isFunction(node)) { Node gramp = parent.getParent(); visitFunction(traversal, node, parent, gramp); } return true; } @Override public void visit(NodeTraversal traversal, Node node, Node parent) {"
      },
      {
        "txt": "if (inExterns) { return; } if (!NodeUtil.nodeTypeMayHaveSideEffects(node)) { return; } if (NodeUtil.isCall(node) || NodeUtil.isNew(node)) { allFunctionCalls.add(node); } Node enclosingFunction = traversal.getEnclosingFunction();"
      },
      {
        "txt": "if (enclosingFunction != null) { FunctionInformation sideEffectInfo = functionSideEffectMap.get(enclosingFunction); Preconditions.checkNotNull(sideEffectInfo); if (NodeUtil.isAssignmentOp(node)) { visitAssignmentOrUnaryOperatorLhs( sideEffectInfo, traversal.getScope(), node.getFirstChild()); } else { switch(node.getType()) { case Token.CALL:"
      },
      {
        "txt": "case Token.NEW: visitCall(sideEffectInfo, node); break; case Token.DELPROP: case Token.DEC: case Token.INC: visitAssignmentOrUnaryOperatorLhs( sideEffectInfo, traversal.getScope(), node.getFirstChild()); break; case Token.NAME:"
      },
      {
        "txt": "Preconditions.checkArgument( NodeUtil.isVarDeclaration(node)); break; case Token.THROW: visitThrow(sideEffectInfo); break; default: throw new IllegalArgumentException( \"Unhandled side effect node type \" + Token.name(node.getType()));"
      },
      {
        "txt": "} } } } private void visitAssignmentOrUnaryOperatorLhs( FunctionInformation sideEffectInfo, Scope scope, Node lhs) { if (NodeUtil.isName(lhs)) { Var var = scope.getVar(lhs.getString()); if (var == null || var.scope != scope) { sideEffectInfo.setTaintsGlobalState();"
      },
      {
        "txt": "} } else if (NodeUtil.isGetProp(lhs)) { if (NodeUtil.isThis(lhs.getFirstChild())) { sideEffectInfo.setTaintsThis(); } else { sideEffectInfo.setTaintsUnknown(); } } else { sideEffectInfo.setTaintsUnknown(); }"
      },
      {
        "txt": "} private void visitCall(FunctionInformation sideEffectInfo, Node node) { sideEffectInfo.appendCall(node); } private void visitFunction(NodeTraversal traversal, Node node, Node parent, Node gramp) { Preconditions.checkArgument(!functionSideEffectMap.containsKey(node)); FunctionInformation sideEffectInfo = new FunctionInformation(inExterns);"
      },
      {
        "txt": "functionSideEffectMap.put(node, sideEffectInfo); if (hasNoSideEffectsAnnotation(node, parent, gramp)) { if (inExterns) { sideEffectInfo.setIsPure(); } else { traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION); } } else if (inExterns) { sideEffectInfo.setTaintsGlobalState(); }"
      },
      {
        "txt": "} private void visitThrow(FunctionInformation sideEffectInfo) { sideEffectInfo.setFunctionThrows(); } private boolean hasNoSideEffectsAnnotation(Node node, Node parent, Node gramp) { { JSDocInfo docInfo = node.getJSDocInfo(); if (docInfo != null && docInfo.isNoSideEffects()) {"
      },
      {
        "txt": "return true; } } if (NodeUtil.isName(parent)) { JSDocInfo docInfo = gramp.getJSDocInfo(); return gramp.hasOneChild() && docInfo != null && docInfo.isNoSideEffects(); } else if (NodeUtil.isAssign(parent)) { JSDocInfo docInfo = parent.getJSDocInfo();"
      },
      {
        "txt": "return docInfo != null && docInfo.isNoSideEffects(); } else { return false; } } } private static class SideEffectPropagationCallback implements EdgeCallback<FunctionInformation, Node> { public boolean traverseEdge(FunctionInformation callee, Node callSite,"
      },
      {
        "txt": "FunctionInformation caller) { Preconditions.checkArgument(callSite.getType() == Token.CALL || callSite.getType() == Token.NEW); boolean changed = false; if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) { caller.setTaintsGlobalState(); changed = true; } if (!caller.functionThrows() && callee.functionThrows()) { caller.setFunctionThrows();"
      },
      {
        "txt": "changed = true; } if (callee.mutatesThis()) { if (callSite.getType() != Token.NEW) { Node objectNode = getCallThisObject(callSite); if (objectNode != null && NodeUtil.isThis(objectNode)) { if (!caller.mutatesThis()) { caller.setTaintsThis(); changed = true; }"
      },
      {
        "txt": "} else if (!caller.mutatesGlobalState()) { caller.setTaintsGlobalState(); changed = true; } } } return changed; } } private static Node getCallThisObject(Node callSite) {"
      },
      {
        "txt": "Node foo = callSite.getFirstChild(); if (!NodeUtil.isGetProp(foo)) { return null; } Node object = null; String propString = foo.getLastChild().getString(); if (propString.equals(\"call\") || propString.equals(\"apply\")) { return foo.getNext(); } else { return foo.getFirstChild();"
      },
      {
        "txt": "} } private static class FunctionInformation { private final boolean extern; private final List<Node> callsInFunctionBody = Lists.newArrayList(); private boolean pureFunction = false; private boolean functionThrows = false; private boolean taintsGlobalState = false; private boolean taintsThis = false; private boolean taintsUnknown = false;"
      },
      {
        "txt": "FunctionInformation(boolean extern) { this.extern = extern; checkInvariant(); } boolean isExtern() { return extern; } boolean mayBePure() { return !(functionThrows || taintsGlobalState ||"
      },
      {
        "txt": "taintsThis || taintsUnknown); } boolean mayHaveSideEffects() { return !pureFunction; } void setIsPure() { pureFunction = true; checkInvariant(); }"
      },
      {
        "txt": "void setTaintsGlobalState() { taintsGlobalState = true; checkInvariant(); } void setTaintsThis() { taintsThis = true; checkInvariant(); } void setFunctionThrows() { functionThrows = true;"
      },
      {
        "txt": "checkInvariant(); } void setTaintsUnknown() { taintsUnknown = true; checkInvariant(); } boolean mutatesGlobalState() { return taintsGlobalState || taintsUnknown; } boolean mutatesThis() {"
      },
      {
        "txt": "return taintsThis; } boolean functionThrows() { return functionThrows; } private void checkInvariant() { boolean invariant = mayBePure() || mayHaveSideEffects(); if (!invariant) { throw new IllegalStateException(\"Invariant failed. \" + toString()); }"
      },
      {
        "txt": "} void appendCall(Node callNode) { callsInFunctionBody.add(callNode); } List<Node> getCallsInFunctionBody() { return callsInFunctionBody; } @Override public String toString() { List<String> status = Lists.newArrayList();"
      },
      {
        "txt": "if (extern) { status.add(\"extern\"); } if (pureFunction) { status.add(\"pure\"); } if (taintsThis) { status.add(\"this\"); } if (taintsGlobalState) {"
      },
      {
        "txt": "status.add(\"global\"); } if (functionThrows) { status.add(\"throw\"); } if (taintsUnknown) { status.add(\"complex\"); } return \"Side effects: \" + status.toString(); }"
      }
    ]
  },
  {
    "id": 562,
    "file_path": "src/com/google/javascript/jscomp/PureFunctionIdentifier.java",
    "start-bug-line": 179,
    "end-bug-line": 181,
    "bug": "if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists;"
      },
      {
        "txt": "import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.DefinitionsRemover.Definition; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.rhino.JSDocInfo;"
      },
      {
        "txt": "import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; class PureFunctionIdentifier implements CompilerPass { static final DiagnosticType INVALID_NO_SIDE_EFFECT_ANNOTATION = DiagnosticType.error( \"JSC_INVALID_NO_SIDE_EFFECT_ANNOTATION\","
      },
      {
        "txt": "\"@nosideeffects may only appear in externs files.\"); private final AbstractCompiler compiler; private final DefinitionProvider definitionProvider; private final Map<Node, FunctionInformation> functionSideEffectMap; private final List<Node> allFunctionCalls; private Node externs; private Node root; public PureFunctionIdentifier(AbstractCompiler compiler, DefinitionProvider definitionProvider) { this.compiler = compiler;"
      },
      {
        "txt": "this.definitionProvider = definitionProvider; this.functionSideEffectMap = Maps.newHashMap(); this.allFunctionCalls = Lists.newArrayList(); this.externs = null; this.root = null; } @Override public void process(Node externsAst, Node srcAst) { if (externs != null || root != null) { throw new IllegalStateException("
      },
      {
        "txt": "\"It is illegal to call PureFunctionIdentifier.process \" + \"twice the same instance. Please use a new \" + \"PureFunctionIdentifier instance each time.\"); } externs = externsAst; root = srcAst; NodeTraversal.traverse(compiler, externs, new FunctionAnalyzer(true)); NodeTraversal.traverse(compiler, root, new FunctionAnalyzer(false)); propagateSideEffects(); markPureFunctionCalls();"
      },
      {
        "txt": "} String getDebugReport() { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); StringBuilder sb = new StringBuilder(); FunctionNames functionNames = new FunctionNames(compiler); functionNames.process(null, externs); functionNames.process(null, root); sb.append(\"Pure functions:\\n\"); for (Map.Entry<Node, FunctionInformation> entry :"
      },
      {
        "txt": "functionSideEffectMap.entrySet()) { Node function = entry.getKey(); FunctionInformation functionInfo = entry.getValue(); boolean isPure = functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects(); if (isPure) { sb.append(\" \" + functionNames.getFunctionName(function) + \"\\n\"); } } sb.append(\"\\n\");"
      },
      {
        "txt": "for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { Node function = entry.getKey(); FunctionInformation functionInfo = entry.getValue(); Set<String> depFunctionNames = Sets.newHashSet(); for (Node callSite : functionInfo.getCallsInFunctionBody()) { Collection<Definition> defs = getCallableDefinitions(definitionProvider, callSite.getFirstChild()); if (defs == null) {"
      },
      {
        "txt": "depFunctionNames.add(\"<null def list>\"); continue; } for (Definition def : defs) { depFunctionNames.add( functionNames.getFunctionName(def.getRValue())); } } sb.append(functionNames.getFunctionName(function) + \" \" + functionInfo.toString() +"
      },
      {
        "txt": "} return sb.toString(); } private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { List<Definition> result = Lists.newArrayList(); <extra_id_0> Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) { return null; } for (Definition current : decls) {"
      },
      {
        "txt": "} for (Definition current : decls) { Node rValue = current.getRValue(); if ((rValue != null) && NodeUtil.isFunction(rValue)) { result.add(current); } else { return null; } } return result;"
      },
      {
        "txt": "} private void propagateSideEffects() { DiGraph<FunctionInformation, Node> sideEffectGraph = new LinkedDirectedGraph<FunctionInformation, Node>(); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { sideEffectGraph.createNode(functionInfo); } for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (!functionInfo.mayHaveSideEffects()) { continue;"
      },
      {
        "txt": "} for (Node callSite : functionInfo.getCallsInFunctionBody()) { Node callee = callSite.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, callee); if (defs == null) { functionInfo.setTaintsUnknown(); break; } for (Definition def : defs) {"
      },
      {
        "txt": "Node defValue = def.getRValue(); FunctionInformation dep = functionSideEffectMap.get(defValue); Preconditions.checkNotNull(dep); sideEffectGraph.connect(dep, callSite, functionInfo); } } } FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback()) .computeFixedPoint(sideEffectGraph); for (FunctionInformation functionInfo : functionSideEffectMap.values()) {"
      },
      {
        "txt": "if (functionInfo.mayBePure()) { functionInfo.setIsPure(); } } } private void markPureFunctionCalls() { for (Node callNode : allFunctionCalls) { Node name = callNode.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, name);"
      },
      {
        "txt": "if (defs == null) { continue; } boolean hasSideEffects = false; for (Definition def : defs) { FunctionInformation functionInfo = functionSideEffectMap.get(def.getRValue()); Preconditions.checkNotNull(functionInfo); if ((NodeUtil.isCall(callNode) && functionInfo.mayHaveSideEffects()) || (NodeUtil.isNew(callNode) && (functionInfo.mutatesGlobalState() ||"
      },
      {
        "txt": "functionInfo.functionThrows()))) { hasSideEffects = true; break; } } if (!hasSideEffects) { callNode.setIsNoSideEffectsCall(); } } }"
      },
      {
        "txt": "private class FunctionAnalyzer implements Callback { private final boolean inExterns; FunctionAnalyzer(boolean inExterns) { this.inExterns = inExterns; } @Override public boolean shouldTraverse(NodeTraversal traversal, Node node, Node parent) { if (NodeUtil.isFunction(node)) {"
      },
      {
        "txt": "Node gramp = parent.getParent(); visitFunction(traversal, node, parent, gramp); } return true; } @Override public void visit(NodeTraversal traversal, Node node, Node parent) { if (inExterns) { return; }"
      },
      {
        "txt": "if (!NodeUtil.nodeTypeMayHaveSideEffects(node)) { return; } if (NodeUtil.isCall(node) || NodeUtil.isNew(node)) { allFunctionCalls.add(node); } Node enclosingFunction = traversal.getEnclosingFunction(); if (enclosingFunction != null) { FunctionInformation sideEffectInfo = functionSideEffectMap.get(enclosingFunction);"
      },
      {
        "txt": "Preconditions.checkNotNull(sideEffectInfo); if (NodeUtil.isAssignmentOp(node)) { visitAssignmentOrUnaryOperatorLhs( sideEffectInfo, traversal.getScope(), node.getFirstChild()); } else { switch(node.getType()) { case Token.CALL: case Token.NEW: visitCall(sideEffectInfo, node); break;"
      },
      {
        "txt": "case Token.DELPROP: case Token.DEC: case Token.INC: visitAssignmentOrUnaryOperatorLhs( sideEffectInfo, traversal.getScope(), node.getFirstChild()); break; case Token.NAME: Preconditions.checkArgument( NodeUtil.isVarDeclaration(node)); break;"
      },
      {
        "txt": "case Token.THROW: visitThrow(sideEffectInfo); break; default: throw new IllegalArgumentException( \"Unhandled side effect node type \" + Token.name(node.getType())); } } }"
      },
      {
        "txt": "} private void visitAssignmentOrUnaryOperatorLhs( FunctionInformation sideEffectInfo, Scope scope, Node lhs) { if (NodeUtil.isName(lhs)) { Var var = scope.getVar(lhs.getString()); if (var == null || var.scope != scope) { sideEffectInfo.setTaintsGlobalState(); } } else if (NodeUtil.isGetProp(lhs)) { if (NodeUtil.isThis(lhs.getFirstChild())) {"
      },
      {
        "txt": "sideEffectInfo.setTaintsThis(); } else { sideEffectInfo.setTaintsUnknown(); } } else { sideEffectInfo.setTaintsUnknown(); } } private void visitCall(FunctionInformation sideEffectInfo, Node node) { sideEffectInfo.appendCall(node);"
      },
      {
        "txt": "} private void visitFunction(NodeTraversal traversal, Node node, Node parent, Node gramp) { Preconditions.checkArgument(!functionSideEffectMap.containsKey(node)); FunctionInformation sideEffectInfo = new FunctionInformation(inExterns); functionSideEffectMap.put(node, sideEffectInfo); if (hasNoSideEffectsAnnotation(node, parent, gramp)) { if (inExterns) {"
      },
      {
        "txt": "sideEffectInfo.setIsPure(); } else { traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION); } } else if (inExterns) { sideEffectInfo.setTaintsGlobalState(); } } private void visitThrow(FunctionInformation sideEffectInfo) { sideEffectInfo.setFunctionThrows();"
      },
      {
        "txt": "} private boolean hasNoSideEffectsAnnotation(Node node, Node parent, Node gramp) { { JSDocInfo docInfo = node.getJSDocInfo(); if (docInfo != null && docInfo.isNoSideEffects()) { return true; } }"
      },
      {
        "txt": "if (NodeUtil.isName(parent)) { JSDocInfo docInfo = gramp.getJSDocInfo(); return gramp.hasOneChild() && docInfo != null && docInfo.isNoSideEffects(); } else if (NodeUtil.isAssign(parent)) { JSDocInfo docInfo = parent.getJSDocInfo(); return docInfo != null && docInfo.isNoSideEffects(); } else { return false;"
      },
      {
        "txt": "} } } private static class SideEffectPropagationCallback implements EdgeCallback<FunctionInformation, Node> { public boolean traverseEdge(FunctionInformation callee, Node callSite, FunctionInformation caller) { Preconditions.checkArgument(callSite.getType() == Token.CALL || callSite.getType() == Token.NEW);"
      },
      {
        "txt": "boolean changed = false; if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) { caller.setTaintsGlobalState(); changed = true; } if (!caller.functionThrows() && callee.functionThrows()) { caller.setFunctionThrows(); changed = true; } if (callee.mutatesThis()) {"
      },
      {
        "txt": "if (callSite.getType() != Token.NEW) { Node objectNode = getCallThisObject(callSite); if (objectNode != null && NodeUtil.isThis(objectNode)) { if (!caller.mutatesThis()) { caller.setTaintsThis(); changed = true; } } else if (!caller.mutatesGlobalState()) { caller.setTaintsGlobalState(); changed = true;"
      },
      {
        "txt": "} } } return changed; } } private static Node getCallThisObject(Node callSite) { Node foo = callSite.getFirstChild(); if (!NodeUtil.isGetProp(foo)) { return null;"
      },
      {
        "txt": "} Node object = null; String propString = foo.getLastChild().getString(); if (propString.equals(\"call\") || propString.equals(\"apply\")) { return foo.getNext(); } else { return foo.getFirstChild(); } } private static class FunctionInformation {"
      },
      {
        "txt": "private final boolean extern; private final List<Node> callsInFunctionBody = Lists.newArrayList(); private boolean pureFunction = false; private boolean functionThrows = false; private boolean taintsGlobalState = false; private boolean taintsThis = false; private boolean taintsUnknown = false; FunctionInformation(boolean extern) { this.extern = extern; checkInvariant();"
      },
      {
        "txt": "} boolean isExtern() { return extern; } boolean mayBePure() { return !(functionThrows || taintsGlobalState || taintsThis || taintsUnknown); }"
      },
      {
        "txt": "boolean mayHaveSideEffects() { return !pureFunction; } void setIsPure() { pureFunction = true; checkInvariant(); } void setTaintsGlobalState() { taintsGlobalState = true; checkInvariant();"
      },
      {
        "txt": "} void setTaintsThis() { taintsThis = true; checkInvariant(); } void setFunctionThrows() { functionThrows = true; checkInvariant(); } void setTaintsUnknown() {"
      },
      {
        "txt": "taintsUnknown = true; checkInvariant(); } boolean mutatesGlobalState() { return taintsGlobalState || taintsUnknown; } boolean mutatesThis() { return taintsThis; } boolean functionThrows() {"
      },
      {
        "txt": "return functionThrows; } private void checkInvariant() { boolean invariant = mayBePure() || mayHaveSideEffects(); if (!invariant) { throw new IllegalStateException(\"Invariant failed. \" + toString()); } } void appendCall(Node callNode) { callsInFunctionBody.add(callNode);"
      },
      {
        "txt": "} List<Node> getCallsInFunctionBody() { return callsInFunctionBody; } @Override public String toString() { List<String> status = Lists.newArrayList(); if (extern) { status.add(\"extern\"); }"
      },
      {
        "txt": "if (pureFunction) { status.add(\"pure\"); } if (taintsThis) { status.add(\"this\"); } if (taintsGlobalState) { status.add(\"global\"); } if (functionThrows) {"
      },
      {
        "txt": "status.add(\"throw\"); } if (taintsUnknown) { status.add(\"complex\"); } return \"Side effects: \" + status.toString(); } }"
      }
    ]
  },
  {
    "id": 563,
    "file_path": "src/com/google/javascript/jscomp/PureFunctionIdentifier.java",
    "start-bug-line": 198,
    "end-bug-line": 198,
    "bug": "",
    "fix": "} else if (name.getType() == Token.OR || name.getType() == Token.HOOK) { Node firstVal; if (name.getType() == Token.HOOK) { firstVal = name.getFirstChild().getNext(); } else { firstVal = name.getFirstChild(); }  Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal); Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext()); if (defs1 != null && defs2 != null) { defs1.addAll(defs2); return defs1; } else { return null; } } else { return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.DefinitionsRemover.Definition; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; class PureFunctionIdentifier implements CompilerPass {"
      },
      {
        "txt": "static final DiagnosticType INVALID_NO_SIDE_EFFECT_ANNOTATION = DiagnosticType.error( \"JSC_INVALID_NO_SIDE_EFFECT_ANNOTATION\", \"@nosideeffects may only appear in externs files.\"); private final AbstractCompiler compiler; private final DefinitionProvider definitionProvider; private final Map<Node, FunctionInformation> functionSideEffectMap; private final List<Node> allFunctionCalls; private Node externs; private Node root;"
      },
      {
        "txt": "public PureFunctionIdentifier(AbstractCompiler compiler, DefinitionProvider definitionProvider) { this.compiler = compiler; this.definitionProvider = definitionProvider; this.functionSideEffectMap = Maps.newHashMap(); this.allFunctionCalls = Lists.newArrayList(); this.externs = null; this.root = null; } @Override"
      },
      {
        "txt": "public void process(Node externsAst, Node srcAst) { if (externs != null || root != null) { throw new IllegalStateException( \"It is illegal to call PureFunctionIdentifier.process \" + \"twice the same instance. Please use a new \" + \"PureFunctionIdentifier instance each time.\"); } externs = externsAst; root = srcAst; NodeTraversal.traverse(compiler, externs, new FunctionAnalyzer(true));"
      },
      {
        "txt": "NodeTraversal.traverse(compiler, root, new FunctionAnalyzer(false)); propagateSideEffects(); markPureFunctionCalls(); } String getDebugReport() { Preconditions.checkNotNull(externs); Preconditions.checkNotNull(root); StringBuilder sb = new StringBuilder(); FunctionNames functionNames = new FunctionNames(compiler); functionNames.process(null, externs);"
      },
      {
        "txt": "functionNames.process(null, root); sb.append(\"Pure functions:\\n\"); for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { Node function = entry.getKey(); FunctionInformation functionInfo = entry.getValue(); boolean isPure = functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects(); if (isPure) { sb.append(\" \" + functionNames.getFunctionName(function) + \"\\n\");"
      },
      {
        "txt": "} } sb.append(\"\\n\"); for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { Node function = entry.getKey(); FunctionInformation functionInfo = entry.getValue(); Set<String> depFunctionNames = Sets.newHashSet(); for (Node callSite : functionInfo.getCallsInFunctionBody()) { Collection<Definition> defs ="
      },
      {
        "txt": "getCallableDefinitions(definitionProvider, callSite.getFirstChild()); if (defs == null) { depFunctionNames.add(\"<null def list>\"); continue; } for (Definition def : defs) { depFunctionNames.add( functionNames.getFunctionName(def.getRValue())); }"
      },
      {
        "txt": "} sb.append(functionNames.getFunctionName(function) + \" \" + functionInfo.toString() + \" Calls: \" + depFunctionNames + \"\\n\"); } return sb.toString(); } private static Collection<Definition> getCallableDefinitions( DefinitionProvider definitionProvider, Node name) { List<Definition> result = Lists.newArrayList();"
      },
      {
        "txt": "if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) { return null; } Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); if (decls == null) { return null; } for (Definition current : decls) { Node rValue = current.getRValue();"
      },
      {
        "txt": "result.add(current); } else { return null; } } return result; <extra_id_0> private void propagateSideEffects() { DiGraph<FunctionInformation, Node> sideEffectGraph = new LinkedDirectedGraph<FunctionInformation, Node>(); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { sideEffectGraph.createNode(functionInfo); }"
      },
      {
        "txt": "sideEffectGraph.createNode(functionInfo); } for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (!functionInfo.mayHaveSideEffects()) { continue; } for (Node callSite : functionInfo.getCallsInFunctionBody()) { Node callee = callSite.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, callee);"
      },
      {
        "txt": "if (defs == null) { functionInfo.setTaintsUnknown(); break; } for (Definition def : defs) { Node defValue = def.getRValue(); FunctionInformation dep = functionSideEffectMap.get(defValue); Preconditions.checkNotNull(dep); sideEffectGraph.connect(dep, callSite, functionInfo); }"
      },
      {
        "txt": "} } FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback()) .computeFixedPoint(sideEffectGraph); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (functionInfo.mayBePure()) { functionInfo.setIsPure(); } } }"
      },
      {
        "txt": "private void markPureFunctionCalls() { for (Node callNode : allFunctionCalls) { Node name = callNode.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, name); if (defs == null) { continue; } boolean hasSideEffects = false; for (Definition def : defs) {"
      },
      {
        "txt": "FunctionInformation functionInfo = functionSideEffectMap.get(def.getRValue()); Preconditions.checkNotNull(functionInfo); if ((NodeUtil.isCall(callNode) && functionInfo.mayHaveSideEffects()) || (NodeUtil.isNew(callNode) && (functionInfo.mutatesGlobalState() || functionInfo.functionThrows()))) { hasSideEffects = true; break; } }"
      },
      {
        "txt": "if (!hasSideEffects) { callNode.setIsNoSideEffectsCall(); } } } private class FunctionAnalyzer implements Callback { private final boolean inExterns; FunctionAnalyzer(boolean inExterns) { this.inExterns = inExterns; }"
      },
      {
        "txt": "@Override public boolean shouldTraverse(NodeTraversal traversal, Node node, Node parent) { if (NodeUtil.isFunction(node)) { Node gramp = parent.getParent(); visitFunction(traversal, node, parent, gramp); } return true; }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal traversal, Node node, Node parent) { if (inExterns) { return; } if (!NodeUtil.nodeTypeMayHaveSideEffects(node)) { return; } if (NodeUtil.isCall(node) || NodeUtil.isNew(node)) { allFunctionCalls.add(node);"
      },
      {
        "txt": "} Node enclosingFunction = traversal.getEnclosingFunction(); if (enclosingFunction != null) { FunctionInformation sideEffectInfo = functionSideEffectMap.get(enclosingFunction); Preconditions.checkNotNull(sideEffectInfo); if (NodeUtil.isAssignmentOp(node)) { visitAssignmentOrUnaryOperatorLhs( sideEffectInfo, traversal.getScope(), node.getFirstChild()); } else {"
      },
      {
        "txt": "switch(node.getType()) { case Token.CALL: case Token.NEW: visitCall(sideEffectInfo, node); break; case Token.DELPROP: case Token.DEC: case Token.INC: visitAssignmentOrUnaryOperatorLhs( sideEffectInfo, traversal.getScope(), node.getFirstChild());"
      },
      {
        "txt": "break; case Token.NAME: Preconditions.checkArgument( NodeUtil.isVarDeclaration(node)); break; case Token.THROW: visitThrow(sideEffectInfo); break; default: throw new IllegalArgumentException("
      },
      {
        "txt": "\"Unhandled side effect node type \" + Token.name(node.getType())); } } } } private void visitAssignmentOrUnaryOperatorLhs( FunctionInformation sideEffectInfo, Scope scope, Node lhs) { if (NodeUtil.isName(lhs)) { Var var = scope.getVar(lhs.getString());"
      },
      {
        "txt": "if (var == null || var.scope != scope) { sideEffectInfo.setTaintsGlobalState(); } } else if (NodeUtil.isGetProp(lhs)) { if (NodeUtil.isThis(lhs.getFirstChild())) { sideEffectInfo.setTaintsThis(); } else { sideEffectInfo.setTaintsUnknown(); } } else {"
      },
      {
        "txt": "sideEffectInfo.setTaintsUnknown(); } } private void visitCall(FunctionInformation sideEffectInfo, Node node) { sideEffectInfo.appendCall(node); } private void visitFunction(NodeTraversal traversal, Node node, Node parent, Node gramp) {"
      },
      {
        "txt": "Preconditions.checkArgument(!functionSideEffectMap.containsKey(node)); FunctionInformation sideEffectInfo = new FunctionInformation(inExterns); functionSideEffectMap.put(node, sideEffectInfo); if (hasNoSideEffectsAnnotation(node, parent, gramp)) { if (inExterns) { sideEffectInfo.setIsPure(); } else { traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION); } } else if (inExterns) {"
      },
      {
        "txt": "sideEffectInfo.setTaintsGlobalState(); } } private void visitThrow(FunctionInformation sideEffectInfo) { sideEffectInfo.setFunctionThrows(); } private boolean hasNoSideEffectsAnnotation(Node node, Node parent, Node gramp) { {"
      },
      {
        "txt": "JSDocInfo docInfo = node.getJSDocInfo(); if (docInfo != null && docInfo.isNoSideEffects()) { return true; } } if (NodeUtil.isName(parent)) { JSDocInfo docInfo = gramp.getJSDocInfo(); return gramp.hasOneChild() && docInfo != null && docInfo.isNoSideEffects();"
      },
      {
        "txt": "} else if (NodeUtil.isAssign(parent)) { JSDocInfo docInfo = parent.getJSDocInfo(); return docInfo != null && docInfo.isNoSideEffects(); } else { return false; } } } private static class SideEffectPropagationCallback implements EdgeCallback<FunctionInformation, Node> {"
      },
      {
        "txt": "public boolean traverseEdge(FunctionInformation callee, Node callSite, FunctionInformation caller) { Preconditions.checkArgument(callSite.getType() == Token.CALL || callSite.getType() == Token.NEW); boolean changed = false; if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) { caller.setTaintsGlobalState(); changed = true; }"
      },
      {
        "txt": "if (!caller.functionThrows() && callee.functionThrows()) { caller.setFunctionThrows(); changed = true; } if (callee.mutatesThis()) { if (callSite.getType() != Token.NEW) { Node objectNode = getCallThisObject(callSite); if (objectNode != null && NodeUtil.isThis(objectNode)) { if (!caller.mutatesThis()) { caller.setTaintsThis();"
      },
      {
        "txt": "changed = true; } } else if (!caller.mutatesGlobalState()) { caller.setTaintsGlobalState(); changed = true; } } } return changed; }"
      },
      {
        "txt": "} private static Node getCallThisObject(Node callSite) { Node foo = callSite.getFirstChild(); if (!NodeUtil.isGetProp(foo)) { return null; } Node object = null; String propString = foo.getLastChild().getString(); if (propString.equals(\"call\") || propString.equals(\"apply\")) { return foo.getNext();"
      },
      {
        "txt": "} else { return foo.getFirstChild(); } } private static class FunctionInformation { private final boolean extern; private final List<Node> callsInFunctionBody = Lists.newArrayList(); private boolean pureFunction = false; private boolean functionThrows = false; private boolean taintsGlobalState = false;"
      },
      {
        "txt": "private boolean taintsThis = false; private boolean taintsUnknown = false; FunctionInformation(boolean extern) { this.extern = extern; checkInvariant(); } boolean isExtern() { return extern; } boolean mayBePure() {"
      },
      {
        "txt": "return !(functionThrows || taintsGlobalState || taintsThis || taintsUnknown); } boolean mayHaveSideEffects() { return !pureFunction; } void setIsPure() { pureFunction = true;"
      },
      {
        "txt": "checkInvariant(); } void setTaintsGlobalState() { taintsGlobalState = true; checkInvariant(); } void setTaintsThis() { taintsThis = true; checkInvariant(); }"
      },
      {
        "txt": "void setFunctionThrows() { functionThrows = true; checkInvariant(); } void setTaintsUnknown() { taintsUnknown = true; checkInvariant(); } boolean mutatesGlobalState() { return taintsGlobalState || taintsUnknown;"
      },
      {
        "txt": "} boolean mutatesThis() { return taintsThis; } boolean functionThrows() { return functionThrows; } private void checkInvariant() { boolean invariant = mayBePure() || mayHaveSideEffects(); if (!invariant) {"
      },
      {
        "txt": "throw new IllegalStateException(\"Invariant failed. \" + toString()); } } void appendCall(Node callNode) { callsInFunctionBody.add(callNode); } List<Node> getCallsInFunctionBody() { return callsInFunctionBody; } @Override"
      },
      {
        "txt": "public String toString() { List<String> status = Lists.newArrayList(); if (extern) { status.add(\"extern\"); } if (pureFunction) { status.add(\"pure\"); } if (taintsThis) { status.add(\"this\");"
      },
      {
        "txt": "} if (taintsGlobalState) { status.add(\"global\"); } if (functionThrows) { status.add(\"throw\"); } if (taintsUnknown) { status.add(\"complex\"); }"
      },
      {
        "txt": "return \"Side effects: \" + status.toString(); } }"
      }
    ]
  }
]