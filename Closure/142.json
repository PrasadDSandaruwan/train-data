[
  {
    "id": 564,
    "file_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
    "start-bug-line": 108,
    "end-bug-line": 108,
    "bug": "",
    "fix": "if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) { liveness.markAllParametersEscaped(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback; import com.google.javascript.jscomp.ControlFlowGraph.Branch;"
      },
      {
        "txt": "import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.jscomp.graph.GraphColoring; import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;"
      },
      {
        "txt": "import com.google.javascript.jscomp.graph.UndiGraph; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.ArrayList; import java.util.Comparator; import java.util.Deque; import java.util.Iterator; import java.util.Set; class CoalesceVariableNames extends AbstractPostOrderCallback implements CompilerPass, ScopedCallback {"
      },
      {
        "txt": "private final AbstractCompiler compiler; private final Deque<GraphColoring<Var, Void>> colorings; private final boolean usePseudoNames; private static final Comparator<Var> coloringTieBreaker = new Comparator<Var>() { public int compare(Var v1, Var v2) { return v1.index - v2.index; } }; CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {"
      },
      {
        "txt": "this.compiler = compiler; colorings = Lists.newLinkedList(); this.usePseudoNames = usePseudoNames; } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); } @Override public void enterScope(NodeTraversal t) {"
      },
      {
        "txt": "if (scope.isGlobal()) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler); <extra_id_0> UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph( t, cfg, liveness.getEscapedLocals()); GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);"
      },
      {
        "txt": "new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker); coloring.color(); colorings.push(coloring); } @Override public void exitScope(NodeTraversal t) { if (t.inGlobalScope()) { return; }"
      },
      {
        "txt": "colorings.pop(); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (colorings.isEmpty() || !NodeUtil.isName(n) || NodeUtil.isFunction(parent)) { return; } Var var = t.getScope().getVar(n.getString()); GraphNode<Var, ?> vNode = colorings.peek().getGraph().getNode(var);"
      },
      {
        "txt": "if (vNode == null) { return; } Var coalescedVar = colorings.peek().getPartitionSuperNode(var); if (!usePseudoNames) { if (vNode.getValue().equals(coalescedVar)) { return; } n.setString(coalescedVar.name); compiler.reportCodeChange();"
      },
      {
        "txt": "if (NodeUtil.isVar(parent)) { removeVarDeclaration(n); } } else { String pseudoName = null; Set<String> allMergedNames = Sets.newTreeSet(); for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) { Var iVar = i.next(); if (colorings.peek().getGraph().getNode(iVar) != null && coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {"
      },
      {
        "txt": "allMergedNames.add(iVar.name); } } if (allMergedNames.size() == 1) { return; } pseudoName = Joiner.on(\"_\").join(allMergedNames); while (t.getScope().isDeclared(pseudoName, true)) { pseudoName += \"$\"; }"
      },
      {
        "txt": "n.setString(pseudoName); compiler.reportCodeChange(); if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) { removeVarDeclaration(n); } } } private UndiGraph<Var, Void> computeVariableNamesInterferenceGraph( NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) { UndiGraph<Var, Void> interferenceGraph ="
      },
      {
        "txt": "new LinkedUndirectedGraph<Var, Void>(); Scope scope = t.getScope(); for (Iterator<Var> i = scope.getVars(); i.hasNext();) { Var v = i.next(); if (!escaped.contains(v)) { if (!NodeUtil.isFunction(v.getParentNode())) { interferenceGraph.createNode(v); } } }"
      },
      {
        "txt": "for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) { FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); if (cfg.isImplicitReturn(cfgNode)) { continue; } int varsInScope = scope.getVarCount(); ArrayList<CombinedLiveRangeChecker> rangesToCheck = new ArrayList<CombinedLiveRangeChecker>( varsInScope * varsInScope); for (Iterator<Var> i1 = scope.getVars(); i1.hasNext();) {"
      },
      {
        "txt": "Var v1 = i1.next(); for (Iterator<Var> i2 = scope.getVars(); i2.hasNext();) { Var v2 = i2.next(); if (v1 == v2 || !interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) { continue; } boolean v1OutLive = state.getOut().isLive(v1); boolean v2OutLive = state.getOut().isLive(v2); if (v1.getParentNode().getType() == Token.LP &&"
      },
      {
        "txt": "v2.getParentNode().getType() == Token.LP) { interferenceGraph.connectIfNotFound(v1, null, v2); } else if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) || (v1OutLive && v2OutLive)) { interferenceGraph.connectIfNotFound(v1, null, v2); } else { LiveRangeChecker checker1 = new LiveRangeChecker(v1, v2OutLive ? null : v2); LiveRangeChecker checker2 = new LiveRangeChecker(v2, v1OutLive ? null : v1);"
      },
      {
        "txt": "rangesToCheck.add(new CombinedLiveRangeChecker(checker1, checker2)); } } } checkRanges(rangesToCheck, cfgNode.getValue()); for (CombinedLiveRangeChecker range : rangesToCheck) { range.connectIfCrossed(interferenceGraph); } } return interferenceGraph;"
      },
      {
        "txt": "} private void checkRanges( ArrayList<CombinedLiveRangeChecker> rangesToCheck, Node root) { CombinedCfgNodeLiveRangeChecker callbacks = new CombinedCfgNodeLiveRangeChecker(rangesToCheck); NodeTraversal.traverse(compiler, root, callbacks); } private static class CombinedCfgNodeLiveRangeChecker extends AbstractCfgNodeTraversalCallback { private final ArrayList<CombinedLiveRangeChecker> callbacks;"
      },
      {
        "txt": "CombinedCfgNodeLiveRangeChecker( ArrayList<CombinedLiveRangeChecker> callbacks) { this.callbacks = callbacks; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (CombinedLiveRangeChecker.shouldVisit(n)) { for (CombinedLiveRangeChecker callback : callbacks) { callback.visit(t, n, parent); }"
      },
      {
        "txt": "} } } private static class CombinedLiveRangeChecker extends AbstractCfgNodeTraversalCallback { private final LiveRangeChecker callback1; private final LiveRangeChecker callback2; CombinedLiveRangeChecker( LiveRangeChecker callback1, LiveRangeChecker callback2) {"
      },
      {
        "txt": "this.callback1 = callback1; this.callback2 = callback2; } public static boolean shouldVisit(Node n) { return LiveRangeChecker.shouldVisit(n); } @Override public void visit(NodeTraversal t, Node n, Node parent) { callback1.visit(t, n, parent); callback2.visit(t, n, parent);"
      },
      {
        "txt": "} void connectIfCrossed(UndiGraph<Var, Void> interferenceGraph) { if (callback1.crossed || callback2.crossed) { Var v1 = callback1.getDef(); Var v2 = callback2.getDef(); interferenceGraph.connectIfNotFound(v1, null, v2); } } } private void removeVarDeclaration(Node name) {"
      },
      {
        "txt": "Node var = name.getParent(); Node parent = var.getParent(); if (NodeUtil.isForIn(parent)) { var.removeChild(name); parent.replaceChild(var, name); } else if (var.getChildCount() == 1) { if (name.hasChildren()) { Node value = name.removeFirstChild(); var.removeChild(name); Node assign = new Node(Token.ASSIGN, name, value);"
      },
      {
        "txt": "if (parent.getType() != Token.FOR) { assign = NodeUtil.newExpr(assign); } parent.replaceChild(var, assign); } else { NodeUtil.removeChild(parent, var); } } else { if (!name.hasChildren()) { var.removeChild(name);"
      },
      {
        "txt": "} } } private static class LiveRangeChecker extends AbstractCfgNodeTraversalCallback { boolean defFound = false; boolean crossed = false; private final Var def; private final Var use; public LiveRangeChecker(Var def, Var use) {"
      },
      {
        "txt": "this.def = def; this.use = use; } Var getDef() { return def; } public static boolean shouldVisit(Node n) { return (NodeUtil.isName(n) || (n.hasChildren() && NodeUtil.isName(n.getFirstChild()))); }"
      },
      {
        "txt": "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (!defFound && isAssignTo(def, n, parent)) { defFound = true; } if (defFound && (use == null || isReadFrom(use, n))) { crossed = true; } } private static boolean isAssignTo(Var var, Node n, Node parent) {"
      },
      {
        "txt": "if (NodeUtil.isName(n) && var.getName().equals(n.getString()) && parent != null) { if (parent.getType() == Token.LP) { return true; } else if (NodeUtil.isVar(parent)) { return n.hasChildren(); } return false; // Definitely a read. } else { Node name = n.getFirstChild();"
      },
      {
        "txt": "return name != null && NodeUtil.isName(name) && var.getName().equals(name.getString()) && NodeUtil.isAssignmentOp(n); } } private static boolean isReadFrom(Var var, Node name) { return name != null && NodeUtil.isName(name) && var.getName().equals(name.getString()) && !NodeUtil.isLhs(name, name.getParent()); }"
      }
    ]
  },
  {
    "id": 565,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1168,
    "end-bug-line": 1168,
    "bug": "",
    "fix": "if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node;"
      },
      {
        "txt": "import com.google.javascript.rhino.ScriptRuntime; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import java.util.HashSet; import java.util.Map; import java.util.Set; public final class JsDocInfoParser {"
      },
      {
        "txt": "private final JsDocTokenStream stream; private final JSTypeRegistry typeRegistry; private final JSDocInfoBuilder jsdocBuilder; private final String sourceName; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private class ErrorReporterParser { void addWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),"
      },
      {
        "txt": "sourceName, lineno, null, charno); } void addWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames;"
      },
      {
        "txt": "private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder; void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION,"
      },
      {
        "txt": "SEARCHING_NEWLINE, NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, String sourceName, Config config, ErrorReporter errorReporter) { this.stream = stream; this.sourceName = sourceName; this.typeRegistry = config.registry;"
      },
      {
        "txt": "this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); this.annotationNames = config.annotationNames; this.errorReporter = errorReporter; } public static Node parseTypeString(String typeString) { Config config = new Config( new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false); JsDocInfoParser parser = new JsDocInfoParser("
      },
      {
        "txt": "new JsDocTokenStream(typeString), \"typeparsing\", config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno; JSTypeExpression type;"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; JsDocToken token = next(); ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (blockInfo.string.length() > 0) { jsdocBuilder.recordBlockDescription(blockInfo.string); } retry: for (;;) { switch (token) { case ANNOTATION:"
      },
      {
        "txt": "if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author);"
      },
      {
        "txt": "} token = authorInfo.token; continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string;"
      },
      {
        "txt": "if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addWarning(\"msg.jsdoc.desc.extra\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry;"
      },
      {
        "txt": "} case FILE_OVERVIEW: ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); String fileOverview = fileOverviewInfo.string; if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = fileOverviewInfo.token; continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) {"
      },
      {
        "txt": "if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "} token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addWarning(\"msg.jsdoc.javadispatch\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { if (!jsdocBuilder.recordBaseType(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "} else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next(); if (matchingRc) {"
      },
      {
        "txt": "if (token != JsDocToken.RC) { parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else {"
      },
      {
        "txt": "parser.addWarning(\"msg.no.type.name\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordOverride()) { parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno();"
      },
      {
        "txt": "charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } }"
      },
      {
        "txt": "token = current(); jsdocBuilder.recordThrowType(type); ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; continue retry;"
      },
      {
        "txt": "case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) {"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token;"
      },
      {
        "txt": "if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next();"
      },
      {
        "txt": "if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type);"
      },
      {
        "txt": "} } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addWarning(\"msg.jsdoc.incompat.type\", name,"
      },
      {
        "txt": "lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); ExtractionInfo paramDescriptionInfo ="
      },
      {
        "txt": "extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC:"
      },
      {
        "txt": "if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string;"
      },
      {
        "txt": "if (reference.length() == 0) { parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; continue retry; case SUPPRESS: token = parseSuppressTag(next());"
      },
      {
        "txt": "continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addWarning(\"msg.jsdoc.template.at.most.once\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} else { if (!jsdocBuilder.recordVersion(version)) { parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN:"
      },
      {
        "txt": "case THIS: case TYPE: case TYPEDEF: skipEOLs(); lineno = stream.getLineno(); charno = stream.getCharno(); token = next(); Node typeNode = parseAndRecordTypeNode(token, lineno, charno); if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode);"
      },
      {
        "txt": "if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE: if (!isValidDefineType(typeNode)) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno); } else if (!jsdocBuilder.recordDefineType(type)) { parser.addWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addWarning("
      },
      {
        "txt": "\"msg.jsdoc.incompat.type\", lineno, charno); break; } token = current(); ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription);"
      },
      {
        "txt": "} token = returnDescriptionInfo.token; continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE:"
      },
      {
        "txt": "if (!jsdocBuilder.recordType(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "break; } token = eatTokensUntilEOL(); } continue retry; } } } break; case EOC:"
      },
      {
        "txt": "if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } return true; case EOF: jsdocBuilder.build(null); parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); return false; case EOL:"
      },
      {
        "txt": "if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else {"
      },
      {
        "txt": "state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) {"
      },
      {
        "txt": "Set<String> suppressions = new HashSet<String>(); while (true) { if (match(JsDocToken.STRING)) { suppressions.add(stream.getString()); token = next(); } else { parser.addWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; }"
      },
      {
        "txt": "if (match(JsDocToken.PIPE)) { token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "token = next(); if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private Node parseAndRecordTypeNode(JsDocToken token) {"
      },
      {
        "txt": "return parseAndRecordTypeNode(token, token == JsDocToken.LC); } private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno) { return parseAndRecordTypeNode(token, lineno, startCharno, token == JsDocToken.LC, false);"
      },
      {
        "txt": "} private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token);"
      },
      {
        "txt": "int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null;"
      },
      {
        "txt": "if (onlyParseSimpleNames) { typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,"
      },
      {
        "txt": "matchingLC); return typeNode; } private boolean isValidDefineType(Node typeNode) { JSType type = typeRegistry.createFromTypeNodes(typeNode, \"\", null); return !type.isUnknownType() && type.isSubtype( typeRegistry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN)); } private String toString(JsDocToken token) { switch (token) {"
      },
      {
        "txt": "case ANNOTATION: return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\";"
      },
      {
        "txt": "case LB: return \"[\"; case LC: return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\";"
      },
      {
        "txt": "case PIPE: return \"|\"; case RB: return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\";"
      },
      {
        "txt": "case ELLIPSIS: return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } }"
      },
      {
        "txt": "private JSTypeExpression createJSTypeExpression(Node n) { return n == null ? null : new JSTypeExpression(n, sourceName, typeRegistry); } private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token;"
      },
      {
        "txt": "} public String getString() { return string; } public JsDocToken getToken() { return token; } } private ExtractionInfo extractSingleLineBlock() { stream.update();"
      },
      {
        "txt": "int lineno = stream.getLineno(); int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {"
      },
      {
        "txt": "return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); } private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {"
      },
      {
        "txt": "if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim();"
      },
      {
        "txt": "} StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (!ignoreStar) {"
      },
      {
        "txt": "if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\");"
      },
      {
        "txt": "ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: <extra_id_0> if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) {"
      },
      {
        "txt": "int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); }"
      },
      {
        "txt": "} while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) { case ANNOTATION: case EOC: case EOF:"
      },
      {
        "txt": "return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue;"
      },
      {
        "txt": "case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false;"
      },
      {
        "txt": "builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true); } private static String trimEnd(String s) { int trimCount = 0;"
      },
      {
        "txt": "while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; } } if (trimCount == 0) { return s;"
      },
      {
        "txt": "} return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeExpression(token); } }"
      },
      {
        "txt": "private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY)); }"
      },
      {
        "txt": "restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs();"
      },
      {
        "txt": "typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; }"
      },
      {
        "txt": "private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next();"
      },
      {
        "txt": "} } return typeNode; } else { return parseTypeName(token); } } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) {"
      },
      {
        "txt": "if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } }"
      },
      {
        "txt": "return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; } Node typeList = new Node(Token.BLOCK); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr); } return typeList; }"
      },
      {
        "txt": "private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { return wrapNode(Token.QMARK, parseBasicTypeExpression(next())); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next();"
      },
      {
        "txt": "return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs();"
      },
      {
        "txt": "return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token);"
      },
      {
        "txt": "} } return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } Node typeName = newStringNode(stream.getString()); if (match(JsDocToken.LT)) {"
      },
      {
        "txt": "next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeName.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next();"
      },
      {
        "txt": "} } return typeName; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null;"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING && \"this\".equals(stream.getString())) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node thisType = wrapNode(Token.THIS, parseTypeName(next())); if (thisType == null) {"
      },
      {
        "txt": "return null; } functionType.addChildToFront(thisType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} else { hasParams = false; } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } }"
      },
      {
        "txt": "} if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next());"
      },
      {
        "txt": "if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.LP); boolean isVarArgs = false;"
      },
      {
        "txt": "Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token);"
      },
      {
        "txt": "if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType);"
      },
      {
        "txt": "if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; }"
      },
      {
        "txt": "private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID);"
      },
      {
        "txt": "} else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) {"
      },
      {
        "txt": "union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE;"
      },
      {
        "txt": "if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; }"
      },
      {
        "txt": "union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union;"
      },
      {
        "txt": "} private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; }"
      },
      {
        "txt": "array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next();"
      },
      {
        "txt": "return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token);"
      },
      {
        "txt": "if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON);"
      },
      {
        "txt": "fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default:"
      },
      {
        "txt": "return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "private Node newStringNode(String s) { return Node.newString(s, stream.getLineno(), stream.getCharno()); } private Node reportTypeSyntaxWarning(String warning) { parser.addWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); }"
      },
      {
        "txt": "private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; }"
      },
      {
        "txt": "token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) {"
      },
      {
        "txt": "unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); } }"
      },
      {
        "txt": "private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next();"
      },
      {
        "txt": "} } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() {"
      },
      {
        "txt": "return jsdocBuilder.build(sourceName); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; }"
      }
    ]
  },
  {
    "id": 566,
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
    "start-bug-line": 1183,
    "end-bug-line": 1183,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp.parsing; import com.google.common.base.Preconditions; import com.google.common.collect.Sets; import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfoBuilder; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.ScriptRuntime;"
      },
      {
        "txt": "import com.google.javascript.rhino.Token; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import java.util.HashSet; import java.util.Map; import java.util.Set; public final class JsDocInfoParser { private final JsDocTokenStream stream;"
      },
      {
        "txt": "private final JSTypeRegistry typeRegistry; private final JSDocInfoBuilder jsdocBuilder; private final String sourceName; private final ErrorReporter errorReporter; private final ErrorReporterParser parser = new ErrorReporterParser(); private class ErrorReporterParser { void addWarning(String messageId, String messageArg, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno);"
      },
      {
        "txt": "} void addWarning(String messageId, int lineno, int charno) { errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno); } } private JSDocInfo fileOverviewJSDocInfo = null; private State state; private final Map<String, Annotation> annotationNames; private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;"
      },
      {
        "txt": "void setFileLevelJsDocBuilder( Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; } void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; } private enum State { SEARCHING_ANNOTATION, SEARCHING_NEWLINE,"
      },
      {
        "txt": "NEXT_IS_ANNOTATION } JsDocInfoParser(JsDocTokenStream stream, String sourceName, Config config, ErrorReporter errorReporter) { this.stream = stream; this.sourceName = sourceName; this.typeRegistry = config.registry; this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);"
      },
      {
        "txt": "this.annotationNames = config.annotationNames; this.errorReporter = errorReporter; } public static Node parseTypeString(String typeString) { Config config = new Config( new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false); JsDocInfoParser parser = new JsDocInfoParser( new JsDocTokenStream(typeString),"
      },
      {
        "txt": "\"typeparsing\", config, NullErrorReporter.forNewRhino()); return parser.parseTopLevelTypeExpression(parser.next()); } boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION;"
      },
      {
        "txt": "JsDocToken token = next(); ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (blockInfo.string.length() > 0) { jsdocBuilder.recordBlockDescription(blockInfo.string); } retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) {"
      },
      {
        "txt": "state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno);"
      },
      {
        "txt": "switch (annotation) { case AUTHOR: ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); }"
      },
      {
        "txt": "token = authorInfo.token; continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR:"
      },
      {
        "txt": "if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else { parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) {"
      },
      {
        "txt": "jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; }"
      },
      {
        "txt": "case FILE_OVERVIEW: ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); String fileOverview = fileOverviewInfo.string; if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = fileOverviewInfo.token; continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) {"
      },
      {
        "txt": "fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null;"
      },
      {
        "txt": "if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\"number\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS:"
      },
      {
        "txt": "if (!jsdocBuilder.recordExterns()) { parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false;"
      },
      {
        "txt": "if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode);"
      },
      {
        "txt": "if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { if (!jsdocBuilder.recordBaseType(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } } else {"
      },
      {
        "txt": "Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno()); } } else { parser.addWarning(\"msg.no.type.name\", lineno, charno);"
      },
      {
        "txt": "} token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry;"
      },
      {
        "txt": "case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addWarning(\"msg.jsdoc.nocheck\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno();"
      },
      {
        "txt": "type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current();"
      },
      {
        "txt": "jsdocBuilder.recordThrowType(type); ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; continue retry; case PARAM:"
      },
      {
        "txt": "skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) {"
      },
      {
        "txt": "token = next(); } if (JsDocToken.STRING != token) { parser.addWarning(\"msg.missing.variable.name\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) {"
      },
      {
        "txt": "token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); }"
      },
      {
        "txt": "} if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno); } else { parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);"
      },
      {
        "txt": "} } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);"
      },
      {
        "txt": "String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addWarning(\"msg.jsdoc.preservertry\","
      },
      {
        "txt": "stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL();"
      },
      {
        "txt": "continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case IMPLICIT_CAST:"
      },
      {
        "txt": "if (!jsdocBuilder.recordImplicitCast()) { parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) {"
      },
      {
        "txt": "parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry;"
      },
      {
        "txt": "case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());"
      },
      {
        "txt": "} token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno()); } else {"
      },
      {
        "txt": "if (!jsdocBuilder.recordVersion(version)) { parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS:"
      },
      {
        "txt": "case TYPE: case TYPEDEF: skipEOLs(); lineno = stream.getLineno(); charno = stream.getCharno(); token = next(); Node typeNode = parseAndRecordTypeNode(token, lineno, charno); if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) {"
      },
      {
        "txt": "typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch (annotation) { case DEFINE: if (!isValidDefineType(typeNode)) { parser.addWarning(\"msg.jsdoc.define.badtype\","
      },
      {
        "txt": "lineno, charno); } else if (!jsdocBuilder.recordDefineType(type)) { parser.addWarning(\"msg.jsdoc.define\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno);"
      },
      {
        "txt": "break; } token = current(); ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); }"
      },
      {
        "txt": "token = returnDescriptionInfo.token; continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) {"
      },
      {
        "txt": "parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addWarning( \"msg.jsdoc.incompat.type\", lineno, charno); } break;"
      },
      {
        "txt": "} token = eatTokensUntilEOL(); } continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) {"
      },
      {
        "txt": "fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } return true; case EOF: jsdocBuilder.build(null); parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno()); return false; case EOL: if (state == State.SEARCHING_NEWLINE) {"
      },
      {
        "txt": "state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE;"
      },
      {
        "txt": "token = eatTokensUntilEOL(); continue retry; } } token = next(); } } private JsDocToken parseSuppressTag(JsDocToken token) { if (token == JsDocToken.LC) { Set<String> suppressions = new HashSet<String>();"
      },
      {
        "txt": "while (true) { if (match(JsDocToken.STRING)) { suppressions.add(stream.getString()); token = next(); } else { parser.addWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); return token; } if (match(JsDocToken.PIPE)) {"
      },
      {
        "txt": "token = next(); } else { break; } } if (!match(JsDocToken.RC)) { parser.addWarning(\"msg.jsdoc.suppress\", stream.getLineno(), stream.getCharno()); } else { token = next();"
      },
      {
        "txt": "if (!jsdocBuilder.recordSuppressions(suppressions)) { parser.addWarning(\"msg.jsdoc.suppress.duplicate\", stream.getLineno(), stream.getCharno()); } } } return token; } private Node parseAndRecordTypeNode(JsDocToken token) { return parseAndRecordTypeNode(token, token == JsDocToken.LC);"
      },
      {
        "txt": "} private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno) { return parseAndRecordTypeNode(token, lineno, startCharno, token == JsDocToken.LC, false); }"
      },
      {
        "txt": "private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); } private Node parseAndRecordParamTypeNode(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); int lineno = stream.getLineno(); int startCharno = stream.getCharno(); Node typeNode = parseParamTypeExpressionAnnotation(token); int endCharno = stream.getCharno();"
      },
      {
        "txt": "jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true); return typeNode; } private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { Node typeNode = null; if (onlyParseSimpleNames) {"
      },
      {
        "txt": "typeNode = parseTypeNameAnnotation(token); } else { typeNode = parseTypeExpressionAnnotation(token); } if (typeNode != null && !matchingLC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } int endCharno = stream.getCharno(); jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, matchingLC);"
      },
      {
        "txt": "return typeNode; } private boolean isValidDefineType(Node typeNode) { JSType type = typeRegistry.createFromTypeNodes(typeNode, \"\", null); return !type.isUnknownType() && type.isSubtype( typeRegistry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN)); } private String toString(JsDocToken token) { switch (token) { case ANNOTATION:"
      },
      {
        "txt": "return \"@\" + stream.getString(); case BANG: return \"!\"; case COMMA: return \",\"; case COLON: return \":\"; case GT: return \">\"; case LB:"
      },
      {
        "txt": "return \"[\"; case LC: return \"{\"; case LP: return \"(\"; case LT: return \".<\"; case QMARK: return \"?\"; case PIPE:"
      },
      {
        "txt": "return \"|\"; case RB: return \"]\"; case RC: return \"}\"; case RP: return \")\"; case STAR: return \"*\"; case ELLIPSIS:"
      },
      {
        "txt": "return \"...\"; case EQUALS: return \"=\"; case STRING: return stream.getString(); default: throw new IllegalStateException(token.toString()); } } private JSTypeExpression createJSTypeExpression(Node n) {"
      },
      {
        "txt": "return n == null ? null : new JSTypeExpression(n, sourceName, typeRegistry); } private static class ExtractionInfo { private final String string; private final JsDocToken token; public ExtractionInfo(String string, JsDocToken token) { this.string = string; this.token = token; }"
      },
      {
        "txt": "public String getString() { return string; } public JsDocToken getToken() { return token; } } private ExtractionInfo extractSingleLineBlock() { stream.update(); int lineno = stream.getLineno();"
      },
      {
        "txt": "int charno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine().trim(); if (line.length() > 0) { jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); } return new ExtractionInfo(line, next()); } private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);"
      },
      {
        "txt": "} private enum WhitespaceOption { PRESERVE, TRIM, SINGLE_LINE } @SuppressWarnings(\"fallthrough\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL ||"
      },
      {
        "txt": "token == JsDocToken.EOF) { return new ExtractionInfo(\"\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); }"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch (token) { case STAR: if (!ignoreStar) { if (builder.length() > 0) {"
      },
      {
        "txt": "builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\"\\n\"); }"
      },
      {
        "txt": "ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); }"
      },
      {
        "txt": "int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); <extra_id_0> default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); }"
      },
      {
        "txt": "builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); }"
      },
      {
        "txt": "} while (true); } private ExtractionInfo extractBlockComment(JsDocToken token) { StringBuilder builder = new StringBuilder(); boolean ignoreStar = true; do { switch (token) { case ANNOTATION: case EOC: case EOF:"
      },
      {
        "txt": "return new ExtractionInfo(builder.toString().trim(), token); case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue;"
      },
      {
        "txt": "case EOL: ignoreStar = true; builder.append('\\n'); token = next(); continue; default: if (!ignoreStar && builder.length() > 0) { builder.append(' '); } ignoreStar = false;"
      },
      {
        "txt": "builder.append(toString(token)); String line = stream.getRemainingJSDocLine(); line = trimEnd(line); builder.append(line); token = next(); } } while (true); } private static String trimEnd(String s) { int trimCount = 0;"
      },
      {
        "txt": "while (trimCount < s.length()) { char ch = s.charAt(s.length() - trimCount - 1); if (Character.isWhitespace(ch)) { trimCount++; } else { break; } } if (trimCount == 0) { return s;"
      },
      {
        "txt": "} return s.substring(0, s.length() - trimCount); } private Node parseTypeExpressionAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTopLevelTypeExpression(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; } else { return parseTypeExpression(token); } }"
      },
      {
        "txt": "private Node parseParamTypeExpressionAnnotation(JsDocToken token) { Preconditions.checkArgument(token == JsDocToken.LC); skipEOLs(); boolean restArg = false; token = next(); if (token == JsDocToken.ELLIPSIS) { token = next(); if (token == JsDocToken.RC) { return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY)); }"
      },
      {
        "txt": "restArg = true; } Node typeNode = parseTopLevelTypeExpression(token); if (typeNode != null) { skipEOLs(); if (restArg) { typeNode = wrapNode(Token.ELLIPSIS, typeNode); } else if (match(JsDocToken.EQUALS)) { next(); skipEOLs();"
      },
      {
        "txt": "typeNode = wrapNode(Token.EQUALS, typeNode); } if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next(); } } return typeNode; }"
      },
      {
        "txt": "private Node parseTypeNameAnnotation(JsDocToken token) { if (token == JsDocToken.LC) { skipEOLs(); Node typeNode = parseTypeName(next()); if (typeNode != null) { skipEOLs(); if (!match(JsDocToken.RC)) { reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } else { next();"
      },
      {
        "txt": "} } return typeNode; } else { return parseTypeName(token); } } private Node parseTopLevelTypeExpression(JsDocToken token) { Node typeExpr = parseTypeExpression(token); if (typeExpr != null) {"
      },
      {
        "txt": "if (match(JsDocToken.PIPE)) { next(); if (match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); return parseUnionTypeWithAlternate(token, typeExpr); } }"
      },
      {
        "txt": "return typeExpr; } private Node parseTypeExpressionList(JsDocToken token) { Node typeExpr = parseTopLevelTypeExpression(token); if (typeExpr == null) { return null; } Node typeList = new Node(Token.BLOCK); typeList.addChildToBack(typeExpr); while (match(JsDocToken.COMMA)) {"
      },
      {
        "txt": "next(); skipEOLs(); typeExpr = parseTopLevelTypeExpression(next()); if (typeExpr == null) { return null; } typeList.addChildToBack(typeExpr); } return typeList; }"
      },
      {
        "txt": "private Node parseTypeExpression(JsDocToken token) { if (token == JsDocToken.QMARK) { return wrapNode(Token.QMARK, parseBasicTypeExpression(next())); } else if (token == JsDocToken.BANG) { return wrapNode(Token.BANG, parseBasicTypeExpression(next())); } else { Node basicTypeExpr = parseBasicTypeExpression(token); if (basicTypeExpr != null) { if (match(JsDocToken.QMARK)) { next();"
      },
      {
        "txt": "return wrapNode(Token.QMARK, basicTypeExpr); } else if (match(JsDocToken.BANG)) { next(); return wrapNode(Token.BANG, basicTypeExpr); } } return basicTypeExpr; } } private Node parseBasicTypeExpression(JsDocToken token) {"
      },
      {
        "txt": "if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs();"
      },
      {
        "txt": "return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\"function\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\"null\".equals(string) || \"undefined\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token);"
      },
      {
        "txt": "} } return reportGenericTypeSyntaxWarning(); } private Node parseTypeName(JsDocToken token) { if (token != JsDocToken.STRING) { return reportGenericTypeSyntaxWarning(); } Node typeName = newStringNode(stream.getString()); if (match(JsDocToken.LT)) {"
      },
      {
        "txt": "next(); skipEOLs(); Node memberType = parseTypeExpressionList(next()); if (memberType != null) { typeName.addChildToFront(memberType); skipEOLs(); if (!match(JsDocToken.GT)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\"); } next();"
      },
      {
        "txt": "} } return typeName; } private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null;"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING && \"this\".equals(stream.getString())) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node thisType = wrapNode(Token.THIS, parseTypeName(next())); if (thisType == null) {"
      },
      {
        "txt": "return null; } functionType.addChildToFront(thisType); } else { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} else { hasParams = false; } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } }"
      },
      {
        "txt": "} if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } skipEOLs(); Node resultType = parseResultType(next());"
      },
      {
        "txt": "if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; } private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.LP); boolean isVarArgs = false;"
      },
      {
        "txt": "Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs();"
      },
      {
        "txt": "if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));"
      },
      {
        "txt": "skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token);"
      },
      {
        "txt": "if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType);"
      },
      {
        "txt": "if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\"); } return paramsType; }"
      },
      {
        "txt": "private Node parseResultType(JsDocToken token) { skipEOLs(); if (!match(JsDocToken.COLON)) { return newNode(Token.EMPTY); } token = next(); skipEOLs(); if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) { next(); return newNode(Token.VOID);"
      },
      {
        "txt": "} else { return parseTypeExpression(next()); } } private Node parseUnionType(JsDocToken token) { return parseUnionTypeWithAlternate(token, null); } private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { Node union = newNode(Token.PIPE); if (alternate != null) {"
      },
      {
        "txt": "union.addChildToBack(alternate); } Node expr = null; do { if (expr != null) { skipEOLs(); token = next(); Preconditions.checkState( token == JsDocToken.PIPE || token == JsDocToken.COMMA); boolean isPipe = token == JsDocToken.PIPE;"
      },
      {
        "txt": "if (isPipe && match(JsDocToken.PIPE)) { next(); } skipEOLs(); token = next(); } expr = parseTypeExpression(token); if (expr == null) { return null; }"
      },
      {
        "txt": "union.addChildToBack(expr); } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); if (alternate == null) { skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\"); } next(); } return union;"
      },
      {
        "txt": "} private Node parseArrayType(JsDocToken token) { Node array = newNode(Token.LB); Node arg = null; boolean hasVarArgs = false; do { if (arg != null) { next(); skipEOLs(); token = next();"
      },
      {
        "txt": "} if (token == JsDocToken.ELLIPSIS) { arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); hasVarArgs = true; } else { arg = parseTypeExpression(token); } if (arg == null) { return null; }"
      },
      {
        "txt": "array.addChildToBack(arg); if (hasVarArgs) { break; } skipEOLs(); } while (match(JsDocToken.COMMA)); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\"); } next();"
      },
      {
        "txt": "return array; } private Node parseRecordType(JsDocToken token) { Node recordType = newNode(Token.LC); Node fieldTypeList = parseFieldTypeList(token); if (fieldTypeList == null) { return reportGenericTypeSyntaxWarning(); } skipEOLs(); if (!match(JsDocToken.RC)) {"
      },
      {
        "txt": "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\"); } next(); recordType.addChildToBack(fieldTypeList); return recordType; } private Node parseFieldTypeList(JsDocToken token) { Node fieldTypeList = newNode(Token.LB); do { Node fieldType = parseFieldType(token);"
      },
      {
        "txt": "if (fieldType == null) { return null; } fieldTypeList.addChildToBack(fieldType); skipEOLs(); if (!match(JsDocToken.COMMA)) { break; } next(); skipEOLs();"
      },
      {
        "txt": "token = next(); } while (true); return fieldTypeList; } private Node parseFieldType(JsDocToken token) { Node fieldName = parseFieldName(token); if (fieldName == null) { return null; } skipEOLs();"
      },
      {
        "txt": "if (!match(JsDocToken.COLON)) { return fieldName; } next(); skipEOLs(); Node typeExpression = parseTypeExpression(next()); if (typeExpression == null) { return null; } Node fieldType = newNode(Token.COLON);"
      },
      {
        "txt": "fieldType.addChildToBack(fieldName); fieldType.addChildToBack(typeExpression); return fieldType; } private Node parseFieldName(JsDocToken token) { switch (token) { case STRING: String string = stream.getString(); return newStringNode(string); default:"
      },
      {
        "txt": "return null; } } private Node wrapNode(int type, Node n) { return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()); } private Node newNode(int type) { return new Node(type, stream.getLineno(), stream.getCharno()); }"
      },
      {
        "txt": "private Node newStringNode(String s) { return Node.newString(s, stream.getLineno(), stream.getCharno()); } private Node reportTypeSyntaxWarning(String warning) { parser.addWarning(warning, stream.getLineno(), stream.getCharno()); return null; } private Node reportGenericTypeSyntaxWarning() { return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\"); }"
      },
      {
        "txt": "private JsDocToken eatTokensUntilEOL() { return eatTokensUntilEOL(next()); } private JsDocToken eatTokensUntilEOL(JsDocToken token) { do { if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { state = State.SEARCHING_ANNOTATION; return token; }"
      },
      {
        "txt": "token = next(); } while (true); } private static final JsDocToken NO_UNREAD_TOKEN = null; private JsDocToken unreadToken = NO_UNREAD_TOKEN; private boolean match(JsDocToken token) { unreadToken = next(); return unreadToken == token; } private boolean match(JsDocToken token1, JsDocToken token2) {"
      },
      {
        "txt": "unreadToken = next(); return unreadToken == token1 || unreadToken == token2; } private JsDocToken next() { if (unreadToken == NO_UNREAD_TOKEN) { return stream.getJsDocToken(); } else { return current(); } }"
      },
      {
        "txt": "private JsDocToken current() { JsDocToken t = unreadToken; unreadToken = NO_UNREAD_TOKEN; return t; } private void skipEOLs() { while (match(JsDocToken.EOL)) { next(); if (match(JsDocToken.STAR)) { next();"
      },
      {
        "txt": "} } } private boolean hasParsedFileOverviewDocInfo() { return jsdocBuilder.isPopulatedWithFileOverview(); } boolean hasParsedJSDocInfo() { return jsdocBuilder.isPopulated(); } JSDocInfo retrieveAndResetParsedJSDocInfo() {"
      },
      {
        "txt": "return jsdocBuilder.build(sourceName); } JSDocInfo getFileOverviewJSDocInfo() { return fileOverviewJSDocInfo; }"
      }
    ]
  }
]