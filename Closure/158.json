[
  {
    "id": 733,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 197,
    "end-bug-line": 202,
    "bug": "diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF);",
    "fix": "if (config.warningGuards != null) { for (WarningGuardSpec.Entry entry : config.warningGuards.entries) { diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps;"
      },
      {
        "txt": "import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream; import java.io.BufferedWriter; import java.io.Closeable; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream;"
      },
      {
        "txt": "import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.logging.Level;"
      },
      {
        "txt": "abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out; private final PrintStream err; private A compiler; private Charset inputCharset; private String outputCharset; private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null;"
      },
      {
        "txt": "private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100; private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() { this(System.out, System.err); } AbstractCommandLineRunner(PrintStream out, PrintStream err) {"
      },
      {
        "txt": "this.config = new CommandLineConfig(); this.out = out; this.err = err; } @VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier, Supplier<List<JSSourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) {"
      },
      {
        "txt": "Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier; this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver; } protected boolean isInTestMode() { return testMode;"
      },
      {
        "txt": "} protected CommandLineConfig getCommandLineConfig() { return config; } protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() { if (compiler == null) { return new DiagnosticGroups(); }"
      },
      {
        "txt": "} @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {} final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); <extra_id_0> createDefineOrTweakReplacements(config.define, options, false); options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies; if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints);"
      },
      {
        "txt": "if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset(); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile;"
      },
      {
        "txt": "} if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) { options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); }"
      },
      {
        "txt": "if (!config.propertyMapInputFile.equals(\"\")) { options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) {"
      },
      {
        "txt": "options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\"); } } options.acceptConstKeyword = config.acceptConstKeyword;"
      },
      {
        "txt": "} final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1; if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops();"
      },
      {
        "txt": "} try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); } } catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1;"
      },
      {
        "txt": "} catch (Throwable t) { t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); } if (testMode) { exitCodeReceiverForTesting.apply(result); } else {"
      },
      {
        "txt": "System.exit(result); } } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception { private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message);"
      },
      {
        "txt": "} } protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) { if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile);"
      },
      {
        "txt": "} else { if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); } inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; }"
      },
      {
        "txt": "} return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get(); } if (files.isEmpty()) { files = Collections.singletonList(\"-\");"
      },
      {
        "txt": "} try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } } private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) {"
      },
      {
        "txt": "return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\")); } try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); } } List<JSModule> createJsModules( List<String> specs, List<String> jsFiles)"
      },
      {
        "txt": "throws FlagUsageException, IOException { if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null); final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();"
      },
      {
        "txt": "for (String spec : specs) { String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0]; checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name);"
      },
      {
        "txt": "} JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1; } if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1]"
      },
      {
        "txt": "+ \"' for module: \" + name); } if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); } List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) {"
      },
      {
        "txt": "module.add(input); } nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\"); for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"Module '\" + name + \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } } } modulesByName.put(name, module); }"
      },
      {
        "txt": "if (nextJsFileIndex < totalNumJsFiles) { throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name) throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\");"
      },
      {
        "txt": "} } static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size()); for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); }"
      },
      {
        "txt": "for (String spec : specs) { int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos); if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); }"
      },
      {
        "txt": "String wrapper = spec.substring(pos + 1); if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); } return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code,"
      },
      {
        "txt": "String wrapper, String codePlaceholder) throws IOException { int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix); } out.append(code); int suffixStart = pos + codePlaceholder.length();"
      },
      {
        "txt": "if (suffixStart != wrapper.length()) { out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); } } else { out.append(code); out.append('\\n');"
      },
      {
        "txt": "} } private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File( pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs();"
      },
      {
        "txt": "} } } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler(); B options = createOptions(); List<JSModule> modules = null; Result result;"
      },
      {
        "txt": "setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); } List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) {"
      },
      {
        "txt": "modules = createJsModules(moduleSpecs, jsFiles); result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options); if (out instanceof Closeable) { ((Closeable) out).close(); }"
      },
      {
        "txt": "return errCode; } int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; } if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1;"
      },
      {
        "txt": "} else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) { if (compiler.getRoot() == null) { return 1; } else {"
      },
      {
        "txt": "ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) { if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1;"
      },
      {
        "txt": "} else { compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) { if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);"
      },
      {
        "txt": "outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null; if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); }"
      },
      {
        "txt": "for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m),"
      },
      {
        "txt": "moduleWrappers.get(m.getName()), \"%s\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close(); mapOut = null; } }"
      },
      {
        "txt": "if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile); eeOut.append(result.externExport); eeOut.close(); }"
      },
      {
        "txt": "outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\");"
      },
      {
        "txt": "} return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\");"
      },
      {
        "txt": "} return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); }"
      },
      {
        "txt": "private boolean shouldGenerateMapPerModule(B options) { return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) { return null; } String exPath = options.externExportsPath;"
      },
      {
        "txt": "if (!exPath.contains(File.separator)) { File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath( String path, JSModule forModule) { String sub; if (forModule != null) {"
      },
      {
        "txt": "sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\"; } else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub); } @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) {"
      },
      {
        "txt": "if (Strings.isEmpty(options.sourceMapOutputPath)) { return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) { if (Strings.isEmpty(config.outputManifest)) { return null; }"
      },
      {
        "txt": "return expandCommandLinePath(config.outputManifest, forModule); } private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) { return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName));"
      },
      {
        "txt": "} protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName); } private Writer streamToOutputWriter(OutputStream stream) throws IOException {"
      },
      {
        "txt": "if (outputCharset == null) { return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); } } private void outputSourceMap(B options) throws IOException {"
      },
      {
        "txt": "if (Strings.isEmpty(options.sourceMapOutputPath)) { return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close(); } private String getMapPath(String outputFile) { String basePath = \"\";"
      },
      {
        "txt": "if (outputFile.equals(\"\")) { if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else { File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) {"
      },
      {
        "txt": "outputFileName = outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; } private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null;"
      },
      {
        "txt": "String variableMapOutputPath = null; String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\"; } if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"The flags variable_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) { throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); }"
      },
      {
        "txt": "propertyMapOutputPath = config.propertyMapOutputFile; } if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } } if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath);"
      },
      {
        "txt": "} } if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file); compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush();"
      },
      {
        "txt": "file.close(); } } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) { for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0];"
      },
      {
        "txt": "if (defName.length() > 0) { String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue); } else { options.setDefineToBooleanLiteral(defName, isTrue); }"
      },
      {
        "txt": "continue; } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal = defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) {"
      },
      {
        "txt": "options.setTweakToStringLiteral(defName, maybeStringVal); } else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else { try { double value = Double.parseDouble(defValue); if (tweaks) {"
      },
      {
        "txt": "options.setTweakToDoubleLiteral(defName, value); } else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { } } } if (tweaks) {"
      },
      {
        "txt": "throw new RuntimeException( \"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } } private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null"
      },
      {
        "txt": "&& config.outputManifest.contains(\"%outname%\"); } private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; } JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules();"
      },
      {
        "txt": "for (JSModule module : modules) { Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null)); if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else {"
      },
      {
        "txt": "printModuleGraphManifestTo(graph, out); } out.close(); } } @VisibleForTesting void printModuleGraphManifestTo( JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false;"
      },
      {
        "txt": "for (JSModule module : graph.getAllModulesInDependencyOrder()) { if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\", module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out);"
      },
      {
        "txt": "requiresNewline = true; } } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) { names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names);"
      },
      {
        "txt": "out.append(result); out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0; private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis();"
      },
      {
        "txt": "PhaseOptimizer.clearLoopsRun(); } private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) { loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; }"
      },
      {
        "txt": "} private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) { out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; }"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false; CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this;"
      },
      {
        "txt": "} private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false; CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this;"
      },
      {
        "txt": "} private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF; CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this;"
      },
      {
        "txt": "} private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList(); CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs);"
      },
      {
        "txt": "return this; } private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this; } private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) {"
      },
      {
        "txt": "this.jsOutputFile = jsOutputFile; return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module); return this; } private String variableMapInputFile = \"\";"
      },
      {
        "txt": "CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile; return this; } private String variableMapOutputFile = \"\";"
      },
      {
        "txt": "CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles; return this; } private String propertyMapOutputFile = \"\";"
      },
      {
        "txt": "CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention; return this; } private int summaryDetailLevel = 1;"
      },
      {
        "txt": "CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper; return this; } private final List<String> moduleWrapper = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) { this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; }"
      },
      {
        "txt": "private String createSourceMap = \"\"; CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL; CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this;"
      },
      {
        "txt": "} private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; } private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear();"
      },
      {
        "txt": "this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) { this.define.clear(); this.define.addAll(define); return this;"
      },
      {
        "txt": "} private final List<String> tweak = Lists.newArrayList(); CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; } private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing;"
      },
      {
        "txt": "return this; } private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; } private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal;"
      },
      {
        "txt": "return this; } private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this; } private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) {"
      },
      {
        "txt": "this.outputManifest = outputManifest; return this; } private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this; } private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) {"
      },
      {
        "txt": "this.languageIn = languageIn; return this; } }"
      }
    ]
  },
  {
    "id": 734,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 1497,
    "end-bug-line": 1497,
    "bug": "private final List<String> jscompError = Lists.newArrayList();",
    "fix": "private WarningGuardSpec warningGuards = null;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream; import java.io.BufferedWriter; import java.io.Closeable; import java.io.File;"
      },
      {
        "txt": "import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.logging.Level; abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out; private final PrintStream err; private A compiler; private Charset inputCharset;"
      },
      {
        "txt": "private String outputCharset; private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null; private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100; private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() {"
      },
      {
        "txt": "this(System.out, System.err); } AbstractCommandLineRunner(PrintStream out, PrintStream err) { this.config = new CommandLineConfig(); this.out = out; this.err = err; } @VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier,"
      },
      {
        "txt": "Supplier<List<JSSourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier; this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver;"
      },
      {
        "txt": "} protected boolean isInTestMode() { return testMode; } protected CommandLineConfig getCommandLineConfig() { return config; } protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() {"
      },
      {
        "txt": "if (compiler == null) { return new DiagnosticGroups(); } return compiler.getDiagnosticGroups(); } @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {} final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups();"
      },
      {
        "txt": "diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false); options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies;"
      },
      {
        "txt": "if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset(); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile;"
      },
      {
        "txt": "} if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) { options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); }"
      },
      {
        "txt": "if (!config.propertyMapInputFile.equals(\"\")) { options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) {"
      },
      {
        "txt": "options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\"); } } options.acceptConstKeyword = config.acceptConstKeyword;"
      },
      {
        "txt": "} final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1; if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops();"
      },
      {
        "txt": "} try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); } } catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1;"
      },
      {
        "txt": "} catch (Throwable t) { t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); } if (testMode) { exitCodeReceiverForTesting.apply(result); } else {"
      },
      {
        "txt": "System.exit(result); } } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception { private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message);"
      },
      {
        "txt": "} } protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) { if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile);"
      },
      {
        "txt": "} else { if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); } inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; }"
      },
      {
        "txt": "} return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get(); } if (files.isEmpty()) { files = Collections.singletonList(\"-\");"
      },
      {
        "txt": "} try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } } private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) {"
      },
      {
        "txt": "return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\")); } try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); } } List<JSModule> createJsModules( List<String> specs, List<String> jsFiles)"
      },
      {
        "txt": "throws FlagUsageException, IOException { if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null); final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();"
      },
      {
        "txt": "for (String spec : specs) { String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0]; checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name);"
      },
      {
        "txt": "} JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1; } if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1]"
      },
      {
        "txt": "+ \"' for module: \" + name); } if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); } List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) {"
      },
      {
        "txt": "module.add(input); } nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\"); for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"Module '\" + name + \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } } } modulesByName.put(name, module); }"
      },
      {
        "txt": "if (nextJsFileIndex < totalNumJsFiles) { throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name) throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\");"
      },
      {
        "txt": "} } static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size()); for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); }"
      },
      {
        "txt": "for (String spec : specs) { int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos); if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); }"
      },
      {
        "txt": "String wrapper = spec.substring(pos + 1); if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); } return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code,"
      },
      {
        "txt": "String wrapper, String codePlaceholder) throws IOException { int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix); } out.append(code); int suffixStart = pos + codePlaceholder.length();"
      },
      {
        "txt": "if (suffixStart != wrapper.length()) { out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); } } else { out.append(code); out.append('\\n');"
      },
      {
        "txt": "} } private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File( pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs();"
      },
      {
        "txt": "} } } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler(); B options = createOptions(); List<JSModule> modules = null; Result result;"
      },
      {
        "txt": "setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); } List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) {"
      },
      {
        "txt": "modules = createJsModules(moduleSpecs, jsFiles); result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options); if (out instanceof Closeable) { ((Closeable) out).close(); }"
      },
      {
        "txt": "return errCode; } int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; } if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1;"
      },
      {
        "txt": "} else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) { if (compiler.getRoot() == null) { return 1; } else {"
      },
      {
        "txt": "ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) { if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1;"
      },
      {
        "txt": "} else { compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) { if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);"
      },
      {
        "txt": "outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null; if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); }"
      },
      {
        "txt": "for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m),"
      },
      {
        "txt": "moduleWrappers.get(m.getName()), \"%s\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close(); mapOut = null; } }"
      },
      {
        "txt": "if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile); eeOut.append(result.externExport); eeOut.close(); }"
      },
      {
        "txt": "outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\");"
      },
      {
        "txt": "} return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\");"
      },
      {
        "txt": "} return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); }"
      },
      {
        "txt": "private boolean shouldGenerateMapPerModule(B options) { return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) { return null; } String exPath = options.externExportsPath;"
      },
      {
        "txt": "if (!exPath.contains(File.separator)) { File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath( String path, JSModule forModule) { String sub; if (forModule != null) {"
      },
      {
        "txt": "sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\"; } else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub); } @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) {"
      },
      {
        "txt": "if (Strings.isEmpty(options.sourceMapOutputPath)) { return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) { if (Strings.isEmpty(config.outputManifest)) { return null; }"
      },
      {
        "txt": "return expandCommandLinePath(config.outputManifest, forModule); } private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) { return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName));"
      },
      {
        "txt": "} protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName); } private Writer streamToOutputWriter(OutputStream stream) throws IOException {"
      },
      {
        "txt": "if (outputCharset == null) { return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); } } private void outputSourceMap(B options) throws IOException {"
      },
      {
        "txt": "if (Strings.isEmpty(options.sourceMapOutputPath)) { return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close(); } private String getMapPath(String outputFile) { String basePath = \"\";"
      },
      {
        "txt": "if (outputFile.equals(\"\")) { if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else { File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) {"
      },
      {
        "txt": "outputFileName = outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; } private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null;"
      },
      {
        "txt": "String variableMapOutputPath = null; String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\"; } if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"The flags variable_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) { throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); }"
      },
      {
        "txt": "propertyMapOutputPath = config.propertyMapOutputFile; } if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } } if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath);"
      },
      {
        "txt": "} } if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file); compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush();"
      },
      {
        "txt": "file.close(); } } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) { for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0];"
      },
      {
        "txt": "if (defName.length() > 0) { String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue); } else { options.setDefineToBooleanLiteral(defName, isTrue); }"
      },
      {
        "txt": "continue; } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal = defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) {"
      },
      {
        "txt": "options.setTweakToStringLiteral(defName, maybeStringVal); } else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else { try { double value = Double.parseDouble(defValue); if (tweaks) {"
      },
      {
        "txt": "options.setTweakToDoubleLiteral(defName, value); } else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { } } } if (tweaks) {"
      },
      {
        "txt": "throw new RuntimeException( \"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } } private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null"
      },
      {
        "txt": "&& config.outputManifest.contains(\"%outname%\"); } private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; } JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules();"
      },
      {
        "txt": "for (JSModule module : modules) { Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null)); if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else {"
      },
      {
        "txt": "printModuleGraphManifestTo(graph, out); } out.close(); } } @VisibleForTesting void printModuleGraphManifestTo( JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false;"
      },
      {
        "txt": "for (JSModule module : graph.getAllModulesInDependencyOrder()) { if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\", module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out);"
      },
      {
        "txt": "requiresNewline = true; } } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) { names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names);"
      },
      {
        "txt": "out.append(result); out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0; private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis();"
      },
      {
        "txt": "PhaseOptimizer.clearLoopsRun(); } private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) { loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; }"
      },
      {
        "txt": "} private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) { out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; }"
      },
      {
        "txt": "} catch (IOException e) { throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false; CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this;"
      },
      {
        "txt": "} private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false; CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this;"
      },
      {
        "txt": "} private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF; CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this;"
      },
      {
        "txt": "} private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList(); CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs);"
      },
      {
        "txt": "return this; } private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this; } private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) {"
      },
      {
        "txt": "this.jsOutputFile = jsOutputFile; return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module); return this; } private String variableMapInputFile = \"\";"
      },
      {
        "txt": "CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile; return this; } private String variableMapOutputFile = \"\";"
      },
      {
        "txt": "CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles; return this; } private String propertyMapOutputFile = \"\";"
      },
      {
        "txt": "CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention; return this; } private int summaryDetailLevel = 1;"
      },
      {
        "txt": "CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper; return this; } private final List<String> moduleWrapper = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) { this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; }"
      },
      {
        "txt": "private String createSourceMap = \"\"; CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL; CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this;"
      },
      {
        "txt": "private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; } <extra_id_0> CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList();"
      },
      {
        "txt": "} private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear();"
      },
      {
        "txt": "this.jscompOff.addAll(jscompOff); return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) { this.define.clear(); this.define.addAll(define); return this; } private final List<String> tweak = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; } private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing; return this; }"
      },
      {
        "txt": "private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; } private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal; return this; }"
      },
      {
        "txt": "private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this; } private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) { this.outputManifest = outputManifest; return this;"
      },
      {
        "txt": "} private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this; } private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) { this.languageIn = languageIn; return this;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 735,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 1502,
    "end-bug-line": 1516,
    "bug": "CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning); return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff);",
    "fix": "CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) { this.warningGuards = spec;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.ImmutableList;"
      },
      {
        "txt": "import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream; import java.io.BufferedWriter; import java.io.Closeable; import java.io.File; import java.io.FileOutputStream;"
      },
      {
        "txt": "import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.logging.Level; abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out; private final PrintStream err; private A compiler; private Charset inputCharset; private String outputCharset;"
      },
      {
        "txt": "private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null; private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100; private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() { this(System.out, System.err);"
      },
      {
        "txt": "} AbstractCommandLineRunner(PrintStream out, PrintStream err) { this.config = new CommandLineConfig(); this.out = out; this.err = err; } @VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier, Supplier<List<JSSourceFile>> inputsSupplier,"
      },
      {
        "txt": "Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier; this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver; }"
      },
      {
        "txt": "protected boolean isInTestMode() { return testMode; } protected CommandLineConfig getCommandLineConfig() { return config; } protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() { if (compiler == null) {"
      },
      {
        "txt": "return new DiagnosticGroups(); } return compiler.getDiagnosticGroups(); } @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {} final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels("
      },
      {
        "txt": "options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false); options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies; if (config.closureEntryPoints.size() > 0) {"
      },
      {
        "txt": "options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset(); inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile; }"
      },
      {
        "txt": "if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) { options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); } if (!config.propertyMapInputFile.equals(\"\")) {"
      },
      {
        "txt": "options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);"
      },
      {
        "txt": "} else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\"); } } options.acceptConstKeyword = config.acceptConstKeyword; }"
      },
      {
        "txt": "final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1; if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops(); }"
      },
      {
        "txt": "try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); } } catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1; } catch (Throwable t) {"
      },
      {
        "txt": "t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); } if (testMode) { exitCodeReceiverForTesting.apply(result); } else { System.exit(result);"
      },
      {
        "txt": "} } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception { private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message); }"
      },
      {
        "txt": "} protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) { if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile); } else {"
      },
      {
        "txt": "if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); } inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; } }"
      },
      {
        "txt": "return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get(); } if (files.isEmpty()) { files = Collections.singletonList(\"-\"); }"
      },
      {
        "txt": "try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } } private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) { return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\"));"
      },
      {
        "txt": "} try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); } } List<JSModule> createJsModules( List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {"
      },
      {
        "txt": "if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null); final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); for (String spec : specs) {"
      },
      {
        "txt": "String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0]; checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name); }"
      },
      {
        "txt": "JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1; } if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1] + \"' for module: \" + name);"
      },
      {
        "txt": "} if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); } List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) { module.add(input);"
      },
      {
        "txt": "} nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\"); for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) { throw new FlagUsageException(\"Module '\" + name"
      },
      {
        "txt": "+ \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } } } modulesByName.put(name, module); } if (nextJsFileIndex < totalNumJsFiles) {"
      },
      {
        "txt": "throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name) throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\"); }"
      },
      {
        "txt": "} static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size()); for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); } for (String spec : specs) {"
      },
      {
        "txt": "int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos); if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); } String wrapper = spec.substring(pos + 1);"
      },
      {
        "txt": "if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); } return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {"
      },
      {
        "txt": "int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix); } out.append(code); int suffixStart = pos + codePlaceholder.length(); if (suffixStart != wrapper.length()) {"
      },
      {
        "txt": "out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); } } else { out.append(code); out.append('\\n'); }"
      },
      {
        "txt": "} private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File( pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs(); }"
      },
      {
        "txt": "} } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler(); B options = createOptions(); List<JSModule> modules = null; Result result; setRunOptions(options);"
      },
      {
        "txt": "boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); } List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) { modules = createJsModules(moduleSpecs, jsFiles);"
      },
      {
        "txt": "result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options); if (out instanceof Closeable) { ((Closeable) out).close(); } return errCode;"
      },
      {
        "txt": "} int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; } if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1; } else {"
      },
      {
        "txt": "out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) { if (compiler.getRoot() == null) { return 1; } else { ControlFlowGraph<Node> cfg = compiler.computeCFG();"
      },
      {
        "txt": "DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) { if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1; } else {"
      },
      {
        "txt": "compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) { if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER); outputSourceMap(options);"
      },
      {
        "txt": "} else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null; if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); } for (JSModule m : modules) {"
      },
      {
        "txt": "if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");"
      },
      {
        "txt": "if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close(); mapOut = null; } } if (mapOut != null) {"
      },
      {
        "txt": "mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile); eeOut.append(result.externExport); eeOut.close(); } outputNameMaps(options);"
      },
      {
        "txt": "outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); }"
      },
      {
        "txt": "return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) { if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); }"
      },
      {
        "txt": "return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); } private boolean shouldGenerateMapPerModule(B options) {"
      },
      {
        "txt": "return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) { return null; } String exPath = options.externExportsPath; if (!exPath.contains(File.separator)) {"
      },
      {
        "txt": "File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath( String path, JSModule forModule) { String sub; if (forModule != null) { sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\";"
      },
      {
        "txt": "} else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub); } @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) { if (Strings.isEmpty(options.sourceMapOutputPath)) {"
      },
      {
        "txt": "return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) { if (Strings.isEmpty(config.outputManifest)) { return null; } return expandCommandLinePath(config.outputManifest, forModule);"
      },
      {
        "txt": "} private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) { return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName)); }"
      },
      {
        "txt": "protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName); } private Writer streamToOutputWriter(OutputStream stream) throws IOException { if (outputCharset == null) {"
      },
      {
        "txt": "return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); } } private void outputSourceMap(B options) throws IOException { if (Strings.isEmpty(options.sourceMapOutputPath)) {"
      },
      {
        "txt": "return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close(); } private String getMapPath(String outputFile) { String basePath = \"\"; if (outputFile.equals(\"\")) {"
      },
      {
        "txt": "if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else { File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) { outputFileName ="
      },
      {
        "txt": "outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; } private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null; String variableMapOutputPath = null;"
      },
      {
        "txt": "String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\"; } if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) { throw new FlagUsageException(\"The flags variable_map_output_file and \""
      },
      {
        "txt": "+ \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) { throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } propertyMapOutputPath = config.propertyMapOutputFile;"
      },
      {
        "txt": "} if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } } if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath); }"
      },
      {
        "txt": "} if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file); compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush(); file.close();"
      },
      {
        "txt": "} } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) { for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0]; if (defName.length() > 0) {"
      },
      {
        "txt": "String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue); } else { options.setDefineToBooleanLiteral(defName, isTrue); } continue;"
      },
      {
        "txt": "} else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal = defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) { options.setTweakToStringLiteral(defName, maybeStringVal);"
      },
      {
        "txt": "} else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else { try { double value = Double.parseDouble(defValue); if (tweaks) { options.setTweakToDoubleLiteral(defName, value);"
      },
      {
        "txt": "} else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { } } } if (tweaks) { throw new RuntimeException("
      },
      {
        "txt": "\"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } } private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null && config.outputManifest.contains(\"%outname%\");"
      },
      {
        "txt": "} private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; } JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules(); for (JSModule module : modules) {"
      },
      {
        "txt": "Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null)); if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else { printModuleGraphManifestTo(graph, out);"
      },
      {
        "txt": "} out.close(); } } @VisibleForTesting void printModuleGraphManifestTo( JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false; for (JSModule module : graph.getAllModulesInDependencyOrder()) {"
      },
      {
        "txt": "if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\", module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out); requiresNewline = true;"
      },
      {
        "txt": "} } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) { names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names); out.append(result);"
      },
      {
        "txt": "out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0; private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis(); PhaseOptimizer.clearLoopsRun();"
      },
      {
        "txt": "} private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) { loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; } }"
      },
      {
        "txt": "private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) { out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; } } catch (IOException e) {"
      },
      {
        "txt": "throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false; CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this; }"
      },
      {
        "txt": "private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false; CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this; }"
      },
      {
        "txt": "private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF; CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this; }"
      },
      {
        "txt": "private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList(); CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs); return this;"
      },
      {
        "txt": "} private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this; } private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) { this.jsOutputFile = jsOutputFile;"
      },
      {
        "txt": "return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module); return this; } private String variableMapInputFile = \"\"; CommandLineConfig setVariableMapInputFile(String variableMapInputFile) {"
      },
      {
        "txt": "this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile; return this; } private String variableMapOutputFile = \"\"; CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) {"
      },
      {
        "txt": "this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles; return this; } private String propertyMapOutputFile = \"\"; CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) {"
      },
      {
        "txt": "this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention; return this; } private int summaryDetailLevel = 1; CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) {"
      },
      {
        "txt": "this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper; return this; } private final List<String> moduleWrapper = Lists.newArrayList(); CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {"
      },
      {
        "txt": "this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) { this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; } private String createSourceMap = \"\";"
      },
      {
        "txt": "CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL; CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this; }"
      },
      {
        "txt": "SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; } private final List<String> jscompError = Lists.newArrayList(); <extra_id_0> return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) { this.define.clear(); this.define.addAll(define);"
      },
      {
        "txt": "this.define.clear(); this.define.addAll(define); return this; } private final List<String> tweak = Lists.newArrayList(); CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; }"
      },
      {
        "txt": "private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing; return this; } private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; }"
      },
      {
        "txt": "private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal; return this; } private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this;"
      },
      {
        "txt": "} private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) { this.outputManifest = outputManifest; return this; } private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this;"
      },
      {
        "txt": "} private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) { this.languageIn = languageIn; return this; } }"
      }
    ]
  },
  {
    "id": 736,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 1628,
    "end-bug-line": 1628,
    "bug": "",
    "fix": "protected static class WarningGuardSpec { private static class Entry { private final CheckLevel level; private final String groupName;  private Entry(CheckLevel level, String groupName) { this.level = level; this.groupName = groupName; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function;"
      },
      {
        "txt": "import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream;"
      },
      {
        "txt": "import java.io.BufferedWriter; import java.io.Closeable; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer;"
      },
      {
        "txt": "import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.logging.Level; abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out;"
      },
      {
        "txt": "private final PrintStream err; private A compiler; private Charset inputCharset; private String outputCharset; private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null; private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;"
      },
      {
        "txt": "private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() { this(System.out, System.err); } AbstractCommandLineRunner(PrintStream out, PrintStream err) { this.config = new CommandLineConfig(); this.out = out; this.err = err; }"
      },
      {
        "txt": "@VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier, Supplier<List<JSSourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier;"
      },
      {
        "txt": "this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver; } protected boolean isInTestMode() { return testMode; } protected CommandLineConfig getCommandLineConfig() { return config; }"
      },
      {
        "txt": "protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() { if (compiler == null) { return new DiagnosticGroups(); } return compiler.getDiagnosticGroups(); } @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {}"
      },
      {
        "txt": "final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false);"
      },
      {
        "txt": "options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies; if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset();"
      },
      {
        "txt": "inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile; } if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) {"
      },
      {
        "txt": "options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); } if (!config.propertyMapInputFile.equals(\"\")) { options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) {"
      },
      {
        "txt": "options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\");"
      },
      {
        "txt": "} } options.acceptConstKeyword = config.acceptConstKeyword; } final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1;"
      },
      {
        "txt": "if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops(); } try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); }"
      },
      {
        "txt": "} catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1; } catch (Throwable t) { t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); }"
      },
      {
        "txt": "if (testMode) { exitCodeReceiverForTesting.apply(result); } else { System.exit(result); } } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message); } } protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) {"
      },
      {
        "txt": "if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile); } else { if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); }"
      },
      {
        "txt": "inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; } } return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get();"
      },
      {
        "txt": "} if (files.isEmpty()) { files = Collections.singletonList(\"-\"); } try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } }"
      },
      {
        "txt": "private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) { return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\")); } try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); }"
      },
      {
        "txt": "} List<JSModule> createJsModules( List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException { if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null);"
      },
      {
        "txt": "final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); for (String spec : specs) { String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0];"
      },
      {
        "txt": "checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name); } JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1;"
      },
      {
        "txt": "} if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1] + \"' for module: \" + name); } if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); }"
      },
      {
        "txt": "List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) { module.add(input); } nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\");"
      },
      {
        "txt": "for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) { throw new FlagUsageException(\"Module '\" + name + \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } }"
      },
      {
        "txt": "} modulesByName.put(name, module); } if (nextJsFileIndex < totalNumJsFiles) { throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name)"
      },
      {
        "txt": "throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\"); } } static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());"
      },
      {
        "txt": "for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); } for (String spec : specs) { int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos);"
      },
      {
        "txt": "if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); } String wrapper = spec.substring(pos + 1); if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); }"
      },
      {
        "txt": "return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException { int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix);"
      },
      {
        "txt": "} out.append(code); int suffixStart = pos + codePlaceholder.length(); if (suffixStart != wrapper.length()) { out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); }"
      },
      {
        "txt": "} else { out.append(code); out.append('\\n'); } } private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File("
      },
      {
        "txt": "pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs(); } } } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler();"
      },
      {
        "txt": "B options = createOptions(); List<JSModule> modules = null; Result result; setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); }"
      },
      {
        "txt": "List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) { modules = createJsModules(moduleSpecs, jsFiles); result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options);"
      },
      {
        "txt": "if (out instanceof Closeable) { ((Closeable) out).close(); } return errCode; } int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; }"
      },
      {
        "txt": "if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1; } else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { return 1; } else { ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1; } else { compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) {"
      },
      {
        "txt": "if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER); outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null;"
      },
      {
        "txt": "if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); } for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) {"
      },
      {
        "txt": "compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close();"
      },
      {
        "txt": "mapOut = null; } } if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile);"
      },
      {
        "txt": "eeOut.append(result.externExport); eeOut.close(); } outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {"
      },
      {
        "txt": "return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); } private boolean shouldGenerateMapPerModule(B options) { return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) {"
      },
      {
        "txt": "return null; } String exPath = options.externExportsPath; if (!exPath.contains(File.separator)) { File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath("
      },
      {
        "txt": "String path, JSModule forModule) { String sub; if (forModule != null) { sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\"; } else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub);"
      },
      {
        "txt": "} @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) { if (Strings.isEmpty(options.sourceMapOutputPath)) { return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) {"
      },
      {
        "txt": "if (Strings.isEmpty(config.outputManifest)) { return null; } return expandCommandLinePath(config.outputManifest, forModule); } private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) {"
      },
      {
        "txt": "return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName)); } protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName);"
      },
      {
        "txt": "} private Writer streamToOutputWriter(OutputStream stream) throws IOException { if (outputCharset == null) { return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); }"
      },
      {
        "txt": "} private void outputSourceMap(B options) throws IOException { if (Strings.isEmpty(options.sourceMapOutputPath)) { return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close();"
      },
      {
        "txt": "} private String getMapPath(String outputFile) { String basePath = \"\"; if (outputFile.equals(\"\")) { if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else {"
      },
      {
        "txt": "File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) { outputFileName = outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; }"
      },
      {
        "txt": "private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null; String variableMapOutputPath = null; String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\";"
      },
      {
        "txt": "} if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) { throw new FlagUsageException(\"The flags variable_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } propertyMapOutputPath = config.propertyMapOutputFile; } if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } }"
      },
      {
        "txt": "if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath); } } if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file);"
      },
      {
        "txt": "compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush(); file.close(); } } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {"
      },
      {
        "txt": "for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0]; if (defName.length() > 0) { String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue);"
      },
      {
        "txt": "} else { options.setDefineToBooleanLiteral(defName, isTrue); } continue; } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal ="
      },
      {
        "txt": "defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) { options.setTweakToStringLiteral(defName, maybeStringVal); } else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else {"
      },
      {
        "txt": "try { double value = Double.parseDouble(defValue); if (tweaks) { options.setTweakToDoubleLiteral(defName, value); } else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { }"
      },
      {
        "txt": "} } if (tweaks) { throw new RuntimeException( \"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } }"
      },
      {
        "txt": "private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null && config.outputManifest.contains(\"%outname%\"); } private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; }"
      },
      {
        "txt": "JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules(); for (JSModule module : modules) { Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null));"
      },
      {
        "txt": "if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else { printModuleGraphManifestTo(graph, out); } out.close(); } } @VisibleForTesting void printModuleGraphManifestTo("
      },
      {
        "txt": "JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false; for (JSModule module : graph.getAllModulesInDependencyOrder()) { if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\","
      },
      {
        "txt": "module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out); requiresNewline = true; } } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) {"
      },
      {
        "txt": "names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names); out.append(result); out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0;"
      },
      {
        "txt": "private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis(); PhaseOptimizer.clearLoopsRun(); } private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) {"
      },
      {
        "txt": "loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; } } private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) {"
      },
      {
        "txt": "out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; } } catch (IOException e) { throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false;"
      },
      {
        "txt": "CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this; } private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false;"
      },
      {
        "txt": "CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this; } private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this; } private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs); return this; } private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this;"
      },
      {
        "txt": "} private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) { this.jsOutputFile = jsOutputFile; return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module);"
      },
      {
        "txt": "return this; } private String variableMapInputFile = \"\"; CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile;"
      },
      {
        "txt": "return this; } private String variableMapOutputFile = \"\"; CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles;"
      },
      {
        "txt": "return this; } private String propertyMapOutputFile = \"\"; CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention;"
      },
      {
        "txt": "return this; } private int summaryDetailLevel = 1; CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper;"
      },
      {
        "txt": "return this; } private final List<String> moduleWrapper = Lists.newArrayList(); CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {"
      },
      {
        "txt": "this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; } private String createSourceMap = \"\"; CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL;"
      },
      {
        "txt": "CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this; } private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; }"
      },
      {
        "txt": "private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning);"
      },
      {
        "txt": "return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) {"
      },
      {
        "txt": "this.define.clear(); this.define.addAll(define); return this; } private final List<String> tweak = Lists.newArrayList(); CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; }"
      },
      {
        "txt": "private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing; return this; } private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; }"
      },
      {
        "txt": "private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal; return this; } private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this;"
      },
      {
        "txt": "} private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) { this.outputManifest = outputManifest; return this; } private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this;"
      },
      {
        "txt": "private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) { this.languageIn = languageIn; return this; } } <extra_id_0> }"
      }
    ]
  },
  {
    "id": 737,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 1631,
    "end-bug-line": 1631,
    "bug": "",
    "fix": "private final List<Entry> entries = Lists.newArrayList();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function;"
      },
      {
        "txt": "import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream;"
      },
      {
        "txt": "import java.io.BufferedWriter; import java.io.Closeable; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer;"
      },
      {
        "txt": "import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.logging.Level; abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out;"
      },
      {
        "txt": "private final PrintStream err; private A compiler; private Charset inputCharset; private String outputCharset; private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null; private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;"
      },
      {
        "txt": "private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() { this(System.out, System.err); } AbstractCommandLineRunner(PrintStream out, PrintStream err) { this.config = new CommandLineConfig(); this.out = out; this.err = err; }"
      },
      {
        "txt": "@VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier, Supplier<List<JSSourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier;"
      },
      {
        "txt": "this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver; } protected boolean isInTestMode() { return testMode; } protected CommandLineConfig getCommandLineConfig() { return config; }"
      },
      {
        "txt": "protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() { if (compiler == null) { return new DiagnosticGroups(); } return compiler.getDiagnosticGroups(); } @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {}"
      },
      {
        "txt": "final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false);"
      },
      {
        "txt": "options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies; if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset();"
      },
      {
        "txt": "inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile; } if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) {"
      },
      {
        "txt": "options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); } if (!config.propertyMapInputFile.equals(\"\")) { options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) {"
      },
      {
        "txt": "options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\");"
      },
      {
        "txt": "} } options.acceptConstKeyword = config.acceptConstKeyword; } final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1;"
      },
      {
        "txt": "if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops(); } try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); }"
      },
      {
        "txt": "} catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1; } catch (Throwable t) { t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); }"
      },
      {
        "txt": "if (testMode) { exitCodeReceiverForTesting.apply(result); } else { System.exit(result); } } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message); } } protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) {"
      },
      {
        "txt": "if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile); } else { if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); }"
      },
      {
        "txt": "inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; } } return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get();"
      },
      {
        "txt": "} if (files.isEmpty()) { files = Collections.singletonList(\"-\"); } try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } }"
      },
      {
        "txt": "private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) { return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\")); } try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); }"
      },
      {
        "txt": "} List<JSModule> createJsModules( List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException { if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null);"
      },
      {
        "txt": "final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); for (String spec : specs) { String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0];"
      },
      {
        "txt": "checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name); } JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1;"
      },
      {
        "txt": "} if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1] + \"' for module: \" + name); } if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); }"
      },
      {
        "txt": "List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) { module.add(input); } nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\");"
      },
      {
        "txt": "for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) { throw new FlagUsageException(\"Module '\" + name + \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } }"
      },
      {
        "txt": "} modulesByName.put(name, module); } if (nextJsFileIndex < totalNumJsFiles) { throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name)"
      },
      {
        "txt": "throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\"); } } static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());"
      },
      {
        "txt": "for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); } for (String spec : specs) { int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos);"
      },
      {
        "txt": "if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); } String wrapper = spec.substring(pos + 1); if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); }"
      },
      {
        "txt": "return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException { int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix);"
      },
      {
        "txt": "} out.append(code); int suffixStart = pos + codePlaceholder.length(); if (suffixStart != wrapper.length()) { out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); }"
      },
      {
        "txt": "} else { out.append(code); out.append('\\n'); } } private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File("
      },
      {
        "txt": "pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs(); } } } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler();"
      },
      {
        "txt": "B options = createOptions(); List<JSModule> modules = null; Result result; setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); }"
      },
      {
        "txt": "List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) { modules = createJsModules(moduleSpecs, jsFiles); result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options);"
      },
      {
        "txt": "if (out instanceof Closeable) { ((Closeable) out).close(); } return errCode; } int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; }"
      },
      {
        "txt": "if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1; } else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { return 1; } else { ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1; } else { compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) {"
      },
      {
        "txt": "if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER); outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null;"
      },
      {
        "txt": "if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); } for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) {"
      },
      {
        "txt": "compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close();"
      },
      {
        "txt": "mapOut = null; } } if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile);"
      },
      {
        "txt": "eeOut.append(result.externExport); eeOut.close(); } outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {"
      },
      {
        "txt": "return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); } private boolean shouldGenerateMapPerModule(B options) { return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) {"
      },
      {
        "txt": "return null; } String exPath = options.externExportsPath; if (!exPath.contains(File.separator)) { File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath("
      },
      {
        "txt": "String path, JSModule forModule) { String sub; if (forModule != null) { sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\"; } else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub);"
      },
      {
        "txt": "} @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) { if (Strings.isEmpty(options.sourceMapOutputPath)) { return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) {"
      },
      {
        "txt": "if (Strings.isEmpty(config.outputManifest)) { return null; } return expandCommandLinePath(config.outputManifest, forModule); } private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) {"
      },
      {
        "txt": "return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName)); } protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName);"
      },
      {
        "txt": "} private Writer streamToOutputWriter(OutputStream stream) throws IOException { if (outputCharset == null) { return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); }"
      },
      {
        "txt": "} private void outputSourceMap(B options) throws IOException { if (Strings.isEmpty(options.sourceMapOutputPath)) { return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close();"
      },
      {
        "txt": "} private String getMapPath(String outputFile) { String basePath = \"\"; if (outputFile.equals(\"\")) { if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else {"
      },
      {
        "txt": "File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) { outputFileName = outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; }"
      },
      {
        "txt": "private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null; String variableMapOutputPath = null; String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\";"
      },
      {
        "txt": "} if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) { throw new FlagUsageException(\"The flags variable_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } propertyMapOutputPath = config.propertyMapOutputFile; } if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } }"
      },
      {
        "txt": "if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath); } } if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file);"
      },
      {
        "txt": "compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush(); file.close(); } } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {"
      },
      {
        "txt": "for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0]; if (defName.length() > 0) { String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue);"
      },
      {
        "txt": "} else { options.setDefineToBooleanLiteral(defName, isTrue); } continue; } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal ="
      },
      {
        "txt": "defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) { options.setTweakToStringLiteral(defName, maybeStringVal); } else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else {"
      },
      {
        "txt": "try { double value = Double.parseDouble(defValue); if (tweaks) { options.setTweakToDoubleLiteral(defName, value); } else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { }"
      },
      {
        "txt": "} } if (tweaks) { throw new RuntimeException( \"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } }"
      },
      {
        "txt": "private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null && config.outputManifest.contains(\"%outname%\"); } private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; }"
      },
      {
        "txt": "JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules(); for (JSModule module : modules) { Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null));"
      },
      {
        "txt": "if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else { printModuleGraphManifestTo(graph, out); } out.close(); } } @VisibleForTesting void printModuleGraphManifestTo("
      },
      {
        "txt": "JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false; for (JSModule module : graph.getAllModulesInDependencyOrder()) { if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\","
      },
      {
        "txt": "module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out); requiresNewline = true; } } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) {"
      },
      {
        "txt": "names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names); out.append(result); out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0;"
      },
      {
        "txt": "private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis(); PhaseOptimizer.clearLoopsRun(); } private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) {"
      },
      {
        "txt": "loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; } } private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) {"
      },
      {
        "txt": "out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; } } catch (IOException e) { throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false;"
      },
      {
        "txt": "CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this; } private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false;"
      },
      {
        "txt": "CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this; } private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this; } private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs); return this; } private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this;"
      },
      {
        "txt": "} private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) { this.jsOutputFile = jsOutputFile; return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module);"
      },
      {
        "txt": "return this; } private String variableMapInputFile = \"\"; CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile;"
      },
      {
        "txt": "return this; } private String variableMapOutputFile = \"\"; CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles;"
      },
      {
        "txt": "return this; } private String propertyMapOutputFile = \"\"; CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention;"
      },
      {
        "txt": "return this; } private int summaryDetailLevel = 1; CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper;"
      },
      {
        "txt": "return this; } private final List<String> moduleWrapper = Lists.newArrayList(); CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {"
      },
      {
        "txt": "this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; } private String createSourceMap = \"\"; CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL;"
      },
      {
        "txt": "CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this; } private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; }"
      },
      {
        "txt": "private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning);"
      },
      {
        "txt": "return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) {"
      },
      {
        "txt": "this.define.clear(); this.define.addAll(define); return this; } private final List<String> tweak = Lists.newArrayList(); CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; }"
      },
      {
        "txt": "private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing; return this; } private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; }"
      },
      {
        "txt": "private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal; return this; } private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this;"
      },
      {
        "txt": "} private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) { this.outputManifest = outputManifest; return this; } private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this;"
      },
      {
        "txt": "private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) { this.languageIn = languageIn; return this; } } <extra_id_0> }"
      }
    ]
  },
  {
    "id": 738,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 1632,
    "end-bug-line": 1632,
    "bug": "",
    "fix": "protected void add(CheckLevel level, String groupName) { entries.add(new Entry(level, groupName)); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function;"
      },
      {
        "txt": "import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream;"
      },
      {
        "txt": "import java.io.BufferedWriter; import java.io.Closeable; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer;"
      },
      {
        "txt": "import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.logging.Level; abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out;"
      },
      {
        "txt": "private final PrintStream err; private A compiler; private Charset inputCharset; private String outputCharset; private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null; private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;"
      },
      {
        "txt": "private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() { this(System.out, System.err); } AbstractCommandLineRunner(PrintStream out, PrintStream err) { this.config = new CommandLineConfig(); this.out = out; this.err = err; }"
      },
      {
        "txt": "@VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier, Supplier<List<JSSourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier;"
      },
      {
        "txt": "this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver; } protected boolean isInTestMode() { return testMode; } protected CommandLineConfig getCommandLineConfig() { return config; }"
      },
      {
        "txt": "protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() { if (compiler == null) { return new DiagnosticGroups(); } return compiler.getDiagnosticGroups(); } @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {}"
      },
      {
        "txt": "final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false);"
      },
      {
        "txt": "options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies; if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset();"
      },
      {
        "txt": "inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile; } if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) {"
      },
      {
        "txt": "options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); } if (!config.propertyMapInputFile.equals(\"\")) { options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) {"
      },
      {
        "txt": "options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\");"
      },
      {
        "txt": "} } options.acceptConstKeyword = config.acceptConstKeyword; } final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1;"
      },
      {
        "txt": "if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops(); } try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); }"
      },
      {
        "txt": "} catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1; } catch (Throwable t) { t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); }"
      },
      {
        "txt": "if (testMode) { exitCodeReceiverForTesting.apply(result); } else { System.exit(result); } } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message); } } protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) {"
      },
      {
        "txt": "if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile); } else { if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); }"
      },
      {
        "txt": "inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; } } return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get();"
      },
      {
        "txt": "} if (files.isEmpty()) { files = Collections.singletonList(\"-\"); } try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } }"
      },
      {
        "txt": "private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) { return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\")); } try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); }"
      },
      {
        "txt": "} List<JSModule> createJsModules( List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException { if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null);"
      },
      {
        "txt": "final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); for (String spec : specs) { String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0];"
      },
      {
        "txt": "checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name); } JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1;"
      },
      {
        "txt": "} if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1] + \"' for module: \" + name); } if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); }"
      },
      {
        "txt": "List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) { module.add(input); } nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\");"
      },
      {
        "txt": "for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) { throw new FlagUsageException(\"Module '\" + name + \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } }"
      },
      {
        "txt": "} modulesByName.put(name, module); } if (nextJsFileIndex < totalNumJsFiles) { throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name)"
      },
      {
        "txt": "throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\"); } } static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());"
      },
      {
        "txt": "for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); } for (String spec : specs) { int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos);"
      },
      {
        "txt": "if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); } String wrapper = spec.substring(pos + 1); if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); }"
      },
      {
        "txt": "return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException { int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix);"
      },
      {
        "txt": "} out.append(code); int suffixStart = pos + codePlaceholder.length(); if (suffixStart != wrapper.length()) { out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); }"
      },
      {
        "txt": "} else { out.append(code); out.append('\\n'); } } private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File("
      },
      {
        "txt": "pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs(); } } } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler();"
      },
      {
        "txt": "B options = createOptions(); List<JSModule> modules = null; Result result; setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); }"
      },
      {
        "txt": "List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) { modules = createJsModules(moduleSpecs, jsFiles); result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options);"
      },
      {
        "txt": "if (out instanceof Closeable) { ((Closeable) out).close(); } return errCode; } int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; }"
      },
      {
        "txt": "if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1; } else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { return 1; } else { ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1; } else { compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) {"
      },
      {
        "txt": "if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER); outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null;"
      },
      {
        "txt": "if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); } for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) {"
      },
      {
        "txt": "compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close();"
      },
      {
        "txt": "mapOut = null; } } if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile);"
      },
      {
        "txt": "eeOut.append(result.externExport); eeOut.close(); } outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {"
      },
      {
        "txt": "return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); } private boolean shouldGenerateMapPerModule(B options) { return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) {"
      },
      {
        "txt": "return null; } String exPath = options.externExportsPath; if (!exPath.contains(File.separator)) { File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath("
      },
      {
        "txt": "String path, JSModule forModule) { String sub; if (forModule != null) { sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\"; } else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub);"
      },
      {
        "txt": "} @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) { if (Strings.isEmpty(options.sourceMapOutputPath)) { return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) {"
      },
      {
        "txt": "if (Strings.isEmpty(config.outputManifest)) { return null; } return expandCommandLinePath(config.outputManifest, forModule); } private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) {"
      },
      {
        "txt": "return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName)); } protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName);"
      },
      {
        "txt": "} private Writer streamToOutputWriter(OutputStream stream) throws IOException { if (outputCharset == null) { return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); }"
      },
      {
        "txt": "} private void outputSourceMap(B options) throws IOException { if (Strings.isEmpty(options.sourceMapOutputPath)) { return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close();"
      },
      {
        "txt": "} private String getMapPath(String outputFile) { String basePath = \"\"; if (outputFile.equals(\"\")) { if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else {"
      },
      {
        "txt": "File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) { outputFileName = outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; }"
      },
      {
        "txt": "private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null; String variableMapOutputPath = null; String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\";"
      },
      {
        "txt": "} if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) { throw new FlagUsageException(\"The flags variable_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } propertyMapOutputPath = config.propertyMapOutputFile; } if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } }"
      },
      {
        "txt": "if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath); } } if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file);"
      },
      {
        "txt": "compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush(); file.close(); } } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {"
      },
      {
        "txt": "for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0]; if (defName.length() > 0) { String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue);"
      },
      {
        "txt": "} else { options.setDefineToBooleanLiteral(defName, isTrue); } continue; } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal ="
      },
      {
        "txt": "defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) { options.setTweakToStringLiteral(defName, maybeStringVal); } else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else {"
      },
      {
        "txt": "try { double value = Double.parseDouble(defValue); if (tweaks) { options.setTweakToDoubleLiteral(defName, value); } else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { }"
      },
      {
        "txt": "} } if (tweaks) { throw new RuntimeException( \"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } }"
      },
      {
        "txt": "private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null && config.outputManifest.contains(\"%outname%\"); } private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; }"
      },
      {
        "txt": "JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules(); for (JSModule module : modules) { Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null));"
      },
      {
        "txt": "if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else { printModuleGraphManifestTo(graph, out); } out.close(); } } @VisibleForTesting void printModuleGraphManifestTo("
      },
      {
        "txt": "JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false; for (JSModule module : graph.getAllModulesInDependencyOrder()) { if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\","
      },
      {
        "txt": "module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out); requiresNewline = true; } } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) {"
      },
      {
        "txt": "names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names); out.append(result); out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0;"
      },
      {
        "txt": "private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis(); PhaseOptimizer.clearLoopsRun(); } private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) {"
      },
      {
        "txt": "loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; } } private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) {"
      },
      {
        "txt": "out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; } } catch (IOException e) { throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false;"
      },
      {
        "txt": "CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this; } private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false;"
      },
      {
        "txt": "CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this; } private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this; } private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs); return this; } private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this;"
      },
      {
        "txt": "} private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) { this.jsOutputFile = jsOutputFile; return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module);"
      },
      {
        "txt": "return this; } private String variableMapInputFile = \"\"; CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile;"
      },
      {
        "txt": "return this; } private String variableMapOutputFile = \"\"; CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles;"
      },
      {
        "txt": "return this; } private String propertyMapOutputFile = \"\"; CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention;"
      },
      {
        "txt": "return this; } private int summaryDetailLevel = 1; CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper;"
      },
      {
        "txt": "return this; } private final List<String> moduleWrapper = Lists.newArrayList(); CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {"
      },
      {
        "txt": "this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; } private String createSourceMap = \"\"; CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL;"
      },
      {
        "txt": "CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this; } private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; }"
      },
      {
        "txt": "private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning);"
      },
      {
        "txt": "return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) {"
      },
      {
        "txt": "this.define.clear(); this.define.addAll(define); return this; } private final List<String> tweak = Lists.newArrayList(); CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; }"
      },
      {
        "txt": "private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing; return this; } private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; }"
      },
      {
        "txt": "private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal; return this; } private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this;"
      },
      {
        "txt": "} private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) { this.outputManifest = outputManifest; return this; } private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this;"
      },
      {
        "txt": "private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) { this.languageIn = languageIn; return this; } } <extra_id_0> }"
      }
    ]
  },
  {
    "id": 739,
    "file_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
    "start-bug-line": 1633,
    "end-bug-line": 1633,
    "bug": "",
    "fix": "protected void clear() { entries.clear(); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Charsets; import com.google.common.base.Function;"
      },
      {
        "txt": "import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.TweakProcessing; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.TokenStream; import com.google.protobuf.CodedOutputStream;"
      },
      {
        "txt": "import java.io.BufferedWriter; import java.io.Closeable; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintStream; import java.io.StringWriter; import java.io.Writer;"
      },
      {
        "txt": "import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.logging.Level; abstract class AbstractCommandLineRunner<A extends Compiler, B extends CompilerOptions> { private final CommandLineConfig config; private Appendable out;"
      },
      {
        "txt": "private final PrintStream err; private A compiler; private Charset inputCharset; private String outputCharset; private boolean testMode = false; private Supplier<List<JSSourceFile>> externsSupplierForTesting = null; private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null; private Supplier<List<JSModule>> modulesSupplierForTesting = null; private Function<Integer, Boolean> exitCodeReceiverForTesting = null; private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;"
      },
      {
        "txt": "private static final String OUTPUT_WRAPPER_MARKER = \"%output%\"; private final RunTimeStats runTimeStats = new RunTimeStats(); AbstractCommandLineRunner() { this(System.out, System.err); } AbstractCommandLineRunner(PrintStream out, PrintStream err) { this.config = new CommandLineConfig(); this.out = out; this.err = err; }"
      },
      {
        "txt": "@VisibleForTesting void enableTestMode( Supplier<List<JSSourceFile>> externsSupplier, Supplier<List<JSSourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { Preconditions.checkArgument( inputsSupplier == null ^ modulesSupplier == null); testMode = true; this.externsSupplierForTesting = externsSupplier;"
      },
      {
        "txt": "this.inputsSupplierForTesting = inputsSupplier; this.modulesSupplierForTesting = modulesSupplier; this.exitCodeReceiverForTesting = exitCodeReceiver; } protected boolean isInTestMode() { return testMode; } protected CommandLineConfig getCommandLineConfig() { return config; }"
      },
      {
        "txt": "protected abstract A createCompiler(); protected abstract B createOptions(); protected DiagnosticGroups getDiagnosticGroups() { if (compiler == null) { return new DiagnosticGroups(); } return compiler.getDiagnosticGroups(); } @Deprecated protected void initOptionsFromFlags(CompilerOptions options) {}"
      },
      {
        "txt": "final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); diagnosticGroups.setWarningLevels( options, config.jscompError, CheckLevel.ERROR); diagnosticGroups.setWarningLevels( options, config.jscompWarning, CheckLevel.WARNING); diagnosticGroups.setWarningLevels( options, config.jscompOff, CheckLevel.OFF); createDefineOrTweakReplacements(config.define, options, false);"
      },
      {
        "txt": "options.setTweakProcessing(config.tweakProcessing); createDefineOrTweakReplacements(config.tweak, options, true); options.manageClosureDependencies = config.manageClosureDependencies; if (config.closureEntryPoints.size() > 0) { options.setManageClosureDependencies(config.closureEntryPoints); } options.devMode = config.jscompDevMode; options.setCodingConvention(config.codingConvention); options.setSummaryDetailLevel(config.summaryDetailLevel); outputCharset = options.outputCharset = getOutputCharset();"
      },
      {
        "txt": "inputCharset = getInputCharset(); if (config.jsOutputFile.length() > 0) { options.jsOutputFile = config.jsOutputFile; } if (config.createSourceMap.length() > 0) { options.sourceMapOutputPath = config.createSourceMap; } options.sourceMapDetailLevel = config.sourceMapDetailLevel; options.sourceMapFormat = config.sourceMapFormat; if (!config.variableMapInputFile.equals(\"\")) {"
      },
      {
        "txt": "options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes(); } if (!config.propertyMapInputFile.equals(\"\")) { options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes(); } if (config.languageIn.length() > 0) { if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") || config.languageIn.equals(\"ES5_STRICT\")) {"
      },
      {
        "txt": "options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT5\") || config.languageIn.equals(\"ES5\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5); } else if (config.languageIn.equals(\"ECMASCRIPT3\") || config.languageIn.equals(\"ES3\")) { options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3); } else { throw new FlagUsageException(\"Unknown language `\" + config.languageIn + \"' specified.\");"
      },
      {
        "txt": "} } options.acceptConstKeyword = config.acceptConstKeyword; } final protected A getCompiler() { return compiler; } final public void run() { int result = 0; int runs = 1;"
      },
      {
        "txt": "if (config.computePhaseOrdering) { runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; PhaseOptimizer.randomizeLoops(); } try { for (int i = 0; i < runs && result == 0; i++) { runTimeStats.recordStartRun(); result = doRun(); runTimeStats.recordEndRun(); }"
      },
      {
        "txt": "} catch (AbstractCommandLineRunner.FlagUsageException e) { System.err.println(e.getMessage()); result = -1; } catch (Throwable t) { t.printStackTrace(); result = -2; } if (config.computePhaseOrdering) { runTimeStats.outputBestPhaseOrdering(); }"
      },
      {
        "txt": "if (testMode) { exitCodeReceiverForTesting.apply(result); } else { System.exit(result); } } protected PrintStream getErrorPrintStream() { return err; } public static class FlagUsageException extends Exception {"
      },
      {
        "txt": "private static final long serialVersionUID = 1L; public FlagUsageException(String message) { super(message); } } protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size()); boolean usingStdin = false; for (String filename : files) {"
      },
      {
        "txt": "if (!\"-\".equals(filename)) { JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset); inputs.add(newFile); } else { if (!allowStdIn) { throw new FlagUsageException(\"Can't specify stdin.\"); } if (usingStdin) { throw new FlagUsageException(\"Can't specify stdin twice.\"); }"
      },
      {
        "txt": "inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in)); usingStdin = true; } } return inputs; } private List<JSSourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { if (isInTestMode()) { return inputsSupplierForTesting.get();"
      },
      {
        "txt": "} if (files.isEmpty()) { files = Collections.singletonList(\"-\"); } try { return createInputs(files, true); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage()); } }"
      },
      {
        "txt": "private List<JSSourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { if (files.isEmpty()) { return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\")); } try { return createInputs(files, false); } catch (FlagUsageException e) { throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage()); }"
      },
      {
        "txt": "} List<JSModule> createJsModules( List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException { if (isInTestMode()) { return modulesSupplierForTesting.get(); } Preconditions.checkState(specs != null); Preconditions.checkState(!specs.isEmpty()); Preconditions.checkState(jsFiles != null);"
      },
      {
        "txt": "final int totalNumJsFiles = jsFiles.size(); int nextJsFileIndex = 0; Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); for (String spec : specs) { String[] parts = spec.split(\":\"); if (parts.length < 2 || parts.length > 4) { throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \" + \"module spec: \" + spec); } String name = parts[0];"
      },
      {
        "txt": "checkModuleName(name); if (modulesByName.containsKey(name)) { throw new FlagUsageException(\"Duplicate module name: \" + name); } JSModule module = new JSModule(name); int numJsFiles = -1; try { numJsFiles = Integer.parseInt(parts[1]); } catch (NumberFormatException ignored) { numJsFiles = -1;"
      },
      {
        "txt": "} if (numJsFiles < 0) { throw new FlagUsageException(\"Invalid js file count '\" + parts[1] + \"' for module: \" + name); } if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { throw new FlagUsageException(\"Not enough js files specified. Expected \" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + \" more in module:\" + name); }"
      },
      {
        "txt": "List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); for (JSSourceFile input : createInputs(moduleJsFiles, false)) { module.add(input); } nextJsFileIndex += numJsFiles; if (parts.length > 2) { String depList = parts[2]; if (depList.length() > 0) { String[] deps = depList.split(\",\");"
      },
      {
        "txt": "for (String dep : deps) { JSModule other = modulesByName.get(dep); if (other == null) { throw new FlagUsageException(\"Module '\" + name + \"' depends on unknown module '\" + dep + \"'. Be sure to list modules in dependency order.\"); } module.addDependency(other); } }"
      },
      {
        "txt": "} modulesByName.put(name, module); } if (nextJsFileIndex < totalNumJsFiles) { throw new FlagUsageException(\"Too many js files specified. Expected \" + nextJsFileIndex + \" but found \" + totalNumJsFiles); } return Lists.newArrayList(modulesByName.values()); } protected void checkModuleName(String name)"
      },
      {
        "txt": "throws FlagUsageException { if (!TokenStream.isJSIdentifier(name)) { throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\"); } } static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { Preconditions.checkState(specs != null); Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());"
      },
      {
        "txt": "for (JSModule m : modules) { wrappers.put(m.getName(), \"\"); } for (String spec : specs) { int pos = spec.indexOf(':'); if (pos == -1) { throw new FlagUsageException(\"Expected module wrapper to have \" + \"<name>:<wrapper> format: \" + spec); } String name = spec.substring(0, pos);"
      },
      {
        "txt": "if (!wrappers.containsKey(name)) { throw new FlagUsageException(\"Unknown module: '\" + name + \"'\"); } String wrapper = spec.substring(pos + 1); if (!wrapper.contains(\"%s\")) { throw new FlagUsageException(\"No %s placeholder in module wrapper: '\" + wrapper + \"'\"); } wrappers.put(name, wrapper); }"
      },
      {
        "txt": "return wrappers; } static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException { int pos = wrapper.indexOf(codePlaceholder); if (pos != -1) { String prefix = \"\"; if (pos > 0) { prefix = wrapper.substring(0, pos); out.append(prefix);"
      },
      {
        "txt": "} out.append(code); int suffixStart = pos + codePlaceholder.length(); if (suffixStart != wrapper.length()) { out.append(wrapper.substring(suffixStart)); } out.append('\\n'); if (compiler != null && compiler.getSourceMap() != null) { compiler.getSourceMap().setWrapperPrefix(prefix); }"
      },
      {
        "txt": "} else { out.append(code); out.append('\\n'); } } private static void maybeCreateDirsForPath(String pathPrefix) { if (pathPrefix.length() > 0) { String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File("
      },
      {
        "txt": "pathPrefix).getParent(); if (dirName != null) { new File(dirName).mkdirs(); } } } protected int doRun() throws FlagUsageException, IOException { Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); List<JSSourceFile> externs = createExterns(); compiler = createCompiler();"
      },
      {
        "txt": "B options = createOptions(); List<JSModule> modules = null; Result result; setRunOptions(options); boolean writeOutputToFile = !options.jsOutputFile.isEmpty(); if (writeOutputToFile) { out = fileNameToOutputWriter(options.jsOutputFile); } else if (out instanceof OutputStream) { out = streamToOutputWriter((OutputStream) out); }"
      },
      {
        "txt": "List<String> jsFiles = config.js; List<String> moduleSpecs = config.module; if (!moduleSpecs.isEmpty()) { modules = createJsModules(moduleSpecs, jsFiles); result = compiler.compileModules(externs, modules, options); } else { List<JSSourceFile> inputs = createSourceInputs(jsFiles); result = compiler.compile(externs, inputs, options); } int errCode = processResults(result, modules, options);"
      },
      {
        "txt": "if (out instanceof Closeable) { ((Closeable) out).close(); } return errCode; } int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; }"
      },
      {
        "txt": "if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1; } else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { return 1; } else { ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) {"
      },
      {
        "txt": "if (compiler.getRoot() == null) { out.append(\"Code contains errors; no tree was generated.\\n\"); return 1; } else { compiler.getRoot().appendStringTree(out); out.append(\"\\n\"); return 0; } } if (result.success) {"
      },
      {
        "txt": "if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER); outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null;"
      },
      {
        "txt": "if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); } for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter( moduleFilePrefix + m.getName() + \".js\"); if (options.sourceMapOutputPath != null) {"
      },
      {
        "txt": "compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close();"
      },
      {
        "txt": "mapOut = null; } } if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile);"
      },
      {
        "txt": "eeOut.append(result.externExport); eeOut.close(); } outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); } private Charset getInputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return Charset.forName(config.charset); } return Charsets.UTF_8; } private String getOutputCharset() throws FlagUsageException { if (!config.charset.isEmpty()) {"
      },
      {
        "txt": "if (!Charset.isSupported(config.charset)) { throw new FlagUsageException(config.charset + \" is not a valid charset name.\"); } return config.charset; } return \"US-ASCII\"; } protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException {"
      },
      {
        "txt": "return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); } private boolean shouldGenerateMapPerModule(B options) { return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains(\"%outname%\"); } private Writer openExternExportsStream(B options, String path) throws IOException { if (options.externExportsPath == null) {"
      },
      {
        "txt": "return null; } String exPath = options.externExportsPath; if (!exPath.contains(File.separator)) { File outputFile = new File(path); exPath = outputFile.getParent() + File.separatorChar + exPath; } return fileNameToOutputWriter(exPath); } private String expandCommandLinePath("
      },
      {
        "txt": "String path, JSModule forModule) { String sub; if (forModule != null) { sub = config.moduleOutputPathPrefix + forModule.getName() + \".js\"; } else if (!config.module.isEmpty()) { sub = config.moduleOutputPathPrefix; } else { sub = config.jsOutputFile; } return path.replace(\"%outname%\", sub);"
      },
      {
        "txt": "} @VisibleForTesting String expandSourceMapPath(B options, JSModule forModule) { if (Strings.isEmpty(options.sourceMapOutputPath)) { return null; } return expandCommandLinePath(options.sourceMapOutputPath, forModule); } @VisibleForTesting String expandManifest(JSModule forModule) {"
      },
      {
        "txt": "if (Strings.isEmpty(config.outputManifest)) { return null; } return expandCommandLinePath(config.outputManifest, forModule); } private Writer fileNameToOutputWriter(String fileName) throws IOException { if (fileName == null) { return null; } if (testMode) {"
      },
      {
        "txt": "return new StringWriter(); } return streamToOutputWriter(filenameToOutputStream(fileName)); } protected OutputStream filenameToOutputStream(String fileName) throws IOException { if (fileName == null){ return null; } return new FileOutputStream(fileName);"
      },
      {
        "txt": "} private Writer streamToOutputWriter(OutputStream stream) throws IOException { if (outputCharset == null) { return new BufferedWriter( new OutputStreamWriter(stream)); } else { return new BufferedWriter( new OutputStreamWriter(stream, outputCharset)); }"
      },
      {
        "txt": "} private void outputSourceMap(B options) throws IOException { if (Strings.isEmpty(options.sourceMapOutputPath)) { return; } String outName = expandSourceMapPath(options, null); Writer out = fileNameToOutputWriter(outName); compiler.getSourceMap().appendTo(out, outName); out.close();"
      },
      {
        "txt": "} private String getMapPath(String outputFile) { String basePath = \"\"; if (outputFile.equals(\"\")) { if (!config.moduleOutputPathPrefix.equals(\"\")) { basePath = config.moduleOutputPathPrefix; } else { basePath = \"jscompiler\"; } } else {"
      },
      {
        "txt": "File file = new File(outputFile); String outputFileName = file.getName(); if (outputFileName.endsWith(\".js\")) { outputFileName = outputFileName.substring(0, outputFileName.length() - 3); } basePath = file.getParent() + File.separatorChar + outputFileName; } return basePath; }"
      },
      {
        "txt": "private void outputNameMaps(B options) throws FlagUsageException, IOException { String propertyMapOutputPath = null; String variableMapOutputPath = null; String functionInformationMapOutputPath = null; if (config.createNameMapFiles) { String basePath = getMapPath(options.jsOutputFile); propertyMapOutputPath = basePath + \"_props_map.out\"; variableMapOutputPath = basePath + \"_vars_map.out\"; functionInformationMapOutputPath = basePath + \"_functions_map.out\";"
      },
      {
        "txt": "} if (!config.variableMapOutputFile.equals(\"\")) { if (variableMapOutputPath != null) { throw new FlagUsageException(\"The flags variable_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } variableMapOutputPath = config.variableMapOutputFile; } if (!config.propertyMapOutputFile.equals(\"\")) { if (propertyMapOutputPath != null) {"
      },
      {
        "txt": "throw new FlagUsageException(\"The flags property_map_output_file and \" + \"create_name_map_files cannot both be used simultaniously.\"); } propertyMapOutputPath = config.propertyMapOutputFile; } if (variableMapOutputPath != null) { if (compiler.getVariableMap() != null) { compiler.getVariableMap().save(variableMapOutputPath); } }"
      },
      {
        "txt": "if (propertyMapOutputPath != null) { if (compiler.getPropertyMap() != null) { compiler.getPropertyMap().save(propertyMapOutputPath); } } if (functionInformationMapOutputPath != null) { if (compiler.getFunctionalInformationMap() != null) { OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); CodedOutputStream outputStream = CodedOutputStream.newInstance(file);"
      },
      {
        "txt": "compiler.getFunctionalInformationMap().writeTo(outputStream); outputStream.flush(); file.flush(); file.close(); } } } @VisibleForTesting static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {"
      },
      {
        "txt": "for (String override : definitions) { String[] assignment = override.split(\"=\", 2); String defName = assignment[0]; if (defName.length() > 0) { String defValue = assignment.length == 1 ? \"true\" : assignment[1]; boolean isTrue = defValue.equals(\"true\"); boolean isFalse = defValue.equals(\"false\"); if (isTrue || isFalse) { if (tweaks) { options.setTweakToBooleanLiteral(defName, isTrue);"
      },
      {
        "txt": "} else { options.setDefineToBooleanLiteral(defName, isTrue); } continue; } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\'') || (defValue.charAt(0) == '\\\"' && defValue.charAt(defValue.length() - 1) == '\\\"'))) { String maybeStringVal ="
      },
      {
        "txt": "defValue.substring(1, defValue.length() - 1); if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { if (tweaks) { options.setTweakToStringLiteral(defName, maybeStringVal); } else { options.setDefineToStringLiteral(defName, maybeStringVal); } continue; } } else {"
      },
      {
        "txt": "try { double value = Double.parseDouble(defValue); if (tweaks) { options.setTweakToDoubleLiteral(defName, value); } else { options.setDefineToDoubleLiteral(defName, value); } continue; } catch (NumberFormatException e) { }"
      },
      {
        "txt": "} } if (tweaks) { throw new RuntimeException( \"--tweak flag syntax invalid: \" + override); } throw new RuntimeException( \"--define flag syntax invalid: \" + override); } }"
      },
      {
        "txt": "private boolean shouldGenerateManifestPerModule() { return !config.module.isEmpty() && config.outputManifest != null && config.outputManifest.contains(\"%outname%\"); } private void outputManifest() throws IOException { String outputManifest = config.outputManifest; if (Strings.isEmpty(outputManifest)) { return; }"
      },
      {
        "txt": "JSModuleGraph graph = compiler.getModuleGraph(); if (shouldGenerateManifestPerModule()) { Iterable<JSModule> modules = graph.getAllModules(); for (JSModule module : modules) { Writer out = fileNameToOutputWriter(expandManifest(module)); printManifestTo(module.getInputs(), out); out.close(); } } else { Writer out = fileNameToOutputWriter(expandManifest(null));"
      },
      {
        "txt": "if (graph == null) { printManifestTo(compiler.getInputsInOrder(), out); } else { printModuleGraphManifestTo(graph, out); } out.close(); } } @VisibleForTesting void printModuleGraphManifestTo("
      },
      {
        "txt": "JSModuleGraph graph, Appendable out) throws IOException { Joiner commas = Joiner.on(\",\"); boolean requiresNewline = false; for (JSModule module : graph.getAllModulesInDependencyOrder()) { if (requiresNewline) { out.append(\"\\n\"); } String dependencies = commas.join(module.getSortedDependencyNames()); out.append( String.format(\"{%s%s}\\n\","
      },
      {
        "txt": "module.getName(), dependencies.isEmpty() ? \"\" : \":\" + dependencies)); printManifestTo(module.getInputs(), out); requiresNewline = true; } } private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { List<String> names = Lists.newArrayList(); for (CompilerInput input : inputs) {"
      },
      {
        "txt": "names.add(input.getName()); } String result = Joiner.on(\"\\n\").join(names); out.append(result); out.append(\"\\n\"); } private class RunTimeStats { private long bestRunTime = Long.MAX_VALUE; private long worstRunTime = Long.MIN_VALUE; private long lastStartTime = 0;"
      },
      {
        "txt": "private List<List<String>> loopedPassesInBestRun = null; private void recordStartRun() { lastStartTime = System.currentTimeMillis(); PhaseOptimizer.clearLoopsRun(); } private void recordEndRun() { long endTime = System.currentTimeMillis(); long length = endTime - lastStartTime; worstRunTime = Math.max(length, worstRunTime); if (length < bestRunTime) {"
      },
      {
        "txt": "loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); bestRunTime = length; } } private void outputBestPhaseOrdering() { try { out.append(\"Best time: \" + bestRunTime + \"\\n\"); out.append(\"Worst time: \" + worstRunTime + \"\\n\"); int i = 1; for (List<String> loop : loopedPassesInBestRun) {"
      },
      {
        "txt": "out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\"); i++; } } catch (IOException e) { throw new RuntimeException(\"unexpected exception\", e); } } } static class CommandLineConfig { private boolean printTree = false;"
      },
      {
        "txt": "CommandLineConfig setPrintTree(boolean printTree) { this.printTree = printTree; return this; } private boolean computePhaseOrdering = false; CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { this.computePhaseOrdering = computePhaseOrdering; return this; } private boolean printAst = false;"
      },
      {
        "txt": "CommandLineConfig setPrintAst(boolean printAst) { this.printAst = printAst; return this; } private boolean printPassGraph = false; CommandLineConfig setPrintPassGraph(boolean printPassGraph) { this.printPassGraph = printPassGraph; return this; } private CompilerOptions.DevMode jscompDevMode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { this.jscompDevMode = jscompDevMode; return this; } private String loggingLevel = Level.WARNING.getName(); CommandLineConfig setLoggingLevel(String loggingLevel) { this.loggingLevel = loggingLevel; return this; } private final List<String> externs = Lists.newArrayList();"
      },
      {
        "txt": "CommandLineConfig setExterns(List<String> externs) { this.externs.clear(); this.externs.addAll(externs); return this; } private final List<String> js = Lists.newArrayList(); CommandLineConfig setJs(List<String> js) { this.js.clear(); this.js.addAll(js); return this;"
      },
      {
        "txt": "} private String jsOutputFile = \"\"; CommandLineConfig setJsOutputFile(String jsOutputFile) { this.jsOutputFile = jsOutputFile; return this; } private final List<String> module = Lists.newArrayList(); CommandLineConfig setModule(List<String> module) { this.module.clear(); this.module.addAll(module);"
      },
      {
        "txt": "return this; } private String variableMapInputFile = \"\"; CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { this.variableMapInputFile = variableMapInputFile; return this; } private String propertyMapInputFile = \"\"; CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { this.propertyMapInputFile = propertyMapInputFile;"
      },
      {
        "txt": "return this; } private String variableMapOutputFile = \"\"; CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { this.variableMapOutputFile = variableMapOutputFile; return this; } private boolean createNameMapFiles = false; CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { this.createNameMapFiles = createNameMapFiles;"
      },
      {
        "txt": "return this; } private String propertyMapOutputFile = \"\"; CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { this.propertyMapOutputFile = propertyMapOutputFile; return this; } private CodingConvention codingConvention = new DefaultCodingConvention(); CommandLineConfig setCodingConvention(CodingConvention codingConvention) { this.codingConvention = codingConvention;"
      },
      {
        "txt": "return this; } private int summaryDetailLevel = 1; CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { this.summaryDetailLevel = summaryDetailLevel; return this; } private String outputWrapper = \"\"; CommandLineConfig setOutputWrapper(String outputWrapper) { this.outputWrapper = outputWrapper;"
      },
      {
        "txt": "return this; } private final List<String> moduleWrapper = Lists.newArrayList(); CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { this.moduleWrapper.clear(); this.moduleWrapper.addAll(moduleWrapper); return this; } private String moduleOutputPathPrefix = \"\"; CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {"
      },
      {
        "txt": "this.moduleOutputPathPrefix = moduleOutputPathPrefix; return this; } private String createSourceMap = \"\"; CommandLineConfig setCreateSourceMap(String createSourceMap) { this.createSourceMap = createSourceMap; return this; } private SourceMap.DetailLevel sourceMapDetailLevel = SourceMap.DetailLevel.ALL;"
      },
      {
        "txt": "CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { this.sourceMapDetailLevel = level; return this; } private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT; CommandLineConfig setSourceMapFormat(SourceMap.Format format) { this.sourceMapFormat = format; return this; }"
      },
      {
        "txt": "private final List<String> jscompError = Lists.newArrayList(); CommandLineConfig setJscompError(List<String> jscompError) { this.jscompError.clear(); this.jscompError.addAll(jscompError); return this; } private final List<String> jscompWarning = Lists.newArrayList(); CommandLineConfig setJscompWarning(List<String> jscompWarning) { this.jscompWarning.clear(); this.jscompWarning.addAll(jscompWarning);"
      },
      {
        "txt": "return this; } private final List<String> jscompOff = Lists.newArrayList(); CommandLineConfig setJscompOff(List<String> jscompOff) { this.jscompOff.clear(); this.jscompOff.addAll(jscompOff); return this; } private final List<String> define = Lists.newArrayList(); CommandLineConfig setDefine(List<String> define) {"
      },
      {
        "txt": "this.define.clear(); this.define.addAll(define); return this; } private final List<String> tweak = Lists.newArrayList(); CommandLineConfig setTweak(List<String> tweak) { this.tweak.clear(); this.tweak.addAll(tweak); return this; }"
      },
      {
        "txt": "private TweakProcessing tweakProcessing = TweakProcessing.OFF; CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { this.tweakProcessing = tweakProcessing; return this; } private String charset = \"\"; CommandLineConfig setCharset(String charset) { this.charset = charset; return this; }"
      },
      {
        "txt": "private boolean manageClosureDependencies = false; CommandLineConfig setManageClosureDependencies(boolean newVal) { this.manageClosureDependencies = newVal; return this; } private List<String> closureEntryPoints = ImmutableList.of(); CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { Preconditions.checkNotNull(entryPoints); this.closureEntryPoints = entryPoints; return this;"
      },
      {
        "txt": "} private String outputManifest = \"\"; CommandLineConfig setOutputManifest(String outputManifest) { this.outputManifest = outputManifest; return this; } private boolean acceptConstKeyword = false; CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { this.acceptConstKeyword = acceptConstKeyword; return this;"
      },
      {
        "txt": "private String languageIn = \"\"; CommandLineConfig setLanguageIn(String languageIn) { this.languageIn = languageIn; return this; } } <extra_id_0>"
      }
    ]
  },
  {
    "id": 740,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 26,
    "end-bug-line": 26,
    "bug": "",
    "fix": "import com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; <extra_id_0> import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters;"
      },
      {
        "txt": "import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends"
      },
      {
        "txt": "AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\")"
      },
      {
        "txt": "private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\")"
      },
      {
        "txt": "private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "@Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\","
      },
      {
        "txt": "usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \""
      },
      {
        "txt": "+ \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \""
      },
      {
        "txt": "+ \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1;"
      },
      {
        "txt": "@Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" +"
      },
      {
        "txt": "\"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" +"
      },
      {
        "txt": "\"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level ="
      },
      {
        "txt": "CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \""
      },
      {
        "txt": "+ \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \""
      },
      {
        "txt": "+ \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \""
      },
      {
        "txt": "+ \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \""
      },
      {
        "txt": "+ \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES ="
      },
      {
        "txt": "Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try {"
      },
      {
        "txt": "param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) {"
      },
      {
        "txt": "setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } } @Override public String getDefaultMetaVariable() {"
      },
      {
        "txt": "return null; } } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) {"
      },
      {
        "txt": "case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); } }"
      },
      {
        "txt": "} private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {"
      },
      {
        "txt": "super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) {"
      },
      {
        "txt": "processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); } } else { processedArgs.add(arg);"
      },
      {
        "txt": "} } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset()));"
      },
      {
        "txt": "while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \""
      },
      {
        "txt": "+ \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {}));"
      },
      {
        "txt": "if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; }"
      },
      {
        "txt": "if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false;"
      },
      {
        "txt": "parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs)"
      },
      {
        "txt": ".setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() :"
      },
      {
        "txt": "new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define)"
      },
      {
        "txt": ".setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } } @Override protected CompilerOptions createOptions() {"
      },
      {
        "txt": "CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); }"
      },
      {
        "txt": "WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; } @Override protected Compiler createCompiler() {"
      },
      {
        "txt": "return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns();"
      },
      {
        "txt": "defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\","
      },
      {
        "txt": "\"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\","
      },
      {
        "txt": "\"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\","
      },
      {
        "txt": "\"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\","
      },
      {
        "txt": "\"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize());"
      },
      {
        "txt": "externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) {"
      },
      {
        "txt": "externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) {"
      },
      {
        "txt": "runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 741,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 94,
    "end-bug-line": 94,
    "bug": "",
    "fix": "private static final WarningGuardSpec warningGuardSpec = new WarningGuardSpec();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { <extra_id_0> @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "@Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\","
      },
      {
        "txt": "aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\""
      },
      {
        "txt": "+ \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\","
      },
      {
        "txt": "usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\")"
      },
      {
        "txt": "private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\")"
      },
      {
        "txt": "private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \""
      },
      {
        "txt": "+ \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \""
      },
      {
        "txt": "+ \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" +"
      },
      {
        "txt": "\"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\","
      },
      {
        "txt": "usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" +"
      },
      {
        "txt": "\"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\","
      },
      {
        "txt": "usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false;"
      },
      {
        "txt": "@Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true;"
      },
      {
        "txt": "@Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \""
      },
      {
        "txt": "+ \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \""
      },
      {
        "txt": "+ \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \""
      },
      {
        "txt": "+ \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> {"
      },
      {
        "txt": "private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override"
      },
      {
        "txt": "public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase();"
      },
      {
        "txt": "if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; }"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER,"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 742,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 231,
    "end-bug-line": 231,
    "bug": "",
    "fix": "handler = WarningGuardErrorOptionHandler.class,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "\"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", <extra_id_0> DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList();"
      },
      {
        "txt": "\"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" +"
      },
      {
        "txt": "\"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" +"
      },
      {
        "txt": "\"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\")"
      },
      {
        "txt": "private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false; @Option(name = \"--formatting\","
      },
      {
        "txt": "usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \""
      },
      {
        "txt": "+ \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \""
      },
      {
        "txt": "+ \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\")"
      },
      {
        "txt": "private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES ="
      },
      {
        "txt": "Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException {"
      },
      {
        "txt": "String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) {"
      },
      {
        "txt": "setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }"
      },
      {
        "txt": "@Override public String getDefaultMetaVariable() { return null; } } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ;"
      },
      {
        "txt": "private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this);"
      },
      {
        "txt": "} } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err);"
      },
      {
        "txt": "} protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) {"
      },
      {
        "txt": "Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); }"
      },
      {
        "txt": "} else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file);"
      },
      {
        "txt": "StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));"
      },
      {
        "txt": "if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true;"
      },
      {
        "txt": "try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\");"
      },
      {
        "txt": "isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); }"
      },
      {
        "txt": "if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode)"
      },
      {
        "txt": ".setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file)"
      },
      {
        "txt": ".setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning)"
      },
      {
        "txt": ".setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } }"
      },
      {
        "txt": "@Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) {"
      },
      {
        "txt": "options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; }"
      },
      {
        "txt": "@Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs;"
      },
      {
        "txt": "} else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\","
      },
      {
        "txt": "\"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\","
      },
      {
        "txt": "\"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\","
      },
      {
        "txt": "\"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\","
      },
      {
        "txt": "\"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap();"
      },
      {
        "txt": "for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\");"
      },
      {
        "txt": "List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) {"
      },
      {
        "txt": "CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 743,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 236,
    "end-bug-line": 236,
    "bug": "",
    "fix": "handler = WarningGuardWarningOptionHandler.class,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef;"
      },
      {
        "txt": "import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends"
      },
      {
        "txt": "AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\")"
      },
      {
        "txt": "private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\")"
      },
      {
        "txt": "private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "@Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\","
      },
      {
        "txt": "usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \""
      },
      {
        "txt": "+ \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \""
      },
      {
        "txt": "+ \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1;"
      },
      {
        "txt": "@Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" +"
      },
      {
        "txt": "private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", <extra_id_0> \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList();"
      },
      {
        "txt": "DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\","
      },
      {
        "txt": "usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\")"
      },
      {
        "txt": "private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \""
      },
      {
        "txt": "+ \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \""
      },
      {
        "txt": "+ \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\";"
      },
      {
        "txt": "@Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\")"
      },
      {
        "txt": "private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler("
      },
      {
        "txt": "CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}"
      },
      {
        "txt": "if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else {"
      },
      {
        "txt": "setter.addValue(true); return 0; } return 1; } } @Override public String getDefaultMetaVariable() { return null; }"
      },
      {
        "txt": "} } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true;"
      },
      {
        "txt": "break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags();"
      },
      {
        "txt": "private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err);"
      },
      {
        "txt": "} private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2);"
      },
      {
        "txt": "Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); } } else { processedArgs.add(arg); } }"
      },
      {
        "txt": "return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken());"
      },
      {
        "txt": "} flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false;"
      },
      {
        "txt": "} } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err);"
      },
      {
        "txt": "} } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource);"
      },
      {
        "txt": "err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else {"
      },
      {
        "txt": "getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file)"
      },
      {
        "txt": ".setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level)"
      },
      {
        "txt": ".setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)"
      },
      {
        "txt": ".setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention());"
      },
      {
        "txt": "CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options);"
      },
      {
        "txt": "for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; } @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); }"
      },
      {
        "txt": "@Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns;"
      },
      {
        "txt": "} } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\","
      },
      {
        "txt": "\"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\","
      },
      {
        "txt": "\"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\","
      },
      {
        "txt": "\"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\","
      },
      {
        "txt": "\"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream("
      },
      {
        "txt": "\"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); }"
      },
      {
        "txt": "return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else {"
      },
      {
        "txt": "System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 744,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 241,
    "end-bug-line": 241,
    "bug": "",
    "fix": "handler = WarningGuardOffOptionHandler.class,",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets;"
      },
      {
        "txt": "import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler;"
      },
      {
        "txt": "import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer;"
      },
      {
        "txt": "import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" +"
      },
      {
        "txt": "\"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\""
      },
      {
        "txt": "+ \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\")"
      },
      {
        "txt": "private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" +"
      },
      {
        "txt": "\"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false;"
      },
      {
        "txt": "@Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\","
      },
      {
        "txt": "usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\";"
      },
      {
        "txt": "@Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\")"
      },
      {
        "txt": "private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" +"
      },
      {
        "txt": "private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", <extra_id_0> DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" +"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} } @Override public String getDefaultMetaVariable() { return null; } } } private static enum FormattingOption { PRETTY_PRINT,"
      },
      {
        "txt": "PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break;"
      },
      {
        "txt": "default: throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) {"
      },
      {
        "txt": "super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");"
      },
      {
        "txt": "List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else {"
      },
      {
        "txt": "processedArgs.add(value); } } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException {"
      },
      {
        "txt": "List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {}));"
      },
      {
        "txt": "CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args);"
      },
      {
        "txt": "CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false;"
      },
      {
        "txt": "} catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\"));"
      },
      {
        "txt": "err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast)"
      },
      {
        "txt": ".setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file)"
      },
      {
        "txt": ".setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map)"
      },
      {
        "txt": ".setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in);"
      },
      {
        "txt": "} } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options);"
      },
      {
        "txt": "} if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives;"
      },
      {
        "txt": "return options; } @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns();"
      },
      {
        "txt": "if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\","
      },
      {
        "txt": "\"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\","
      },
      {
        "txt": "\"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\","
      },
      {
        "txt": "\"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\","
      },
      {
        "txt": "\"w3c_indexeddb.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\");"
      },
      {
        "txt": "ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState("
      },
      {
        "txt": "externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid;"
      },
      {
        "txt": "} public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 745,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 389,
    "end-bug-line": 389,
    "bug": "",
    "fix": "public static class WarningGuardErrorOptionHandler extends StringOptionHandler { public WarningGuardErrorOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR)); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 746,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 390,
    "end-bug-line": 390,
    "bug": "",
    "fix": "public static class WarningGuardWarningOptionHandler extends StringOptionHandler { public WarningGuardWarningOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.WARNING)); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 747,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 391,
    "end-bug-line": 391,
    "bug": "",
    "fix": "public static class WarningGuardOffOptionHandler extends StringOptionHandler { public WarningGuardOffOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super String> setter) { super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF)); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 748,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 392,
    "end-bug-line": 392,
    "bug": "",
    "fix": "private static class WarningGuardSetter implements Setter { private final Setter proxy; private final CheckLevel level;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 749,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 393,
    "end-bug-line": 393,
    "bug": "",
    "fix": "private WarningGuardSetter(Setter proxy, CheckLevel level) { this.proxy = proxy; this.level = level; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 750,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 394,
    "end-bug-line": 394,
    "bug": "",
    "fix": "@Override public boolean isMultiValued() { return proxy.isMultiValued(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 751,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 395,
    "end-bug-line": 395,
    "bug": "",
    "fix": "@Override public Class getType() { return proxy.getType(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "; private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default:"
      },
      {
        "txt": "throw new RuntimeException(\"Unknown formatting option: \" + this); } } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super();"
      },
      {
        "txt": "initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList();"
      },
      {
        "txt": "for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value);"
      },
      {
        "txt": "} } else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList();"
      },
      {
        "txt": "File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags);"
      },
      {
        "txt": "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags);"
      },
      {
        "txt": "isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) {"
      },
      {
        "txt": "err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush();"
      },
      {
        "txt": "} if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph)"
      },
      {
        "txt": ".setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files)"
      },
      {
        "txt": ".setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error)"
      },
      {
        "txt": ".setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); }"
      },
      {
        "txt": "} @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); }"
      },
      {
        "txt": "if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options;"
      },
      {
        "txt": "} @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) {"
      },
      {
        "txt": "return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\","
      },
      {
        "txt": "\"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\","
      },
      {
        "txt": "\"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\","
      },
      {
        "txt": "\"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\","
      },
      {
        "txt": "\"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input);"
      },
      {
        "txt": "Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),"
      },
      {
        "txt": "\"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; }"
      },
      {
        "txt": "public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 752,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 396,
    "end-bug-line": 396,
    "bug": "",
    "fix": "@Override public void addValue(Object value) throws CmdLineException { proxy.addValue((String) value); warningGuardSpec.add(level, (String) value); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream;"
      },
      {
        "txt": "import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException;"
      },
      {
        "txt": "import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\")"
      },
      {
        "txt": "private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false;"
      },
      {
        "txt": "@Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false;"
      },
      {
        "txt": "@Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\","
      },
      {
        "txt": "usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\";"
      },
      {
        "txt": "@Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \""
      },
      {
        "txt": "+ \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \""
      },
      {
        "txt": "+ \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\","
      },
      {
        "txt": "usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"},"
      },
      {
        "txt": "usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\";"
      },
      {
        "txt": "@Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\")"
      },
      {
        "txt": "private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\")"
      },
      {
        "txt": "private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\","
      },
      {
        "txt": "usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \""
      },
      {
        "txt": "+ \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\","
      },
      {
        "txt": "usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\";"
      },
      {
        "txt": "public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); }"
      },
      {
        "txt": "@Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else {"
      },
      {
        "txt": "String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1;"
      },
      {
        "txt": "} @Override public String getDefaultMetaVariable() { return null; } } <extra_id_0> private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) {"
      },
      {
        "txt": "private void applyToOptions(CompilerOptions options) { switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this);"
      },
      {
        "txt": "} } } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err);"
      },
      {
        "txt": "} protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) {"
      },
      {
        "txt": "Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); }"
      },
      {
        "txt": "} else { processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file);"
      },
      {
        "txt": "StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));"
      },
      {
        "txt": "if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true;"
      },
      {
        "txt": "try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\");"
      },
      {
        "txt": "isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); }"
      },
      {
        "txt": "if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode)"
      },
      {
        "txt": ".setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file)"
      },
      {
        "txt": ".setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning)"
      },
      {
        "txt": ".setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } }"
      },
      {
        "txt": "@Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) {"
      },
      {
        "txt": "options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; }"
      },
      {
        "txt": "@Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs;"
      },
      {
        "txt": "} else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; } } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\","
      },
      {
        "txt": "\"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\","
      },
      {
        "txt": "\"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\","
      },
      {
        "txt": "\"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\","
      },
      {
        "txt": "\"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap();"
      },
      {
        "txt": "for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\");"
      },
      {
        "txt": "List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) {"
      },
      {
        "txt": "CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 753,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 485,
    "end-bug-line": 485,
    "bug": "",
    "fix": "Flags.warningGuardSpec.clear();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef;"
      },
      {
        "txt": "import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends"
      },
      {
        "txt": "AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\")"
      },
      {
        "txt": "private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\")"
      },
      {
        "txt": "private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "@Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\","
      },
      {
        "txt": "usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \""
      },
      {
        "txt": "+ \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \""
      },
      {
        "txt": "+ \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1;"
      },
      {
        "txt": "@Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" +"
      },
      {
        "txt": "\"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" +"
      },
      {
        "txt": "\"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level ="
      },
      {
        "txt": "CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \""
      },
      {
        "txt": "+ \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \""
      },
      {
        "txt": "+ \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \""
      },
      {
        "txt": "+ \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \""
      },
      {
        "txt": "+ \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES ="
      },
      {
        "txt": "Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try {"
      },
      {
        "txt": "param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) {"
      },
      {
        "txt": "setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } } @Override public String getDefaultMetaVariable() {"
      },
      {
        "txt": "return null; } } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) {"
      },
      {
        "txt": "case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); } }"
      },
      {
        "txt": "} private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {"
      },
      {
        "txt": "super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) {"
      },
      {
        "txt": "processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); } } else { processedArgs.add(arg);"
      },
      {
        "txt": "} } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset()));"
      },
      {
        "txt": "argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); <extra_id_0> if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } }"
      },
      {
        "txt": "} } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err);"
      },
      {
        "txt": "} } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource);"
      },
      {
        "txt": "err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else {"
      },
      {
        "txt": "getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file)"
      },
      {
        "txt": ".setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level)"
      },
      {
        "txt": ".setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)"
      },
      {
        "txt": ".setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention());"
      },
      {
        "txt": "CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options);"
      },
      {
        "txt": "for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; } @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); }"
      },
      {
        "txt": "@Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns;"
      },
      {
        "txt": "} } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\","
      },
      {
        "txt": "\"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\","
      },
      {
        "txt": "\"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\","
      },
      {
        "txt": "\"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\","
      },
      {
        "txt": "\"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream("
      },
      {
        "txt": "\"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); }"
      },
      {
        "txt": "return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else {"
      },
      {
        "txt": "System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 754,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 500,
    "end-bug-line": 500,
    "bug": "",
    "fix": "Flags.warningGuardSpec.clear();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef;"
      },
      {
        "txt": "import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; public class CommandLineRunner extends"
      },
      {
        "txt": "AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class, usage = \"Prints out the parse tree and exits\")"
      },
      {
        "txt": "private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\" + \" tree and exits\")"
      },
      {
        "txt": "private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode = CompilerOptions.DevMode.OFF;"
      },
      {
        "txt": "@Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList(); @Option(name = \"--js\","
      },
      {
        "txt": "usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \" + \"unique. Each dep is the name of a module that this module \""
      },
      {
        "txt": "+ \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\", usage = \"File containing the serialized version of the property \""
      },
      {
        "txt": "+ \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \" + \"files will be produced as {binary name}_vars_map.out and \""
      },
      {
        "txt": "+ \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\") private int summary_detail_level = 1;"
      },
      {
        "txt": "@Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\") private List<String> module_wrapper = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" + \"expand to the name of the output file that the source map \" +"
      },
      {
        "txt": "\"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_warning = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" + \"that contains no single quotes. If [=<val>] is omitted, \" +"
      },
      {
        "txt": "\"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\") private CompilationLevel compilation_level ="
      },
      {
        "txt": "CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false; @Option(name = \"--debug\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \" + \"applied to the output JS. Options: \""
      },
      {
        "txt": "+ \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class, usage = \"Automatically sort dependencies so that a file that \""
      },
      {
        "txt": "+ \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \" + \"goog.provides, and their dependencies, will always be left in. \""
      },
      {
        "txt": "+ \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \" + \"If you're using modularization, using %outname% will create \""
      },
      {
        "txt": "+ \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\"; @Option(name = \"--version\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\"); private static final Set<String> FALSES ="
      },
      {
        "txt": "Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null; try {"
      },
      {
        "txt": "param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) {"
      },
      {
        "txt": "setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } } @Override public String getDefaultMetaVariable() {"
      },
      {
        "txt": "return null; } } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) { switch (this) {"
      },
      {
        "txt": "case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); } }"
      },
      {
        "txt": "} private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); } protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {"
      },
      {
        "txt": "super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg); if (matcher.matches()) {"
      },
      {
        "txt": "processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); } } else { processedArgs.add(arg);"
      },
      {
        "txt": "} } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer( Files.toString(flagFileInput, Charset.defaultCharset()));"
      },
      {
        "txt": "while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { err.println(\"ERROR - Arguments in the file cannot contain \""
      },
      {
        "txt": "isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); <extra_id_0> try { parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) {"
      },
      {
        "txt": "} } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false; } if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource);"
      },
      {
        "txt": "err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); } if (!isConfigValid || flags.display_help) { isConfigValid = false; parser.printUsage(err); } else {"
      },
      {
        "txt": "getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level) .setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file)"
      },
      {
        "txt": ".setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level)"
      },
      {
        "txt": ".setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) .setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off) .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies)"
      },
      {
        "txt": ".setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention());"
      },
      {
        "txt": "CompilationLevel level = flags.compilation_level; level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options);"
      },
      {
        "txt": "for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; } @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); }"
      },
      {
        "txt": "@Override protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns;"
      },
      {
        "txt": "} } private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\","
      },
      {
        "txt": "\"w3c_dom1.js\", \"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\","
      },
      {
        "txt": "\"google.js\", \"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\","
      },
      {
        "txt": "\"webstorage.js\", \"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\","
      },
      {
        "txt": "\"webgl.js\"); public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream("
      },
      {
        "txt": "\"externs.zip//\" + entry.getName(), entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); }"
      },
      {
        "txt": "return externs; } public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else {"
      },
      {
        "txt": "System.exit(-1); } }"
      }
    ]
  },
  {
    "id": 755,
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
    "start-bug-line": 552,
    "end-bug-line": 554,
    "bug": ".setJscompError(flags.jscomp_error) .setJscompWarning(flags.jscomp_warning) .setJscompOff(flags.jscomp_off)",
    "fix": ".setWarningGuardSpec(Flags.warningGuardSpec)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.common.io.Files; import com.google.common.io.LimitInputStream; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option;"
      },
      {
        "txt": "import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.StringOptionHandler; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.PrintStream; import java.nio.charset.Charset;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; import java.util.ResourceBundle; import java.util.Set; import java.util.StringTokenizer; import java.util.logging.Level; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream;"
      },
      {
        "txt": "public class CommandLineRunner extends AbstractCommandLineRunner<Compiler, CompilerOptions> { @SuppressWarnings(\"unchecked\") private static class Flags { @Option(name = \"--help\", handler = BooleanOptionHandler.class, usage = \"Displays this message\") private boolean display_help = false; @Option(name = \"--print_tree\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Prints out the parse tree and exits\") private boolean print_tree = false; @Option(name = \"--compute_phase_ordering\", handler = BooleanOptionHandler.class, usage = \"Runs the compile job many times, then prints out the \" + \"best phase ordering from this run\") private boolean compute_phase_ordering = false; @Option(name = \"--print_ast\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the internal abstract syntax\""
      },
      {
        "txt": "+ \" tree and exits\") private boolean print_ast = false; @Option(name = \"--print_pass_graph\", handler = BooleanOptionHandler.class, usage = \"Prints a dot file describing the passes that will get run\" + \" and exits\") private boolean print_pass_graph = false; @Option(name = \"--jscomp_dev_mode\", aliases = {\"--dev_mode\"}) private CompilerOptions.DevMode jscomp_dev_mode ="
      },
      {
        "txt": "CompilerOptions.DevMode.OFF; @Option(name = \"--logging_level\", usage = \"The logging level (standard java.util.logging.Level\" + \" values) for Compiler progress. Does not control errors or\" + \" warnings for the JavaScript code under compilation\") private String logging_level = Level.WARNING.getName(); @Option(name = \"--externs\", usage = \"The file containing javascript externs. You may specify\" + \" multiple\") private List<String> externs = Lists.newArrayList();"
      },
      {
        "txt": "@Option(name = \"--js\", usage = \"The javascript filename. You may specify multiple\") private List<String> js = Lists.newArrayList(); @Option(name = \"--js_output_file\", usage = \"Primary output filename. If not specified, output is \" + \"written to stdout\") private String js_output_file = \"\"; @Option(name = \"--module\", usage = \"A javascript module specification. The format is \" + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \""
      },
      {
        "txt": "+ \"unique. Each dep is the name of a module that this module \" + \"depends on. Modules must be listed in dependency order, and js \" + \"source files must be listed in the corresponding order. Where \" + \"--module flags occur in relation to --js flags is unimportant\") private List<String> module = Lists.newArrayList(); @Option(name = \"--variable_map_input_file\", usage = \"File containing the serialized version of the variable \" + \"renaming map produced by a previous compilation\") private String variable_map_input_file = \"\"; @Option(name = \"--property_map_input_file\","
      },
      {
        "txt": "usage = \"File containing the serialized version of the property \" + \"renaming map produced by a previous compilation\") private String property_map_input_file = \"\"; @Option(name = \"--variable_map_output_file\", usage = \"File where the serialized version of the variable \" + \"renaming map produced should be saved\") private String variable_map_output_file = \"\"; @Option(name = \"--create_name_map_files\", handler = BooleanOptionHandler.class, usage = \"If true, variable renaming and property renaming map \""
      },
      {
        "txt": "+ \"files will be produced as {binary name}_vars_map.out and \" + \"{binary name}_props_map.out. Note that this flag cannot be used \" + \"in conjunction with either variable_map_output_file or \" + \"property_map_output_file\") private boolean create_name_map_files = false; @Option(name = \"--property_map_output_file\", usage = \"File where the serialized version of the property \" + \"renaming map produced should be saved\") private String property_map_output_file = \"\"; @Option(name = \"--third_party\","
      },
      {
        "txt": "handler = BooleanOptionHandler.class, usage = \"Check source validity but do not enforce Closure style \" + \"rules and conventions\") private boolean third_party = false; @Option(name = \"--summary_detail_level\", usage = \"Controls how detailed the compilation summary is. Values:\" + \" 0 (never print summary), 1 (print summary only if there are \" + \"errors or warnings), 2 (print summary if type checking is on, \" + \"see --check_types), 3 (always print summary). The default level \" + \"is 1\")"
      },
      {
        "txt": "private int summary_detail_level = 1; @Option(name = \"--output_wrapper\", usage = \"Interpolate output into this string at the place denoted\" + \" by the marker token %output%. See --output_wrapper_marker\") private String output_wrapper = \"\"; @Option(name = \"--module_wrapper\", usage = \"An output wrapper for a javascript module (optional). \" + \"The format is <name>:<wrapper>. The module name must correspond \" + \"with a module specified using --module. The wrapper must \" + \"contain %s as the code placeholder\")"
      },
      {
        "txt": "private List<String> module_wrapper = Lists.newArrayList(); @Option(name = \"--module_output_path_prefix\", usage = \"Prefix for filenames of compiled js modules. \" + \"<module-name>.js will be appended to this prefix. Directories \" + \"will be created as needed. Use with --module\") private String module_output_path_prefix = \"./\"; @Option(name = \"--create_source_map\", usage = \"If specified, a source map file mapping the generated \" + \"source files back to the original source file will be \" + \"output to the specified path. The %outname% placeholder will \" +"
      },
      {
        "txt": "\"expand to the name of the output file that the source map \" + \"corresponds to.\") private String create_source_map = \"\"; @Option(name = \"--jscomp_error\", usage = \"Make the named class of warnings an error. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_error = Lists.newArrayList(); @Option(name = \"--jscomp_warning\", usage = \"Make the named class of warnings a normal warning. \" + \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)"
      },
      {
        "txt": "private List<String> jscomp_warning = Lists.newArrayList(); @Option(name = \"--jscomp_off\", usage = \"Turn off the named class of warnings. Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES) private List<String> jscomp_off = Lists.newArrayList(); @Option(name = \"--define\", aliases = {\"--D\", \"-D\"}, usage = \"Override the value of a variable annotated @define. \" + \"The format is <name>[=<val>], where <name> is the name of a @define \" + \"variable and <val> is a boolean, number, or a single-quoted string \" +"
      },
      {
        "txt": "\"that contains no single quotes. If [=<val>] is omitted, \" + \"the variable is marked true\") private List<String> define = Lists.newArrayList(); @Option(name = \"--charset\", usage = \"Input and output charset for all files. By default, we \" + \"accept UTF-8 as input and output US_ASCII\") private String charset = \"\"; @Option(name = \"--compilation_level\", usage = \"Specifies the compilation level to use. Options: \" + \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")"
      },
      {
        "txt": "private CompilationLevel compilation_level = CompilationLevel.SIMPLE_OPTIMIZATIONS; @Option(name = \"--warning_level\", usage = \"Specifies the warning level to use. Options: \" + \"QUIET, DEFAULT, VERBOSE\") private WarningLevel warning_level = WarningLevel.DEFAULT; @Option(name = \"--use_only_custom_externs\", handler = BooleanOptionHandler.class, usage = \"Specifies whether the default externs should be excluded\") private boolean use_only_custom_externs = false;"
      },
      {
        "txt": "@Option(name = \"--debug\", handler = BooleanOptionHandler.class, usage = \"Enable debugging options\") private boolean debug = false; @Option(name = \"--generate_exports\", handler = BooleanOptionHandler.class, usage = \"Generates export code for those marked with @export\") private boolean generate_exports = false; @Option(name = \"--formatting\", usage = \"Specifies which formatting options, if any, should be \""
      },
      {
        "txt": "+ \"applied to the output JS. Options: \" + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\") private List<FormattingOption> formatting = Lists.newArrayList(); @Option(name = \"--process_closure_primitives\", handler = BooleanOptionHandler.class, usage = \"Processes built-ins from the Closure library, such as \" + \"goog.require(), goog.provide(), and goog.exportSymbol()\") private boolean process_closure_primitives = true; @Option(name = \"--manage_closure_dependencies\", handler = BooleanOptionHandler.class,"
      },
      {
        "txt": "usage = \"Automatically sort dependencies so that a file that \" + \"goog.provides symbol X will always come before a file that \" + \"goog.requires symbol X. If an input provides symbols, and \" + \"those symbols are never required, then that input will not \" + \"be included in the compilation.\") private boolean manage_closure_dependencies = false; @Option(name = \"--closure_entry_point\", usage = \"Entry points to the program. Must be goog.provide'd \" + \"symbols. Any goog.provide'd symbols that are not a transitive \" + \"dependency of the entry points will be removed. Files without \""
      },
      {
        "txt": "+ \"goog.provides, and their dependencies, will always be left in. \" + \"If any entry points are specified, then the \" + \"manage_closure_dependencies option will be set to true and \" + \"all files will be sorted in dependency order.\") private List<String> closure_entry_point = Lists.newArrayList(); @Option(name = \"--output_manifest\", usage = \"Prints out a list of all the files in the compilation. \" + \"If --manage_closure_dependencies is on, this will not include \" + \"files that got dropped because they were not required. \" + \"The %outname% placeholder expands to the js output file. \""
      },
      {
        "txt": "+ \"If you're using modularization, using %outname% will create \" + \"a manifest for each module.\") private String output_manifest = \"\"; @Option(name = \"--accept_const_keyword\", usage = \"Allows usage of const keyword.\") private boolean accept_const_keyword = false; @Option(name = \"--language_in\", usage = \"Sets what language spec that input sources conform. \" + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\") private String language_in = \"ECMASCRIPT3\";"
      },
      {
        "txt": "@Option(name = \"--version\", handler = BooleanOptionHandler.class, usage = \"Prints the compiler version to stderr.\") private boolean version = false; @Option(name = \"--flagfile\", usage = \"A file containing additional command-line options.\") private String flag_file = \"\"; public static class BooleanOptionHandler extends OptionHandler<Boolean> { private static final Set<String> TRUES = Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\");"
      },
      {
        "txt": "private static final Set<String> FALSES = Sets.newHashSet(\"false\", \"off\", \"no\", \"0\"); public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter) { super(parser, option, setter); } @Override public int parseArguments(Parameters params) throws CmdLineException { String param = null;"
      },
      {
        "txt": "try { param = params.getParameter(0); } catch (CmdLineException e) {} if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true);"
      },
      {
        "txt": "} else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } } @Override"
      },
      {
        "txt": "public String getDefaultMetaVariable() { return null; } } } private static enum FormattingOption { PRETTY_PRINT, PRINT_INPUT_DELIMITER, ; private void applyToOptions(CompilerOptions options) {"
      },
      {
        "txt": "switch (this) { case PRETTY_PRINT: options.prettyPrint = true; break; case PRINT_INPUT_DELIMITER: options.printInputDelimiter = true; break; default: throw new RuntimeException(\"Unknown formatting option: \" + this); }"
      },
      {
        "txt": "} } private final Flags flags = new Flags(); private static final String configResource = \"com.google.javascript.jscomp.parsing.ParserConfig\"; private boolean isConfigValid = false; protected CommandLineRunner(String[] args) { super(); initConfigFromFlags(args, System.err); }"
      },
      {
        "txt": "protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) { super(out, err); initConfigFromFlags(args, err); } private List<String> processArgs(String[] args) { Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\"); Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\"); List<String> processedArgs = Lists.newArrayList(); for (String arg : args) { Matcher matcher = argPattern.matcher(arg);"
      },
      {
        "txt": "if (matcher.matches()) { processedArgs.add(matcher.group(1)); String value = matcher.group(2); Matcher quotesMatcher = quotesPattern.matcher(value); if (quotesMatcher.matches()) { processedArgs.add(quotesMatcher.group(1)); } else { processedArgs.add(value); } } else {"
      },
      {
        "txt": "processedArgs.add(arg); } } return processedArgs; } private void processFlagFile(PrintStream err) throws CmdLineException, IOException { List<String> argsInFile = Lists.newArrayList(); File flagFileInput = new File(flags.flag_file); StringTokenizer tokenizer = new StringTokenizer("
      },
      {
        "txt": "Files.toString(flagFileInput, Charset.defaultCharset())); while (tokenizer.hasMoreTokens()) { argsInFile.add(tokenizer.nextToken()); } flags.flag_file = \"\"; List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {})); CmdLineParser parserFileArgs = new CmdLineParser(flags); parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) {"
      },
      {
        "txt": "err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\"); isConfigValid = false; } } private void initConfigFromFlags(String[] args, PrintStream err) { List<String> processedArgs = processArgs(args); CmdLineParser parser = new CmdLineParser(flags); isConfigValid = true; try {"
      },
      {
        "txt": "parser.parseArgument(processedArgs.toArray(new String[] {})); if (!flags.flag_file.equals(\"\")) { processFlagFile(err); } } catch (CmdLineException e) { err.println(e.getMessage()); isConfigValid = false; } catch (IOException ioErr) { err.println(\"ERROR - \" + flags.flag_file + \" read error.\"); isConfigValid = false;"
      },
      {
        "txt": "} if (flags.version) { ResourceBundle config = ResourceBundle.getBundle(configResource); err.println( \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\")); err.flush(); } if (!isConfigValid || flags.display_help) {"
      },
      {
        "txt": "isConfigValid = false; parser.printUsage(err); } else { getCommandLineConfig() .setPrintTree(flags.print_tree) .setComputePhaseOrdering(flags.compute_phase_ordering) .setPrintAst(flags.print_ast) .setPrintPassGraph(flags.print_pass_graph) .setJscompDevMode(flags.jscomp_dev_mode) .setLoggingLevel(flags.logging_level)"
      },
      {
        "txt": ".setExterns(flags.externs) .setJs(flags.js) .setJsOutputFile(flags.js_output_file) .setModule(flags.module) .setVariableMapInputFile(flags.variable_map_input_file) .setPropertyMapInputFile(flags.property_map_input_file) .setVariableMapOutputFile(flags.variable_map_output_file) .setCreateNameMapFiles(flags.create_name_map_files) .setPropertyMapOutputFile(flags.property_map_output_file) .setCodingConvention(flags.third_party ?"
      },
      {
        "txt": "new ClosureCodingConvention()) .setSummaryDetailLevel(flags.summary_detail_level) .setOutputWrapper(flags.output_wrapper) .setModuleWrapper(flags.module_wrapper) .setModuleOutputPathPrefix(flags.module_output_path_prefix) .setCreateSourceMap(flags.create_source_map) <extra_id_0> .setDefine(flags.define) .setCharset(flags.charset) .setManageClosureDependencies(flags.manage_closure_dependencies) .setClosureEntryPoints(flags.closure_entry_point) .setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword)"
      },
      {
        "txt": ".setOutputManifest(flags.output_manifest) .setAcceptConstKeyword(flags.accept_const_keyword) .setLanguageIn(flags.language_in); } } @Override protected CompilerOptions createOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel level = flags.compilation_level;"
      },
      {
        "txt": "level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } if(flags.generate_exports) { options.setGenerateExports(flags.generate_exports); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) {"
      },
      {
        "txt": "formattingOption.applyToOptions(options); } options.closurePass = flags.process_closure_primitives; return options; } @Override protected Compiler createCompiler() { return new Compiler(getErrorPrintStream()); } @Override"
      },
      {
        "txt": "protected List<JSSourceFile> createExterns() throws FlagUsageException, IOException { List<JSSourceFile> externs = super.createExterns(); if (flags.use_only_custom_externs || isInTestMode()) { return externs; } else { List<JSSourceFile> defaultExterns = getDefaultExterns(); defaultExterns.addAll(externs); return defaultExterns; }"
      },
      {
        "txt": "} private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of( \"es3.js\", \"es5.js\", \"w3c_event.js\", \"w3c_event3.js\", \"gecko_event.js\", \"ie_event.js\", \"webkit_event.js\", \"w3c_dom1.js\","
      },
      {
        "txt": "\"w3c_dom2.js\", \"w3c_dom3.js\", \"gecko_dom.js\", \"ie_dom.js\", \"webkit_dom.js\", \"w3c_css.js\", \"gecko_css.js\", \"ie_css.js\", \"webkit_css.js\", \"google.js\","
      },
      {
        "txt": "\"deprecated.js\", \"fileapi.js\", \"flash.js\", \"gears_symbols.js\", \"gears_types.js\", \"gecko_xml.js\", \"html5.js\", \"ie_vml.js\", \"iphone.js\", \"webstorage.js\","
      },
      {
        "txt": "\"w3c_css3d.js\", \"w3c_elementtraversal.js\", \"w3c_geolocation.js\", \"w3c_indexeddb.js\", \"w3c_range.js\", \"w3c_selectors.js\", \"w3c_xml.js\", \"window.js\", \"webkit_notifications.js\", \"webgl.js\");"
      },
      {
        "txt": "public static List<JSSourceFile> getDefaultExterns() throws IOException { InputStream input = CommandLineRunner.class.getResourceAsStream( \"/externs.zip\"); ZipInputStream zip = new ZipInputStream(input); Map<String, JSSourceFile> externsMap = Maps.newHashMap(); for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) { LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize()); externsMap.put(entry.getName(), JSSourceFile.fromInputStream( \"externs.zip//\" + entry.getName(),"
      },
      {
        "txt": "entryStream)); } Preconditions.checkState( externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)), \"Externs zip must match our hard-coded list of externs.\"); List<JSSourceFile> externs = Lists.newArrayList(); for (String key : DEFAULT_EXTERNS_NAMES) { externs.add(externsMap.get(key)); } return externs;"
      },
      {
        "txt": "} public boolean shouldRunCompiler() { return this.isConfigValid; } public static void main(String[] args) { CommandLineRunner runner = new CommandLineRunner(args); if (runner.shouldRunCompiler()) { runner.run(); } else { System.exit(-1);"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 756,
    "file_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
    "start-bug-line": 185,
    "end-bug-line": 187,
    "bug": "void setWarningLevels(CompilerOptions options, java.util.List<String> diagnosticGroups, CheckLevel level) { for (String name : diagnosticGroups) {",
    "fix": "void setWarningLevel(CompilerOptions options, String name, CheckLevel level) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions;"
      },
      {
        "txt": "import com.google.common.collect.ImmutableMap; import com.google.common.collect.Maps; import java.util.Map; public class DiagnosticGroups { public DiagnosticGroups() {} private final static Map<String, DiagnosticGroup> groupsByName = Maps.newHashMap(); static DiagnosticGroup registerGroup(String name, DiagnosticGroup group) { groupsByName.put(name, group);"
      },
      {
        "txt": "return group; } static DiagnosticGroup registerGroup(String name, DiagnosticType ... types) { DiagnosticGroup group = new DiagnosticGroup(name, types); groupsByName.put(name, group); return group; } static DiagnosticGroup registerGroup(String name, DiagnosticGroup ... groups) {"
      },
      {
        "txt": "DiagnosticGroup group = new DiagnosticGroup(name, groups); groupsByName.put(name, group); return group; } protected Map<String, DiagnosticGroup> getRegisteredGroups() { return ImmutableMap.copyOf(groupsByName); } protected DiagnosticGroup forName(String name) { return groupsByName.get(name); }"
      },
      {
        "txt": "static final String DIAGNOSTIC_GROUP_NAMES = \"accessControls, ambiguousFunctionDecl, checkRegExp,\" + \"checkTypes, checkVars, constantProperty, deprecated, \" + \"externsValidation, fileoverviewTags, globalThis, \" + \"internetExplorerChecks, nvalidCasts, missingProperties, \" + \"nonStandardJsDocs, strictModuleDepCheck, typeInvalidation, \" + \"undefinedVars, unknownDefines, uselessCode, \" + \"visibility\"; public static DiagnosticGroup GLOBAL_THIS = DiagnosticGroups .registerGroup(\"globalThis\","
      },
      {
        "txt": "CheckGlobalThis.GLOBAL_THIS); public static DiagnosticGroup DEPRECATED = DiagnosticGroups .registerGroup(\"deprecated\", CheckAccessControls.DEPRECATED_NAME, CheckAccessControls.DEPRECATED_NAME_REASON, CheckAccessControls.DEPRECATED_PROP, CheckAccessControls.DEPRECATED_PROP_REASON, CheckAccessControls.DEPRECATED_CLASS, CheckAccessControls.DEPRECATED_CLASS_REASON); public static DiagnosticGroup VISIBILITY = DiagnosticGroups"
      },
      {
        "txt": ".registerGroup(\"visibility\", CheckAccessControls.BAD_PRIVATE_GLOBAL_ACCESS, CheckAccessControls.BAD_PRIVATE_PROPERTY_ACCESS, CheckAccessControls.BAD_PROTECTED_PROPERTY_ACCESS, CheckAccessControls.PRIVATE_OVERRIDE, CheckAccessControls.VISIBILITY_MISMATCH); public static DiagnosticGroup CONSTANT_PROPERTY = DiagnosticGroups .registerGroup(\"constantProperty\", CheckAccessControls.CONST_PROPERTY_REASSIGNED_VALUE); public static DiagnosticGroup NON_STANDARD_JSDOC ="
      },
      {
        "txt": "DiagnosticGroups.registerGroup(\"nonStandardJsDocs\", RhinoErrorReporter.BAD_JSDOC_ANNOTATION); public static DiagnosticGroup ACCESS_CONTROLS = DiagnosticGroups.registerGroup(\"accessControls\", DEPRECATED, VISIBILITY); public static DiagnosticGroup INVALID_CASTS = DiagnosticGroups .registerGroup(\"invalidCasts\", TypeValidator.INVALID_CAST); public static DiagnosticGroup FILEOVERVIEW_JSDOC = DiagnosticGroups.registerGroup(\"fileoverviewTags\","
      },
      {
        "txt": "RhinoErrorReporter.EXTRA_FILEOVERVIEW); public static DiagnosticGroup STRICT_MODULE_DEP_CHECK = DiagnosticGroups.registerGroup(\"strictModuleDepCheck\", VarCheck.STRICT_MODULE_DEP_ERROR, CheckGlobalNames.STRICT_MODULE_DEP_QNAME); public static DiagnosticGroup EXTERNS_VALIDATION = DiagnosticGroups.registerGroup(\"externsValidation\", VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR, VarCheck.UNDEFINED_EXTERN_VAR_ERROR); public static DiagnosticGroup AMBIGUOUS_FUNCTION_DECL ="
      },
      {
        "txt": "DiagnosticGroups.registerGroup(\"ambiguousFunctionDecl\", VariableReferenceCheck.AMBIGUOUS_FUNCTION_DECL); public static DiagnosticGroup UNKNOWN_DEFINES = DiagnosticGroups.registerGroup(\"unknownDefines\", ProcessDefines.UNKNOWN_DEFINE_WARNING); public static DiagnosticGroup TWEAKS = DiagnosticGroups.registerGroup(\"tweakValidation\", ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING, ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING, ProcessTweaks.UNKNOWN_TWEAK_WARNING);"
      },
      {
        "txt": "public static DiagnosticGroup MISSING_PROPERTIES = DiagnosticGroups.registerGroup(\"missingProperties\", TypeCheck.INEXISTENT_PROPERTY); public static DiagnosticGroup INTERNET_EXPLORER_CHECKS = DiagnosticGroups.registerGroup(\"internetExplorerChecks\", RhinoErrorReporter.TRAILING_COMMA); public static DiagnosticGroup UNDEFINED_VARIABLES = DiagnosticGroups.registerGroup(\"undefinedVars\", VarCheck.UNDEFINED_VAR_ERROR); public static DiagnosticGroup CHECK_REGEXP ="
      },
      {
        "txt": "DiagnosticGroups.registerGroup(\"checkRegExp\", CheckRegExp.REGEXP_REFERENCE); public static DiagnosticGroup CHECK_TYPES = DiagnosticGroups.registerGroup(\"checkTypes\", TypeValidator.ALL_DIAGNOSTICS, TypeCheck.ALL_DIAGNOSTICS); public static DiagnosticGroup CHECK_VARIABLES = DiagnosticGroups.registerGroup(\"checkVars\", VarCheck.UNDEFINED_VAR_ERROR, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);"
      },
      {
        "txt": "DiagnosticGroups.registerGroup(\"uselessCode\", CheckSideEffects.USELESS_CODE_ERROR, CheckUnreachableCode.UNREACHABLE_CODE); public static DiagnosticGroup TYPE_INVALIDATION = DiagnosticGroups.registerGroup(\"typeInvalidation\", DisambiguateProperties.Warnings.INVALIDATION); <extra_id_0> DiagnosticGroup group = forName(name); Preconditions.checkNotNull(group, \"No warning class for name: \" + name); options.setWarningLevel(group, level); } } }"
      }
    ]
  },
  {
    "id": 757,
    "file_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
    "start-bug-line": 191,
    "end-bug-line": 191,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableMap; import com.google.common.collect.Maps; import java.util.Map; public class DiagnosticGroups { public DiagnosticGroups() {} private final static Map<String, DiagnosticGroup> groupsByName ="
      },
      {
        "txt": "Maps.newHashMap(); static DiagnosticGroup registerGroup(String name, DiagnosticGroup group) { groupsByName.put(name, group); return group; } static DiagnosticGroup registerGroup(String name, DiagnosticType ... types) { DiagnosticGroup group = new DiagnosticGroup(name, types); groupsByName.put(name, group);"
      },
      {
        "txt": "return group; } static DiagnosticGroup registerGroup(String name, DiagnosticGroup ... groups) { DiagnosticGroup group = new DiagnosticGroup(name, groups); groupsByName.put(name, group); return group; } protected Map<String, DiagnosticGroup> getRegisteredGroups() { return ImmutableMap.copyOf(groupsByName);"
      },
      {
        "txt": "} protected DiagnosticGroup forName(String name) { return groupsByName.get(name); } static final String DIAGNOSTIC_GROUP_NAMES = \"accessControls, ambiguousFunctionDecl, checkRegExp,\" + \"checkTypes, checkVars, constantProperty, deprecated, \" + \"externsValidation, fileoverviewTags, globalThis, \" + \"internetExplorerChecks, nvalidCasts, missingProperties, \" + \"nonStandardJsDocs, strictModuleDepCheck, typeInvalidation, \" +"
      },
      {
        "txt": "\"undefinedVars, unknownDefines, uselessCode, \" + \"visibility\"; public static DiagnosticGroup GLOBAL_THIS = DiagnosticGroups .registerGroup(\"globalThis\", CheckGlobalThis.GLOBAL_THIS); public static DiagnosticGroup DEPRECATED = DiagnosticGroups .registerGroup(\"deprecated\", CheckAccessControls.DEPRECATED_NAME, CheckAccessControls.DEPRECATED_NAME_REASON, CheckAccessControls.DEPRECATED_PROP,"
      },
      {
        "txt": "CheckAccessControls.DEPRECATED_PROP_REASON, CheckAccessControls.DEPRECATED_CLASS, CheckAccessControls.DEPRECATED_CLASS_REASON); public static DiagnosticGroup VISIBILITY = DiagnosticGroups .registerGroup(\"visibility\", CheckAccessControls.BAD_PRIVATE_GLOBAL_ACCESS, CheckAccessControls.BAD_PRIVATE_PROPERTY_ACCESS, CheckAccessControls.BAD_PROTECTED_PROPERTY_ACCESS, CheckAccessControls.PRIVATE_OVERRIDE, CheckAccessControls.VISIBILITY_MISMATCH);"
      },
      {
        "txt": "public static DiagnosticGroup CONSTANT_PROPERTY = DiagnosticGroups .registerGroup(\"constantProperty\", CheckAccessControls.CONST_PROPERTY_REASSIGNED_VALUE); public static DiagnosticGroup NON_STANDARD_JSDOC = DiagnosticGroups.registerGroup(\"nonStandardJsDocs\", RhinoErrorReporter.BAD_JSDOC_ANNOTATION); public static DiagnosticGroup ACCESS_CONTROLS = DiagnosticGroups.registerGroup(\"accessControls\", DEPRECATED, VISIBILITY); public static DiagnosticGroup INVALID_CASTS = DiagnosticGroups"
      },
      {
        "txt": ".registerGroup(\"invalidCasts\", TypeValidator.INVALID_CAST); public static DiagnosticGroup FILEOVERVIEW_JSDOC = DiagnosticGroups.registerGroup(\"fileoverviewTags\", RhinoErrorReporter.EXTRA_FILEOVERVIEW); public static DiagnosticGroup STRICT_MODULE_DEP_CHECK = DiagnosticGroups.registerGroup(\"strictModuleDepCheck\", VarCheck.STRICT_MODULE_DEP_ERROR, CheckGlobalNames.STRICT_MODULE_DEP_QNAME); public static DiagnosticGroup EXTERNS_VALIDATION ="
      },
      {
        "txt": "DiagnosticGroups.registerGroup(\"externsValidation\", VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR, VarCheck.UNDEFINED_EXTERN_VAR_ERROR); public static DiagnosticGroup AMBIGUOUS_FUNCTION_DECL = DiagnosticGroups.registerGroup(\"ambiguousFunctionDecl\", VariableReferenceCheck.AMBIGUOUS_FUNCTION_DECL); public static DiagnosticGroup UNKNOWN_DEFINES = DiagnosticGroups.registerGroup(\"unknownDefines\", ProcessDefines.UNKNOWN_DEFINE_WARNING); public static DiagnosticGroup TWEAKS ="
      },
      {
        "txt": "DiagnosticGroups.registerGroup(\"tweakValidation\", ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING, ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING, ProcessTweaks.UNKNOWN_TWEAK_WARNING); public static DiagnosticGroup MISSING_PROPERTIES = DiagnosticGroups.registerGroup(\"missingProperties\", TypeCheck.INEXISTENT_PROPERTY); public static DiagnosticGroup INTERNET_EXPLORER_CHECKS = DiagnosticGroups.registerGroup(\"internetExplorerChecks\", RhinoErrorReporter.TRAILING_COMMA);"
      },
      {
        "txt": "public static DiagnosticGroup UNDEFINED_VARIABLES = DiagnosticGroups.registerGroup(\"undefinedVars\", VarCheck.UNDEFINED_VAR_ERROR); public static DiagnosticGroup CHECK_REGEXP = DiagnosticGroups.registerGroup(\"checkRegExp\", CheckRegExp.REGEXP_REFERENCE); public static DiagnosticGroup CHECK_TYPES = DiagnosticGroups.registerGroup(\"checkTypes\", TypeValidator.ALL_DIAGNOSTICS, TypeCheck.ALL_DIAGNOSTICS);"
      },
      {
        "txt": "public static DiagnosticGroup CHECK_VARIABLES = DiagnosticGroups.registerGroup(\"checkVars\", VarCheck.UNDEFINED_VAR_ERROR, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); public static DiagnosticGroup CHECK_USELESS_CODE = DiagnosticGroups.registerGroup(\"uselessCode\", CheckSideEffects.USELESS_CODE_ERROR, CheckUnreachableCode.UNREACHABLE_CODE); public static DiagnosticGroup TYPE_INVALIDATION = DiagnosticGroups.registerGroup(\"typeInvalidation\","
      },
      {
        "txt": "void setWarningLevels(CompilerOptions options, java.util.List<String> diagnosticGroups, CheckLevel level) { for (String name : diagnosticGroups) { DiagnosticGroup group = forName(name); Preconditions.checkNotNull(group, \"No warning class for name: \" + name); options.setWarningLevel(group, level); <extra_id_0> } }"
      }
    ]
  }
]