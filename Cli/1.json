[
  {
    "id": 64,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 19,
    "end-bug-line": 19,
    "bug": "import java.util.HashMap;",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; <extra_id_0> import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList();"
      },
      {
        "txt": "public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) {"
      },
      {
        "txt": "return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt))"
      },
      {
        "txt": "{ return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); }"
      },
      {
        "txt": "public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt)"
      },
      {
        "txt": "{ opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues();"
      },
      {
        "txt": "} return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt);"
      },
      {
        "txt": "return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer);"
      },
      {
        "txt": "return answer; } public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString());"
      },
      {
        "txt": "buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg); } void addOption(Option opt)"
      },
      {
        "txt": "{ hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key);"
      },
      {
        "txt": "} options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions() { Collection processed = options.values();"
      },
      {
        "txt": "Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 65,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 23,
    "end-bug-line": 23,
    "bug": "import java.util.Map;",
    "fix": "import java.util.Set; import java.util.HashSet;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; <extra_id_0> public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine()"
      },
      {
        "txt": "private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) {"
      },
      {
        "txt": "return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType();"
      },
      {
        "txt": "return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0];"
      },
      {
        "txt": "} public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt))"
      },
      {
        "txt": "{ key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt)"
      },
      {
        "txt": "{ return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) {"
      },
      {
        "txt": "return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() {"
      },
      {
        "txt": "return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString();"
      },
      {
        "txt": "} void addArg(String arg) { args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null)"
      },
      {
        "txt": "{ key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator()"
      },
      {
        "txt": "{ return hashcodeMap.values().iterator(); } public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 66,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 46,
    "end-bug-line": 47,
    "bug": "private Map options = new HashMap(); private Map names = new HashMap();",
    "fix": "private Set options = new HashSet();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); <extra_id_0> private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) {"
      },
      {
        "txt": "public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) {"
      },
      {
        "txt": "String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) {"
      },
      {
        "txt": "return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt));"
      },
      {
        "txt": "} public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key))"
      },
      {
        "txt": "{ return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue)"
      },
      {
        "txt": "{ String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() {"
      },
      {
        "txt": "String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer();"
      },
      {
        "txt": "buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg);"
      },
      {
        "txt": "} void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else"
      },
      {
        "txt": "{ names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions()"
      },
      {
        "txt": "{ Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 67,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 51,
    "end-bug-line": 51,
    "bug": "private Map hashcodeMap = new HashMap();",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); <extra_id_0> CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt);"
      },
      {
        "txt": "{ return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt);"
      },
      {
        "txt": "if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt));"
      },
      {
        "txt": "} public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); }"
      },
      {
        "txt": "public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key)) {"
      },
      {
        "txt": "return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) {"
      },
      {
        "txt": "String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()];"
      },
      {
        "txt": "args.toArray(answer); return answer; } public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \");"
      },
      {
        "txt": "buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg); }"
      },
      {
        "txt": "void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else {"
      },
      {
        "txt": "names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions() {"
      },
      {
        "txt": "Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 68,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 69,
    "end-bug-line": 69,
    "bug": "return options.containsKey(opt);",
    "fix": "return options.contains( resolveOption(opt));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap();"
      },
      {
        "txt": "private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { <extra_id_0> } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt)"
      },
      {
        "txt": "} public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type);"
      },
      {
        "txt": "} public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; }"
      },
      {
        "txt": "public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) {"
      },
      {
        "txt": "key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) {"
      },
      {
        "txt": "return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue);"
      },
      {
        "txt": "} public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args;"
      },
      {
        "txt": "} public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); }"
      },
      {
        "txt": "void addArg(String arg) { args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) {"
      },
      {
        "txt": "key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() {"
      },
      {
        "txt": "return hashcodeMap.values().iterator(); } public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 69,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 93,
    "end-bug-line": 93,
    "bug": "if (!options.containsKey(opt))",
    "fix": "Option option = resolveOption(opt); if (option == null)",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList();"
      },
      {
        "txt": "private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); }"
      },
      {
        "txt": "{ return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); <extra_id_0> { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }"
      },
      {
        "txt": "return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0];"
      },
      {
        "txt": "} public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt))"
      },
      {
        "txt": "{ key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt)"
      },
      {
        "txt": "{ return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) {"
      },
      {
        "txt": "return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() {"
      },
      {
        "txt": "return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString();"
      },
      {
        "txt": "} void addArg(String arg) { args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null)"
      },
      {
        "txt": "{ key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator()"
      },
      {
        "txt": "{ return hashcodeMap.values().iterator(); } public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 70,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 98,
    "end-bug-line": 98,
    "bug": "Object type = ((Option) options.get(opt)).getType();",
    "fix": "Object type = option.getType();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine()"
      },
      {
        "txt": "{ } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); }"
      },
      {
        "txt": "{ String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } <extra_id_0> return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); }"
      },
      {
        "txt": "return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt));"
      },
      {
        "txt": "} public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key))"
      },
      {
        "txt": "{ return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue)"
      },
      {
        "txt": "{ String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() {"
      },
      {
        "txt": "String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer();"
      },
      {
        "txt": "buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg);"
      },
      {
        "txt": "} void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else"
      },
      {
        "txt": "{ names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions()"
      },
      {
        "txt": "{ Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 71,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 149,
    "end-bug-line": 149,
    "bug": "opt = Util.stripLeadingHyphens(opt);",
    "fix": "Option key = resolveOption( opt );",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap();"
      },
      {
        "txt": "private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) {"
      },
      {
        "txt": "return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType();"
      },
      {
        "txt": "return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0];"
      },
      {
        "txt": "public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { <extra_id_0> String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key))"
      },
      {
        "txt": "} if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt));"
      },
      {
        "txt": "} public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); }"
      },
      {
        "txt": "public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; }"
      },
      {
        "txt": "public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg)"
      },
      {
        "txt": "{ args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt();"
      },
      {
        "txt": "} else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator();"
      },
      {
        "txt": "} public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 72,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 151,
    "end-bug-line": 156,
    "bug": "String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key))",
    "fix": "if (options.contains(key))",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection;"
      },
      {
        "txt": "import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap();"
      },
      {
        "txt": "CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt));"
      },
      {
        "txt": "} public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type);"
      },
      {
        "txt": "} public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; }"
      },
      {
        "txt": "{ return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); <extra_id_0> { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt)"
      },
      {
        "txt": "} public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; }"
      },
      {
        "txt": "public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; }"
      },
      {
        "txt": "public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString());"
      },
      {
        "txt": "buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt);"
      },
      {
        "txt": "String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt);"
      },
      {
        "txt": "} public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray);"
      }
    ]
  },
  {
    "id": 73,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 158,
    "end-bug-line": 158,
    "bug": "return ((Option) options.get(key)).getValues();",
    "fix": "return key.getValues();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList();"
      },
      {
        "txt": "private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); }"
      },
      {
        "txt": "public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null;"
      },
      {
        "txt": "} Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) {"
      },
      {
        "txt": "String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt);"
      },
      {
        "txt": "if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key)) { <extra_id_0> } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt));"
      },
      {
        "txt": "{ return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) {"
      },
      {
        "txt": "return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() {"
      },
      {
        "txt": "return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString();"
      },
      {
        "txt": "} void addArg(String arg) { args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null)"
      },
      {
        "txt": "{ key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator()"
      },
      {
        "txt": "{ return hashcodeMap.values().iterator(); } public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 74,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 169,
    "end-bug-line": 169,
    "bug": "",
    "fix": "private Option resolveOption( String opt ) { opt = Util.stripLeadingHyphens(opt); for ( Iterator it = options.iterator(); it.hasNext(); ) { Option option = (Option) it.next(); if (opt.equals(option.getOpt())) { return option; } if (opt.equals( option.getLongOpt())) { return option; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine()"
      },
      {
        "txt": "{ } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); }"
      },
      {
        "txt": "public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }"
      },
      {
        "txt": "public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt)"
      },
      {
        "txt": "{ return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt);"
      },
      {
        "txt": "if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } <extra_id_0> public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) {"
      },
      {
        "txt": "public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs()"
      },
      {
        "txt": "{ String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; } public String toString() {"
      },
      {
        "txt": "StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) {"
      },
      {
        "txt": "args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); }"
      },
      {
        "txt": "else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator(); }"
      },
      {
        "txt": "public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 75,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 170,
    "end-bug-line": 170,
    "bug": "",
    "fix": "} return null; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine()"
      },
      {
        "txt": "{ } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); }"
      },
      {
        "txt": "public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }"
      },
      {
        "txt": "public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt)"
      },
      {
        "txt": "{ return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt);"
      },
      {
        "txt": "if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } <extra_id_0> public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) {"
      },
      {
        "txt": "public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs()"
      },
      {
        "txt": "{ String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; } public String toString() {"
      },
      {
        "txt": "StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) {"
      },
      {
        "txt": "args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); }"
      },
      {
        "txt": "else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator(); }"
      },
      {
        "txt": "public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 76,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 277,
    "end-bug-line": 287,
    "bug": "hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt);",
    "fix": "options.add(opt);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap();"
      },
      {
        "txt": "private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) {"
      },
      {
        "txt": "return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType();"
      },
      {
        "txt": "return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0];"
      },
      {
        "txt": "} public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt))"
      },
      {
        "txt": "{ key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt)"
      },
      {
        "txt": "{ return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) {"
      },
      {
        "txt": "return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() {"
      },
      {
        "txt": "return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString();"
      },
      {
        "txt": "void addArg(String arg) { args.add(arg); } void addOption(Option opt) { <extra_id_0> } public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions()"
      },
      {
        "txt": "} public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 77,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 298,
    "end-bug-line": 298,
    "bug": "return hashcodeMap.values().iterator();",
    "fix": "return options.iterator();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList;"
      },
      {
        "txt": "import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine() { }"
      },
      {
        "txt": "public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) {"
      },
      {
        "txt": "String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) {"
      },
      {
        "txt": "return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt));"
      },
      {
        "txt": "} public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key))"
      },
      {
        "txt": "{ return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue)"
      },
      {
        "txt": "{ String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() {"
      },
      {
        "txt": "String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer();"
      },
      {
        "txt": "buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg);"
      },
      {
        "txt": "} void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else"
      },
      {
        "txt": "names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { <extra_id_0> } public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray);"
      },
      {
        "txt": "Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); }"
      }
    ]
  },
  {
    "id": 78,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 308,
    "end-bug-line": 308,
    "bug": "Collection processed = options.values();",
    "fix": "Collection processed = options;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList();"
      },
      {
        "txt": "private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine() { } public boolean hasOption(String opt) { return options.containsKey(opt); }"
      },
      {
        "txt": "public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); } public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null;"
      },
      {
        "txt": "} Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); } public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) {"
      },
      {
        "txt": "String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt) { return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt);"
      },
      {
        "txt": "String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt); } if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null;"
      },
      {
        "txt": "} public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt)); } public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; }"
      },
      {
        "txt": "public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); } public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; }"
      },
      {
        "txt": "public List getArgList() { return args; } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString());"
      },
      {
        "txt": "buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg) { args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt);"
      },
      {
        "txt": "String key = opt.getKey(); if (key == null) { key = opt.getLongOpt(); } else { names.put(opt.getLongOpt(), key); } options.put(key, opt);"
      },
      {
        "txt": "public Iterator iterator() { return hashcodeMap.values().iterator(); } public Option[] getOptions() { <extra_id_0> Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); } }"
      }
    ]
  },
  {
    "id": 79,
    "file_path": "src/java/org/apache/commons/cli/CommandLine.java",
    "start-bug-line": 316,
    "end-bug-line": 316,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.cli; import java.util.Collection; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Map; public class CommandLine { private List args = new LinkedList(); private Map options = new HashMap(); private Map names = new HashMap(); private Map hashcodeMap = new HashMap(); CommandLine()"
      },
      {
        "txt": "{ } public boolean hasOption(String opt) { return options.containsKey(opt); } public boolean hasOption(char opt) { return hasOption(String.valueOf(opt)); }"
      },
      {
        "txt": "public Object getOptionObject(String opt) { String res = getOptionValue(opt); if (!options.containsKey(opt)) { return null; } Object type = ((Option) options.get(opt)).getType(); return (res == null) ? null : TypeHandler.createValue(res, type); }"
      },
      {
        "txt": "public Object getOptionObject(char opt) { return getOptionObject(String.valueOf(opt)); } public String getOptionValue(String opt) { String[] values = getOptionValues(opt); return (values == null) ? null : values[0]; } public String getOptionValue(char opt)"
      },
      {
        "txt": "{ return getOptionValue(String.valueOf(opt)); } public String[] getOptionValues(String opt) { opt = Util.stripLeadingHyphens(opt); String key = opt; if (names.containsKey(opt)) { key = (String) names.get(opt);"
      },
      {
        "txt": "} if (options.containsKey(key)) { return ((Option) options.get(key)).getValues(); } return null; } public String[] getOptionValues(char opt) { return getOptionValues(String.valueOf(opt));"
      },
      {
        "txt": "} public String getOptionValue(String opt, String defaultValue) { String answer = getOptionValue(opt); return (answer != null) ? answer : defaultValue; } public String getOptionValue(char opt, String defaultValue) { return getOptionValue(String.valueOf(opt), defaultValue); }"
      },
      {
        "txt": "public String[] getArgs() { String[] answer = new String[args.size()]; args.toArray(answer); return answer; } public List getArgList() { return args; }"
      },
      {
        "txt": "public String toString() { StringBuffer buf = new StringBuffer(); buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \"); buf.append(args.toString()); buf.append(\" ] ]\"); return buf.toString(); } void addArg(String arg)"
      },
      {
        "txt": "{ args.add(arg); } void addOption(Option opt) { hashcodeMap.put(new Integer(opt.hashCode()), opt); String key = opt.getKey(); if (key == null) { key = opt.getLongOpt();"
      },
      {
        "txt": "} else { names.put(opt.getLongOpt(), key); } options.put(key, opt); } public Iterator iterator() { return hashcodeMap.values().iterator();"
      },
      {
        "txt": "public Option[] getOptions() { Collection processed = options.values(); Option[] optionsArray = new Option[processed.size()]; return (Option[]) processed.toArray(optionsArray); } <extra_id_0>"
      }
    ]
  }
]