[
  {
    "id": 1296,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserBase.java",
    "start-bug-line": 869,
    "end-bug-line": 871,
    "bug": "final String numDesc = _longIntegerDesc(rawNum); _reportError(\"Numeric value (%s) out of range of %s\", numDesc, (expType == NR_LONG) ? \"long\" : \"int\");",
    "fix": "if (expType == NR_INT) { reportOverflowInt(rawNum); } else { reportOverflowLong(rawNum); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.JsonParser.Feature; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.json.DupDetector; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.PackageVersion; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.TextBuffer;"
      },
      {
        "txt": "public abstract class ParserBase extends ParserMinimalBase { final protected IOContext _ioContext; protected boolean _closed; protected int _inputPtr; protected int _inputEnd; protected long _currInputProcessed; protected int _currInputRow = 1; protected int _currInputRowStart; protected long _tokenInputTotal;"
      },
      {
        "txt": "protected int _tokenInputRow = 1; protected int _tokenInputCol; protected JsonReadContext _parsingContext; protected JsonToken _nextToken; protected final TextBuffer _textBuffer; protected char[] _nameCopyBuffer; protected boolean _nameCopied; protected ByteArrayBuilder _byteArrayBuilder; protected byte[] _binaryValue; protected int _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "protected int _numberInt; protected long _numberLong; protected double _numberDouble; protected BigInteger _numberBigInt; protected BigDecimal _numberBigDecimal; protected boolean _numberNegative; protected int _intLength; protected int _fractLength; protected int _expLength; protected ParserBase(IOContext ctxt, int features) {"
      },
      {
        "txt": "super(features); _ioContext = ctxt; _textBuffer = ctxt.constructTextBuffer(); DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features) ? DupDetector.rootDetector(this) : null; _parsingContext = JsonReadContext.createRootContext(dups); } @Override public Version version() { return PackageVersion.VERSION; } @Override public Object getCurrentValue() {"
      },
      {
        "txt": "return _parsingContext.getCurrentValue(); } @Override public void setCurrentValue(Object v) { _parsingContext.setCurrentValue(v); } @Override public JsonParser enable(Feature f) { _features |= f.getMask(); if (f == Feature.STRICT_DUPLICATE_DETECTION) { // enabling dup detection?"
      },
      {
        "txt": "if (_parsingContext.getDupDetector() == null) { // but only if disabled currently _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this)); } } return this; } @Override public JsonParser disable(Feature f) { _features &= ~f.getMask(); if (f == Feature.STRICT_DUPLICATE_DETECTION) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.withDupDetector(null); } return this; } @Override @Deprecated public JsonParser setFeatureMask(int newMask) { int changes = (_features ^ newMask); if (changes != 0) { _features = newMask;"
      },
      {
        "txt": "_checkStdFeatureChanges(newMask, changes); } return this; } @Override // since 2.7 public JsonParser overrideStdFeatures(int values, int mask) { int oldState = _features; int newState = (oldState & ~mask) | (values & mask); int changed = oldState ^ newState; if (changed != 0) {"
      },
      {
        "txt": "_features = newState; _checkStdFeatureChanges(newState, changed); } return this; } protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) { int f = Feature.STRICT_DUPLICATE_DETECTION.getMask(); if ((changedFeatures & f) != 0) { if ((newFeatureFlags & f) != 0) {"
      },
      {
        "txt": "if (_parsingContext.getDupDetector() == null) { _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this)); } else { // disabling _parsingContext = _parsingContext.withDupDetector(null); } } } } @Override public String getCurrentName() throws IOException { if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "JsonReadContext parent = _parsingContext.getParent(); if (parent != null) { return parent.getCurrentName(); } } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new IllegalStateException(e); } } @Override public void close() throws IOException { if (!_closed) {"
      },
      {
        "txt": "_inputPtr = Math.max(_inputPtr, _inputEnd); _closed = true; try { _closeInput(); } finally { _releaseBuffers(); } } } @Override public boolean isClosed() { return _closed; }"
      },
      {
        "txt": "@Override public JsonReadContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return new JsonLocation(_getSourceReference(), -1L, getTokenCharacterOffset(), // bytes, chars getTokenLineNr(), getTokenColumnNr()); } @Override public JsonLocation getCurrentLocation() {"
      },
      {
        "txt": "int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_getSourceReference(), -1L, _currInputProcessed + _inputPtr, // bytes, chars _currInputRow, col); } @Override public boolean hasTextCharacters() { if (_currToken == JsonToken.VALUE_STRING) { return true; } // usually true if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; } return false;"
      },
      {
        "txt": "} @SuppressWarnings(\"resource\") @Override // since 2.7 public byte[] getBinaryValue(Base64Variant variant) throws IOException { if (_binaryValue == null) { if (_currToken != JsonToken.VALUE_STRING) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\"); } ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, variant); _binaryValue = builder.toByteArray(); } return _binaryValue; } public long getTokenCharacterOffset() { return _tokenInputTotal; } public int getTokenLineNr() { return _tokenInputRow; } public int getTokenColumnNr() { int col = _tokenInputCol; return (col < 0) ? col : (col + 1);"
      },
      {
        "txt": "} protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException { _textBuffer.releaseBuffers(); char[] buf = _nameCopyBuffer; if (buf != null) { _nameCopyBuffer = null; _ioContext.releaseNameCopyBuffer(buf); } }"
      },
      {
        "txt": "@Override protected void _handleEOF() throws JsonParseException { if (!_parsingContext.inRoot()) { String marker = _parsingContext.inArray() ? \"Array\" : \"Object\"; _reportInvalidEOF(String.format( \": expected close marker for %s (start marker at %s)\", marker, _parsingContext.getStartLocation(_getSourceReference())), null); }"
      },
      {
        "txt": "} protected final int _eofAsNextChar() throws JsonParseException { _handleEOF(); return -1; } public ByteArrayBuilder _getByteArrayBuilder() { if (_byteArrayBuilder == null) { _byteArrayBuilder = new ByteArrayBuilder(); } else {"
      },
      {
        "txt": "_byteArrayBuilder.reset(); } return _byteArrayBuilder; } protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { if (fractLen < 1 && expLen < 1) { // integer return resetInt(negative, intLen); } return resetFloat(negative, intLen, fractLen, expLen);"
      },
      {
        "txt": "} protected final JsonToken resetInt(boolean negative, int intLen) { _numberNegative = negative; _intLength = intLen; _fractLength = 0; _expLength = 0; _numTypesValid = NR_UNKNOWN; // to force parsing return JsonToken.VALUE_NUMBER_INT; }"
      },
      {
        "txt": "protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) { _numberNegative = negative; _intLength = intLen; _fractLength = fractLen; _expLength = expLen; _numTypesValid = NR_UNKNOWN; // to force parsing return JsonToken.VALUE_NUMBER_FLOAT; } protected final JsonToken resetAsNaN(String valueStr, double value)"
      },
      {
        "txt": "{ _textBuffer.resetWithString(valueStr); _numberDouble = value; _numTypesValid = NR_DOUBLE; return JsonToken.VALUE_NUMBER_FLOAT; } @Override public boolean isNaN() { if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { if ((_numTypesValid & NR_DOUBLE) != 0) {"
      },
      {
        "txt": "double d = _numberDouble; return Double.isNaN(d) || Double.isInfinite(d); } } return false; } @Override public Number getNumberValue() throws IOException { if (_numTypesValid == NR_UNKNOWN) {"
      },
      {
        "txt": "_parseNumericValue(NR_UNKNOWN); // will also check event type } if (_currToken == JsonToken.VALUE_NUMBER_INT) { if ((_numTypesValid & NR_INT) != 0) { return _numberInt; } if ((_numTypesValid & NR_LONG) != 0) { return _numberLong; } if ((_numTypesValid & NR_BIGINT) != 0) {"
      },
      {
        "txt": "return _numberBigInt; } return _numberBigDecimal; } if ((_numTypesValid & NR_BIGDECIMAL) != 0) { return _numberBigDecimal; } if ((_numTypesValid & NR_DOUBLE) == 0) { // sanity check _throwInternal(); }"
      },
      {
        "txt": "return _numberDouble; } @Override public NumberType getNumberType() throws IOException { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_UNKNOWN); // will also check event type } if (_currToken == JsonToken.VALUE_NUMBER_INT) { if ((_numTypesValid & NR_INT) != 0) {"
      },
      {
        "txt": "return NumberType.INT; } if ((_numTypesValid & NR_LONG) != 0) { return NumberType.LONG; } return NumberType.BIG_INTEGER; } if ((_numTypesValid & NR_BIGDECIMAL) != 0) { return NumberType.BIG_DECIMAL; }"
      },
      {
        "txt": "return NumberType.DOUBLE; } @Override public int getIntValue() throws IOException { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { // not parsed at all return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?"
      },
      {
        "txt": "convertNumberToInt(); // let's make it so, if possible } } return _numberInt; } @Override public long getLongValue() throws IOException { if ((_numTypesValid & NR_LONG) == 0) { if (_numTypesValid == NR_UNKNOWN) {"
      },
      {
        "txt": "_parseNumericValue(NR_LONG); } if ((_numTypesValid & NR_LONG) == 0) { convertNumberToLong(); } } return _numberLong; } @Override public BigInteger getBigIntegerValue() throws IOException"
      },
      {
        "txt": "{ if ((_numTypesValid & NR_BIGINT) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_BIGINT); } if ((_numTypesValid & NR_BIGINT) == 0) { convertNumberToBigInteger(); } } return _numberBigInt;"
      },
      {
        "txt": "} @Override public float getFloatValue() throws IOException { double value = getDoubleValue(); if (value < -Float.MAX_VALUE || value > MAX_FLOAT_D) { _reportError(\"Numeric value (\"+getText()+\") out of range of Java float\"); } return (float) value; }"
      },
      {
        "txt": "@Override public double getDoubleValue() throws IOException { if ((_numTypesValid & NR_DOUBLE) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_DOUBLE); } if ((_numTypesValid & NR_DOUBLE) == 0) { convertNumberToDouble(); }"
      },
      {
        "txt": "} return _numberDouble; } @Override public BigDecimal getDecimalValue() throws IOException { if ((_numTypesValid & NR_BIGDECIMAL) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_BIGDECIMAL); }"
      },
      {
        "txt": "if ((_numTypesValid & NR_BIGDECIMAL) == 0) { convertNumberToBigDecimal(); } } return _numberBigDecimal; } protected void _parseNumericValue(int expType) throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { int len = _intLength;"
      },
      {
        "txt": "if (len <= 9) { int i = _textBuffer.contentsAsInt(_numberNegative); _numberInt = i; _numTypesValid = NR_INT; return; } if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls long l = _textBuffer.contentsAsLong(_numberNegative); if (len == 10) { if (_numberNegative) {"
      },
      {
        "txt": "if (l >= MIN_INT_L) { _numberInt = (int) l; _numTypesValid = NR_INT; return; } } else { if (l <= MAX_INT_L) { _numberInt = (int) l; _numTypesValid = NR_INT; return;"
      },
      {
        "txt": "} } } _numberLong = l; _numTypesValid = NR_LONG; return; } _parseSlowInt(expType); return; }"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { _parseSlowFloat(expType); return; } _reportError(\"Current token (%s) not numeric, can not use numeric value accessors\", _currToken); } protected int _parseIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) { if (_intLength <= 9) {"
      },
      {
        "txt": "int i = _textBuffer.contentsAsInt(_numberNegative); _numberInt = i; _numTypesValid = NR_INT; return i; } } _parseNumericValue(NR_INT); if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt(); }"
      },
      {
        "txt": "return _numberInt; } private void _parseSlowFloat(int expType) throws IOException { try { if (expType == NR_BIGDECIMAL) { _numberBigDecimal = _textBuffer.contentsAsDecimal(); _numTypesValid = NR_BIGDECIMAL; } else { _numberDouble = _textBuffer.contentsAsDouble();"
      },
      {
        "txt": "_numTypesValid = NR_DOUBLE; } } catch (NumberFormatException nex) { _wrapError(\"Malformed numeric value (\"+_longNumberDesc(_textBuffer.contentsAsString())+\")\", nex); } } private void _parseSlowInt(int expType) throws IOException { String numStr = _textBuffer.contentsAsString(); try {"
      },
      {
        "txt": "int len = _intLength; char[] buf = _textBuffer.getTextBuffer(); int offset = _textBuffer.getTextOffset(); if (_numberNegative) { ++offset; } if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { _numberLong = Long.parseLong(numStr); _numTypesValid = NR_LONG; } else {"
      },
      {
        "txt": "if ((expType == NR_INT) || (expType == NR_LONG)) { _reportTooLongIntegral(expType, numStr); } if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) { _numberDouble = NumberInput.parseDouble(numStr); _numTypesValid = NR_DOUBLE; } else { _numberBigInt = new BigInteger(numStr); _numTypesValid = NR_BIGINT; }"
      },
      {
        "txt": "} catch (NumberFormatException nex) { _wrapError(\"Malformed numeric value (\"+_longNumberDesc(numStr)+\")\", nex); } } protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException { <extra_id_0> } protected void convertNumberToInt() throws IOException { if ((_numTypesValid & NR_LONG) != 0) { int result = (int) _numberLong; if (((long) result) != _numberLong) {"
      },
      {
        "txt": "int result = (int) _numberLong; if (((long) result) != _numberLong) { _reportError(\"Numeric value (\"+getText()+\") out of range of int\"); } _numberInt = result; } else if ((_numTypesValid & NR_BIGINT) != 0) { if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { reportOverflowInt(); }"
      },
      {
        "txt": "_numberInt = _numberBigInt.intValue(); } else if ((_numTypesValid & NR_DOUBLE) != 0) { if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { reportOverflowInt(); } _numberInt = (int) _numberDouble; } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { reportOverflowInt();"
      },
      {
        "txt": "} _numberInt = _numberBigDecimal.intValue(); } else { _throwInternal(); } _numTypesValid |= NR_INT; } protected void convertNumberToLong() throws IOException { if ((_numTypesValid & NR_INT) != 0) {"
      },
      {
        "txt": "_numberLong = (long) _numberInt; } else if ((_numTypesValid & NR_BIGINT) != 0) { if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { reportOverflowLong(); } _numberLong = _numberBigInt.longValue(); } else if ((_numTypesValid & NR_DOUBLE) != 0) { if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { reportOverflowLong();"
      },
      {
        "txt": "} _numberLong = (long) _numberDouble; } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { reportOverflowLong(); } _numberLong = _numberBigDecimal.longValue(); } else { _throwInternal();"
      },
      {
        "txt": "} _numTypesValid |= NR_LONG; } protected void convertNumberToBigInteger() throws IOException { if ((_numTypesValid & NR_BIGDECIMAL) != 0) { _numberBigInt = _numberBigDecimal.toBigInteger(); } else if ((_numTypesValid & NR_LONG) != 0) { _numberBigInt = BigInteger.valueOf(_numberLong); } else if ((_numTypesValid & NR_INT) != 0) {"
      },
      {
        "txt": "_numberBigInt = BigInteger.valueOf(_numberInt); } else if ((_numTypesValid & NR_DOUBLE) != 0) { _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger(); } else { _throwInternal(); } _numTypesValid |= NR_BIGINT; } protected void convertNumberToDouble() throws IOException {"
      },
      {
        "txt": "if ((_numTypesValid & NR_BIGDECIMAL) != 0) { _numberDouble = _numberBigDecimal.doubleValue(); } else if ((_numTypesValid & NR_BIGINT) != 0) { _numberDouble = _numberBigInt.doubleValue(); } else if ((_numTypesValid & NR_LONG) != 0) { _numberDouble = (double) _numberLong; } else if ((_numTypesValid & NR_INT) != 0) { _numberDouble = (double) _numberInt; } else { _throwInternal();"
      },
      {
        "txt": "} _numTypesValid |= NR_DOUBLE; } protected void convertNumberToBigDecimal() throws IOException { if ((_numTypesValid & NR_DOUBLE) != 0) { _numberBigDecimal = NumberInput.parseBigDecimal(getText()); } else if ((_numTypesValid & NR_BIGINT) != 0) { _numberBigDecimal = new BigDecimal(_numberBigInt); } else if ((_numTypesValid & NR_LONG) != 0) {"
      },
      {
        "txt": "_numberBigDecimal = BigDecimal.valueOf(_numberLong); } else if ((_numTypesValid & NR_INT) != 0) { _numberBigDecimal = BigDecimal.valueOf(_numberInt); } else { _throwInternal(); } _numTypesValid |= NR_BIGDECIMAL; } protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException { JsonReadContext ctxt = getParsingContext();"
      },
      {
        "txt": "_reportError(String.format( \"Unexpected close marker '%s': expected '%c' (for %s starting at %s)\", (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference()))); } @SuppressWarnings(\"deprecation\") protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { return ch; } if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {"
      },
      {
        "txt": "return ch; } _reportError(\"Unrecognized character escape \"+_getCharDesc(ch)); return ch; } @SuppressWarnings(\"deprecation\") protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) { char c = (char) i; String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;"
      },
      {
        "txt": "_reportError(msg); } } protected char _decodeEscaped() throws IOException { throw new UnsupportedOperationException(); } protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException { if (ch != '\\\\') { throw reportInvalidBase64Char(b64variant, ch, index);"
      },
      {
        "txt": "} int unescaped = _decodeEscaped(); if (unescaped <= INT_SPACE) { if (index == 0) { // whitespace only allowed to be skipped between triplets return -1; } } int bits = b64variant.decodeBase64Char(unescaped); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "throw reportInvalidBase64Char(b64variant, unescaped, index); } } return bits; } protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException { if (ch != '\\\\') { throw reportInvalidBase64Char(b64variant, ch, index); }"
      },
      {
        "txt": "char unescaped = _decodeEscaped(); if (unescaped <= INT_SPACE) { if (index == 0) { // whitespace only allowed to be skipped between triplets return -1; } } int bits = b64variant.decodeBase64Char(unescaped); if (bits < 0) { if ((bits != Base64Variant.BASE64_VALUE_PADDING) || (index < 2)) { throw reportInvalidBase64Char(b64variant, unescaped, index);"
      },
      {
        "txt": "} } return bits; } protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException { return reportInvalidBase64Char(b64variant, ch, bindex, null); } protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException { String base; if (ch <= INT_SPACE) {"
      },
      {
        "txt": "base = String.format(\"Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units\", Integer.toHexString(ch), (bindex+1)); } else if (b64variant.usesPaddingChar(ch)) { base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\"; } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } else { base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } if (msg != null) {"
      },
      {
        "txt": "base = base + \": \" + msg; } return new IllegalArgumentException(base); } protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException { _reportError(b64variant.missingPaddingMessage()); } protected Object _getSourceReference() { if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) {"
      },
      {
        "txt": "return _ioContext.getSourceReference(); } return null; } protected static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more);"
      },
      {
        "txt": "} @Deprecated // since 2.8 protected void loadMoreGuaranteed() throws IOException { if (!loadMore()) { _reportInvalidEOF(); } } @Deprecated // since 2.8 protected boolean loadMore() throws IOException { return false; } protected void _finishString() throws IOException { }"
      }
    ]
  },
  {
    "id": 1297,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserBase.java",
    "start-bug-line": 887,
    "end-bug-line": 887,
    "bug": "_reportError(\"Numeric value (\"+getText()+\") out of range of int\");",
    "fix": "reportOverflowInt(getText(), currentToken());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.*; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.JsonParser.Feature; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.json.DupDetector; import com.fasterxml.jackson.core.json.JsonReadContext; import com.fasterxml.jackson.core.json.PackageVersion; import com.fasterxml.jackson.core.util.ByteArrayBuilder;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.TextBuffer; public abstract class ParserBase extends ParserMinimalBase { final protected IOContext _ioContext; protected boolean _closed; protected int _inputPtr; protected int _inputEnd; protected long _currInputProcessed; protected int _currInputRow = 1; protected int _currInputRowStart;"
      },
      {
        "txt": "protected long _tokenInputTotal; protected int _tokenInputRow = 1; protected int _tokenInputCol; protected JsonReadContext _parsingContext; protected JsonToken _nextToken; protected final TextBuffer _textBuffer; protected char[] _nameCopyBuffer; protected boolean _nameCopied; protected ByteArrayBuilder _byteArrayBuilder; protected byte[] _binaryValue;"
      },
      {
        "txt": "protected int _numTypesValid = NR_UNKNOWN; protected int _numberInt; protected long _numberLong; protected double _numberDouble; protected BigInteger _numberBigInt; protected BigDecimal _numberBigDecimal; protected boolean _numberNegative; protected int _intLength; protected int _fractLength; protected int _expLength;"
      },
      {
        "txt": "protected ParserBase(IOContext ctxt, int features) { super(features); _ioContext = ctxt; _textBuffer = ctxt.constructTextBuffer(); DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features) ? DupDetector.rootDetector(this) : null; _parsingContext = JsonReadContext.createRootContext(dups); } @Override public Version version() { return PackageVersion.VERSION; } @Override"
      },
      {
        "txt": "public Object getCurrentValue() { return _parsingContext.getCurrentValue(); } @Override public void setCurrentValue(Object v) { _parsingContext.setCurrentValue(v); } @Override public JsonParser enable(Feature f) { _features |= f.getMask();"
      },
      {
        "txt": "if (f == Feature.STRICT_DUPLICATE_DETECTION) { // enabling dup detection? if (_parsingContext.getDupDetector() == null) { // but only if disabled currently _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this)); } } return this; } @Override public JsonParser disable(Feature f) { _features &= ~f.getMask();"
      },
      {
        "txt": "if (f == Feature.STRICT_DUPLICATE_DETECTION) { _parsingContext = _parsingContext.withDupDetector(null); } return this; } @Override @Deprecated public JsonParser setFeatureMask(int newMask) { int changes = (_features ^ newMask); if (changes != 0) {"
      },
      {
        "txt": "_features = newMask; _checkStdFeatureChanges(newMask, changes); } return this; } @Override // since 2.7 public JsonParser overrideStdFeatures(int values, int mask) { int oldState = _features; int newState = (oldState & ~mask) | (values & mask); int changed = oldState ^ newState;"
      },
      {
        "txt": "if (changed != 0) { _features = newState; _checkStdFeatureChanges(newState, changed); } return this; } protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) { int f = Feature.STRICT_DUPLICATE_DETECTION.getMask(); if ((changedFeatures & f) != 0) {"
      },
      {
        "txt": "if ((newFeatureFlags & f) != 0) { if (_parsingContext.getDupDetector() == null) { _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this)); } else { // disabling _parsingContext = _parsingContext.withDupDetector(null); } } } } @Override public String getCurrentName() throws IOException {"
      },
      {
        "txt": "if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonReadContext parent = _parsingContext.getParent(); if (parent != null) { return parent.getCurrentName(); } } return _parsingContext.getCurrentName(); } @Override public void overrideCurrentName(String name) { JsonReadContext ctxt = _parsingContext;"
      },
      {
        "txt": "if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { ctxt = ctxt.getParent(); } try { ctxt.setCurrentName(name); } catch (IOException e) { throw new IllegalStateException(e); } } @Override public void close() throws IOException {"
      },
      {
        "txt": "if (!_closed) { _inputPtr = Math.max(_inputPtr, _inputEnd); _closed = true; try { _closeInput(); } finally { _releaseBuffers(); } } }"
      },
      {
        "txt": "@Override public boolean isClosed() { return _closed; } @Override public JsonReadContext getParsingContext() { return _parsingContext; } @Override public JsonLocation getTokenLocation() { return new JsonLocation(_getSourceReference(), -1L, getTokenCharacterOffset(), // bytes, chars getTokenLineNr(), getTokenColumnNr()); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_getSourceReference(), -1L, _currInputProcessed + _inputPtr, // bytes, chars _currInputRow, col); } @Override public boolean hasTextCharacters() { if (_currToken == JsonToken.VALUE_STRING) { return true; } // usually true if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; }"
      },
      {
        "txt": "return false; } @SuppressWarnings(\"resource\") @Override // since 2.7 public byte[] getBinaryValue(Base64Variant variant) throws IOException { if (_binaryValue == null) { if (_currToken != JsonToken.VALUE_STRING) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\"); }"
      },
      {
        "txt": "ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, variant); _binaryValue = builder.toByteArray(); } return _binaryValue; } public long getTokenCharacterOffset() { return _tokenInputTotal; } public int getTokenLineNr() { return _tokenInputRow; } public int getTokenColumnNr() { int col = _tokenInputCol;"
      },
      {
        "txt": "return (col < 0) ? col : (col + 1); } protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException { _textBuffer.releaseBuffers(); char[] buf = _nameCopyBuffer; if (buf != null) { _nameCopyBuffer = null; _ioContext.releaseNameCopyBuffer(buf); }"
      },
      {
        "txt": "} @Override protected void _handleEOF() throws JsonParseException { if (!_parsingContext.inRoot()) { String marker = _parsingContext.inArray() ? \"Array\" : \"Object\"; _reportInvalidEOF(String.format( \": expected close marker for %s (start marker at %s)\", marker, _parsingContext.getStartLocation(_getSourceReference())), null);"
      },
      {
        "txt": "} } protected final int _eofAsNextChar() throws JsonParseException { _handleEOF(); return -1; } public ByteArrayBuilder _getByteArrayBuilder() { if (_byteArrayBuilder == null) { _byteArrayBuilder = new ByteArrayBuilder();"
      },
      {
        "txt": "} else { _byteArrayBuilder.reset(); } return _byteArrayBuilder; } protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { if (fractLen < 1 && expLen < 1) { // integer return resetInt(negative, intLen); }"
      },
      {
        "txt": "return resetFloat(negative, intLen, fractLen, expLen); } protected final JsonToken resetInt(boolean negative, int intLen) { _numberNegative = negative; _intLength = intLen; _fractLength = 0; _expLength = 0; _numTypesValid = NR_UNKNOWN; // to force parsing return JsonToken.VALUE_NUMBER_INT;"
      },
      {
        "txt": "} protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) { _numberNegative = negative; _intLength = intLen; _fractLength = fractLen; _expLength = expLen; _numTypesValid = NR_UNKNOWN; // to force parsing return JsonToken.VALUE_NUMBER_FLOAT; }"
      },
      {
        "txt": "protected final JsonToken resetAsNaN(String valueStr, double value) { _textBuffer.resetWithString(valueStr); _numberDouble = value; _numTypesValid = NR_DOUBLE; return JsonToken.VALUE_NUMBER_FLOAT; } @Override public boolean isNaN() { if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {"
      },
      {
        "txt": "if ((_numTypesValid & NR_DOUBLE) != 0) { double d = _numberDouble; return Double.isNaN(d) || Double.isInfinite(d); } } return false; } @Override public Number getNumberValue() throws IOException {"
      },
      {
        "txt": "if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_UNKNOWN); // will also check event type } if (_currToken == JsonToken.VALUE_NUMBER_INT) { if ((_numTypesValid & NR_INT) != 0) { return _numberInt; } if ((_numTypesValid & NR_LONG) != 0) { return _numberLong; }"
      },
      {
        "txt": "if ((_numTypesValid & NR_BIGINT) != 0) { return _numberBigInt; } return _numberBigDecimal; } if ((_numTypesValid & NR_BIGDECIMAL) != 0) { return _numberBigDecimal; } if ((_numTypesValid & NR_DOUBLE) == 0) { // sanity check _throwInternal();"
      },
      {
        "txt": "} return _numberDouble; } @Override public NumberType getNumberType() throws IOException { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_UNKNOWN); // will also check event type } if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "if ((_numTypesValid & NR_INT) != 0) { return NumberType.INT; } if ((_numTypesValid & NR_LONG) != 0) { return NumberType.LONG; } return NumberType.BIG_INTEGER; } if ((_numTypesValid & NR_BIGDECIMAL) != 0) { return NumberType.BIG_DECIMAL;"
      },
      {
        "txt": "} return NumberType.DOUBLE; } @Override public int getIntValue() throws IOException { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { // not parsed at all return _parseIntValue(); }"
      },
      {
        "txt": "if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively? convertNumberToInt(); // let's make it so, if possible } } return _numberInt; } @Override public long getLongValue() throws IOException { if ((_numTypesValid & NR_LONG) == 0) {"
      },
      {
        "txt": "if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_LONG); } if ((_numTypesValid & NR_LONG) == 0) { convertNumberToLong(); } } return _numberLong; } @Override"
      },
      {
        "txt": "public BigInteger getBigIntegerValue() throws IOException { if ((_numTypesValid & NR_BIGINT) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_BIGINT); } if ((_numTypesValid & NR_BIGINT) == 0) { convertNumberToBigInteger(); } }"
      },
      {
        "txt": "return _numberBigInt; } @Override public float getFloatValue() throws IOException { double value = getDoubleValue(); if (value < -Float.MAX_VALUE || value > MAX_FLOAT_D) { _reportError(\"Numeric value (\"+getText()+\") out of range of Java float\"); } return (float) value;"
      },
      {
        "txt": "} @Override public double getDoubleValue() throws IOException { if ((_numTypesValid & NR_DOUBLE) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_DOUBLE); } if ((_numTypesValid & NR_DOUBLE) == 0) { convertNumberToDouble();"
      },
      {
        "txt": "} } return _numberDouble; } @Override public BigDecimal getDecimalValue() throws IOException { if ((_numTypesValid & NR_BIGDECIMAL) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_BIGDECIMAL);"
      },
      {
        "txt": "} if ((_numTypesValid & NR_BIGDECIMAL) == 0) { convertNumberToBigDecimal(); } } return _numberBigDecimal; } protected void _parseNumericValue(int expType) throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "int len = _intLength; if (len <= 9) { int i = _textBuffer.contentsAsInt(_numberNegative); _numberInt = i; _numTypesValid = NR_INT; return; } if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls long l = _textBuffer.contentsAsLong(_numberNegative); if (len == 10) {"
      },
      {
        "txt": "if (_numberNegative) { if (l >= MIN_INT_L) { _numberInt = (int) l; _numTypesValid = NR_INT; return; } } else { if (l <= MAX_INT_L) { _numberInt = (int) l; _numTypesValid = NR_INT;"
      },
      {
        "txt": "return; } } } _numberLong = l; _numTypesValid = NR_LONG; return; } _parseSlowInt(expType); return;"
      },
      {
        "txt": "} if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { _parseSlowFloat(expType); return; } _reportError(\"Current token (%s) not numeric, can not use numeric value accessors\", _currToken); } protected int _parseIntValue() throws IOException { if (_currToken == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "if (_intLength <= 9) { int i = _textBuffer.contentsAsInt(_numberNegative); _numberInt = i; _numTypesValid = NR_INT; return i; } } _parseNumericValue(NR_INT); if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt();"
      },
      {
        "txt": "} return _numberInt; } private void _parseSlowFloat(int expType) throws IOException { try { if (expType == NR_BIGDECIMAL) { _numberBigDecimal = _textBuffer.contentsAsDecimal(); _numTypesValid = NR_BIGDECIMAL; } else {"
      },
      {
        "txt": "_numberDouble = _textBuffer.contentsAsDouble(); _numTypesValid = NR_DOUBLE; } } catch (NumberFormatException nex) { _wrapError(\"Malformed numeric value (\"+_longNumberDesc(_textBuffer.contentsAsString())+\")\", nex); } } private void _parseSlowInt(int expType) throws IOException { String numStr = _textBuffer.contentsAsString();"
      },
      {
        "txt": "try { int len = _intLength; char[] buf = _textBuffer.getTextBuffer(); int offset = _textBuffer.getTextOffset(); if (_numberNegative) { ++offset; } if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { _numberLong = Long.parseLong(numStr); _numTypesValid = NR_LONG;"
      },
      {
        "txt": "} else { if ((expType == NR_INT) || (expType == NR_LONG)) { _reportTooLongIntegral(expType, numStr); } if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) { _numberDouble = NumberInput.parseDouble(numStr); _numTypesValid = NR_DOUBLE; } else { _numberBigInt = new BigInteger(numStr); _numTypesValid = NR_BIGINT;"
      },
      {
        "txt": "} } } catch (NumberFormatException nex) { _wrapError(\"Malformed numeric value (\"+_longNumberDesc(numStr)+\")\", nex); } } protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException { final String numDesc = _longIntegerDesc(rawNum); _reportError(\"Numeric value (%s) out of range of %s\", numDesc,"
      },
      {
        "txt": "} protected void convertNumberToInt() throws IOException { if ((_numTypesValid & NR_LONG) != 0) { int result = (int) _numberLong; if (((long) result) != _numberLong) { <extra_id_0> } _numberInt = result; } else if ((_numTypesValid & NR_BIGINT) != 0) { if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { reportOverflowInt();"
      },
      {
        "txt": "|| BI_MAX_INT.compareTo(_numberBigInt) < 0) { reportOverflowInt(); } _numberInt = _numberBigInt.intValue(); } else if ((_numTypesValid & NR_DOUBLE) != 0) { if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { reportOverflowInt(); } _numberInt = (int) _numberDouble; } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {"
      },
      {
        "txt": "if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { reportOverflowInt(); } _numberInt = _numberBigDecimal.intValue(); } else { _throwInternal(); } _numTypesValid |= NR_INT; }"
      },
      {
        "txt": "protected void convertNumberToLong() throws IOException { if ((_numTypesValid & NR_INT) != 0) { _numberLong = (long) _numberInt; } else if ((_numTypesValid & NR_BIGINT) != 0) { if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { reportOverflowLong(); } _numberLong = _numberBigInt.longValue();"
      },
      {
        "txt": "} else if ((_numTypesValid & NR_DOUBLE) != 0) { if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { reportOverflowLong(); } _numberLong = (long) _numberDouble; } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { reportOverflowLong(); }"
      },
      {
        "txt": "_numberLong = _numberBigDecimal.longValue(); } else { _throwInternal(); } _numTypesValid |= NR_LONG; } protected void convertNumberToBigInteger() throws IOException { if ((_numTypesValid & NR_BIGDECIMAL) != 0) { _numberBigInt = _numberBigDecimal.toBigInteger();"
      },
      {
        "txt": "} else if ((_numTypesValid & NR_LONG) != 0) { _numberBigInt = BigInteger.valueOf(_numberLong); } else if ((_numTypesValid & NR_INT) != 0) { _numberBigInt = BigInteger.valueOf(_numberInt); } else if ((_numTypesValid & NR_DOUBLE) != 0) { _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger(); } else { _throwInternal(); } _numTypesValid |= NR_BIGINT;"
      },
      {
        "txt": "} protected void convertNumberToDouble() throws IOException { if ((_numTypesValid & NR_BIGDECIMAL) != 0) { _numberDouble = _numberBigDecimal.doubleValue(); } else if ((_numTypesValid & NR_BIGINT) != 0) { _numberDouble = _numberBigInt.doubleValue(); } else if ((_numTypesValid & NR_LONG) != 0) { _numberDouble = (double) _numberLong; } else if ((_numTypesValid & NR_INT) != 0) {"
      },
      {
        "txt": "_numberDouble = (double) _numberInt; } else { _throwInternal(); } _numTypesValid |= NR_DOUBLE; } protected void convertNumberToBigDecimal() throws IOException { if ((_numTypesValid & NR_DOUBLE) != 0) { _numberBigDecimal = NumberInput.parseBigDecimal(getText());"
      },
      {
        "txt": "} else if ((_numTypesValid & NR_BIGINT) != 0) { _numberBigDecimal = new BigDecimal(_numberBigInt); } else if ((_numTypesValid & NR_LONG) != 0) { _numberBigDecimal = BigDecimal.valueOf(_numberLong); } else if ((_numTypesValid & NR_INT) != 0) { _numberBigDecimal = BigDecimal.valueOf(_numberInt); } else { _throwInternal(); } _numTypesValid |= NR_BIGDECIMAL;"
      },
      {
        "txt": "} protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException { JsonReadContext ctxt = getParsingContext(); _reportError(String.format( \"Unexpected close marker '%s': expected '%c' (for %s starting at %s)\", (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference()))); } @SuppressWarnings(\"deprecation\") protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {"
      },
      {
        "txt": "return ch; } if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return ch; } _reportError(\"Unrecognized character escape \"+_getCharDesc(ch)); return ch; } @SuppressWarnings(\"deprecation\") protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {"
      },
      {
        "txt": "if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) { char c = (char) i; String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc; _reportError(msg); } } protected char _decodeEscaped() throws IOException { throw new UnsupportedOperationException(); } protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException"
      },
      {
        "txt": "{ if (ch != '\\\\') { throw reportInvalidBase64Char(b64variant, ch, index); } int unescaped = _decodeEscaped(); if (unescaped <= INT_SPACE) { if (index == 0) { // whitespace only allowed to be skipped between triplets return -1; } }"
      },
      {
        "txt": "int bits = b64variant.decodeBase64Char(unescaped); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { throw reportInvalidBase64Char(b64variant, unescaped, index); } } return bits; } protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException {"
      },
      {
        "txt": "if (ch != '\\\\') { throw reportInvalidBase64Char(b64variant, ch, index); } char unescaped = _decodeEscaped(); if (unescaped <= INT_SPACE) { if (index == 0) { // whitespace only allowed to be skipped between triplets return -1; } } int bits = b64variant.decodeBase64Char(unescaped);"
      },
      {
        "txt": "if (bits < 0) { if ((bits != Base64Variant.BASE64_VALUE_PADDING) || (index < 2)) { throw reportInvalidBase64Char(b64variant, unescaped, index); } } return bits; } protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException { return reportInvalidBase64Char(b64variant, ch, bindex, null); }"
      },
      {
        "txt": "protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException { String base; if (ch <= INT_SPACE) { base = String.format(\"Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units\", Integer.toHexString(ch), (bindex+1)); } else if (b64variant.usesPaddingChar(ch)) { base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\"; } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } else {"
      },
      {
        "txt": "base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } if (msg != null) { base = base + \": \" + msg; } return new IllegalArgumentException(base); } protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException { _reportError(b64variant.missingPaddingMessage());"
      },
      {
        "txt": "} protected Object _getSourceReference() { if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) { return _ioContext.getSourceReference(); } return null; } protected static int[] growArrayBy(int[] arr, int more) { if (arr == null) {"
      },
      {
        "txt": "return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @Deprecated // since 2.8 protected void loadMoreGuaranteed() throws IOException { if (!loadMore()) { _reportInvalidEOF(); } } @Deprecated // since 2.8 protected boolean loadMore() throws IOException { return false; }"
      }
    ]
  },
  {
    "id": 1298,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
    "start-bug-line": 565,
    "end-bug-line": 566,
    "bug": "_reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));",
    "fix": "reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.IOException; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.exc.InputCoercionException; import com.fasterxml.jackson.core.io.JsonEOFException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.VersionUtil; import static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser {"
      },
      {
        "txt": "protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_APOS = '\\'';"
      },
      {
        "txt": "protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_ASTERISK = '*'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_0 = '0'; protected final static int INT_9 = '9'; protected final static int INT_MINUS = '-'; protected final static int INT_PLUS = '+';"
      },
      {
        "txt": "protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected final static char CHAR_NULL = '\\0'; protected final static byte[] NO_BYTES = new byte[0]; protected final static int[] NO_INTS = new int[0]; protected final static int NR_UNKNOWN = 0; protected final static int NR_INT = 0x0001; protected final static int NR_LONG = 0x0002; protected final static int NR_BIGINT = 0x0004;"
      },
      {
        "txt": "protected final static int NR_DOUBLE = 0x008; protected final static int NR_BIGDECIMAL = 0x0010; protected final static int NR_FLOAT = 0x020; protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE); protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE); protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE); protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG); protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG); protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);"
      },
      {
        "txt": "protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT); protected final static long MIN_INT_L = (long) Integer.MIN_VALUE; protected final static long MAX_INT_L = (long) Integer.MAX_VALUE; protected final static double MIN_LONG_D = (double) Long.MIN_VALUE; protected final static double MAX_LONG_D = (double) Long.MAX_VALUE; protected final static double MIN_INT_D = (double) Integer.MIN_VALUE; protected final static double MAX_INT_D = (double) Integer.MAX_VALUE; protected final static int MAX_ERROR_TOKEN_LENGTH = 256; protected JsonToken _currToken; protected JsonToken _lastClearedToken;"
      },
      {
        "txt": "protected ParserMinimalBase() { } protected ParserMinimalBase(int features) { super(features); } @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken() { return _currToken; } @Override public int currentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public JsonToken getCurrentToken() { return _currToken; } @Override public int getCurrentTokenId() {"
      },
      {
        "txt": "final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public boolean hasCurrentToken() { return _currToken != null; } @Override public boolean hasTokenId(int id) { final JsonToken t = _currToken; if (t == null) { return (JsonTokenId.ID_NO_TOKEN == id); } return t.id() == id;"
      },
      {
        "txt": "} @Override public boolean hasToken(JsonToken t) { return (_currToken == t); } @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; } @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; } @Override public JsonToken nextValue() throws IOException { JsonToken t = nextToken(); if (t == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "t = nextToken(); } return t; } @Override public JsonParser skipChildren() throws IOException { if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { return this;"
      },
      {
        "txt": "} int open = 1; while (true) { JsonToken t = nextToken(); if (t == null) { _handleEOF(); return this; } if (t.isStructStart()) { ++open;"
      },
      {
        "txt": "} else if (t.isStructEnd()) { if (--open == 0) { return this; } } else if (t == JsonToken.NOT_AVAILABLE) { _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\", getClass().getName()); } } }"
      },
      {
        "txt": "protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() { if (_currToken != null) { _lastClearedToken = _currToken; _currToken = null; }"
      },
      {
        "txt": "} @Override public JsonToken getLastClearedToken() { return _lastClearedToken; } @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override"
      },
      {
        "txt": "public boolean getValueAsBoolean(boolean defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText().trim(); if (\"true\".equals(str)) { return true; }"
      },
      {
        "txt": "if (\"false\".equals(str)) { return false; } if (_hasTextualNull(str)) { return false; } break; case ID_NUMBER_INT: return getIntValue() != 0; case ID_TRUE:"
      },
      {
        "txt": "return true; case ID_FALSE: case ID_NULL: return false; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Boolean) { return (Boolean) value; } break;"
      },
      {
        "txt": "default: } } return defaultValue; } @Override public int getValueAsInt() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {"
      },
      {
        "txt": "return getIntValue(); } return getValueAsInt(0); } @Override public int getValueAsInt(int defaultValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getIntValue();"
      },
      {
        "txt": "} if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0; } return NumberInput.parseAsInt(str, defaultValue); case ID_TRUE:"
      },
      {
        "txt": "return 1; case ID_FALSE: return 0; case ID_NULL: return 0; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).intValue(); }"
      },
      {
        "txt": "} } return defaultValue; } @Override public long getValueAsLong() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue();"
      },
      {
        "txt": "} return getValueAsLong(0L); } @Override public long getValueAsLong(long defaultValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue(); }"
      },
      {
        "txt": "if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsLong(str, defaultValue); case ID_TRUE: return 1L;"
      },
      {
        "txt": "case ID_FALSE: case ID_NULL: return 0L; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).longValue(); } } }"
      },
      {
        "txt": "return defaultValue; } @Override public double getValueAsDouble(double defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText();"
      },
      {
        "txt": "if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsDouble(str, defaultValue); case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return getDoubleValue(); case ID_TRUE: return 1.0; case ID_FALSE:"
      },
      {
        "txt": "case ID_NULL: return 0.0; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).doubleValue(); } } } return defaultValue;"
      },
      {
        "txt": "} @Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return getValueAsString(null);"
      },
      {
        "txt": "} @Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {"
      },
      {
        "txt": "return defaultValue; } return getText(); } protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException { try { b64variant.decode(str, builder); } catch (IllegalArgumentException e) { _reportError(e.getMessage());"
      },
      {
        "txt": "} } protected boolean _hasTextualNull(String value) { return \"null\".equals(value); } protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException { String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; } _reportError(msg); }"
      },
      {
        "txt": "_reportError(\"Invalid numeric value: \"+msg); } protected void reportOverflowInt() throws IOException { reportOverflowInt(getText()); } protected void reportOverflowInt(String numDesc) throws IOException { <extra_id_0> } protected void reportOverflowLong() throws IOException { reportOverflowLong(getText()); } protected void reportOverflowLong(String numDesc) throws IOException { _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\","
      },
      {
        "txt": "protected void reportOverflowLong(String numDesc) throws IOException { _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE)); } protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException { throw new InputCoercionException(this, msg, inputType, targetType); } protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length();"
      },
      {
        "txt": "if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[Integer with %d digits]\", rawLen); } protected String _longNumberDesc(String rawNum) { int rawLen = rawNum.length();"
      },
      {
        "txt": "if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[number with %d characters]\", rawLen); } protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException {"
      },
      {
        "txt": "if (ch < 0) { // sanity check _reportInvalidEOF(); } String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; } _reportError(msg); } protected void _reportInvalidEOF() throws JsonParseException {"
      },
      {
        "txt": "_reportInvalidEOF(\" in \"+_currToken, _currToken); } protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException { String msg; if (type == JsonToken.VALUE_STRING) { msg = \" in a String value\"; } else if ((type == JsonToken.VALUE_NUMBER_INT) || (type == JsonToken.VALUE_NUMBER_FLOAT)) { msg = \" in a Number value\"; } else {"
      },
      {
        "txt": "msg = \" in a value\"; } _reportInvalidEOF(msg, type); } protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException { throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg); } @Deprecated // since 2.8 protected void _reportInvalidEOFInValue() throws JsonParseException { _reportInvalidEOF(\" in a value\");"
      },
      {
        "txt": "} @Deprecated // since 2.8 protected void _reportInvalidEOF(String msg) throws JsonParseException { throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg); } protected void _reportMissingRootWS(int ch) throws JsonParseException { _reportUnexpectedChar(ch, \"Expected space separating root-level values\"); } protected void _throwInvalidSpace(int i) throws JsonParseException { char c = (char) i;"
      },
      {
        "txt": "String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\"; _reportError(msg); } protected final static String _getCharDesc(int ch) { char c = (char) ch; if (Character.isISOControl(c)) { return \"(CTRL-CHAR, code \"+ch+\")\"; } if (ch > 255) {"
      },
      {
        "txt": "return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\"; } return \"'\"+c+\"' (code \"+ch+\")\"; } protected final void _reportError(String msg) throws JsonParseException { throw _constructError(msg); } protected final void _reportError(String msg, Object arg) throws JsonParseException { throw _constructError(String.format(msg, arg)); }"
      },
      {
        "txt": "protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException { throw _constructError(String.format(msg, arg1, arg2)); } protected final void _wrapError(String msg, Throwable t) throws JsonParseException { throw _constructError(msg, t); } protected final void _throwInternal() { VersionUtil.throwInternal(); } protected final JsonParseException _constructError(String msg, Throwable t) {"
      },
      {
        "txt": "return new JsonParseException(this, msg, t); } protected static byte[] _asciiBytes(String str) { byte[] b = new byte[str.length()]; for (int i = 0, len = str.length(); i < len; ++i) { b[i] = (byte) str.charAt(i); } return b; } protected static String _ascii(byte[] b) {"
      },
      {
        "txt": "try { return new String(b, \"US-ASCII\"); } catch (IOException e) { // never occurs throw new RuntimeException(e); } }"
      }
    ]
  },
  {
    "id": 1299,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
    "start-bug-line": 570,
    "end-bug-line": 570,
    "bug": "",
    "fix": "protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE), inputType, Integer.TYPE); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.IOException; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.exc.InputCoercionException;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.io.JsonEOFException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.VersionUtil; import static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r';"
      },
      {
        "txt": "protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_APOS = '\\''; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_ASTERISK = '*';"
      },
      {
        "txt": "protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_0 = '0'; protected final static int INT_9 = '9'; protected final static int INT_MINUS = '-'; protected final static int INT_PLUS = '+'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E';"
      },
      {
        "txt": "protected final static char CHAR_NULL = '\\0'; protected final static byte[] NO_BYTES = new byte[0]; protected final static int[] NO_INTS = new int[0]; protected final static int NR_UNKNOWN = 0; protected final static int NR_INT = 0x0001; protected final static int NR_LONG = 0x0002; protected final static int NR_BIGINT = 0x0004; protected final static int NR_DOUBLE = 0x008; protected final static int NR_BIGDECIMAL = 0x0010; protected final static int NR_FLOAT = 0x020;"
      },
      {
        "txt": "protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE); protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE); protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE); protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG); protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG); protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT); protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT); protected final static long MIN_INT_L = (long) Integer.MIN_VALUE; protected final static long MAX_INT_L = (long) Integer.MAX_VALUE;"
      },
      {
        "txt": "protected final static double MIN_LONG_D = (double) Long.MIN_VALUE; protected final static double MAX_LONG_D = (double) Long.MAX_VALUE; protected final static double MIN_INT_D = (double) Integer.MIN_VALUE; protected final static double MAX_INT_D = (double) Integer.MAX_VALUE; protected final static int MAX_ERROR_TOKEN_LENGTH = 256; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { } protected ParserMinimalBase(int features) { super(features); } @Override public abstract JsonToken nextToken() throws IOException;"
      },
      {
        "txt": "@Override public JsonToken currentToken() { return _currToken; } @Override public int currentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public JsonToken getCurrentToken() { return _currToken; } @Override public int getCurrentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); }"
      },
      {
        "txt": "@Override public boolean hasCurrentToken() { return _currToken != null; } @Override public boolean hasTokenId(int id) { final JsonToken t = _currToken; if (t == null) { return (JsonTokenId.ID_NO_TOKEN == id); } return t.id() == id; } @Override public boolean hasToken(JsonToken t) { return (_currToken == t);"
      },
      {
        "txt": "} @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; } @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; } @Override public JsonToken nextValue() throws IOException { JsonToken t = nextToken(); if (t == JsonToken.FIELD_NAME) { t = nextToken(); } return t;"
      },
      {
        "txt": "} @Override public JsonParser skipChildren() throws IOException { if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { return this; } int open = 1; while (true) {"
      },
      {
        "txt": "JsonToken t = nextToken(); if (t == null) { _handleEOF(); return this; } if (t.isStructStart()) { ++open; } else if (t.isStructEnd()) { if (--open == 0) { return this;"
      },
      {
        "txt": "} } else if (t == JsonToken.NOT_AVAILABLE) { _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\", getClass().getName()); } } } protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException;"
      },
      {
        "txt": "@Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() { if (_currToken != null) { _lastClearedToken = _currToken; _currToken = null; } } @Override public JsonToken getLastClearedToken() { return _lastClearedToken; } @Override public abstract void overrideCurrentName(String name);"
      },
      {
        "txt": "@Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { JsonToken t = _currToken;"
      },
      {
        "txt": "if (t != null) { switch (t.id()) { case ID_STRING: String str = getText().trim(); if (\"true\".equals(str)) { return true; } if (\"false\".equals(str)) { return false; }"
      },
      {
        "txt": "if (_hasTextualNull(str)) { return false; } break; case ID_NUMBER_INT: return getIntValue() != 0; case ID_TRUE: return true; case ID_FALSE: case ID_NULL:"
      },
      {
        "txt": "return false; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Boolean) { return (Boolean) value; } break; default: } }"
      },
      {
        "txt": "return defaultValue; } @Override public int getValueAsInt() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getIntValue(); } return getValueAsInt(0);"
      },
      {
        "txt": "} @Override public int getValueAsInt(int defaultValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getIntValue(); } if (t != null) { switch (t.id()) {"
      },
      {
        "txt": "case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0; } return NumberInput.parseAsInt(str, defaultValue); case ID_TRUE: return 1; case ID_FALSE: return 0;"
      },
      {
        "txt": "case ID_NULL: return 0; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).intValue(); } } } return defaultValue;"
      },
      {
        "txt": "} @Override public long getValueAsLong() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue(); } return getValueAsLong(0L); }"
      },
      {
        "txt": "@Override public long getValueAsLong(long defaultValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue(); } if (t != null) { switch (t.id()) { case ID_STRING:"
      },
      {
        "txt": "String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsLong(str, defaultValue); case ID_TRUE: return 1L; case ID_FALSE: case ID_NULL: return 0L;"
      },
      {
        "txt": "case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).longValue(); } } } return defaultValue; } @Override"
      },
      {
        "txt": "public double getValueAsDouble(double defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; }"
      },
      {
        "txt": "return NumberInput.parseAsDouble(str, defaultValue); case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return getDoubleValue(); case ID_TRUE: return 1.0; case ID_FALSE: case ID_NULL: return 0.0; case ID_EMBEDDED_OBJECT:"
      },
      {
        "txt": "Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).doubleValue(); } } } return defaultValue; } @Override public String getValueAsString() throws IOException {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return getValueAsString(null); } @Override public String getValueAsString(String defaultValue) throws IOException {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; } return getText();"
      },
      {
        "txt": "} protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException { try { b64variant.decode(str, builder); } catch (IllegalArgumentException e) { _reportError(e.getMessage()); } } protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }"
      },
      {
        "txt": "protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException { String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; } _reportError(msg); } protected void reportInvalidNumber(String msg) throws JsonParseException { _reportError(\"Invalid numeric value: \"+msg); }"
      },
      {
        "txt": "reportOverflowInt(getText()); } protected void reportOverflowInt(String numDesc) throws IOException { _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE)); } <extra_id_0> protected void reportOverflowLong() throws IOException { reportOverflowLong(getText()); } protected void reportOverflowLong(String numDesc) throws IOException { _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));"
      },
      {
        "txt": "_reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE)); } protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException { throw new InputCoercionException(this, msg, inputType, targetType); } protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) {"
      },
      {
        "txt": "return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[Integer with %d digits]\", rawLen); } protected String _longNumberDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) {"
      },
      {
        "txt": "return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[number with %d characters]\", rawLen); } protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { if (ch < 0) { // sanity check"
      },
      {
        "txt": "_reportInvalidEOF(); } String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; } _reportError(msg); } protected void _reportInvalidEOF() throws JsonParseException { _reportInvalidEOF(\" in \"+_currToken, _currToken);"
      },
      {
        "txt": "} protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException { String msg; if (type == JsonToken.VALUE_STRING) { msg = \" in a String value\"; } else if ((type == JsonToken.VALUE_NUMBER_INT) || (type == JsonToken.VALUE_NUMBER_FLOAT)) { msg = \" in a Number value\"; } else { msg = \" in a value\";"
      },
      {
        "txt": "} _reportInvalidEOF(msg, type); } protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException { throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg); } @Deprecated // since 2.8 protected void _reportInvalidEOFInValue() throws JsonParseException { _reportInvalidEOF(\" in a value\"); }"
      },
      {
        "txt": "@Deprecated // since 2.8 protected void _reportInvalidEOF(String msg) throws JsonParseException { throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg); } protected void _reportMissingRootWS(int ch) throws JsonParseException { _reportUnexpectedChar(ch, \"Expected space separating root-level values\"); } protected void _throwInvalidSpace(int i) throws JsonParseException { char c = (char) i; String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";"
      },
      {
        "txt": "_reportError(msg); } protected final static String _getCharDesc(int ch) { char c = (char) ch; if (Character.isISOControl(c)) { return \"(CTRL-CHAR, code \"+ch+\")\"; } if (ch > 255) { return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";"
      },
      {
        "txt": "} return \"'\"+c+\"' (code \"+ch+\")\"; } protected final void _reportError(String msg) throws JsonParseException { throw _constructError(msg); } protected final void _reportError(String msg, Object arg) throws JsonParseException { throw _constructError(String.format(msg, arg)); } protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException {"
      },
      {
        "txt": "throw _constructError(String.format(msg, arg1, arg2)); } protected final void _wrapError(String msg, Throwable t) throws JsonParseException { throw _constructError(msg, t); } protected final void _throwInternal() { VersionUtil.throwInternal(); } protected final JsonParseException _constructError(String msg, Throwable t) { return new JsonParseException(this, msg, t);"
      },
      {
        "txt": "} protected static byte[] _asciiBytes(String str) { byte[] b = new byte[str.length()]; for (int i = 0, len = str.length(); i < len; ++i) { b[i] = (byte) str.charAt(i); } return b; } protected static String _ascii(byte[] b) { try {"
      },
      {
        "txt": "return new String(b, \"US-ASCII\"); } catch (IOException e) { // never occurs throw new RuntimeException(e); } }"
      }
    ]
  },
  {
    "id": 1300,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
    "start-bug-line": 582,
    "end-bug-line": 583,
    "bug": "_reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));",
    "fix": "reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.IOException; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.exc.InputCoercionException; import com.fasterxml.jackson.core.io.JsonEOFException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.VersionUtil;"
      },
      {
        "txt": "import static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{';"
      },
      {
        "txt": "protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_APOS = '\\''; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_ASTERISK = '*'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_0 = '0';"
      },
      {
        "txt": "protected final static int INT_9 = '9'; protected final static int INT_MINUS = '-'; protected final static int INT_PLUS = '+'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected final static char CHAR_NULL = '\\0'; protected final static byte[] NO_BYTES = new byte[0]; protected final static int[] NO_INTS = new int[0]; protected final static int NR_UNKNOWN = 0;"
      },
      {
        "txt": "protected final static int NR_INT = 0x0001; protected final static int NR_LONG = 0x0002; protected final static int NR_BIGINT = 0x0004; protected final static int NR_DOUBLE = 0x008; protected final static int NR_BIGDECIMAL = 0x0010; protected final static int NR_FLOAT = 0x020; protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE); protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE); protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);"
      },
      {
        "txt": "protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG); protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG); protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT); protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT); protected final static long MIN_INT_L = (long) Integer.MIN_VALUE; protected final static long MAX_INT_L = (long) Integer.MAX_VALUE; protected final static double MIN_LONG_D = (double) Long.MIN_VALUE; protected final static double MAX_LONG_D = (double) Long.MAX_VALUE; protected final static double MIN_INT_D = (double) Integer.MIN_VALUE; protected final static double MAX_INT_D = (double) Integer.MAX_VALUE;"
      },
      {
        "txt": "protected final static int MAX_ERROR_TOKEN_LENGTH = 256; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { } protected ParserMinimalBase(int features) { super(features); } @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken() { return _currToken; } @Override public int currentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();"
      },
      {
        "txt": "} @Override public JsonToken getCurrentToken() { return _currToken; } @Override public int getCurrentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public boolean hasCurrentToken() { return _currToken != null; } @Override public boolean hasTokenId(int id) { final JsonToken t = _currToken; if (t == null) {"
      },
      {
        "txt": "return (JsonTokenId.ID_NO_TOKEN == id); } return t.id() == id; } @Override public boolean hasToken(JsonToken t) { return (_currToken == t); } @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; } @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; } @Override"
      },
      {
        "txt": "public JsonToken nextValue() throws IOException { JsonToken t = nextToken(); if (t == JsonToken.FIELD_NAME) { t = nextToken(); } return t; } @Override public JsonParser skipChildren() throws IOException {"
      },
      {
        "txt": "if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { return this; } int open = 1; while (true) { JsonToken t = nextToken(); if (t == null) { _handleEOF(); return this;"
      },
      {
        "txt": "} if (t.isStructStart()) { ++open; } else if (t.isStructEnd()) { if (--open == 0) { return this; } } else if (t == JsonToken.NOT_AVAILABLE) { _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\", getClass().getName());"
      },
      {
        "txt": "} } } protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() { if (_currToken != null) {"
      },
      {
        "txt": "_lastClearedToken = _currToken; _currToken = null; } } @Override public JsonToken getLastClearedToken() { return _lastClearedToken; } @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException;"
      },
      {
        "txt": "@Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText().trim();"
      },
      {
        "txt": "if (\"true\".equals(str)) { return true; } if (\"false\".equals(str)) { return false; } if (_hasTextualNull(str)) { return false; } break;"
      },
      {
        "txt": "case ID_NUMBER_INT: return getIntValue() != 0; case ID_TRUE: return true; case ID_FALSE: case ID_NULL: return false; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Boolean) {"
      },
      {
        "txt": "return (Boolean) value; } break; default: } } return defaultValue; } @Override public int getValueAsInt() throws IOException"
      },
      {
        "txt": "{ JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getIntValue(); } return getValueAsInt(0); } @Override public int getValueAsInt(int defaultValue) throws IOException {"
      },
      {
        "txt": "JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getIntValue(); } if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0;"
      },
      {
        "txt": "} return NumberInput.parseAsInt(str, defaultValue); case ID_TRUE: return 1; case ID_FALSE: return 0; case ID_NULL: return 0; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject();"
      },
      {
        "txt": "if (value instanceof Number) { return ((Number) value).intValue(); } } } return defaultValue; } @Override public long getValueAsLong() throws IOException {"
      },
      {
        "txt": "JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue(); } return getValueAsLong(0L); } @Override public long getValueAsLong(long defaultValue) throws IOException { JsonToken t = _currToken;"
      },
      {
        "txt": "if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue(); } if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; }"
      },
      {
        "txt": "return NumberInput.parseAsLong(str, defaultValue); case ID_TRUE: return 1L; case ID_FALSE: case ID_NULL: return 0L; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).longValue();"
      },
      {
        "txt": "} } } return defaultValue; } @Override public double getValueAsDouble(double defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) {"
      },
      {
        "txt": "switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsDouble(str, defaultValue); case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return getDoubleValue();"
      },
      {
        "txt": "case ID_TRUE: return 1.0; case ID_FALSE: case ID_NULL: return 0.0; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).doubleValue(); }"
      },
      {
        "txt": "} } return defaultValue; } @Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return getCurrentName(); } return getValueAsString(null); } @Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; } return getText(); } protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException { try {"
      },
      {
        "txt": "b64variant.decode(str, builder); } catch (IllegalArgumentException e) { _reportError(e.getMessage()); } } protected boolean _hasTextualNull(String value) { return \"null\".equals(value); } protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException { String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment;"
      },
      {
        "txt": "} _reportError(msg); } protected void reportInvalidNumber(String msg) throws JsonParseException { _reportError(\"Invalid numeric value: \"+msg); } protected void reportOverflowInt() throws IOException { reportOverflowInt(getText()); } protected void reportOverflowInt(String numDesc) throws IOException {"
      },
      {
        "txt": "_longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE)); } protected void reportOverflowLong() throws IOException { reportOverflowLong(getText()); } protected void reportOverflowLong(String numDesc) throws IOException { <extra_id_0> } protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException { throw new InputCoercionException(this, msg, inputType, targetType); } protected String _longIntegerDesc(String rawNum) {"
      },
      {
        "txt": "} protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[Integer with %d digits]\", rawLen);"
      },
      {
        "txt": "} protected String _longNumberDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[number with %d characters]\", rawLen);"
      },
      {
        "txt": "} protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { if (ch < 0) { // sanity check _reportInvalidEOF(); } String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; }"
      },
      {
        "txt": "_reportError(msg); } protected void _reportInvalidEOF() throws JsonParseException { _reportInvalidEOF(\" in \"+_currToken, _currToken); } protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException { String msg; if (type == JsonToken.VALUE_STRING) { msg = \" in a String value\"; } else if ((type == JsonToken.VALUE_NUMBER_INT)"
      },
      {
        "txt": "|| (type == JsonToken.VALUE_NUMBER_FLOAT)) { msg = \" in a Number value\"; } else { msg = \" in a value\"; } _reportInvalidEOF(msg, type); } protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException { throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg); }"
      },
      {
        "txt": "@Deprecated // since 2.8 protected void _reportInvalidEOFInValue() throws JsonParseException { _reportInvalidEOF(\" in a value\"); } @Deprecated // since 2.8 protected void _reportInvalidEOF(String msg) throws JsonParseException { throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg); } protected void _reportMissingRootWS(int ch) throws JsonParseException { _reportUnexpectedChar(ch, \"Expected space separating root-level values\");"
      },
      {
        "txt": "} protected void _throwInvalidSpace(int i) throws JsonParseException { char c = (char) i; String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\"; _reportError(msg); } protected final static String _getCharDesc(int ch) { char c = (char) ch; if (Character.isISOControl(c)) {"
      },
      {
        "txt": "return \"(CTRL-CHAR, code \"+ch+\")\"; } if (ch > 255) { return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\"; } return \"'\"+c+\"' (code \"+ch+\")\"; } protected final void _reportError(String msg) throws JsonParseException { throw _constructError(msg); }"
      },
      {
        "txt": "protected final void _reportError(String msg, Object arg) throws JsonParseException { throw _constructError(String.format(msg, arg)); } protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException { throw _constructError(String.format(msg, arg1, arg2)); } protected final void _wrapError(String msg, Throwable t) throws JsonParseException { throw _constructError(msg, t); } protected final void _throwInternal() {"
      },
      {
        "txt": "VersionUtil.throwInternal(); } protected final JsonParseException _constructError(String msg, Throwable t) { return new JsonParseException(this, msg, t); } protected static byte[] _asciiBytes(String str) { byte[] b = new byte[str.length()]; for (int i = 0, len = str.length(); i < len; ++i) { b[i] = (byte) str.charAt(i); }"
      },
      {
        "txt": "return b; } protected static String _ascii(byte[] b) { try { return new String(b, \"US-ASCII\"); } catch (IOException e) { // never occurs throw new RuntimeException(e); } }"
      }
    ]
  },
  {
    "id": 1301,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
    "start-bug-line": 587,
    "end-bug-line": 587,
    "bug": "",
    "fix": "protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException { _reportInputCoercion(String.format(\"Numeric value (%s) out of range of long (%d - %s)\", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE), inputType, Long.TYPE); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.IOException; import java.math.BigDecimal;"
      },
      {
        "txt": "import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.exc.InputCoercionException; import com.fasterxml.jackson.core.io.JsonEOFException; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.VersionUtil; import static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser {"
      },
      {
        "txt": "protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_APOS = '\\'';"
      },
      {
        "txt": "protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_ASTERISK = '*'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_0 = '0'; protected final static int INT_9 = '9'; protected final static int INT_MINUS = '-'; protected final static int INT_PLUS = '+';"
      },
      {
        "txt": "protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected final static char CHAR_NULL = '\\0'; protected final static byte[] NO_BYTES = new byte[0]; protected final static int[] NO_INTS = new int[0]; protected final static int NR_UNKNOWN = 0; protected final static int NR_INT = 0x0001; protected final static int NR_LONG = 0x0002; protected final static int NR_BIGINT = 0x0004;"
      },
      {
        "txt": "protected final static int NR_DOUBLE = 0x008; protected final static int NR_BIGDECIMAL = 0x0010; protected final static int NR_FLOAT = 0x020; protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE); protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE); protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE); protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG); protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG); protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);"
      },
      {
        "txt": "protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT); protected final static long MIN_INT_L = (long) Integer.MIN_VALUE; protected final static long MAX_INT_L = (long) Integer.MAX_VALUE; protected final static double MIN_LONG_D = (double) Long.MIN_VALUE; protected final static double MAX_LONG_D = (double) Long.MAX_VALUE; protected final static double MIN_INT_D = (double) Integer.MIN_VALUE; protected final static double MAX_INT_D = (double) Integer.MAX_VALUE; protected final static int MAX_ERROR_TOKEN_LENGTH = 256; protected JsonToken _currToken; protected JsonToken _lastClearedToken;"
      },
      {
        "txt": "protected ParserMinimalBase() { } protected ParserMinimalBase(int features) { super(features); } @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken currentToken() { return _currToken; } @Override public int currentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public JsonToken getCurrentToken() { return _currToken; } @Override public int getCurrentTokenId() {"
      },
      {
        "txt": "final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public boolean hasCurrentToken() { return _currToken != null; } @Override public boolean hasTokenId(int id) { final JsonToken t = _currToken; if (t == null) { return (JsonTokenId.ID_NO_TOKEN == id); } return t.id() == id;"
      },
      {
        "txt": "} @Override public boolean hasToken(JsonToken t) { return (_currToken == t); } @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; } @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; } @Override public JsonToken nextValue() throws IOException { JsonToken t = nextToken(); if (t == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "t = nextToken(); } return t; } @Override public JsonParser skipChildren() throws IOException { if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { return this;"
      },
      {
        "txt": "} int open = 1; while (true) { JsonToken t = nextToken(); if (t == null) { _handleEOF(); return this; } if (t.isStructStart()) { ++open;"
      },
      {
        "txt": "} else if (t.isStructEnd()) { if (--open == 0) { return this; } } else if (t == JsonToken.NOT_AVAILABLE) { _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\", getClass().getName()); } } }"
      },
      {
        "txt": "protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() { if (_currToken != null) { _lastClearedToken = _currToken; _currToken = null; }"
      },
      {
        "txt": "} @Override public JsonToken getLastClearedToken() { return _lastClearedToken; } @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override"
      },
      {
        "txt": "public boolean getValueAsBoolean(boolean defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText().trim(); if (\"true\".equals(str)) { return true; }"
      },
      {
        "txt": "if (\"false\".equals(str)) { return false; } if (_hasTextualNull(str)) { return false; } break; case ID_NUMBER_INT: return getIntValue() != 0; case ID_TRUE:"
      },
      {
        "txt": "return true; case ID_FALSE: case ID_NULL: return false; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Boolean) { return (Boolean) value; } break;"
      },
      {
        "txt": "default: } } return defaultValue; } @Override public int getValueAsInt() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {"
      },
      {
        "txt": "return getIntValue(); } return getValueAsInt(0); } @Override public int getValueAsInt(int defaultValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getIntValue();"
      },
      {
        "txt": "} if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0; } return NumberInput.parseAsInt(str, defaultValue); case ID_TRUE:"
      },
      {
        "txt": "return 1; case ID_FALSE: return 0; case ID_NULL: return 0; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).intValue(); }"
      },
      {
        "txt": "} } return defaultValue; } @Override public long getValueAsLong() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue();"
      },
      {
        "txt": "} return getValueAsLong(0L); } @Override public long getValueAsLong(long defaultValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { return getLongValue(); }"
      },
      {
        "txt": "if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsLong(str, defaultValue); case ID_TRUE: return 1L;"
      },
      {
        "txt": "case ID_FALSE: case ID_NULL: return 0L; case ID_EMBEDDED_OBJECT: Object value = getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).longValue(); } } }"
      },
      {
        "txt": "return defaultValue; } @Override public double getValueAsDouble(double defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText();"
      },
      {
        "txt": "if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsDouble(str, defaultValue); case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return getDoubleValue(); case ID_TRUE: return 1.0; case ID_FALSE:"
      },
      {
        "txt": "case ID_NULL: return 0.0; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).doubleValue(); } } } return defaultValue;"
      },
      {
        "txt": "} @Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return getValueAsString(null);"
      },
      {
        "txt": "} @Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {"
      },
      {
        "txt": "return defaultValue; } return getText(); } protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException { try { b64variant.decode(str, builder); } catch (IllegalArgumentException e) { _reportError(e.getMessage());"
      },
      {
        "txt": "} } protected boolean _hasTextualNull(String value) { return \"null\".equals(value); } protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException { String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; } _reportError(msg); }"
      },
      {
        "txt": "protected void reportInvalidNumber(String msg) throws JsonParseException { _reportError(\"Invalid numeric value: \"+msg); } protected void reportOverflowInt() throws IOException { reportOverflowInt(getText()); } protected void reportOverflowInt(String numDesc) throws IOException { _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\", _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE)); }"
      },
      {
        "txt": "reportOverflowLong(getText()); } protected void reportOverflowLong(String numDesc) throws IOException { _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\", _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE)); } <extra_id_0> protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType) throws InputCoercionException { throw new InputCoercionException(this, msg, inputType, targetType); } protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length();"
      },
      {
        "txt": "protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[Integer with %d digits]\", rawLen); }"
      },
      {
        "txt": "protected String _longNumberDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith(\"-\")) { rawLen -= 1; } return String.format(\"[number with %d characters]\", rawLen); }"
      },
      {
        "txt": "protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { if (ch < 0) { // sanity check _reportInvalidEOF(); } String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch)); if (comment != null) { msg += \": \"+comment; } _reportError(msg);"
      },
      {
        "txt": "} protected void _reportInvalidEOF() throws JsonParseException { _reportInvalidEOF(\" in \"+_currToken, _currToken); } protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException { String msg; if (type == JsonToken.VALUE_STRING) { msg = \" in a String value\"; } else if ((type == JsonToken.VALUE_NUMBER_INT) || (type == JsonToken.VALUE_NUMBER_FLOAT)) {"
      },
      {
        "txt": "msg = \" in a Number value\"; } else { msg = \" in a value\"; } _reportInvalidEOF(msg, type); } protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException { throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg); } @Deprecated // since 2.8"
      },
      {
        "txt": "protected void _reportInvalidEOFInValue() throws JsonParseException { _reportInvalidEOF(\" in a value\"); } @Deprecated // since 2.8 protected void _reportInvalidEOF(String msg) throws JsonParseException { throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg); } protected void _reportMissingRootWS(int ch) throws JsonParseException { _reportUnexpectedChar(ch, \"Expected space separating root-level values\"); }"
      },
      {
        "txt": "protected void _throwInvalidSpace(int i) throws JsonParseException { char c = (char) i; String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\"; _reportError(msg); } protected final static String _getCharDesc(int ch) { char c = (char) ch; if (Character.isISOControl(c)) { return \"(CTRL-CHAR, code \"+ch+\")\";"
      },
      {
        "txt": "} if (ch > 255) { return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\"; } return \"'\"+c+\"' (code \"+ch+\")\"; } protected final void _reportError(String msg) throws JsonParseException { throw _constructError(msg); } protected final void _reportError(String msg, Object arg) throws JsonParseException {"
      },
      {
        "txt": "throw _constructError(String.format(msg, arg)); } protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException { throw _constructError(String.format(msg, arg1, arg2)); } protected final void _wrapError(String msg, Throwable t) throws JsonParseException { throw _constructError(msg, t); } protected final void _throwInternal() { VersionUtil.throwInternal();"
      },
      {
        "txt": "} protected final JsonParseException _constructError(String msg, Throwable t) { return new JsonParseException(this, msg, t); } protected static byte[] _asciiBytes(String str) { byte[] b = new byte[str.length()]; for (int i = 0, len = str.length(); i < len; ++i) { b[i] = (byte) str.charAt(i); } return b;"
      },
      {
        "txt": "} protected static String _ascii(byte[] b) { try { return new String(b, \"US-ASCII\"); } catch (IOException e) { // never occurs throw new RuntimeException(e); } }"
      }
    ]
  }
]