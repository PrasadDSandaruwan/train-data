[
  {
    "id": 1275,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
    "start-bug-line": 53,
    "end-bug-line": 53,
    "bug": "",
    "fix": "protected final static int MAX_BIG_DECIMAL_SCALE = 9999;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.*; import java.math.BigDecimal; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.json.DupDetector; import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.DefaultPrettyPrinter; import com.fasterxml.jackson.core.util.VersionUtil;"
      },
      {
        "txt": "public abstract class GeneratorBase extends JsonGenerator { public final static int SURR1_FIRST = 0xD800; public final static int SURR1_LAST = 0xDBFF; public final static int SURR2_FIRST = 0xDC00; public final static int SURR2_LAST = 0xDFFF; protected final static int DERIVED_FEATURES_MASK = Feature.WRITE_NUMBERS_AS_STRINGS.getMask() | Feature.ESCAPE_NON_ASCII.getMask() | Feature.STRICT_DUPLICATE_DETECTION.getMask()"
      },
      {
        "txt": "protected final static String WRITE_BINARY = \"write a binary value\"; protected final static String WRITE_BOOLEAN = \"write a boolean value\"; protected final static String WRITE_NULL = \"write a null\"; protected final static String WRITE_NUMBER = \"write a number\"; protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\"; <extra_id_0> protected ObjectCodec _objectCodec; protected int _features; protected boolean _cfgNumbersAsStrings; protected JsonWriteContext _writeContext; protected boolean _closed; protected GeneratorBase(int features, ObjectCodec codec) {"
      },
      {
        "txt": "protected boolean _closed; protected GeneratorBase(int features, ObjectCodec codec) { super(); _features = features; _objectCodec = codec; DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features) ? DupDetector.rootDetector(this) : null; _writeContext = JsonWriteContext.createRootContext(dups); _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features); }"
      },
      {
        "txt": "protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) { super(); _features = features; _objectCodec = codec; _writeContext = ctxt; _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features); } @Override public Version version() { return VersionUtil.versionFor(getClass()); } @Override public Object getCurrentValue() {"
      },
      {
        "txt": "return _writeContext.getCurrentValue(); } @Override public void setCurrentValue(Object v) { _writeContext.setCurrentValue(v); } @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; } @Override public int getFeatureMask() { return _features; } @Override public JsonGenerator enable(Feature f) {"
      },
      {
        "txt": "final int mask = f.getMask(); _features |= mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = true; } else if (f == Feature.ESCAPE_NON_ASCII) { setHighestNonEscapedChar(127); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { if (_writeContext.getDupDetector() == null) { // but only if disabled currently _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));"
      },
      {
        "txt": "} } } return this; } @Override public JsonGenerator disable(Feature f) { final int mask = f.getMask(); _features &= ~mask; if ((mask & DERIVED_FEATURES_MASK) != 0) {"
      },
      {
        "txt": "if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = false; } else if (f == Feature.ESCAPE_NON_ASCII) { setHighestNonEscapedChar(0); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { _writeContext = _writeContext.withDupDetector(null); } } return this; }"
      },
      {
        "txt": "@Override @Deprecated public JsonGenerator setFeatureMask(int newMask) { int changed = newMask ^ _features; _features = newMask; if (changed != 0) { _checkStdFeatureChanges(newMask, changed); } return this; }"
      },
      {
        "txt": "@Override // since 2.7 public JsonGenerator overrideStdFeatures(int values, int mask) { int oldState = _features; int newState = (oldState & ~mask) | (values & mask); int changed = oldState ^ newState; if (changed != 0) { _features = newState; _checkStdFeatureChanges(newState, changed); } return this;"
      },
      {
        "txt": "} protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) { if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) { return; } _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags); if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) { if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) { setHighestNonEscapedChar(127);"
      },
      {
        "txt": "} else { setHighestNonEscapedChar(0); } } if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) { if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling if (_writeContext.getDupDetector() == null) { // but only if disabled currently _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this)); } } else { // disabling"
      },
      {
        "txt": "_writeContext = _writeContext.withDupDetector(null); } } } @Override public JsonGenerator useDefaultPrettyPrinter() { if (getPrettyPrinter() != null) { return this; } return setPrettyPrinter(_constructDefaultPrettyPrinter()); }"
      },
      {
        "txt": "@Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public JsonWriteContext getOutputContext() { return _writeContext; } @Override public void writeFieldName(SerializableString name) throws IOException { writeFieldName(name.getValue()); } @Override"
      },
      {
        "txt": "public void writeString(SerializableString text) throws IOException { writeString(text.getValue()); } @Override public void writeRawValue(String text) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text); } @Override public void writeRawValue(String text, int offset, int len) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text, offset, len);"
      },
      {
        "txt": "} @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text, offset, len); } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text); } @Override"
      },
      {
        "txt": "public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { _reportUnsupportedOperation(); return 0; } public abstract void writeNumber(int i) public abstract void writeNumber(long l) public abstract void writeNumber(double d) public abstract void writeNumber(float f) public abstract void writeNumber(BigDecimal dec) public abstract void writeBoolean(boolean state)"
      },
      {
        "txt": "public abstract void writeNull() @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); } else { if (_objectCodec != null) { _objectCodec.writeValue(this, value); return; }"
      },
      {
        "txt": "_writeSimpleObject(value); } } @Override public void writeTree(TreeNode rootNode) throws IOException { if (rootNode == null) { writeNull(); } else { if (_objectCodec == null) { throw new IllegalStateException(\"No ObjectCodec defined\");"
      },
      {
        "txt": "} _objectCodec.writeValue(this, rootNode); } } @Override public abstract void flush() throws IOException; @Override public void close() throws IOException { _closed = true; } @Override public boolean isClosed() { return _closed; } protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter() {"
      },
      {
        "txt": "return new DefaultPrettyPrinter(); } protected String _asString(BigDecimal value) throws IOException { return value.toString(); } protected final int _decodeSurrogate(int surr1, int surr2) throws IOException { if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) { String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2); _reportError(msg);"
      },
      {
        "txt": "} int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST); return c; }"
      }
    ]
  },
  {
    "id": 1276,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
    "start-bug-line": 434,
    "end-bug-line": 434,
    "bug": "",
    "fix": "if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.*; import java.math.BigDecimal; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.json.DupDetector;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.DefaultPrettyPrinter; import com.fasterxml.jackson.core.util.VersionUtil; public abstract class GeneratorBase extends JsonGenerator { public final static int SURR1_FIRST = 0xD800; public final static int SURR1_LAST = 0xDBFF; public final static int SURR2_FIRST = 0xDC00; public final static int SURR2_LAST = 0xDFFF; protected final static int DERIVED_FEATURES_MASK ="
      },
      {
        "txt": "Feature.WRITE_NUMBERS_AS_STRINGS.getMask() | Feature.ESCAPE_NON_ASCII.getMask() | Feature.STRICT_DUPLICATE_DETECTION.getMask() ; protected final static String WRITE_BINARY = \"write a binary value\"; protected final static String WRITE_BOOLEAN = \"write a boolean value\"; protected final static String WRITE_NULL = \"write a null\"; protected final static String WRITE_NUMBER = \"write a number\"; protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\";"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _features; protected boolean _cfgNumbersAsStrings; protected JsonWriteContext _writeContext; protected boolean _closed; protected GeneratorBase(int features, ObjectCodec codec) { super(); _features = features; _objectCodec = codec; DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)"
      },
      {
        "txt": "? DupDetector.rootDetector(this) : null; _writeContext = JsonWriteContext.createRootContext(dups); _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features); } protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) { super(); _features = features; _objectCodec = codec; _writeContext = ctxt; _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);"
      },
      {
        "txt": "} @Override public Version version() { return VersionUtil.versionFor(getClass()); } @Override public Object getCurrentValue() { return _writeContext.getCurrentValue(); } @Override public void setCurrentValue(Object v) { _writeContext.setCurrentValue(v); }"
      },
      {
        "txt": "@Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; } @Override public int getFeatureMask() { return _features; } @Override public JsonGenerator enable(Feature f) { final int mask = f.getMask(); _features |= mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = true; } else if (f == Feature.ESCAPE_NON_ASCII) {"
      },
      {
        "txt": "setHighestNonEscapedChar(127); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { if (_writeContext.getDupDetector() == null) { // but only if disabled currently _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this)); } } } return this; } @Override"
      },
      {
        "txt": "public JsonGenerator disable(Feature f) { final int mask = f.getMask(); _features &= ~mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = false; } else if (f == Feature.ESCAPE_NON_ASCII) { setHighestNonEscapedChar(0); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { _writeContext = _writeContext.withDupDetector(null);"
      },
      {
        "txt": "} } return this; } @Override @Deprecated public JsonGenerator setFeatureMask(int newMask) { int changed = newMask ^ _features; _features = newMask; if (changed != 0) {"
      },
      {
        "txt": "_checkStdFeatureChanges(newMask, changed); } return this; } @Override // since 2.7 public JsonGenerator overrideStdFeatures(int values, int mask) { int oldState = _features; int newState = (oldState & ~mask) | (values & mask); int changed = oldState ^ newState; if (changed != 0) {"
      },
      {
        "txt": "_features = newState; _checkStdFeatureChanges(newState, changed); } return this; } protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) { if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) { return; }"
      },
      {
        "txt": "_cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags); if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) { if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) { setHighestNonEscapedChar(127); } else { setHighestNonEscapedChar(0); } } if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) { if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling"
      },
      {
        "txt": "if (_writeContext.getDupDetector() == null) { // but only if disabled currently _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this)); } } else { // disabling _writeContext = _writeContext.withDupDetector(null); } } } @Override public JsonGenerator useDefaultPrettyPrinter() { if (getPrettyPrinter() != null) {"
      },
      {
        "txt": "return this; } return setPrettyPrinter(_constructDefaultPrettyPrinter()); } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public JsonWriteContext getOutputContext() { return _writeContext; }"
      },
      {
        "txt": "@Override public void writeFieldName(SerializableString name) throws IOException { writeFieldName(name.getValue()); } @Override public void writeString(SerializableString text) throws IOException { writeString(text.getValue()); } @Override public void writeRawValue(String text) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text);"
      },
      {
        "txt": "} @Override public void writeRawValue(String text, int offset, int len) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text, offset, len); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text, offset, len); } @Override public void writeRawValue(SerializableString text) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(\"write raw value\"); writeRaw(text); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { _reportUnsupportedOperation(); return 0; } public abstract void writeNumber(int i) public abstract void writeNumber(long l)"
      },
      {
        "txt": "public abstract void writeNumber(double d) public abstract void writeNumber(float f) public abstract void writeNumber(BigDecimal dec) public abstract void writeBoolean(boolean state) public abstract void writeNull() @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); } else {"
      },
      {
        "txt": "if (_objectCodec != null) { _objectCodec.writeValue(this, value); return; } _writeSimpleObject(value); } } @Override public void writeTree(TreeNode rootNode) throws IOException { if (rootNode == null) {"
      },
      {
        "txt": "writeNull(); } else { if (_objectCodec == null) { throw new IllegalStateException(\"No ObjectCodec defined\"); } _objectCodec.writeValue(this, rootNode); } } @Override public abstract void flush() throws IOException; @Override public void close() throws IOException { _closed = true; }"
      },
      {
        "txt": "protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter() { return new DefaultPrettyPrinter(); } protected String _asString(BigDecimal value) throws IOException { <extra_id_0> return value.toString(); } protected final int _decodeSurrogate(int surr1, int surr2) throws IOException { if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) { String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);"
      },
      {
        "txt": "if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) { String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2); _reportError(msg); } int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST); return c; }"
      }
    ]
  },
  {
    "id": 1277,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java",
    "start-bug-line": 435,
    "end-bug-line": 435,
    "bug": "",
    "fix": "int scale = value.scale(); if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) { _reportError(String.format( \"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\", scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE)); } return value.toPlainString(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.*; import java.math.BigDecimal; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.json.DupDetector;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.json.JsonWriteContext; import com.fasterxml.jackson.core.util.DefaultPrettyPrinter; import com.fasterxml.jackson.core.util.VersionUtil; public abstract class GeneratorBase extends JsonGenerator { public final static int SURR1_FIRST = 0xD800; public final static int SURR1_LAST = 0xDBFF; public final static int SURR2_FIRST = 0xDC00; public final static int SURR2_LAST = 0xDFFF; protected final static int DERIVED_FEATURES_MASK ="
      },
      {
        "txt": "Feature.WRITE_NUMBERS_AS_STRINGS.getMask() | Feature.ESCAPE_NON_ASCII.getMask() | Feature.STRICT_DUPLICATE_DETECTION.getMask() ; protected final static String WRITE_BINARY = \"write a binary value\"; protected final static String WRITE_BOOLEAN = \"write a boolean value\"; protected final static String WRITE_NULL = \"write a null\"; protected final static String WRITE_NUMBER = \"write a number\"; protected final static String WRITE_RAW = \"write a raw (unencoded) value\"; protected final static String WRITE_STRING = \"write a string\";"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; protected int _features; protected boolean _cfgNumbersAsStrings; protected JsonWriteContext _writeContext; protected boolean _closed; protected GeneratorBase(int features, ObjectCodec codec) { super(); _features = features; _objectCodec = codec; DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)"
      },
      {
        "txt": "? DupDetector.rootDetector(this) : null; _writeContext = JsonWriteContext.createRootContext(dups); _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features); } protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) { super(); _features = features; _objectCodec = codec; _writeContext = ctxt; _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);"
      },
      {
        "txt": "} @Override public Version version() { return VersionUtil.versionFor(getClass()); } @Override public Object getCurrentValue() { return _writeContext.getCurrentValue(); } @Override public void setCurrentValue(Object v) { _writeContext.setCurrentValue(v); }"
      },
      {
        "txt": "@Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; } @Override public int getFeatureMask() { return _features; } @Override public JsonGenerator enable(Feature f) { final int mask = f.getMask(); _features |= mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = true; } else if (f == Feature.ESCAPE_NON_ASCII) {"
      },
      {
        "txt": "setHighestNonEscapedChar(127); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { if (_writeContext.getDupDetector() == null) { // but only if disabled currently _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this)); } } } return this; } @Override"
      },
      {
        "txt": "public JsonGenerator disable(Feature f) { final int mask = f.getMask(); _features &= ~mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = false; } else if (f == Feature.ESCAPE_NON_ASCII) { setHighestNonEscapedChar(0); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { _writeContext = _writeContext.withDupDetector(null);"
      },
      {
        "txt": "} } return this; } @Override @Deprecated public JsonGenerator setFeatureMask(int newMask) { int changed = newMask ^ _features; _features = newMask; if (changed != 0) {"
      },
      {
        "txt": "_checkStdFeatureChanges(newMask, changed); } return this; } @Override // since 2.7 public JsonGenerator overrideStdFeatures(int values, int mask) { int oldState = _features; int newState = (oldState & ~mask) | (values & mask); int changed = oldState ^ newState; if (changed != 0) {"
      },
      {
        "txt": "_features = newState; _checkStdFeatureChanges(newState, changed); } return this; } protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) { if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) { return; }"
      },
      {
        "txt": "_cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags); if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) { if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) { setHighestNonEscapedChar(127); } else { setHighestNonEscapedChar(0); } } if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) { if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling"
      },
      {
        "txt": "if (_writeContext.getDupDetector() == null) { // but only if disabled currently _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this)); } } else { // disabling _writeContext = _writeContext.withDupDetector(null); } } } @Override public JsonGenerator useDefaultPrettyPrinter() { if (getPrettyPrinter() != null) {"
      },
      {
        "txt": "return this; } return setPrettyPrinter(_constructDefaultPrettyPrinter()); } @Override public JsonGenerator setCodec(ObjectCodec oc) { _objectCodec = oc; return this; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public JsonWriteContext getOutputContext() { return _writeContext; }"
      },
      {
        "txt": "@Override public void writeFieldName(SerializableString name) throws IOException { writeFieldName(name.getValue()); } @Override public void writeString(SerializableString text) throws IOException { writeString(text.getValue()); } @Override public void writeRawValue(String text) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text);"
      },
      {
        "txt": "} @Override public void writeRawValue(String text, int offset, int len) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text, offset, len); } @Override public void writeRawValue(char[] text, int offset, int len) throws IOException { _verifyValueWrite(\"write raw value\"); writeRaw(text, offset, len); } @Override public void writeRawValue(SerializableString text) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(\"write raw value\"); writeRaw(text); } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { _reportUnsupportedOperation(); return 0; } public abstract void writeNumber(int i) public abstract void writeNumber(long l)"
      },
      {
        "txt": "public abstract void writeNumber(double d) public abstract void writeNumber(float f) public abstract void writeNumber(BigDecimal dec) public abstract void writeBoolean(boolean state) public abstract void writeNull() @Override public void writeObject(Object value) throws IOException { if (value == null) { writeNull(); } else {"
      },
      {
        "txt": "if (_objectCodec != null) { _objectCodec.writeValue(this, value); return; } _writeSimpleObject(value); } } @Override public void writeTree(TreeNode rootNode) throws IOException { if (rootNode == null) {"
      },
      {
        "txt": "writeNull(); } else { if (_objectCodec == null) { throw new IllegalStateException(\"No ObjectCodec defined\"); } _objectCodec.writeValue(this, rootNode); } } @Override public abstract void flush() throws IOException; @Override public void close() throws IOException { _closed = true; }"
      },
      {
        "txt": "protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException; protected PrettyPrinter _constructDefaultPrettyPrinter() { return new DefaultPrettyPrinter(); } protected String _asString(BigDecimal value) throws IOException { <extra_id_0> } protected final int _decodeSurrogate(int surr1, int surr2) throws IOException { if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) { String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2); _reportError(msg);"
      },
      {
        "txt": "String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2); _reportError(msg); } int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST); return c; }"
      }
    ]
  },
  {
    "id": 1278,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 910,
    "end-bug-line": 913,
    "bug": "String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString());",
    "fix": "_writeQuotedRaw(_asString(value));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator"
      },
      {
        "txt": "extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ',';"
      },
      {
        "txt": "private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail;"
      },
      {
        "txt": "protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { super(ctxt, features, codec);"
      },
      {
        "txt": "_outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); }"
      },
      {
        "txt": "} public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer;"
      },
      {
        "txt": "_outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() { return _outputStream; } @Override"
      },
      {
        "txt": "public int getOutputBuffered() { return _outputTail; } @Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; }"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; }"
      },
      {
        "txt": "if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len);"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeUnq(name); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_LBRACKET; } } @Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; } _writeContext = _writeContext.clearAndGetParent(); }"
      },
      {
        "txt": "@Override public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_LCURLY; } } @Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; } _writeContext = _writeContext.clearAndGetParent(); }"
      },
      {
        "txt": "protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this);"
      },
      {
        "txt": "} if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true); return; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(_charBuffer, 0, len);"
      },
      {
        "txt": "} else { _writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } protected final void _writePPFieldName(SerializableString name) throws IOException {"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } } @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull();"
      },
      {
        "txt": "return; } final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeString(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len);"
      },
      {
        "txt": "} else { _writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public final void writeString(SerializableString text) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else {"
      },
      {
        "txt": "_outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) {"
      },
      {
        "txt": "_writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "public void writeRaw(String text) throws IOException { final int len = text.length(); final char[] buf = _charBuffer; if (len <= buf.length) { text.getChars(0, len, buf, 0); writeRaw(buf, 0, len); } else { writeRaw(text, 0, len); } }"
      },
      {
        "txt": "@Override public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer; if (len <= buf.length) { text.getChars(offset, offset+len, buf, 0); writeRaw(buf, 0, len); return; } final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16"
      },
      {
        "txt": "final int maxBytes = maxChunk * 3; while (len > 0) { int len2 = Math.min(maxChunk, len); text.getChars(offset, offset+len2, buf, 0); if ((_outputTail + maxBytes) > _outputEnd) { _flushBuffer(); } if (len > 0) { char ch = buf[len2-1]; if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {"
      },
      {
        "txt": "--len2; } } _writeRawSegment(buf, 0, len2); offset += len2; len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException"
      },
      {
        "txt": "{ byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8();"
      },
      {
        "txt": "if (raw.length > 0) { _writeBytes(raw); } } @Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { { int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) {"
      },
      {
        "txt": "if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; } _flushBuffer(); } } len += offset; // now marks the end main_loop: while (offset < len) {"
      },
      {
        "txt": "inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop; }"
      },
      {
        "txt": "} char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } } }"
      },
      {
        "txt": "@Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte?"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { } } private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd; final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len;"
      },
      {
        "txt": "main_loop: while (offset < inputEnd) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; } if (_outputTail >= end) { _flushBuffer();"
      },
      {
        "txt": "} bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop; } } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } char ch = cbuf[offset++];"
      },
      {
        "txt": "if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } } private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException {"
      },
      {
        "txt": "main_loop: while (offset < end) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= end) {"
      },
      {
        "txt": "break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, end); }"
      },
      {
        "txt": "} } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public int writeBinary(Base64Variant b64variant,"
      },
      {
        "txt": "InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes;"
      },
      {
        "txt": "try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; }"
      },
      {
        "txt": "} finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes; } @Override"
      },
      {
        "txt": "public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return; }"
      },
      {
        "txt": "_outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedInt(i); return;"
      },
      {
        "txt": "} _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l); return; }"
      },
      {
        "txt": "if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull();"
      },
      {
        "txt": "} else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException { if (_cfgNumbersAsStrings ||"
      },
      {
        "txt": "(((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); } @Override public void writeNumber(float f) throws IOException"
      },
      {
        "txt": "{ if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); }"
      },
      {
        "txt": "public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { <extra_id_0> } else { writeRaw(_asString(value)); } } @Override public void writeNumber(String encodedValue) throws IOException"
      },
      {
        "txt": "@Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue); } }"
      },
      {
        "txt": "private final void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;"
      },
      {
        "txt": "int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); _outputTail += len; } @Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL); _writeNull(); }"
      },
      {
        "txt": "@Override protected final void _verifyValueWrite(String typeMsg) throws IOException { int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); } if (_cfgPrettyPrinter == null) { byte b; switch (status) {"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA; break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) {"
      },
      {
        "txt": "_writeBytes(raw); } } return; case JsonWriteContext.STATUS_OK_AS_IS: default: return; } if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail] = b; ++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status); } protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) {"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS:"
      },
      {
        "txt": "if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default: _throwInternal(); break; }"
      },
      {
        "txt": "} @Override public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } }"
      },
      {
        "txt": "} @Override public void close() throws IOException { super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) {"
      },
      {
        "txt": "writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else { break; } } } _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered"
      },
      {
        "txt": "if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } _releaseBuffers(); } @Override"
      },
      {
        "txt": "protected void _releaseBuffers() { byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); } char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null;"
      },
      {
        "txt": "_ioContext.releaseConcatBuffer(cbuf); } } private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length; if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len);"
      },
      {
        "txt": "return; } } System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { if ((_outputTail + len) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len); return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeStringSegments(String text, boolean addQuotes) throws IOException {"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length(); int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left);"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; left -= len; } if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(cbuf, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen);"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException"
      },
      {
        "txt": "{ len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) { break; }"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else {"
      },
      {
        "txt": "_writeStringSegmentASCII2(cbuf, offset, len); } } } private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "while (offset < len) { int ch = text.charAt(offset); if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) {"
      },
      {
        "txt": "if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len); } } } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) {"
      },
      {
        "txt": "if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "} continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } }"
      },
      {
        "txt": "_outputTail = outputPtr; } private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; }"
      },
      {
        "txt": "if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;"
      },
      {
        "txt": "final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine"
      },
      {
        "txt": "outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) {"
      },
      {
        "txt": "outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } }"
      },
      {
        "txt": "_outputTail = outputPtr; } private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);"
      },
      {
        "txt": "} else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch);"
      },
      {
        "txt": "if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);"
      },
      {
        "txt": "} System.arraycopy(raw, 0, outputBuffer, outputPtr, len); return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException { int len = raw.length; if ((outputPtr + len) > outputEnd) {"
      },
      {
        "txt": "_outputTail = outputPtr; _flushBuffer(); outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr; } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; }"
      },
      {
        "txt": "if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer(); return _outputTail; } return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { do {"
      },
      {
        "txt": "int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++]; if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; } } if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) }"
      },
      {
        "txt": "System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail;"
      },
      {
        "txt": "} final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++]; int ch = b; if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush"
      },
      {
        "txt": "_flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2;"
      },
      {
        "txt": "} } int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;"
      },
      {
        "txt": "} _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0;"
      },
      {
        "txt": "int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; }"
      },
      {
        "txt": "lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);"
      },
      {
        "txt": "if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output?"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1;"
      },
      {
        "txt": "} _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; } } return bytesLeft; } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);"
      },
      {
        "txt": "inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8;"
      },
      {
        "txt": "b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } }"
      },
      {
        "txt": "if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; }"
      },
      {
        "txt": "bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; } private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0;"
      },
      {
        "txt": "while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd; if (length == 0) { break;"
      },
      {
        "txt": "} int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3); return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)"
      },
      {
        "txt": "throws IOException { if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(String.format( \"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch)); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1;"
      },
      {
        "txt": "} } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; } protected final void _outputSurrogates(int surr1, int surr2) throws IOException {"
      },
      {
        "txt": "int c = _decodeSurrogate(surr1, surr2); if ((_outputTail + 4) > _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); }"
      },
      {
        "txt": "private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException { byte[] bbuf = _outputBuffer; if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];"
      },
      {
        "txt": "} else { bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; } private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4); _outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u;"
      },
      {
        "txt": "if (charToEscape > 0xFF) { int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];"
      },
      {
        "txt": "bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; return outputPtr; } protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) { _outputTail = 0; _outputStream.write(_outputBuffer, 0, len); }"
      }
    ]
  },
  {
    "id": 1279,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java",
    "start-bug-line": 687,
    "end-bug-line": 690,
    "bug": "String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { writeRaw(value.toPlainString());",
    "fix": "_writeQuotedRaw(_asString(value));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public final class WriterBasedJsonGenerator extends JsonGeneratorImpl"
      },
      {
        "txt": "{ final protected static int SHORT_WRITE = 32; final protected static char[] HEX_CHARS = CharTypes.copyHexChars(); final protected Writer _writer; protected char[] _outputBuffer; protected int _outputHead; protected int _outputTail; protected int _outputEnd; protected char[] _entityBuffer; protected SerializableString _currentEscape;"
      },
      {
        "txt": "public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { super(ctxt, features, codec); _writer = w; _outputBuffer = ctxt.allocConcatBuffer(); _outputEnd = _outputBuffer.length; } @Override public Object getOutputTarget() {"
      },
      {
        "txt": "return _writer; } @Override public int getOutputBuffered() { int len = _outputTail - _outputHead; return Math.max(0, len); } @Override public void writeFieldName(String name) throws IOException {"
      },
      {
        "txt": "int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); } @Override public void writeFieldName(SerializableString name) throws IOException { int status = _writeContext.writeFieldName(name.getValue());"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); } protected void _writeFieldName(String name, boolean commaBefore) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name, commaBefore); return;"
      },
      {
        "txt": "} if ((_outputTail + 1) >= _outputEnd) { _flushBuffer(); } if (commaBefore) { _outputBuffer[_outputTail++] = ','; } if (_cfgUnqNames) { _writeString(name); return;"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = '\"'; _writeString(name); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; } protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException {"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _writePPFieldName(name, commaBefore); return; } if ((_outputTail + 1) >= _outputEnd) { _flushBuffer(); } if (commaBefore) { _outputBuffer[_outputTail++] = ','; }"
      },
      {
        "txt": "final char[] quoted = name.asQuotedChars(); if (_cfgUnqNames) { writeRaw(quoted, 0, quoted.length); return; } _outputBuffer[_outputTail++] = '\"'; final int qlen = quoted.length; if ((_outputTail + qlen + 1) >= _outputEnd) { writeRaw(quoted, 0, qlen); if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; } else { System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen); _outputTail += qlen; _outputBuffer[_outputTail++] = '\"'; } } @Override"
      },
      {
        "txt": "public void writeStartArray() throws IOException, JsonGenerationException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '['; } } @Override public void writeEndArray() throws IOException, JsonGenerationException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = ']'; } _writeContext = _writeContext.clearAndGetParent(); } @Override"
      },
      {
        "txt": "public void writeStartObject() throws IOException, JsonGenerationException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '{'; } } @Override public void writeEndObject() throws IOException, JsonGenerationException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '}'; } _writeContext = _writeContext.clearAndGetParent(); } protected void _writePPFieldName(String name, boolean commaBefore) throws IOException"
      },
      {
        "txt": "{ if (commaBefore) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } if (_cfgUnqNames) {// non-standard, omit quotes _writeString(name); } else { if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; _writeString(name); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; } }"
      },
      {
        "txt": "protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException { if (commaBefore) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final char[] quoted = name.asQuotedChars(); if (_cfgUnqNames) {// non-standard, omit quotes writeRaw(quoted, 0, quoted.length);"
      },
      {
        "txt": "} else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; writeRaw(quoted, 0, quoted.length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"';"
      },
      {
        "txt": "} } @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull(); return; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; _writeString(text); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; _writeString(text, offset, len); if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; } @Override public void writeString(SerializableString sstr) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = '\"'; char[] text = sstr.asQuotedChars(); final int len = text.length; if (len < SHORT_WRITE) { int room = _outputEnd - _outputTail; if (len > room) { _flushBuffer(); } System.arraycopy(text, 0, _outputBuffer, _outputTail, len);"
      },
      {
        "txt": "_outputTail += len; } else { _flushBuffer(); _writer.write(text, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; }"
      },
      {
        "txt": "@Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeUTF8String(byte[] text, int offset, int length) throws IOException { _reportUnsupportedOperation(); } @Override public void writeRaw(String text) throws IOException"
      },
      {
        "txt": "{ int len = text.length(); int room = _outputEnd - _outputTail; if (room == 0) { _flushBuffer(); room = _outputEnd - _outputTail; } if (room >= len) { text.getChars(0, len, _outputBuffer, _outputTail); _outputTail += len;"
      },
      {
        "txt": "} else { writeRawLong(text); } } @Override public void writeRaw(String text, int start, int len) throws IOException { int room = _outputEnd - _outputTail; if (room < len) { _flushBuffer();"
      },
      {
        "txt": "room = _outputEnd - _outputTail; } if (room >= len) { text.getChars(start, start+len, _outputBuffer, _outputTail); _outputTail += len; } else { writeRawLong(text.substring(start, start+len)); } } @Override"
      },
      {
        "txt": "public void writeRaw(SerializableString text) throws IOException { writeRaw(text.getValue()); } @Override public void writeRaw(char[] text, int offset, int len) throws IOException { if (len < SHORT_WRITE) { int room = _outputEnd - _outputTail; if (len > room) { _flushBuffer();"
      },
      {
        "txt": "} System.arraycopy(text, offset, _outputBuffer, _outputTail, len); _outputTail += len; return; } _flushBuffer(); _writer.write(text, offset, len); } @Override public void writeRaw(char c) throws IOException"
      },
      {
        "txt": "{ if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = c; } private void writeRawLong(String text) throws IOException { int room = _outputEnd - _outputTail; text.getChars(0, room, _outputBuffer, _outputTail);"
      },
      {
        "txt": "_outputTail += room; _flushBuffer(); int offset = room; int len = text.length() - room; while (len > _outputEnd) { int amount = _outputEnd; text.getChars(offset, offset+amount, _outputBuffer, 0); _outputHead = 0; _outputTail = amount; _flushBuffer();"
      },
      {
        "txt": "offset += amount; len -= amount; } text.getChars(offset, offset+len, _outputBuffer, 0); _outputHead = 0; _outputTail = len; } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '\"'; } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = '\"'; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) {"
      },
      {
        "txt": "_reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '\"'; return bytes; } @Override public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return;"
      },
      {
        "txt": "} if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '\"'; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = '\"'; } @Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedInt(i);"
      },
      {
        "txt": "return; } if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = '\"'; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = '\"'; } @Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) {"
      },
      {
        "txt": "_writeQuotedLong(l); return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = '\"'; } @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException"
      },
      {
        "txt": "{ if (_cfgNumbersAsStrings || (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) { writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); } @Override"
      },
      {
        "txt": "public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings || (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); }"
      },
      {
        "txt": "public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { <extra_id_0> } else { writeRaw(_asString(value)); } } @Override public void writeNumber(String encodedValue) throws IOException"
      },
      {
        "txt": "@Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue); } }"
      },
      {
        "txt": "private void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\"'; writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '\"'; } @Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } int ptr = _outputTail;"
      },
      {
        "txt": "char[] buf = _outputBuffer; if (state) { buf[ptr] = 't'; buf[++ptr] = 'r'; buf[++ptr] = 'u'; buf[++ptr] = 'e'; } else { buf[ptr] = 'f'; buf[++ptr] = 'a'; buf[++ptr] = 'l';"
      },
      {
        "txt": "buf[++ptr] = 's'; buf[++ptr] = 'e'; } _outputTail = ptr+1; } @Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL); _writeNull(); }"
      },
      {
        "txt": "@Override protected void _verifyValueWrite(String typeMsg) throws IOException { if (_cfgPrettyPrinter != null) { _verifyPrettyValueWrite(typeMsg); return; } char c; final int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) {"
      },
      {
        "txt": "_reportError(\"Can not \"+typeMsg+\", expecting field name\"); } switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: c = ','; break; case JsonWriteContext.STATUS_OK_AFTER_COLON: c = ':'; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator"
      },
      {
        "txt": "if (_rootValueSeparator != null) { writeRaw(_rootValueSeparator.getValue()); } return; case JsonWriteContext.STATUS_OK_AS_IS: default: return; } if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail] = c; ++_outputTail; } protected void _verifyPrettyValueWrite(String typeMsg) throws IOException { final int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); }"
      },
      {
        "txt": "switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break;"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default: _throwInternal(); break;"
      },
      {
        "txt": "} } @Override public void flush() throws IOException { _flushBuffer(); if (_writer != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _writer.flush(); }"
      },
      {
        "txt": "} } @Override public void close() throws IOException { super.close(); if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext();"
      },
      {
        "txt": "if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else { break; } } } _flushBuffer();"
      },
      {
        "txt": "_outputHead = 0; _outputTail = 0; if (_writer != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _writer.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _writer.flush(); } } _releaseBuffers();"
      },
      {
        "txt": "} @Override protected void _releaseBuffers() { char[] buf = _outputBuffer; if (buf != null) { _outputBuffer = null; _ioContext.releaseConcatBuffer(buf); } }"
      },
      {
        "txt": "private void _writeString(String text) throws IOException { final int len = text.length(); if (len > _outputEnd) { // Let's reserve space for entity at begin/end _writeLongString(text); return; } if ((_outputTail + len) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "text.getChars(0, len, _outputBuffer, _outputTail); if (_characterEscapes != null) { _writeStringCustom(len); } else if (_maximumNonEscapedChar != 0) { _writeStringASCII(len, _maximumNonEscapedChar); } else { _writeString2(len); } } private void _writeString2(final int len) throws IOException"
      },
      {
        "txt": "{ final int end = _outputTail + len; final int[] escCodes = _outputEscapes; final int escLen = escCodes.length; output_loop: while (_outputTail < end) { escape_loop: while (true) { char c = _outputBuffer[_outputTail]; if (c < escLen && escCodes[c] != 0) {"
      },
      {
        "txt": "break escape_loop; } if (++_outputTail >= end) { break output_loop; } } int flushLen = (_outputTail - _outputHead); if (flushLen > 0) { _writer.write(_outputBuffer, _outputHead, flushLen); }"
      },
      {
        "txt": "char c = _outputBuffer[_outputTail++]; _prependOrWriteCharacterEscape(c, escCodes[c]); } } private void _writeLongString(String text) throws IOException { _flushBuffer(); final int textLen = text.length(); int offset = 0; do {"
      },
      {
        "txt": "int max = _outputEnd; int segmentLen = ((offset + max) > textLen) ? (textLen - offset) : max; text.getChars(offset, offset+segmentLen, _outputBuffer, 0); if (_characterEscapes != null) { _writeSegmentCustom(segmentLen); } else if (_maximumNonEscapedChar != 0) { _writeSegmentASCII(segmentLen, _maximumNonEscapedChar); } else { _writeSegment(segmentLen);"
      },
      {
        "txt": "} offset += segmentLen; } while (offset < textLen); } private void _writeSegment(int end) throws IOException { final int[] escCodes = _outputEscapes; final int escLen = escCodes.length; int ptr = 0; int start = ptr;"
      },
      {
        "txt": "output_loop: while (ptr < end) { char c; while (true) { c = _outputBuffer[ptr]; if (c < escLen && escCodes[c] != 0) { break; } if (++ptr >= end) { break;"
      },
      {
        "txt": "} } int flushLen = (ptr - start); if (flushLen > 0) { _writer.write(_outputBuffer, start, flushLen); if (ptr >= end) { break output_loop; } } ++ptr;"
      },
      {
        "txt": "start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]); } } private void _writeString(char[] text, int offset, int len) throws IOException { if (_characterEscapes != null) { _writeStringCustom(text, offset, len); return; } if (_maximumNonEscapedChar != 0) {"
      },
      {
        "txt": "_writeStringASCII(text, offset, len, _maximumNonEscapedChar); return; } len += offset; // -> len marks the end from now on final int[] escCodes = _outputEscapes; final int escLen = escCodes.length; while (offset < len) { int start = offset; while (true) { char c = text[offset];"
      },
      {
        "txt": "if (c < escLen && escCodes[c] != 0) { break; } if (++offset >= len) { break; } } int newAmount = offset - start; if (newAmount < SHORT_WRITE) { if ((_outputTail + newAmount) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } if (newAmount > 0) { System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); _outputTail += newAmount; } } else { // Nope: better just write through _flushBuffer(); _writer.write(text, start, newAmount); }"
      },
      {
        "txt": "if (offset >= len) { // yup break; } char c = text[offset++]; _appendCharacterEscape(c, escCodes[c]); } } private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "int end = _outputTail + len; final int[] escCodes = _outputEscapes; final int escLimit = Math.min(escCodes.length, maxNonEscaped+1); int escCode = 0; output_loop: while (_outputTail < end) { char c; escape_loop: while (true) { c = _outputBuffer[_outputTail];"
      },
      {
        "txt": "if (c < escLimit) { escCode = escCodes[c]; if (escCode != 0) { break escape_loop; } } else if (c > maxNonEscaped) { escCode = CharacterEscapes.ESCAPE_STANDARD; break escape_loop; } if (++_outputTail >= end) {"
      },
      {
        "txt": "break output_loop; } } int flushLen = (_outputTail - _outputHead); if (flushLen > 0) { _writer.write(_outputBuffer, _outputHead, flushLen); } ++_outputTail; _prependOrWriteCharacterEscape(c, escCode); }"
      },
      {
        "txt": "} private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; final int escLimit = Math.min(escCodes.length, maxNonEscaped+1); int ptr = 0; int escCode = 0; int start = ptr; output_loop:"
      },
      {
        "txt": "while (ptr < end) { char c; while (true) { c = _outputBuffer[ptr]; if (c < escLimit) { escCode = escCodes[c]; if (escCode != 0) { break; } } else if (c > maxNonEscaped) {"
      },
      {
        "txt": "escCode = CharacterEscapes.ESCAPE_STANDARD; break; } if (++ptr >= end) { break; } } int flushLen = (ptr - start); if (flushLen > 0) { _writer.write(_outputBuffer, start, flushLen);"
      },
      {
        "txt": "if (ptr >= end) { break output_loop; } } ++ptr; start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); } } private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { len += offset; // -> len marks the end from now on final int[] escCodes = _outputEscapes; final int escLimit = Math.min(escCodes.length, maxNonEscaped+1); int escCode = 0; while (offset < len) { int start = offset; char c; while (true) {"
      },
      {
        "txt": "c = text[offset]; if (c < escLimit) { escCode = escCodes[c]; if (escCode != 0) { break; } } else if (c > maxNonEscaped) { escCode = CharacterEscapes.ESCAPE_STANDARD; break; }"
      },
      {
        "txt": "if (++offset >= len) { break; } } int newAmount = offset - start; if (newAmount < SHORT_WRITE) { if ((_outputTail + newAmount) > _outputEnd) { _flushBuffer(); } if (newAmount > 0) {"
      },
      {
        "txt": "System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); _outputTail += newAmount; } } else { // Nope: better just write through _flushBuffer(); _writer.write(text, start, newAmount); } if (offset >= len) { // yup break; }"
      },
      {
        "txt": "++offset; _appendCharacterEscape(c, escCode); } } private void _writeStringCustom(final int len) throws IOException, JsonGenerationException { int end = _outputTail + len; final int[] escCodes = _outputEscapes; final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;"
      },
      {
        "txt": "final int escLimit = Math.min(escCodes.length, maxNonEscaped+1); int escCode = 0; final CharacterEscapes customEscapes = _characterEscapes; output_loop: while (_outputTail < end) { char c; escape_loop: while (true) { c = _outputBuffer[_outputTail]; if (c < escLimit) {"
      },
      {
        "txt": "escCode = escCodes[c]; if (escCode != 0) { break escape_loop; } } else if (c > maxNonEscaped) { escCode = CharacterEscapes.ESCAPE_STANDARD; break escape_loop; } else { if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { escCode = CharacterEscapes.ESCAPE_CUSTOM;"
      },
      {
        "txt": "break escape_loop; } } if (++_outputTail >= end) { break output_loop; } } int flushLen = (_outputTail - _outputHead); if (flushLen > 0) { _writer.write(_outputBuffer, _outputHead, flushLen);"
      },
      {
        "txt": "} ++_outputTail; _prependOrWriteCharacterEscape(c, escCode); } } private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;"
      },
      {
        "txt": "final int escLimit = Math.min(escCodes.length, maxNonEscaped+1); final CharacterEscapes customEscapes = _characterEscapes; int ptr = 0; int escCode = 0; int start = ptr; output_loop: while (ptr < end) { char c; while (true) { c = _outputBuffer[ptr];"
      },
      {
        "txt": "if (c < escLimit) { escCode = escCodes[c]; if (escCode != 0) { break; } } else if (c > maxNonEscaped) { escCode = CharacterEscapes.ESCAPE_STANDARD; break; } else { if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {"
      },
      {
        "txt": "escCode = CharacterEscapes.ESCAPE_CUSTOM; break; } } if (++ptr >= end) { break; } } int flushLen = (ptr - start); if (flushLen > 0) {"
      },
      {
        "txt": "_writer.write(_outputBuffer, start, flushLen); if (ptr >= end) { break output_loop; } } ++ptr; start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); } } private void _writeStringCustom(char[] text, int offset, int len)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { len += offset; // -> len marks the end from now on final int[] escCodes = _outputEscapes; final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; final int escLimit = Math.min(escCodes.length, maxNonEscaped+1); final CharacterEscapes customEscapes = _characterEscapes; int escCode = 0; while (offset < len) { int start = offset;"
      },
      {
        "txt": "char c; while (true) { c = text[offset]; if (c < escLimit) { escCode = escCodes[c]; if (escCode != 0) { break; } } else if (c > maxNonEscaped) { escCode = CharacterEscapes.ESCAPE_STANDARD;"
      },
      {
        "txt": "break; } else { if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { escCode = CharacterEscapes.ESCAPE_CUSTOM; break; } } if (++offset >= len) { break; }"
      },
      {
        "txt": "} int newAmount = offset - start; if (newAmount < SHORT_WRITE) { if ((_outputTail + newAmount) > _outputEnd) { _flushBuffer(); } if (newAmount > 0) { System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); _outputTail += newAmount; }"
      },
      {
        "txt": "} else { // Nope: better just write through _flushBuffer(); _writer.write(text, start, newAmount); } if (offset >= len) { // yup break; } ++offset; _appendCharacterEscape(c, escCode); }"
      },
      {
        "txt": "} protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer();"
      },
      {
        "txt": "} int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; }"
      },
      {
        "txt": "} int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; }"
      },
      {
        "txt": "_outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } } protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3;"
      },
      {
        "txt": "int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3;"
      },
      {
        "txt": "} if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) {"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but..."
      },
      {
        "txt": "_flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1; }"
      },
      {
        "txt": "_outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; } } return bytesLeft; } protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0;"
      },
      {
        "txt": "if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;"
      },
      {
        "txt": "b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { // yes, but do we have room for output?"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount;"
      },
      {
        "txt": "_outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; } private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0; while (inputPtr < inputEnd) {"
      },
      {
        "txt": "readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd; if (length == 0) { break; }"
      },
      {
        "txt": "int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3); return inputEnd; } private final void _writeNull() throws IOException {"
      },
      {
        "txt": "if ((_outputTail + 4) >= _outputEnd) { _flushBuffer(); } int ptr = _outputTail; char[] buf = _outputBuffer; buf[ptr] = 'n'; buf[++ptr] = 'u'; buf[++ptr] = 'l'; buf[++ptr] = 'l'; _outputTail = ptr+1;"
      },
      {
        "txt": "} private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { if (escCode >= 0) { // \\\\N (2 char) if (_outputTail >= 2) { // fits, just prepend int ptr = _outputTail - 2; _outputHead = ptr; _outputBuffer[ptr++] = '\\\\'; _outputBuffer[ptr] = (char) escCode;"
      },
      {
        "txt": "return; } char[] buf = _entityBuffer; if (buf == null) { buf = _allocateEntityBuffer(); } _outputHead = _outputTail; buf[1] = (char) escCode; _writer.write(buf, 0, 2); return;"
      },
      {
        "txt": "} if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX if (_outputTail >= 6) { // fits, prepend to buffer char[] buf = _outputBuffer; int ptr = _outputTail - 6; _outputHead = ptr; buf[ptr] = '\\\\'; buf[++ptr] = 'u'; if (ch > 0xFF) { // beyond 8 bytes int hi = (ch >> 8) & 0xFF;"
      },
      {
        "txt": "buf[++ptr] = HEX_CHARS[hi >> 4]; buf[++ptr] = HEX_CHARS[hi & 0xF]; ch &= 0xFF; } else { buf[++ptr] = '0'; buf[++ptr] = '0'; } buf[++ptr] = HEX_CHARS[ch >> 4]; buf[++ptr] = HEX_CHARS[ch & 0xF]; return;"
      },
      {
        "txt": "} char[] buf = _entityBuffer; if (buf == null) { buf = _allocateEntityBuffer(); } _outputHead = _outputTail; if (ch > 0xFF) { // beyond 8 bytes int hi = (ch >> 8) & 0xFF; int lo = ch & 0xFF; buf[10] = HEX_CHARS[hi >> 4];"
      },
      {
        "txt": "buf[11] = HEX_CHARS[hi & 0xF]; buf[12] = HEX_CHARS[lo >> 4]; buf[13] = HEX_CHARS[lo & 0xF]; _writer.write(buf, 8, 6); } else { // We know it's a control char, so only the last 2 chars are non-0 buf[6] = HEX_CHARS[ch >> 4]; buf[7] = HEX_CHARS[ch & 0xF]; _writer.write(buf, 2, 6); } return;"
      },
      {
        "txt": "} String escape; if (_currentEscape == null) { escape = _characterEscapes.getEscapeSequence(ch).getValue(); } else { escape = _currentEscape.getValue(); _currentEscape = null; } int len = escape.length(); if (_outputTail >= len) { // fits in, prepend"
      },
      {
        "txt": "int ptr = _outputTail - len; _outputHead = ptr; escape.getChars(0, len, _outputBuffer, ptr); return; } _outputHead = _outputTail; _writer.write(escape); } private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { if (escCode >= 0) { // \\\\N (2 char) if (ptr > 1 && ptr < end) { // fits, just prepend ptr -= 2; buffer[ptr] = '\\\\'; buffer[ptr+1] = (char) escCode; } else { // won't fit, write char[] ent = _entityBuffer; if (ent == null) {"
      },
      {
        "txt": "ent = _allocateEntityBuffer(); } ent[1] = (char) escCode; _writer.write(ent, 0, 2); } return ptr; } if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX if (ptr > 5 && ptr < end) { // fits, prepend to buffer ptr -= 6;"
      },
      {
        "txt": "buffer[ptr++] = '\\\\'; buffer[ptr++] = 'u'; if (ch > 0xFF) { // beyond 8 bytes int hi = (ch >> 8) & 0xFF; buffer[ptr++] = HEX_CHARS[hi >> 4]; buffer[ptr++] = HEX_CHARS[hi & 0xF]; ch &= 0xFF; } else { buffer[ptr++] = '0'; buffer[ptr++] = '0';"
      },
      {
        "txt": "} buffer[ptr++] = HEX_CHARS[ch >> 4]; buffer[ptr] = HEX_CHARS[ch & 0xF]; ptr -= 5; } else { char[] ent = _entityBuffer; if (ent == null) { ent = _allocateEntityBuffer(); } _outputHead = _outputTail;"
      },
      {
        "txt": "if (ch > 0xFF) { // beyond 8 bytes int hi = (ch >> 8) & 0xFF; int lo = ch & 0xFF; ent[10] = HEX_CHARS[hi >> 4]; ent[11] = HEX_CHARS[hi & 0xF]; ent[12] = HEX_CHARS[lo >> 4]; ent[13] = HEX_CHARS[lo & 0xF]; _writer.write(ent, 8, 6); } else { // We know it's a control char, so only the last 2 chars are non-0 ent[6] = HEX_CHARS[ch >> 4];"
      },
      {
        "txt": "ent[7] = HEX_CHARS[ch & 0xF]; _writer.write(ent, 2, 6); } } return ptr; } String escape; if (_currentEscape == null) { escape = _characterEscapes.getEscapeSequence(ch).getValue(); } else {"
      },
      {
        "txt": "escape = _currentEscape.getValue(); _currentEscape = null; } int len = escape.length(); if (ptr >= len && ptr < end) { // fits in, prepend ptr -= len; escape.getChars(0, len, buffer, ptr); } else { // won't fit, write separately _writer.write(escape); }"
      },
      {
        "txt": "return ptr; } private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { if (escCode >= 0) { // \\\\N (2 char) if ((_outputTail + 2) > _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '\\\\';"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = (char) escCode; return; } if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } int ptr = _outputTail; char[] buf = _outputBuffer; buf[ptr++] = '\\\\';"
      },
      {
        "txt": "buf[ptr++] = 'u'; if (ch > 0xFF) { // beyond 8 bytes int hi = (ch >> 8) & 0xFF; buf[ptr++] = HEX_CHARS[hi >> 4]; buf[ptr++] = HEX_CHARS[hi & 0xF]; ch &= 0xFF; } else { buf[ptr++] = '0'; buf[ptr++] = '0'; }"
      },
      {
        "txt": "buf[ptr++] = HEX_CHARS[ch >> 4]; buf[ptr++] = HEX_CHARS[ch & 0xF]; _outputTail = ptr; return; } String escape; if (_currentEscape == null) { escape = _characterEscapes.getEscapeSequence(ch).getValue(); } else { escape = _currentEscape.getValue();"
      },
      {
        "txt": "_currentEscape = null; } int len = escape.length(); if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > _outputEnd) { // very very long escape; unlikely but theoretically possible _writer.write(escape); return; } }"
      },
      {
        "txt": "escape.getChars(0, len, _outputBuffer, _outputTail); _outputTail += len; } private char[] _allocateEntityBuffer() { char[] buf = new char[14]; buf[0] = '\\\\'; buf[2] = '\\\\'; buf[3] = 'u'; buf[4] = '0';"
      },
      {
        "txt": "buf[5] = '0'; buf[8] = '\\\\'; buf[9] = 'u'; _entityBuffer = buf; return buf; } protected void _flushBuffer() throws IOException { int len = _outputTail - _outputHead; if (len > 0) {"
      },
      {
        "txt": "int offset = _outputHead; _outputTail = _outputHead = 0; _writer.write(_outputBuffer, offset, len); } }"
      }
    ]
  }
]