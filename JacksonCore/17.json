[
  {
    "id": 1268,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 528,
    "end-bug-line": 528,
    "bug": "",
    "fix": "if (len <= buf.length) { text.getChars(offset, offset+len, buf, 0); _writeRawSegment(buf, 0, len); return; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator"
      },
      {
        "txt": "extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ',';"
      },
      {
        "txt": "private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail;"
      },
      {
        "txt": "protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { super(ctxt, features, codec);"
      },
      {
        "txt": "_outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); }"
      },
      {
        "txt": "} public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer;"
      },
      {
        "txt": "_outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() { return _outputStream; } @Override"
      },
      {
        "txt": "public int getOutputBuffered() { return _outputTail; } @Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; }"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; }"
      },
      {
        "txt": "if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len);"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeUnq(name); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_LBRACKET; } } @Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; } _writeContext = _writeContext.clearAndGetParent(); }"
      },
      {
        "txt": "@Override public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_LCURLY; } } @Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; } _writeContext = _writeContext.clearAndGetParent(); }"
      },
      {
        "txt": "protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this);"
      },
      {
        "txt": "} if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true); return; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(_charBuffer, 0, len);"
      },
      {
        "txt": "} else { _writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } protected final void _writePPFieldName(SerializableString name) throws IOException {"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } } @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull();"
      },
      {
        "txt": "return; } final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeString(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len);"
      },
      {
        "txt": "} else { _writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public final void writeString(SerializableString text) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else {"
      },
      {
        "txt": "_outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) {"
      },
      {
        "txt": "_writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "writeRaw(text, 0, text.length()); } @Override public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer; <extra_id_0> while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); offset += len2; len -= len2;"
      },
      {
        "txt": "offset += len2; len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException { byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw);"
      },
      {
        "txt": "} } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } }"
      },
      {
        "txt": "@Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { { int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) { if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; }"
      },
      {
        "txt": "_flushBuffer(); } } len += offset; // now marks the end main_loop: while (offset < len) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) {"
      },
      {
        "txt": "break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } } } @Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { }"
      },
      {
        "txt": "} private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd; final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len; main_loop: while (offset < inputEnd) { inner_loop: while (true) {"
      },
      {
        "txt": "int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; } if (_outputTail >= end) { _flushBuffer(); } bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop;"
      },
      {
        "txt": "} } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); }"
      },
      {
        "txt": "bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes;"
      },
      {
        "txt": "} @Override public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s);"
      },
      {
        "txt": "return; } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) {"
      },
      {
        "txt": "_writeQuotedInt(i); return; } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l);"
      },
      {
        "txt": "return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException"
      },
      {
        "txt": "{ if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); }"
      },
      {
        "txt": "@Override public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "writeRaw(String.valueOf(f)); } @Override public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)"
      },
      {
        "txt": "? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(String encodedValue) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue); } } private final void _writeQuotedRaw(String value) throws IOException {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);"
      },
      {
        "txt": "_outputTail += len; } @Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL); _writeNull(); } @Override protected final void _verifyValueWrite(String typeMsg) throws IOException"
      },
      {
        "txt": "{ int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); } if (_cfgPrettyPrinter == null) { byte b; switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA;"
      },
      {
        "txt": "break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); }"
      },
      {
        "txt": "} return; case JsonWriteContext.STATUS_OK_AS_IS: default: return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail] = b;"
      },
      {
        "txt": "++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status); } protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this);"
      },
      {
        "txt": "break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this);"
      },
      {
        "txt": "} else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default: _throwInternal(); break; } } @Override"
      },
      {
        "txt": "public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } } @Override"
      },
      {
        "txt": "public void close() throws IOException { super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) {"
      },
      {
        "txt": "writeEndObject(); } else { break; } } } _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {"
      },
      {
        "txt": "_outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } _releaseBuffers(); } @Override protected void _releaseBuffers() {"
      },
      {
        "txt": "byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); } char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null; _ioContext.releaseConcatBuffer(cbuf); }"
      },
      {
        "txt": "} private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length; if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len); return; }"
      },
      {
        "txt": "} System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len);"
      },
      {
        "txt": "return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeStringSegments(String text, boolean addQuotes) throws IOException { if (addQuotes) { if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length(); int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(text, offset, len); offset += len; left -= len; } if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(cbuf, offset, len);"
      },
      {
        "txt": "offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(text, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException { len += offset; // becomes end marker, then"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset;"
      },
      {
        "txt": "} _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else { _writeStringSegmentASCII2(cbuf, offset, len); }"
      },
      {
        "txt": "} } private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = text.charAt(offset);"
      },
      {
        "txt": "if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len);"
      },
      {
        "txt": "} else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len); } } } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch;"
      },
      {
        "txt": "continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue;"
      },
      {
        "txt": "} if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; }"
      },
      {
        "txt": "private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = text.charAt(offset++);"
      },
      {
        "txt": "if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar;"
      },
      {
        "txt": "while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; }"
      },
      {
        "txt": "if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) {"
      },
      {
        "txt": "int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape;"
      },
      {
        "txt": "} else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); }"
      },
      {
        "txt": "continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue;"
      },
      {
        "txt": "} if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; }"
      },
      {
        "txt": "private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null"
      },
      {
        "txt": "while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "} continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); } System.arraycopy(raw, 0, outputBuffer, outputPtr, len);"
      },
      {
        "txt": "return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException { int len = raw.length; if ((outputPtr + len) > outputEnd) { _outputTail = outputPtr; _flushBuffer();"
      },
      {
        "txt": "outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr; } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; } if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer();"
      },
      {
        "txt": "return _outputTail; } return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { do { int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len);"
      },
      {
        "txt": "offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++];"
      },
      {
        "txt": "if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; } } if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) } System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len;"
      },
      {
        "txt": "} private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail; } final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++]; int ch = b; if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } } _outputTail = outputPtr; } protected final void _writeBinary(Base64Variant b64variant,"
      },
      {
        "txt": "byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); }"
      },
      {
        "txt": "int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } }"
      },
      {
        "txt": "int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; } _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);"
      },
      {
        "txt": "} } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6;"
      },
      {
        "txt": "int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; }"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\';"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer();"
      },
      {
        "txt": "} int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1; } _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);"
      },
      {
        "txt": "bytesLeft -= amount; } } return bytesLeft; } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0;"
      },
      {
        "txt": "int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes"
      },
      {
        "txt": "break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);"
      },
      {
        "txt": "bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but..."
      },
      {
        "txt": "_flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);"
      },
      {
        "txt": "} return bytesDone; } private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0; while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++];"
      },
      {
        "txt": "} inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd; if (length == 0) { break; } int count = in.read(readBuffer, inputEnd, length);"
      },
      {
        "txt": "if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3); return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {"
      },
      {
        "txt": "if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(\"Split surrogate on writeRaw() input (last character)\"); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; } } final byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; } protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2); if ((_outputTail + 4) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException { byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else { bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));"
      },
      {
        "txt": "bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; } private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) { _flushBuffer(); } System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);"
      },
      {
        "txt": "_outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) { int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4];"
      },
      {
        "txt": "bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; return outputPtr; }"
      },
      {
        "txt": "protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) { _outputTail = 0; _outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  },
  {
    "id": 1269,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 532,
    "end-bug-line": 532,
    "bug": "",
    "fix": "final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16 final int maxBytes = maxChunk * 3;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator"
      },
      {
        "txt": "extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ',';"
      },
      {
        "txt": "private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail;"
      },
      {
        "txt": "protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { super(ctxt, features, codec);"
      },
      {
        "txt": "_outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); }"
      },
      {
        "txt": "} public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer;"
      },
      {
        "txt": "_outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() { return _outputStream; } @Override"
      },
      {
        "txt": "public int getOutputBuffered() { return _outputTail; } @Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; }"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; }"
      },
      {
        "txt": "if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len);"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeUnq(name); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } }"
      },
      {
        "txt": "@Override public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_LBRACKET; } } @Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; } _writeContext = _writeContext.clearAndGetParent(); }"
      },
      {
        "txt": "@Override public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_LCURLY; } } @Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; } _writeContext = _writeContext.clearAndGetParent(); }"
      },
      {
        "txt": "protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this);"
      },
      {
        "txt": "} if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true); return; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(_charBuffer, 0, len);"
      },
      {
        "txt": "} else { _writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } protected final void _writePPFieldName(SerializableString name) throws IOException {"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } } @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull();"
      },
      {
        "txt": "return; } final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeString(char[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len);"
      },
      {
        "txt": "} else { _writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public final void writeString(SerializableString text) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else {"
      },
      {
        "txt": "_outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) {"
      },
      {
        "txt": "_writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "writeRaw(text, 0, text.length()); } @Override public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer; <extra_id_0> while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); offset += len2; len -= len2;"
      },
      {
        "txt": "offset += len2; len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException { byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw);"
      },
      {
        "txt": "} } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } }"
      },
      {
        "txt": "@Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { { int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) { if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; }"
      },
      {
        "txt": "_flushBuffer(); } } len += offset; // now marks the end main_loop: while (offset < len) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) {"
      },
      {
        "txt": "break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } } } @Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { }"
      },
      {
        "txt": "} private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd; final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len; main_loop: while (offset < inputEnd) { inner_loop: while (true) {"
      },
      {
        "txt": "int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; } if (_outputTail >= end) { _flushBuffer(); } bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop;"
      },
      {
        "txt": "} } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); }"
      },
      {
        "txt": "bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes;"
      },
      {
        "txt": "} @Override public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s);"
      },
      {
        "txt": "return; } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) {"
      },
      {
        "txt": "_writeQuotedInt(i); return; } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l);"
      },
      {
        "txt": "return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException"
      },
      {
        "txt": "{ if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); }"
      },
      {
        "txt": "@Override public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "writeRaw(String.valueOf(f)); } @Override public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)"
      },
      {
        "txt": "? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(String encodedValue) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue); } } private final void _writeQuotedRaw(String value) throws IOException {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);"
      },
      {
        "txt": "_outputTail += len; } @Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL); _writeNull(); } @Override protected final void _verifyValueWrite(String typeMsg) throws IOException"
      },
      {
        "txt": "{ int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); } if (_cfgPrettyPrinter == null) { byte b; switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA;"
      },
      {
        "txt": "break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); }"
      },
      {
        "txt": "} return; case JsonWriteContext.STATUS_OK_AS_IS: default: return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail] = b;"
      },
      {
        "txt": "++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status); } protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this);"
      },
      {
        "txt": "break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this);"
      },
      {
        "txt": "} else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default: _throwInternal(); break; } } @Override"
      },
      {
        "txt": "public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } } @Override"
      },
      {
        "txt": "public void close() throws IOException { super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) {"
      },
      {
        "txt": "writeEndObject(); } else { break; } } } _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {"
      },
      {
        "txt": "_outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } _releaseBuffers(); } @Override protected void _releaseBuffers() {"
      },
      {
        "txt": "byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); } char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null; _ioContext.releaseConcatBuffer(cbuf); }"
      },
      {
        "txt": "} private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length; if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len); return; }"
      },
      {
        "txt": "} System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len);"
      },
      {
        "txt": "return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeStringSegments(String text, boolean addQuotes) throws IOException { if (addQuotes) { if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length(); int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(text, offset, len); offset += len; left -= len; } if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(cbuf, offset, len);"
      },
      {
        "txt": "offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(text, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException { len += offset; // becomes end marker, then"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset;"
      },
      {
        "txt": "} _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else { _writeStringSegmentASCII2(cbuf, offset, len); }"
      },
      {
        "txt": "} } private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = text.charAt(offset);"
      },
      {
        "txt": "if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len);"
      },
      {
        "txt": "} else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len); } } } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch;"
      },
      {
        "txt": "continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue;"
      },
      {
        "txt": "} if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; }"
      },
      {
        "txt": "private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = text.charAt(offset++);"
      },
      {
        "txt": "if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar;"
      },
      {
        "txt": "while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; }"
      },
      {
        "txt": "if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) {"
      },
      {
        "txt": "int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape;"
      },
      {
        "txt": "} else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); }"
      },
      {
        "txt": "continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue;"
      },
      {
        "txt": "} if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; }"
      },
      {
        "txt": "private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null"
      },
      {
        "txt": "while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "} continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); } System.arraycopy(raw, 0, outputBuffer, outputPtr, len);"
      },
      {
        "txt": "return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException { int len = raw.length; if ((outputPtr + len) > outputEnd) { _outputTail = outputPtr; _flushBuffer();"
      },
      {
        "txt": "outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr; } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; } if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer();"
      },
      {
        "txt": "return _outputTail; } return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { do { int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len);"
      },
      {
        "txt": "offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++];"
      },
      {
        "txt": "if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; } } if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) } System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len;"
      },
      {
        "txt": "} private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail; } final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++]; int ch = b; if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } } _outputTail = outputPtr; } protected final void _writeBinary(Base64Variant b64variant,"
      },
      {
        "txt": "byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); }"
      },
      {
        "txt": "int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } }"
      },
      {
        "txt": "int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; } _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);"
      },
      {
        "txt": "} } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6;"
      },
      {
        "txt": "int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; }"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\';"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer();"
      },
      {
        "txt": "} int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1; } _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);"
      },
      {
        "txt": "bytesLeft -= amount; } } return bytesLeft; } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0;"
      },
      {
        "txt": "int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes"
      },
      {
        "txt": "break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);"
      },
      {
        "txt": "bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but..."
      },
      {
        "txt": "_flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);"
      },
      {
        "txt": "} return bytesDone; } private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0; while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++];"
      },
      {
        "txt": "} inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd; if (length == 0) { break; } int count = in.read(readBuffer, inputEnd, length);"
      },
      {
        "txt": "if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3); return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException {"
      },
      {
        "txt": "if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(\"Split surrogate on writeRaw() input (last character)\"); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; } } final byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; } protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2); if ((_outputTail + 4) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException { byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else { bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));"
      },
      {
        "txt": "bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; } private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) { _flushBuffer(); } System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);"
      },
      {
        "txt": "_outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) { int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4];"
      },
      {
        "txt": "bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; return outputPtr; }"
      },
      {
        "txt": "protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) { _outputTail = 0; _outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  },
  {
    "id": 1270,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 534,
    "end-bug-line": 534,
    "bug": "int len2 = Math.min(buf.length, len);",
    "fix": "int len2 = Math.min(maxChunk, len);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator extends JsonGeneratorImpl"
      },
      {
        "txt": "{ private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':';"
      },
      {
        "txt": "private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd;"
      },
      {
        "txt": "protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { super(ctxt, features, codec); _outputStream = out;"
      },
      {
        "txt": "_bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); } }"
      },
      {
        "txt": "public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer; _outputEnd = _outputBuffer.length;"
      },
      {
        "txt": "_outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() { return _outputStream; } @Override public int getOutputBuffered() {"
      },
      {
        "txt": "return _outputTail; } @Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name);"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) {"
      },
      {
        "txt": "_writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len); }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name);"
      },
      {
        "txt": "return; } final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeUnq(name); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } } @Override"
      },
      {
        "txt": "public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_LBRACKET; } } @Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; } _writeContext = _writeContext.clearAndGetParent(); } @Override"
      },
      {
        "txt": "public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_LCURLY; } } @Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; } _writeContext = _writeContext.clearAndGetParent(); } protected final void _writePPFieldName(String name) throws IOException"
      },
      {
        "txt": "{ int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); }"
      },
      {
        "txt": "if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(_charBuffer, 0, len); } else {"
      },
      {
        "txt": "_writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } protected final void _writePPFieldName(SerializableString name) throws IOException { final int status = _writeContext.writeFieldName(name.getValue());"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard if (addQuotes) {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } } @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull(); return;"
      },
      {
        "txt": "} final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "_writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeString(char[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); } else {"
      },
      {
        "txt": "_writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public final void writeString(SerializableString text) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else { _outputTail += len;"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _verifyValueWrite(WRITE_STRING);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { _writeUTF8Segment(text, offset, len);"
      },
      {
        "txt": "} else { _writeUTF8Segments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRaw(String text) throws IOException {"
      },
      {
        "txt": "} @Override public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer; while (len > 0) { <extra_id_0> text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); offset += len2; len -= len2; } }"
      },
      {
        "txt": "} } @Override public void writeRaw(SerializableString text) throws IOException { byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } }"
      },
      {
        "txt": "@Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException"
      },
      {
        "txt": "{ { int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) { if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; } _flushBuffer(); }"
      },
      {
        "txt": "} len += offset; // now marks the end main_loop: while (offset < len) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } } } @Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { } } private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException"
      },
      {
        "txt": "{ final int end = _outputEnd; final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len; main_loop: while (offset < inputEnd) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch >= 0x80) {"
      },
      {
        "txt": "break inner_loop; } if (_outputTail >= end) { _flushBuffer(); } bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop; } }"
      },
      {
        "txt": "if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); }"
      },
      {
        "txt": "} } @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public int writeBinary(Base64Variant b64variant,"
      },
      {
        "txt": "InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes;"
      },
      {
        "txt": "try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; }"
      },
      {
        "txt": "} finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes; } @Override"
      },
      {
        "txt": "public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return; }"
      },
      {
        "txt": "_outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedInt(i); return;"
      },
      {
        "txt": "} _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l); return; }"
      },
      {
        "txt": "if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull();"
      },
      {
        "txt": "} else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException { if (_cfgNumbersAsStrings ||"
      },
      {
        "txt": "(((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); } @Override public void writeNumber(float f) throws IOException"
      },
      {
        "txt": "{ if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); }"
      },
      {
        "txt": "@Override public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw);"
      },
      {
        "txt": "} else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(value.toString()); } } @Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue); } } private final void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeBoolean(boolean state) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); _outputTail += len; }"
      },
      {
        "txt": "@Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL); _writeNull(); } @Override protected final void _verifyValueWrite(String typeMsg) throws IOException { int status = _writeContext.writeValue();"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); } if (_cfgPrettyPrinter == null) { byte b; switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA; break; case JsonWriteContext.STATUS_OK_AFTER_COLON:"
      },
      {
        "txt": "b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } return;"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AS_IS: default: return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail] = b; ++_outputTail; return;"
      },
      {
        "txt": "} _verifyPrettyValueWrite(typeMsg, status); } protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON:"
      },
      {
        "txt": "_cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this);"
      },
      {
        "txt": "} break; default: _throwInternal(); break; } } @Override public void flush() throws IOException {"
      },
      {
        "txt": "_flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } } @Override public void close() throws IOException {"
      },
      {
        "txt": "super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else {"
      },
      {
        "txt": "break; } } } _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {"
      },
      {
        "txt": "_outputStream.flush(); } } _releaseBuffers(); } @Override protected void _releaseBuffers() { byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) {"
      },
      {
        "txt": "_outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); } char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null; _ioContext.releaseConcatBuffer(cbuf); } } private final void _writeBytes(byte[] bytes) throws IOException"
      },
      {
        "txt": "{ final int len = bytes.length; if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len); return; } } System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);"
      },
      {
        "txt": "_outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len); return; }"
      },
      {
        "txt": "} System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeStringSegments(String text, boolean addQuotes) throws IOException { if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length(); int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len);"
      },
      {
        "txt": "offset += len; left -= len; } if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } }"
      },
      {
        "txt": "private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(cbuf, offset, len); offset += len; totalLen -= len;"
      },
      {
        "txt": "} while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len);"
      },
      {
        "txt": "offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr;"
      },
      {
        "txt": "if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else { _writeStringSegmentASCII2(cbuf, offset, len); } } }"
      },
      {
        "txt": "private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = text.charAt(offset); if (ch > 0x7F || escCodes[ch] != 0) { break;"
      },
      {
        "txt": "} outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len);"
      },
      {
        "txt": "} else { _writeStringSegmentASCII2(text, offset, len); } } } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; }"
      },
      {
        "txt": "int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException {"
      },
      {
        "txt": "if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) {"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); }"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar;"
      },
      {
        "txt": "while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; }"
      },
      {
        "txt": "if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = text.charAt(offset++);"
      },
      {
        "txt": "if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) {"
      },
      {
        "txt": "if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch);"
      },
      {
        "txt": "if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; }"
      },
      {
        "txt": "if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException {"
      },
      {
        "txt": "if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = text.charAt(offset++);"
      },
      {
        "txt": "if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {"
      },
      {
        "txt": "SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue;"
      },
      {
        "txt": "} if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; }"
      },
      {
        "txt": "if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); return (outputPtr + len); }"
      },
      {
        "txt": "private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException { int len = raw.length; if ((outputPtr + len) > outputEnd) { _outputTail = outputPtr; _flushBuffer(); outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible..."
      },
      {
        "txt": "_outputStream.write(raw, 0, len); return outputPtr; } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; } if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer(); return _outputTail; }"
      },
      {
        "txt": "return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { do { int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len); offset += len; totalLen -= len;"
      },
      {
        "txt": "} while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++]; if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len);"
      },
      {
        "txt": "return; } } if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) } System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail; } final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end'"
      },
      {
        "txt": "while (offset < len) { byte b = utf8[offset++]; int ch = b; if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } } _outputTail = outputPtr; } protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF;"
      },
      {
        "txt": "b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output?"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; } _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } }"
      },
      {
        "txt": "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets"
      },
      {
        "txt": "if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer();"
      },
      {
        "txt": "} int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2;"
      },
      {
        "txt": "} } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16;"
      },
      {
        "txt": "int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1; } _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; }"
      },
      {
        "txt": "} return bytesLeft; } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3;"
      },
      {
        "txt": "int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; }"
      },
      {
        "txt": "lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);"
      },
      {
        "txt": "if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); }"
      },
      {
        "txt": "int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone;"
      },
      {
        "txt": "} private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0; while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0;"
      },
      {
        "txt": "inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd; if (length == 0) { break; } int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd;"
      },
      {
        "txt": "} inputEnd += count; } while (inputEnd < 3); return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException { if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP"
      },
      {
        "txt": "if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(\"Split surrogate on writeRaw() input (last character)\"); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; } } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; } protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2); if ((_outputTail + 4) > _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException { byte[] bbuf = _outputBuffer; if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else { bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); }"
      },
      {
        "txt": "return outputPtr; } private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) { _flushBuffer(); } System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4); _outputTail += 4; }"
      },
      {
        "txt": "private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) { int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF;"
      },
      {
        "txt": "} else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; return outputPtr; } protected final void _flushBuffer() throws IOException {"
      },
      {
        "txt": "int len = _outputTail; if (len > 0) { _outputTail = 0; _outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  },
  {
    "id": 1271,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 536,
    "end-bug-line": 536,
    "bug": "writeRaw(buf, 0, len2);",
    "fix": "if ((_outputTail + maxBytes) > _outputEnd) { _flushBuffer(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u';"
      },
      {
        "txt": "private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512;"
      },
      {
        "txt": "private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer;"
      },
      {
        "txt": "protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer();"
      },
      {
        "txt": "_outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); } } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out,"
      },
      {
        "txt": "byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer; _outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer();"
      },
      {
        "txt": "_charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() { return _outputStream; } @Override public int getOutputBuffered() { return _outputTail; }"
      },
      {
        "txt": "@Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\");"
      },
      {
        "txt": "} if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeStringSegments(name, false); return;"
      },
      {
        "txt": "} final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; }"
      },
      {
        "txt": "final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; }"
      },
      {
        "txt": "if (_cfgUnqNames) { _writeUnq(name); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing"
      },
      {
        "txt": "_writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException {"
      },
      {
        "txt": "int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } } @Override public final void writeStartArray() throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LBRACKET; }"
      },
      {
        "txt": "} @Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; } _writeContext = _writeContext.clearAndGetParent(); } @Override public final void writeStartObject() throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LCURLY; }"
      },
      {
        "txt": "} @Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; } _writeContext = _writeContext.clearAndGetParent(); } protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name);"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } if (_cfgUnqNames) { _writeStringSegments(name, false);"
      },
      {
        "txt": "return; } final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(_charBuffer, 0, len); } else { _writeStringSegments(_charBuffer, 0, len); }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } protected final void _writePPFieldName(SerializableString name) throws IOException { final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\");"
      },
      {
        "txt": "} if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "} @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull(); return; } final int len = text.length();"
      },
      {
        "txt": "if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeString(char[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); } else { _writeStringSegments(text, offset, len); }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public final void writeString(SerializableString text) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { _writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len);"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRaw(String text) throws IOException { writeRaw(text, 0, text.length()); }"
      },
      {
        "txt": "public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer; while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); <extra_id_0> offset += len2; len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException"
      },
      {
        "txt": "@Override public void writeRaw(SerializableString text) throws IOException { byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public void writeRawValue(SerializableString text) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { {"
      },
      {
        "txt": "int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) { if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; } _flushBuffer(); } } len += offset; // now marks the end"
      },
      {
        "txt": "main_loop: while (offset < len) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) {"
      },
      {
        "txt": "break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); }"
      },
      {
        "txt": "} } @Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) {"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { } } private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd;"
      },
      {
        "txt": "final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len; main_loop: while (offset < inputEnd) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; }"
      },
      {
        "txt": "if (_outputTail >= end) { _flushBuffer(); } bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop; } } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } }"
      },
      {
        "txt": "@Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "_writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown"
      },
      {
        "txt": "bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer);"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes; } @Override public void writeNumber(short s) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return; } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); }"
      },
      {
        "txt": "private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(int i) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedInt(i); return; } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);"
      },
      {
        "txt": "} private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l); return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString());"
      },
      {
        "txt": "} else { writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException { if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {"
      },
      {
        "txt": "writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings ||"
      },
      {
        "txt": "(((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); } @Override public void writeNumber(BigDecimal value) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString());"
      },
      {
        "txt": "} else { writeRaw(value.toString()); } } @Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue);"
      },
      {
        "txt": "} else { writeRaw(encodedValue); } } private final void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN);"
      },
      {
        "txt": "if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); _outputTail += len; } @Override public void writeNull() throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NULL); _writeNull(); } @Override protected final void _verifyValueWrite(String typeMsg) throws IOException { int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\");"
      },
      {
        "txt": "} if (_cfgPrettyPrinter == null) { byte b; switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA; break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break;"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } return; case JsonWriteContext.STATUS_OK_AS_IS: default:"
      },
      {
        "txt": "return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail] = b; ++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status);"
      },
      {
        "txt": "} protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break;"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break;"
      },
      {
        "txt": "default: _throwInternal(); break; } } @Override public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) {"
      },
      {
        "txt": "if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } } @Override public void close() throws IOException { super.close(); if ((_outputBuffer != null)"
      },
      {
        "txt": "&& isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else { break; }"
      },
      {
        "txt": "} } _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); }"
      },
      {
        "txt": "} _releaseBuffers(); } @Override protected void _releaseBuffers() { byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf);"
      },
      {
        "txt": "} char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null; _ioContext.releaseConcatBuffer(cbuf); } } private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length;"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len); return; } } System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; }"
      },
      {
        "txt": "private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len); return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);"
      },
      {
        "txt": "_outputTail += len; } private final void _writeStringSegments(String text, boolean addQuotes) throws IOException { if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "int left = text.length(); int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; left -= len;"
      },
      {
        "txt": "} if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException {"
      },
      {
        "txt": "do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(cbuf, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); }"
      },
      {
        "txt": "private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; totalLen -= len;"
      },
      {
        "txt": "} while (totalLen > 0); } private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) {"
      },
      {
        "txt": "int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) {"
      },
      {
        "txt": "_writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else { _writeStringSegmentASCII2(cbuf, offset, len); } } } private final void _writeStringSegment(String text, int offset, int len) throws IOException {"
      },
      {
        "txt": "len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = text.charAt(offset); if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch;"
      },
      {
        "txt": "++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len);"
      },
      {
        "txt": "} } } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine"
      },
      {
        "txt": "outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));"
      },
      {
        "txt": "} else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; }"
      },
      {
        "txt": "if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++];"
      },
      {
        "txt": "if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) {"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); }"
      },
      {
        "txt": "continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch;"
      },
      {
        "txt": "continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\""
      },
      {
        "txt": "+Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));"
      },
      {
        "txt": "} else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) {"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) {"
      },
      {
        "txt": "_reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { int len = raw.length; if ((outputPtr + len) > outputEnd) { _outputTail = outputPtr; _flushBuffer(); outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr;"
      },
      {
        "txt": "} System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; } if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer(); return _outputTail; } return outputPtr; }"
      },
      {
        "txt": "private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { do { int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); }"
      },
      {
        "txt": "private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++]; if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; }"
      },
      {
        "txt": "} if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) } System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail; } final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++];"
      },
      {
        "txt": "int ch = b; if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } } _outputTail = outputPtr; } protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3;"
      },
      {
        "txt": "int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);"
      },
      {
        "txt": "if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer();"
      },
      {
        "txt": "} int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; } _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);"
      },
      {
        "txt": "inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8;"
      },
      {
        "txt": "b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } }"
      },
      {
        "txt": "if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) {"
      },
      {
        "txt": "b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1; } _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; } } return bytesLeft;"
      },
      {
        "txt": "} protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6;"
      },
      {
        "txt": "int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; }"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\';"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1;"
      },
      {
        "txt": "if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; } private final int _readMore(InputStream in,"
      },
      {
        "txt": "byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0; while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length);"
      },
      {
        "txt": "do { int length = maxRead - inputEnd; if (length == 0) { break; } int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd; } inputEnd += count;"
      },
      {
        "txt": "} while (inputEnd < 3); return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException { if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(\"Split surrogate on writeRaw() input (last character)\");"
      },
      {
        "txt": "} _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; } } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset;"
      },
      {
        "txt": "} protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2); if ((_outputTail + 4) > _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException { byte[] bbuf = _outputBuffer; if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];"
      },
      {
        "txt": "bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else { bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; }"
      },
      {
        "txt": "private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) { _flushBuffer(); } System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4); _outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException {"
      },
      {
        "txt": "final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) { int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0;"
      },
      {
        "txt": "bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; return outputPtr; } protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) {"
      },
      {
        "txt": "_outputTail = 0; _outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  },
  {
    "id": 1272,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 539,
    "end-bug-line": 539,
    "bug": "",
    "fix": "if (len > 0) { char ch = buf[len2-1]; if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) { --len2; } } _writeRawSegment(buf, 0, len2);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0';"
      },
      {
        "txt": "private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();"
      },
      {
        "txt": "private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength;"
      },
      {
        "txt": "protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length;"
      },
      {
        "txt": "_outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); } } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)"
      },
      {
        "txt": "{ super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer; _outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length;"
      },
      {
        "txt": "} @Override public Object getOutputTarget() { return _outputStream; } @Override public int getOutputBuffered() { return _outputTail; } @Override"
      },
      {
        "txt": "public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); }"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeStringSegments(name, false); return; }"
      },
      {
        "txt": "final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) {"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name.getValue());"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) {"
      },
      {
        "txt": "_writeUnq(name); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8());"
      },
      {
        "txt": "} else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);"
      },
      {
        "txt": "if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } } @Override public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\");"
      },
      {
        "txt": "_writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LBRACKET; } }"
      },
      {
        "txt": "@Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; } _writeContext = _writeContext.clearAndGetParent(); } @Override public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\");"
      },
      {
        "txt": "_writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LCURLY; } }"
      },
      {
        "txt": "@Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; } _writeContext = _writeContext.clearAndGetParent(); } protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {"
      },
      {
        "txt": "_reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } if (_cfgUnqNames) { _writeStringSegments(name, false); return;"
      },
      {
        "txt": "} final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(_charBuffer, 0, len); } else { _writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } protected final void _writePPFieldName(SerializableString name) throws IOException { final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); }"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } }"
      },
      {
        "txt": "@Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull(); return; } final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling"
      },
      {
        "txt": "_writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeString(char[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); } else { _writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public final void writeString(SerializableString text) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { _writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len); }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRaw(String text) throws IOException { writeRaw(text, 0, text.length()); } @Override"
      },
      {
        "txt": "{ final char[] buf = _charBuffer; while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); <extra_id_0> len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException {"
      },
      {
        "txt": "public void writeRaw(SerializableString text) throws IOException { byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW);"
      },
      {
        "txt": "byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { { int len3 = len+len+len;"
      },
      {
        "txt": "if ((_outputTail + len3) > _outputEnd) { if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; } _flushBuffer(); } } len += offset; // now marks the end main_loop:"
      },
      {
        "txt": "while (offset < len) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop;"
      },
      {
        "txt": "} } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } }"
      },
      {
        "txt": "} @Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch;"
      },
      {
        "txt": "} else if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { } } private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd; final byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "final int inputEnd = offset + len; main_loop: while (offset < inputEnd) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; } if (_outputTail >= end) {"
      },
      {
        "txt": "_flushBuffer(); } bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop; } } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } } @Override"
      },
      {
        "txt": "public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer);"
      },
      {
        "txt": "} else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer); }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes; } @Override public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return; } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException {"
      },
      {
        "txt": "if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(int i) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedInt(i); return; } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); }"
      },
      {
        "txt": "private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l); return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} @Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else {"
      },
      {
        "txt": "writeRaw(value.toString()); } } @Override public void writeNumber(double d) throws IOException { if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d));"
      },
      {
        "txt": "return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f))"
      },
      {
        "txt": "&& Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); } @Override public void writeNumber(BigDecimal value) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else {"
      },
      {
        "txt": "writeRaw(value.toString()); } } @Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else {"
      },
      {
        "txt": "writeRaw(encodedValue); } } private final void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); _outputTail += len; } @Override public void writeNull() throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_NULL); _writeNull(); } @Override protected final void _verifyValueWrite(String typeMsg) throws IOException { int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); }"
      },
      {
        "txt": "if (_cfgPrettyPrinter == null) { byte b; switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA; break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator"
      },
      {
        "txt": "if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } return; case JsonWriteContext.STATUS_OK_AS_IS: default: return;"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail] = b; ++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status); }"
      },
      {
        "txt": "protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE:"
      },
      {
        "txt": "_cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default:"
      },
      {
        "txt": "_throwInternal(); break; } } @Override public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {"
      },
      {
        "txt": "_outputStream.flush(); } } } @Override public void close() throws IOException { super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {"
      },
      {
        "txt": "while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else { break; } }"
      },
      {
        "txt": "} _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } }"
      },
      {
        "txt": "_releaseBuffers(); } @Override protected void _releaseBuffers() { byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); }"
      },
      {
        "txt": "char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null; _ioContext.releaseConcatBuffer(cbuf); } } private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length; if ((_outputTail + len) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len); return; } } System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len); return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len;"
      },
      {
        "txt": "} private final void _writeStringSegments(String text, boolean addQuotes) throws IOException { if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length();"
      },
      {
        "txt": "int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; left -= len; }"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do {"
      },
      {
        "txt": "int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(cbuf, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException"
      },
      {
        "txt": "{ do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; totalLen -= len; } while (totalLen > 0);"
      },
      {
        "txt": "} private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset];"
      },
      {
        "txt": "if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len);"
      },
      {
        "txt": "} else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else { _writeStringSegmentASCII2(cbuf, offset, len); } } } private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = text.charAt(offset); if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset;"
      },
      {
        "txt": "} _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len); }"
      },
      {
        "txt": "} } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; }"
      },
      {
        "txt": "int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException {"
      },
      {
        "txt": "if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) {"
      },
      {
        "txt": "if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "} continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));"
      },
      {
        "txt": "} else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch;"
      },
      {
        "txt": "continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue;"
      },
      {
        "txt": "} if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr);"
      },
      {
        "txt": "} } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail;"
      },
      {
        "txt": "final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\");"
      },
      {
        "txt": "} outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue;"
      },
      {
        "txt": "} SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch;"
      },
      {
        "txt": "continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\""
      },
      {
        "txt": "+Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));"
      },
      {
        "txt": "} else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote"
      },
      {
        "txt": "int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ int len = raw.length; if ((outputPtr + len) > outputEnd) { _outputTail = outputPtr; _flushBuffer(); outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr; }"
      },
      {
        "txt": "System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; } if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer(); return _outputTail; } return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { do { int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)"
      },
      {
        "txt": "throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes; for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++]; if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; } }"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) } System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { int outputPtr = _outputTail;"
      },
      {
        "txt": "if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail; } final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++]; int ch = b;"
      },
      {
        "txt": "if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "} } _outputTail = outputPtr; } protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6;"
      },
      {
        "txt": "int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) {"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); }"
      },
      {
        "txt": "int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; } _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0;"
      },
      {
        "txt": "if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;"
      },
      {
        "txt": "b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) {"
      },
      {
        "txt": "inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;"
      },
      {
        "txt": "amount = 2; } else { amount = 1; } _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; } } return bytesLeft; }"
      },
      {
        "txt": "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;"
      },
      {
        "txt": "while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush"
      },
      {
        "txt": "_flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n';"
      },
      {
        "txt": "chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) {"
      },
      {
        "txt": "b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; } private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd,"
      },
      {
        "txt": "int maxRead) throws IOException { int i = 0; while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do {"
      },
      {
        "txt": "int length = maxRead - inputEnd; if (length == 0) { break; } int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3);"
      },
      {
        "txt": "return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException { if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(\"Split surrogate on writeRaw() input (last character)\"); }"
      },
      {
        "txt": "_outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; } } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; }"
      },
      {
        "txt": "protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2); if ((_outputTail + 4) > _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException { byte[] bbuf = _outputBuffer; if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];"
      },
      {
        "txt": "bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else { bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; } private final void _writeNull() throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 4) >= _outputEnd) { _flushBuffer(); } System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4); _outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) { int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0;"
      },
      {
        "txt": "} bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; return outputPtr; } protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) { _outputTail = 0;"
      },
      {
        "txt": "_outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  },
  {
    "id": 1273,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 672,
    "end-bug-line": 672,
    "bug": "",
    "fix": "private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException { main_loop: while (offset < end) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= end) { break main_loop; } } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, end); } } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import com.fasterxml.jackson.core.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{'; private final static byte BYTE_RCURLY = (byte) '}';"
      },
      {
        "txt": "private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' }; final protected OutputStream _outputStream;"
      },
      {
        "txt": "protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out)"
      },
      {
        "txt": "{ super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; if (isEnabled(Feature.ESCAPE_NON_ASCII)) {"
      },
      {
        "txt": "setHighestNonEscapedChar(127); } } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = bufferRecyclable;"
      },
      {
        "txt": "_outputTail = outputOffset; _outputBuffer = outputBuffer; _outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() { return _outputStream;"
      },
      {
        "txt": "} @Override public int getOutputBuffered() { return _outputTail; } @Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name);"
      },
      {
        "txt": "return; } final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true); return;"
      },
      {
        "txt": "} if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(name, 0, len);"
      },
      {
        "txt": "} else { _writeStringSegments(name, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeFieldName(SerializableString name) throws IOException"
      },
      {
        "txt": "{ if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeUnq(name); return; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len;"
      },
      {
        "txt": "} } @Override public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this); } else {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LBRACKET; } } @Override public final void writeEndArray() throws IOException { if (!_writeContext.inArray()) {"
      },
      {
        "txt": "_reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET; }"
      },
      {
        "txt": "_writeContext = _writeContext.clearAndGetParent(); } @Override public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this); } else {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LCURLY; } } @Override public final void writeEndObject() throws IOException { if (!_writeContext.inObject()) {"
      },
      {
        "txt": "_reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY; }"
      },
      {
        "txt": "_writeContext = _writeContext.clearAndGetParent(); } protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) { _cfgPrettyPrinter.writeObjectEntrySeparator(this);"
      },
      {
        "txt": "} else { _cfgPrettyPrinter.beforeObjectEntries(this); } if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { _writeStringSegments(name, true);"
      },
      {
        "txt": "return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(_charBuffer, 0, len); } else { _writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "protected final void _writePPFieldName(SerializableString name) throws IOException { final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this);"
      },
      {
        "txt": "} final boolean addQuotes = !_cfgUnqNames; // standard if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8()); if (addQuotes) {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } } @Override public void writeString(String text) throws IOException { _verifyValueWrite(WRITE_STRING);"
      },
      {
        "txt": "if (text == null) { _writeNull(); return; } final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; } if ((_outputTail + len) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "public void writeString(char[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(text, offset, len); } else { _writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public final void writeString(SerializableString text) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) {"
      },
      {
        "txt": "_writeBytes(text.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { _writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} @Override public void writeRaw(String text) throws IOException { writeRaw(text, 0, text.length()); } @Override public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer; while (len > 0) {"
      },
      {
        "txt": "int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); offset += len2; len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException {"
      },
      {
        "txt": "byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) {"
      },
      {
        "txt": "_writeBytes(raw); } } @Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { { int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) { if (_outputEnd < len3) { // wouldn't be enough..."
      },
      {
        "txt": "_writeSegmentedRaw(cbuf, offset, len); return; } _flushBuffer(); } } len += offset; // now marks the end main_loop: while (offset < len) { inner_loop:"
      },
      {
        "txt": "while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop; } }"
      },
      {
        "txt": "char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } } } @Override"
      },
      {
        "txt": "public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { } } private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd; final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len; main_loop:"
      },
      {
        "txt": "while (offset < inputEnd) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; } if (_outputTail >= end) { _flushBuffer(); }"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop; } } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte?"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } } <extra_id_0> @Override public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY);"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else { int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) {"
      },
      {
        "txt": "_reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes; } @Override public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return; } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 11) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} if (_cfgNumbersAsStrings) { _writeQuotedInt(i); return; } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private final void _writeQuotedInt(int i) throws IOException { if ((_outputTail + 13) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(long l) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if (_cfgNumbersAsStrings) { _writeQuotedLong(l); return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); } private final void _writeQuotedLong(long l) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 23) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(BigInteger value) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString()); } }"
      },
      {
        "txt": "@Override public void writeNumber(double d) throws IOException { if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d)); return; } _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "writeRaw(String.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(f)); return;"
      },
      {
        "txt": "} _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); } @Override public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull();"
      },
      {
        "txt": "} else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(value.toString()); } }"
      },
      {
        "txt": "@Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue); } }"
      },
      {
        "txt": "private final void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value); if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer(); } byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;"
      },
      {
        "txt": "int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); _outputTail += len; } @Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL); _writeNull(); }"
      },
      {
        "txt": "@Override protected final void _verifyValueWrite(String typeMsg) throws IOException { int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); } if (_cfgPrettyPrinter == null) { byte b; switch (status) {"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA; break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) { byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) {"
      },
      {
        "txt": "_writeBytes(raw); } } return; case JsonWriteContext.STATUS_OK_AS_IS: default: return; } if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail] = b; ++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status); } protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException { switch (status) {"
      },
      {
        "txt": "case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AS_IS:"
      },
      {
        "txt": "if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default: _throwInternal(); break; }"
      },
      {
        "txt": "} @Override public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } }"
      },
      {
        "txt": "} @Override public void close() throws IOException { super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) { JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) {"
      },
      {
        "txt": "writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else { break; } } } _flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered"
      },
      {
        "txt": "if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } _releaseBuffers(); } @Override"
      },
      {
        "txt": "protected void _releaseBuffers() { byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); } char[] cbuf = _charBuffer; if (cbuf != null) { _charBuffer = null;"
      },
      {
        "txt": "_ioContext.releaseConcatBuffer(cbuf); } } private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length; if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len);"
      },
      {
        "txt": "return; } } System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { if ((_outputTail + len) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len); return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeStringSegments(String text, boolean addQuotes) throws IOException {"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length(); int offset = 0; while (left > 0) { int len = Math.min(_outputMaxContiguous, left);"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; left -= len; } if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; } } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer();"
      },
      {
        "txt": "} _writeStringSegment(cbuf, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen);"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException"
      },
      {
        "txt": "{ len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) { break; }"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(cbuf, offset, len); } else {"
      },
      {
        "txt": "_writeStringSegmentASCII2(cbuf, offset, len); } } } private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "while (offset < len) { int ch = text.charAt(offset); if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) {"
      },
      {
        "txt": "if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len); } } } private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) {"
      },
      {
        "txt": "if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "} continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } }"
      },
      {
        "txt": "_outputTail = outputPtr; } private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH;"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; }"
      },
      {
        "txt": "if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr);"
      },
      {
        "txt": "continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;"
      },
      {
        "txt": "final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine"
      },
      {
        "txt": "outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else {"
      },
      {
        "txt": "outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) {"
      },
      {
        "txt": "outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } }"
      },
      {
        "txt": "_outputTail = outputPtr; } private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); } outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);"
      },
      {
        "txt": "} else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } SerializableString esc = customEscapes.getEscapeSequence(ch);"
      },
      {
        "txt": "if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length; if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);"
      },
      {
        "txt": "} System.arraycopy(raw, 0, outputBuffer, outputPtr, len); return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException { int len = raw.length; if ((outputPtr + len) > outputEnd) {"
      },
      {
        "txt": "_outputTail = outputPtr; _flushBuffer(); outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr; } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); outputPtr += len; }"
      },
      {
        "txt": "if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer(); return _outputTail; } return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { do {"
      },
      {
        "txt": "int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { final int[] escCodes = _outputEscapes;"
      },
      {
        "txt": "for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++]; if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; } } if ((_outputTail + len) > _outputEnd) { // enough room or need to flush? _flushBuffer(); // but yes once we flush (caller guarantees length restriction) }"
      },
      {
        "txt": "System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) { _flushBuffer(); outputPtr = _outputTail;"
      },
      {
        "txt": "} final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++]; int ch = b; if (ch < 0 || escCodes[ch] == 0) { outputBuffer[outputPtr++] = b; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } } _outputTail = outputPtr;"
      },
      {
        "txt": "} protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush"
      },
      {
        "txt": "_flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2;"
      },
      {
        "txt": "} } int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16; if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;"
      },
      {
        "txt": "} _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0;"
      },
      {
        "txt": "int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; }"
      },
      {
        "txt": "lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);"
      },
      {
        "txt": "if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output?"
      },
      {
        "txt": "if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } else { amount = 1;"
      },
      {
        "txt": "} _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; } } return bytesLeft; } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);"
      },
      {
        "txt": "inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8;"
      },
      {
        "txt": "b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } }"
      },
      {
        "txt": "if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; }"
      },
      {
        "txt": "bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; } private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { int i = 0;"
      },
      {
        "txt": "while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd; if (length == 0) { break;"
      },
      {
        "txt": "} int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3); return inputEnd; } private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)"
      },
      {
        "txt": "throws IOException { if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down _reportError(\"Split surrogate on writeRaw() input (last character)\"); } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; }"
      },
      {
        "txt": "} final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; } protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2);"
      },
      {
        "txt": "if ((_outputTail + 4) > _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException"
      },
      {
        "txt": "{ byte[] bbuf = _outputBuffer; if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else {"
      },
      {
        "txt": "bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; } private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4); _outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) {"
      },
      {
        "txt": "int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];"
      },
      {
        "txt": "return outputPtr; } protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) { _outputTail = 0; _outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  },
  {
    "id": 1274,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java",
    "start-bug-line": 1887,
    "end-bug-line": 1887,
    "bug": "_reportError(\"Split surrogate on writeRaw() input (last character)\");",
    "fix": "_reportError(String.format( \"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.*; public class UTF8JsonGenerator extends JsonGeneratorImpl { private final static byte BYTE_u = (byte) 'u'; private final static byte BYTE_0 = (byte) '0'; private final static byte BYTE_LBRACKET = (byte) '['; private final static byte BYTE_RBRACKET = (byte) ']'; private final static byte BYTE_LCURLY = (byte) '{';"
      },
      {
        "txt": "private final static byte BYTE_RCURLY = (byte) '}'; private final static byte BYTE_BACKSLASH = (byte) '\\\\'; private final static byte BYTE_COMMA = (byte) ','; private final static byte BYTE_COLON = (byte) ':'; private final static byte BYTE_QUOTE = (byte) '\"'; private final static int MAX_BYTES_TO_BUFFER = 512; private final static byte[] HEX_CHARS = CharTypes.copyHexBytes(); private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' }; private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' }; private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };"
      },
      {
        "txt": "final protected OutputStream _outputStream; protected byte[] _outputBuffer; protected int _outputTail; protected final int _outputEnd; protected final int _outputMaxContiguous; protected char[] _charBuffer; protected final int _charBufferLength; protected byte[] _entityBuffer; protected boolean _bufferRecyclable; public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,"
      },
      {
        "txt": "OutputStream out) { super(ctxt, features, codec); _outputStream = out; _bufferRecyclable = true; _outputBuffer = ctxt.allocWriteEncodingBuffer(); _outputEnd = _outputBuffer.length; _outputMaxContiguous = _outputEnd >> 3; _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length;"
      },
      {
        "txt": "if (isEnabled(Feature.ESCAPE_NON_ASCII)) { setHighestNonEscapedChar(127); } } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable) { super(ctxt, features, codec); _outputStream = out;"
      },
      {
        "txt": "_bufferRecyclable = bufferRecyclable; _outputTail = outputOffset; _outputBuffer = outputBuffer; _outputEnd = _outputBuffer.length; _outputMaxContiguous = (_outputEnd >> 3); _charBuffer = ctxt.allocConcatBuffer(); _charBufferLength = _charBuffer.length; } @Override public Object getOutputTarget() {"
      },
      {
        "txt": "return _outputStream; } @Override public int getOutputBuffered() { return _outputTail; } @Override public void writeFieldName(String name) throws IOException { if (_cfgPrettyPrinter != null) {"
      },
      {
        "txt": "_writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) { // no, offline _writeStringSegments(name, true);"
      },
      {
        "txt": "return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); }"
      },
      {
        "txt": "_writeStringSegment(name, 0, len); } else { _writeStringSegments(name, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override"
      },
      {
        "txt": "public void writeFieldName(SerializableString name) throws IOException { if (_cfgPrettyPrinter != null) { _writePPFieldName(name); return; } final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); }"
      },
      {
        "txt": "if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_COMMA; } if (_cfgUnqNames) { _writeUnq(name); return; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { // couldn't append, bit longer processing _writeBytes(name.asQuotedUTF8()); } else { _outputTail += len; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } private final void _writeUnq(SerializableString name) throws IOException { int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); if (len < 0) { _writeBytes(name.asQuotedUTF8()); } else {"
      },
      {
        "txt": "_outputTail += len; } } @Override public final void writeStartArray() throws IOException { _verifyValueWrite(\"start an array\"); _writeContext = _writeContext.createChildArrayContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartArray(this);"
      },
      {
        "txt": "} else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LBRACKET; } } @Override public final void writeEndArray() throws IOException {"
      },
      {
        "txt": "if (!_writeContext.inArray()) { _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RBRACKET;"
      },
      {
        "txt": "} _writeContext = _writeContext.clearAndGetParent(); } @Override public final void writeStartObject() throws IOException { _verifyValueWrite(\"start an object\"); _writeContext = _writeContext.createChildObjectContext(); if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeStartObject(this);"
      },
      {
        "txt": "} else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_LCURLY; } } @Override public final void writeEndObject() throws IOException {"
      },
      {
        "txt": "if (!_writeContext.inObject()) { _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_RCURLY;"
      },
      {
        "txt": "} _writeContext = _writeContext.clearAndGetParent(); } protected final void _writePPFieldName(String name) throws IOException { int status = _writeContext.writeFieldName(name); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {"
      },
      {
        "txt": "_cfgPrettyPrinter.writeObjectEntrySeparator(this); } else { _cfgPrettyPrinter.beforeObjectEntries(this); } if (_cfgUnqNames) { _writeStringSegments(name, false); return; } final int len = name.length(); if (len > _charBufferLength) {"
      },
      {
        "txt": "_writeStringSegments(name, true); return; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; name.getChars(0, len, _charBuffer, 0); if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space"
      },
      {
        "txt": "_flushBuffer(); } _writeStringSegment(_charBuffer, 0, len); } else { _writeStringSegments(_charBuffer, 0, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} protected final void _writePPFieldName(SerializableString name) throws IOException { final int status = _writeContext.writeFieldName(name.getValue()); if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { _reportError(\"Can not write a field name, expecting a value\"); } if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { _cfgPrettyPrinter.writeObjectEntrySeparator(this); } else {"
      },
      {
        "txt": "_cfgPrettyPrinter.beforeObjectEntries(this); } final boolean addQuotes = !_cfgUnqNames; // standard if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } _writeBytes(name.asQuotedUTF8());"
      },
      {
        "txt": "if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } } @Override public void writeString(String text) throws IOException {"
      },
      {
        "txt": "_verifyValueWrite(WRITE_STRING); if (text == null) { _writeNull(); return; } final int len = text.length(); if (len > _outputMaxContiguous) { // nope: off-line handling _writeStringSegments(text, true); return; }"
      },
      {
        "txt": "if ((_outputTail + len) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeStringSegment(text, 0, len); // we checked space already above if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeString(char[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space"
      },
      {
        "txt": "_flushBuffer(); } _writeStringSegment(text, offset, len); } else { _writeStringSegments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE;"
      },
      {
        "txt": "} @Override public final void writeString(SerializableString text) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);"
      },
      {
        "txt": "if (len < 0) { _writeBytes(text.asQuotedUTF8()); } else { _outputTail += len; } if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBytes(text, offset, length); if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeUTF8String(byte[] text, int offset, int len) throws IOException { _verifyValueWrite(WRITE_STRING); if (_outputTail >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} _outputBuffer[_outputTail++] = BYTE_QUOTE; if (len <= _outputMaxContiguous) { _writeUTF8Segment(text, offset, len); } else { _writeUTF8Segments(text, offset, len); } if (_outputTail >= _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeRaw(String text) throws IOException { writeRaw(text, 0, text.length()); } @Override public void writeRaw(String text, int offset, int len) throws IOException { final char[] buf = _charBuffer;"
      },
      {
        "txt": "while (len > 0) { int len2 = Math.min(buf.length, len); text.getChars(offset, offset+len2, buf, 0); writeRaw(buf, 0, len2); offset += len2; len -= len2; } } @Override public void writeRaw(SerializableString text) throws IOException"
      },
      {
        "txt": "{ byte[] raw = text.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } @Override public void writeRawValue(SerializableString text) throws IOException { _verifyValueWrite(WRITE_RAW); byte[] raw = text.asUnquotedUTF8();"
      },
      {
        "txt": "if (raw.length > 0) { _writeBytes(raw); } } @Override public final void writeRaw(char[] cbuf, int offset, int len) throws IOException { { int len3 = len+len+len; if ((_outputTail + len3) > _outputEnd) {"
      },
      {
        "txt": "if (_outputEnd < len3) { // wouldn't be enough... _writeSegmentedRaw(cbuf, offset, len); return; } _flushBuffer(); } } len += offset; // now marks the end main_loop: while (offset < len) {"
      },
      {
        "txt": "inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch > 0x7F) { break inner_loop; } _outputBuffer[_outputTail++] = (byte) ch; if (++offset >= len) { break main_loop; }"
      },
      {
        "txt": "} char ch = cbuf[offset++]; if (ch < 0x800) { // 2-byte? _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, len); } } }"
      },
      {
        "txt": "@Override public void writeRaw(char ch) throws IOException { if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; if (ch <= 0x7F) { bbuf[_outputTail++] = (byte) ch; } else if (ch < 0x800) { // 2-byte?"
      },
      {
        "txt": "bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { } } private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException { final int end = _outputEnd; final byte[] bbuf = _outputBuffer; final int inputEnd = offset + len;"
      },
      {
        "txt": "main_loop: while (offset < inputEnd) { inner_loop: while (true) { int ch = (int) cbuf[offset]; if (ch >= 0x80) { break inner_loop; } if (_outputTail >= end) { _flushBuffer();"
      },
      {
        "txt": "} bbuf[_outputTail++] = (byte) ch; if (++offset >= inputEnd) { break main_loop; } } if ((_outputTail + 3) >= _outputEnd) { _flushBuffer(); } char ch = cbuf[offset++];"
      },
      {
        "txt": "if (ch < 0x800) { // 2-byte? bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); } else { offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd); } } } @Override public void writeBinary(Base64Variant b64variant,"
      },
      {
        "txt": "byte[] data, int offset, int len) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY); if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _writeBinary(b64variant, data, offset, offset+len); if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { _verifyValueWrite(WRITE_BINARY);"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; byte[] encodingBuffer = _ioContext.allocBase64Buffer(); int bytes; try { if (dataLength < 0) { // length unknown bytes = _writeBinary(b64variant, data, encodingBuffer); } else {"
      },
      {
        "txt": "int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); if (missing > 0) { _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\"); } bytes = dataLength; } } finally { _ioContext.releaseBase64Buffer(encodingBuffer); } if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; return bytes; } @Override public void writeNumber(short s) throws IOException { _verifyValueWrite(WRITE_NUMBER); if ((_outputTail + 6) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedShort(s); return; } _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); } private final void _writeQuotedShort(short s) throws IOException { if ((_outputTail + 8) >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(int i) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if ((_outputTail + 11) >= _outputEnd) { _flushBuffer(); } if (_cfgNumbersAsStrings) { _writeQuotedInt(i); return; } _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); } private final void _writeQuotedInt(int i) throws IOException"
      },
      {
        "txt": "{ if ((_outputTail + 13) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeNumber(long l) throws IOException"
      },
      {
        "txt": "{ _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedLong(l); return; } if ((_outputTail + 21) >= _outputEnd) { _flushBuffer(); } _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);"
      },
      {
        "txt": "} private final void _writeQuotedLong(long l) throws IOException { if ((_outputTail + 23) >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); _outputBuffer[_outputTail++] = BYTE_QUOTE; }"
      },
      {
        "txt": "@Override public void writeNumber(BigInteger value) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { _writeQuotedRaw(value.toString()); } else { writeRaw(value.toString());"
      },
      {
        "txt": "} } @Override public void writeNumber(double d) throws IOException { if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) { writeString(String.valueOf(d)); return;"
      },
      {
        "txt": "} _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(d)); } @Override public void writeNumber(float f) throws IOException { if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {"
      },
      {
        "txt": "writeString(String.valueOf(f)); return; } _verifyValueWrite(WRITE_NUMBER); writeRaw(String.valueOf(f)); } @Override public void writeNumber(BigDecimal value) throws IOException { _verifyValueWrite(WRITE_NUMBER);"
      },
      {
        "txt": "if (value == null) { _writeNull(); } else if (_cfgNumbersAsStrings) { String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString(); _writeQuotedRaw(raw); } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) { writeRaw(value.toPlainString()); } else { writeRaw(value.toString());"
      },
      {
        "txt": "} } @Override public void writeNumber(String encodedValue) throws IOException { _verifyValueWrite(WRITE_NUMBER); if (_cfgNumbersAsStrings) { _writeQuotedRaw(encodedValue); } else { writeRaw(encodedValue);"
      },
      {
        "txt": "} } private final void _writeQuotedRaw(String value) throws IOException { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; writeRaw(value); if (_outputTail >= _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } @Override public void writeBoolean(boolean state) throws IOException { _verifyValueWrite(WRITE_BOOLEAN); if ((_outputTail + 5) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES; int len = keyword.length; System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len); _outputTail += len; } @Override public void writeNull() throws IOException { _verifyValueWrite(WRITE_NULL);"
      },
      {
        "txt": "_writeNull(); } @Override protected final void _verifyValueWrite(String typeMsg) throws IOException { int status = _writeContext.writeValue(); if (status == JsonWriteContext.STATUS_EXPECT_NAME) { _reportError(\"Can not \"+typeMsg+\", expecting field name\"); } if (_cfgPrettyPrinter == null) {"
      },
      {
        "txt": "byte b; switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: b = BYTE_COMMA; break; case JsonWriteContext.STATUS_OK_AFTER_COLON: b = BYTE_COLON; break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator if (_rootValueSeparator != null) {"
      },
      {
        "txt": "byte[] raw = _rootValueSeparator.asUnquotedUTF8(); if (raw.length > 0) { _writeBytes(raw); } } return; case JsonWriteContext.STATUS_OK_AS_IS: default: return; }"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail] = b; ++_outputTail; return; } _verifyPrettyValueWrite(typeMsg, status); } protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException"
      },
      {
        "txt": "{ switch (status) { case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array _cfgPrettyPrinter.writeArrayValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_COLON: _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); break; case JsonWriteContext.STATUS_OK_AFTER_SPACE: _cfgPrettyPrinter.writeRootValueSeparator(this);"
      },
      {
        "txt": "break; case JsonWriteContext.STATUS_OK_AS_IS: if (_writeContext.inArray()) { _cfgPrettyPrinter.beforeArrayValues(this); } else if (_writeContext.inObject()) { _cfgPrettyPrinter.beforeObjectEntries(this); } break; default: _throwInternal();"
      },
      {
        "txt": "break; } } @Override public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush();"
      },
      {
        "txt": "} } } @Override public void close() throws IOException { super.close(); if ((_outputBuffer != null) && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { while (true) {"
      },
      {
        "txt": "JsonStreamContext ctxt = getOutputContext(); if (ctxt.inArray()) { writeEndArray(); } else if (ctxt.inObject()) { writeEndObject(); } else { break; } } }"
      },
      {
        "txt": "_flushBuffer(); _outputTail = 0; // just to ensure we don't think there's anything buffered if (_outputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { _outputStream.close(); } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } _releaseBuffers();"
      },
      {
        "txt": "} @Override protected void _releaseBuffers() { byte[] buf = _outputBuffer; if (buf != null && _bufferRecyclable) { _outputBuffer = null; _ioContext.releaseWriteEncodingBuffer(buf); } char[] cbuf = _charBuffer;"
      },
      {
        "txt": "if (cbuf != null) { _charBuffer = null; _ioContext.releaseConcatBuffer(cbuf); } } private final void _writeBytes(byte[] bytes) throws IOException { final int len = bytes.length; if ((_outputTail + len) > _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, 0, len); return; } } System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException {"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { _flushBuffer(); if (len > MAX_BYTES_TO_BUFFER) { _outputStream.write(bytes, offset, len); return; } } System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); _outputTail += len; }"
      },
      {
        "txt": "private final void _writeStringSegments(String text, boolean addQuotes) throws IOException { if (addQuotes) { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } int left = text.length(); int offset = 0;"
      },
      {
        "txt": "while (left > 0) { int len = Math.min(_outputMaxContiguous, left); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; left -= len; } if (addQuotes) {"
      },
      {
        "txt": "if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = BYTE_QUOTE; } } private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException { do { int len = Math.min(_outputMaxContiguous, totalLen);"
      },
      {
        "txt": "if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(cbuf, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException {"
      },
      {
        "txt": "do { int len = Math.min(_outputMaxContiguous, totalLen); if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space _flushBuffer(); } _writeStringSegment(text, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); }"
      },
      {
        "txt": "private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = cbuf[offset]; if (ch > 0x7F || escCodes[ch] != 0) {"
      },
      {
        "txt": "break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; } _outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(cbuf, offset, len); } else if (_maximumNonEscapedChar == 0) {"
      },
      {
        "txt": "_writeStringSegment2(cbuf, offset, len); } else { _writeStringSegmentASCII2(cbuf, offset, len); } } } private final void _writeStringSegment(String text, int offset, int len) throws IOException { len += offset; // becomes end marker, then int outputPtr = _outputTail;"
      },
      {
        "txt": "final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < len) { int ch = text.charAt(offset); if (ch > 0x7F || escCodes[ch] != 0) { break; } outputBuffer[outputPtr++] = (byte) ch; ++offset; }"
      },
      {
        "txt": "_outputTail = outputPtr; if (offset < len) { if (_characterEscapes != null) { _writeCustomStringSegment2(text, offset, len); } else if (_maximumNonEscapedChar == 0) { _writeStringSegment2(text, offset, len); } else { _writeStringSegmentASCII2(text, offset, len); } }"
      },
      {
        "txt": "} private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) {"
      },
      {
        "txt": "int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape;"
      },
      {
        "txt": "} else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr);"
      },
      {
        "txt": "} } _outputTail = outputPtr; } private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail;"
      },
      {
        "txt": "final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch];"
      },
      {
        "txt": "if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) {"
      },
      {
        "txt": "outputBuffer[outputPtr++] = (byte) ch; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); }"
      },
      {
        "txt": "continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); }"
      },
      {
        "txt": "int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = _maximumNonEscapedChar; while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; }"
      },
      {
        "txt": "if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail; final byte[] outputBuffer = _outputBuffer;"
      },
      {
        "txt": "final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = cbuf[offset++]; if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue; }"
      },
      {
        "txt": "int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\"); }"
      },
      {
        "txt": "outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue; }"
      },
      {
        "txt": "SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else { outputPtr = _outputMultiByteChar(ch, outputPtr);"
      },
      {
        "txt": "} } _outputTail = outputPtr; } private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException { if ((_outputTail + 6 * (end - offset)) > _outputEnd) { _flushBuffer(); } int outputPtr = _outputTail;"
      },
      {
        "txt": "final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; final CharacterEscapes customEscapes = _characterEscapes; // non-null while (offset < end) { int ch = text.charAt(offset++); if (ch <= 0x7F) { if (escCodes[ch] == 0) { outputBuffer[outputPtr++] = (byte) ch; continue;"
      },
      {
        "txt": "} int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc == null) { _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\" +Integer.toHexString(ch)+\", although was supposed to have one\");"
      },
      {
        "txt": "} outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); } else { outputPtr = _writeGenericEscape(ch, outputPtr); } continue; } if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars: outputPtr = _writeGenericEscape(ch, outputPtr); continue;"
      },
      {
        "txt": "} SerializableString esc = customEscapes.getEscapeSequence(ch); if (esc != null) { outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset); continue; } if (ch <= 0x7FF) { // fine, just needs 2 byte output outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } else {"
      },
      {
        "txt": "outputPtr = _outputMultiByteChar(ch, outputPtr); } } _outputTail = outputPtr; } private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote int len = raw.length;"
      },
      {
        "txt": "if (len > 6) { // may violate constraints we have, do offline return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); } System.arraycopy(raw, 0, outputBuffer, outputPtr, len); return (outputPtr + len); } private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "int len = raw.length; if ((outputPtr + len) > outputEnd) { _outputTail = outputPtr; _flushBuffer(); outputPtr = _outputTail; if (len > outputBuffer.length) { // very unlikely, but possible... _outputStream.write(raw, 0, len); return outputPtr; } System.arraycopy(raw, 0, outputBuffer, outputPtr, len);"
      },
      {
        "txt": "outputPtr += len; } if ((outputPtr + 6 * remainingChars) > outputEnd) { _flushBuffer(); return _outputTail; } return outputPtr; } private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ do { int len = Math.min(_outputMaxContiguous, totalLen); _writeUTF8Segment(utf8, offset, len); offset += len; totalLen -= len; } while (totalLen > 0); } private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException"
      },
      {
        "txt": "{ final int[] escCodes = _outputEscapes; for (int ptr = offset, end = offset + len; ptr < end; ) { int ch = utf8[ptr++]; if ((ch >= 0) && escCodes[ch] != 0) { _writeUTF8Segment2(utf8, offset, len); return; } } if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?"
      },
      {
        "txt": "_flushBuffer(); // but yes once we flush (caller guarantees length restriction) } System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); _outputTail += len; } private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { int outputPtr = _outputTail; if ((outputPtr + (len * 6)) > _outputEnd) {"
      },
      {
        "txt": "_flushBuffer(); outputPtr = _outputTail; } final byte[] outputBuffer = _outputBuffer; final int[] escCodes = _outputEscapes; len += offset; // so 'len' becomes 'end' while (offset < len) { byte b = utf8[offset++]; int ch = b; if (ch < 0 || escCodes[ch] == 0) {"
      },
      {
        "txt": "outputBuffer[outputPtr++] = b; continue; } int escape = escCodes[ch]; if (escape > 0) { // 2-char escape, fine outputBuffer[outputPtr++] = BYTE_BACKSLASH; outputBuffer[outputPtr++] = (byte) escape; } else { outputPtr = _writeGenericEscape(ch, outputPtr); }"
      },
      {
        "txt": "} _outputTail = outputPtr; } protected final void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { int safeInputEnd = inputEnd - 3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;"
      },
      {
        "txt": "while (inputPtr <= safeInputEnd) { if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 8; b24 |= ((int) input[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\';"
      },
      {
        "txt": "_outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } int inputLeft = inputEnd - inputPtr; // 0, 1 or 2 if (inputLeft > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) input[inputPtr++]) << 16;"
      },
      {
        "txt": "if (inputLeft == 2) { b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; } _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); } } protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException {"
      },
      {
        "txt": "int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (bytesLeft > 2) { // main loop for full triplets if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes"
      },
      {
        "txt": "break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);"
      },
      {
        "txt": "bytesLeft -= 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (bytesLeft > 0) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);"
      },
      {
        "txt": "inputPtr = 0; if (inputEnd > 0) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2;"
      },
      {
        "txt": "} else { amount = 1; } _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); bytesLeft -= amount; } } return bytesLeft; } protected final int _writeBinary(Base64Variant b64variant,"
      },
      {
        "txt": "InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) {"
      },
      {
        "txt": "if (inputPtr > lastFullOffset) { // need to load more inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { // required to try to read to have at least 3 bytes break; } lastFullOffset = inputEnd-3; } if (_outputTail > safeOutputEnd) { // need to flush _flushBuffer();"
      },
      {
        "txt": "} int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2;"
      },
      {
        "txt": "} } if (inputPtr < inputEnd) { // yes, but do we have room for output? if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but... _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;"
      },
      {
        "txt": "amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; } private final int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException"
      },
      {
        "txt": "{ int i = 0; while (inputPtr < inputEnd) { readBuffer[i++] = readBuffer[inputPtr++]; } inputPtr = 0; inputEnd = i; maxRead = Math.min(maxRead, readBuffer.length); do { int length = maxRead - inputEnd;"
      },
      {
        "txt": "if (length == 0) { break; } int count = in.read(readBuffer, inputEnd, length); if (count < 0) { return inputEnd; } inputEnd += count; } while (inputEnd < 3); return inputEnd;"
      },
      {
        "txt": "private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd) throws IOException { if (ch >= SURR1_FIRST) { if (ch <= SURR2_LAST) { // yes, outside of BMP if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down <extra_id_0> } _outputSurrogates(ch, cbuf[inputOffset]); return inputOffset+1; } } final byte[] bbuf = _outputBuffer;"
      },
      {
        "txt": "} final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12)); bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); return inputOffset; } protected final void _outputSurrogates(int surr1, int surr2) throws IOException { int c = _decodeSurrogate(surr1, surr2);"
      },
      {
        "txt": "if ((_outputTail + 4) > _outputEnd) { _flushBuffer(); } final byte[] bbuf = _outputBuffer; bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f)); bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f)); } private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException"
      },
      {
        "txt": "{ byte[] bbuf = _outputBuffer; if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; } else {"
      },
      {
        "txt": "bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); } return outputPtr; } private final void _writeNull() throws IOException { if ((_outputTail + 4) >= _outputEnd) { _flushBuffer();"
      },
      {
        "txt": "} System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4); _outputTail += 4; } private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { final byte[] bbuf = _outputBuffer; bbuf[outputPtr++] = BYTE_BACKSLASH; bbuf[outputPtr++] = BYTE_u; if (charToEscape > 0xFF) {"
      },
      {
        "txt": "int hi = (charToEscape >> 8) & 0xFF; bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; charToEscape &= 0xFF; } else { bbuf[outputPtr++] = BYTE_0; bbuf[outputPtr++] = BYTE_0; } bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];"
      },
      {
        "txt": "return outputPtr; } protected final void _flushBuffer() throws IOException { int len = _outputTail; if (len > 0) { _outputTail = 0; _outputStream.write(_outputBuffer, 0, len); } }"
      }
    ]
  }
]