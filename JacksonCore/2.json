[
  {
    "id": 1212,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 952,
    "end-bug-line": 952,
    "bug": "",
    "fix": "if (_parsingContext.inRoot()) { _verifyRootSpace(ch); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer; import com.fasterxml.jackson.core.util.*;"
      },
      {
        "txt": "public final class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected Reader _reader; protected char[] _inputBuffer; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed;"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed();"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override"
      },
      {
        "txt": "public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count; }"
      },
      {
        "txt": "@Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_reader != null) {"
      },
      {
        "txt": "int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd); }"
      },
      {
        "txt": "} return false; } protected char getNextChar(String eofMsg) throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg); }"
      },
      {
        "txt": "} return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close(); }"
      },
      {
        "txt": "_reader = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); char[] buf = _inputBuffer; if (buf != null) {"
      },
      {
        "txt": "_inputBuffer = null; _ioContext.releaseTokenBuffer(buf); } } @Override public String getText() throws IOException, JsonParseException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(t); } @Override public String getValueAsString() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }"
      },
      {
        "txt": "@Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); }"
      },
      {
        "txt": "return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName();"
      },
      {
        "txt": "case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);"
      },
      {
        "txt": "} else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null;"
      },
      {
        "txt": "} @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING:"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; }"
      },
      {
        "txt": "} return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME: return 0;"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: }"
      },
      {
        "txt": "} return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");"
      },
      {
        "txt": "} if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) {"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf);"
      },
      {
        "txt": "} finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0;"
      },
      {
        "txt": "while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square?"
      },
      {
        "txt": "if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) {"
      },
      {
        "txt": "outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null);"
      },
      {
        "txt": "} _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) {"
      },
      {
        "txt": "if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } boolean inObject = _parsingContext.inObject(); if (inObject) { String name = _parseName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); } JsonToken t; switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE;"
      },
      {
        "txt": "break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-':"
      },
      {
        "txt": "case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "t = _parseNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; }"
      },
      {
        "txt": "_currToken = t; return t; } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException @Override public String nextTextValue()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false; JsonToken t = _nextToken;"
      },
      {
        "txt": "_nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE;"
      },
      {
        "txt": "case VALUE_FALSE: return Boolean.FALSE; default: return null; } } @Override public void close() throws IOException { super.close();"
      },
      {
        "txt": "_symbols.release(); } protected JsonToken _parseNumber(int ch) throws IOException { boolean negative = (ch == INT_MINUS); int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; dummy_loop: do { // dummy loop, to be able to break out"
      },
      {
        "txt": "if (negative) { // need to read the next digit if (ptr >= _inputEnd) { break dummy_loop; } ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } }"
      },
      {
        "txt": "if (ch == INT_0) { break dummy_loop; } int intLen = 1; // already got one int_loop: while (true) { if (ptr >= _inputEnd) { break dummy_loop; } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) { if (ptr >= inputLen) {"
      },
      {
        "txt": "break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");"
      },
      {
        "txt": "} } int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now if (ptr >= inputLen) {"
      },
      {
        "txt": "break dummy_loop; } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; <extra_id_0> _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen); } while (false); _inputPtr = negative ? (startPtr+1) : startPtr; return _parseNumber2(negative); }"
      },
      {
        "txt": "return _parseNumber2(negative); } private JsonToken _parseNumber2(boolean negative) throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (negative) { outBuf[outPtr++] = '-'; } int intLen = 0;"
      },
      {
        "txt": "char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') { ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true; break int_loop; } c = _inputBuffer[_inputPtr++]; }"
      },
      {
        "txt": "if (intLen == 0) { reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\"); } int fractLen = 0; if (c == '.') { // yes, fraction outBuf[outPtr++] = c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true;"
      },
      {
        "txt": "break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = _inputBuffer[_inputPtr++]; } if (expLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return reset(negative, intLen, fractLen, expLen); } private char _verifyNoLeadingZeroes() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd && !loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\");"
      },
      {
        "txt": "} ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0'; } ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return"
      },
      {
        "txt": "break; } } } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);"
      },
      {
        "txt": "} _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); }"
      },
      {
        "txt": "} reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected String _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } int ptr = _inputPtr;"
      },
      {
        "txt": "int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) {"
      },
      {
        "txt": "if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset();"
      },
      {
        "txt": "int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { // identifier, and not a number firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); } else { firstOk = Character.isJavaIdentifierPart((char) i); }"
      },
      {
        "txt": "if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr]; if (ch < maxCode) {"
      },
      {
        "txt": "if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); }"
      },
      {
        "txt": "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); } protected String _parseAposName() throws IOException {"
      },
      {
        "txt": "int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch == '\\'') { int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); }"
      },
      {
        "txt": "int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos();"
      },
      {
        "txt": "} break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I':"
      },
      {
        "txt": "_matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue();"
      },
      {
        "txt": "} } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; }"
      },
      {
        "txt": "protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break; } if (i < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) { break;"
      },
      {
        "txt": "} } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); }"
      },
      {
        "txt": "} @Override protected void _finishString() throws IOException { int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do {"
      },
      {
        "txt": "int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1; return; } break; } ++ptr;"
      },
      {
        "txt": "} while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2(); } protected void _finishString2() throws IOException { char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) {"
      },
      {
        "txt": "c = _decodeEscaped(); } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; int inputPtr = _inputPtr; int inputLen = _inputEnd; char[] inputBuffer = _inputBuffer; while (true) { if (inputPtr >= inputLen) { _inputPtr = inputPtr; if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); }"
      },
      {
        "txt": "inputPtr = _inputPtr; inputLen = _inputEnd; } char c = inputBuffer[inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inputPtr; c = _decodeEscaped(); inputPtr = _inputPtr;"
      },
      {
        "txt": "inputLen = _inputEnd; } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inputPtr; break; } if (i < INT_SPACE) { _inputPtr = inputPtr; _throwUnquotedSpace(i, \"string value\"); }"
      },
      {
        "txt": "} } } } protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') { ++_inputPtr; }"
      },
      {
        "txt": "} ++_currInputRow; _currInputRowStart = _inputPtr; } private int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) {"
      },
      {
        "txt": "return i; } switch (codes[i]) { case -1: _throwInvalidSpace(i); case 0: return i; case 1: continue; case '\\n':"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r': _skipCR(); break; case '/': _skipComment(); break; case '#':"
      },
      {
        "txt": "if (!_skipYAMLComment()) { return i; } break; } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException {"
      },
      {
        "txt": "final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) { return i; } switch (codes[i]) { case -1: _throwInvalidSpace(i); case 0:"
      },
      {
        "txt": "return i; case 1: continue; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r': _skipCR(); break;"
      },
      {
        "txt": "case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; } }"
      },
      {
        "txt": "_handleEOF(); return -1; } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\");"
      },
      {
        "txt": "} char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } }"
      },
      {
        "txt": "private void _skipCComment() throws IOException { main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !loadMore()) { break main_loop; }"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private void _skipLine() throws IOException {"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) { _skipCR(); break;"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t';"
      },
      {
        "txt": "case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/': case '\\\\': return c;"
      },
      {
        "txt": "case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\");"
      },
      {
        "txt": "} } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value;"
      },
      {
        "txt": "} protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i)); } }"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd) { if (!loadMore()) { return; } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } return; } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "} while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; }"
      },
      {
        "txt": "} int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4;"
      },
      {
        "txt": "builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "builder.appendThreeBytes(decodedData); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart);"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) { break; }"
      },
      {
        "txt": "++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"); }"
      }
    ]
  },
  {
    "id": 1213,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 1081,
    "end-bug-line": 1081,
    "bug": "",
    "fix": "if (_parsingContext.inRoot()) { _verifyRootSpace(c); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer; import com.fasterxml.jackson.core.util.*;"
      },
      {
        "txt": "public final class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected Reader _reader; protected char[] _inputBuffer; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed;"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed();"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override"
      },
      {
        "txt": "public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count; }"
      },
      {
        "txt": "@Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_reader != null) {"
      },
      {
        "txt": "int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd); }"
      },
      {
        "txt": "} return false; } protected char getNextChar(String eofMsg) throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg); }"
      },
      {
        "txt": "} return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close(); }"
      },
      {
        "txt": "_reader = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); char[] buf = _inputBuffer; if (buf != null) {"
      },
      {
        "txt": "_inputBuffer = null; _ioContext.releaseTokenBuffer(buf); } } @Override public String getText() throws IOException, JsonParseException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(t); } @Override public String getValueAsString() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }"
      },
      {
        "txt": "@Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); }"
      },
      {
        "txt": "return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName();"
      },
      {
        "txt": "case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);"
      },
      {
        "txt": "} else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null;"
      },
      {
        "txt": "} @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING:"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; }"
      },
      {
        "txt": "} return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME: return 0;"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: }"
      },
      {
        "txt": "} return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");"
      },
      {
        "txt": "} if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) {"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf);"
      },
      {
        "txt": "} finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0;"
      },
      {
        "txt": "while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square?"
      },
      {
        "txt": "if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) {"
      },
      {
        "txt": "outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null);"
      },
      {
        "txt": "} _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) {"
      },
      {
        "txt": "if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } boolean inObject = _parsingContext.inObject(); if (inObject) { String name = _parseName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); } JsonToken t; switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE;"
      },
      {
        "txt": "break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-':"
      },
      {
        "txt": "case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "t = _parseNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; }"
      },
      {
        "txt": "_currToken = t; return t; } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException @Override public String nextTextValue()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false; JsonToken t = _nextToken;"
      },
      {
        "txt": "_nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE;"
      },
      {
        "txt": "case VALUE_FALSE: return Boolean.FALSE; default: return null; } } @Override public void close() throws IOException { super.close();"
      },
      {
        "txt": "_symbols.release(); } protected JsonToken _parseNumber(int ch) throws IOException { boolean negative = (ch == INT_MINUS); int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; dummy_loop: do { // dummy loop, to be able to break out"
      },
      {
        "txt": "if (negative) { // need to read the next digit if (ptr >= _inputEnd) { break dummy_loop; } ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } }"
      },
      {
        "txt": "if (ch == INT_0) { break dummy_loop; } int intLen = 1; // already got one int_loop: while (true) { if (ptr >= _inputEnd) { break dummy_loop; } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) { if (ptr >= inputLen) {"
      },
      {
        "txt": "break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");"
      },
      {
        "txt": "} } int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now if (ptr >= inputLen) {"
      },
      {
        "txt": "break dummy_loop; } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "} if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen);"
      },
      {
        "txt": "} while (false); _inputPtr = negative ? (startPtr+1) : startPtr; return _parseNumber2(negative); } private JsonToken _parseNumber2(boolean negative) throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (negative) { outBuf[outPtr++] = '-';"
      },
      {
        "txt": "} int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') { ++intLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true; break int_loop; }"
      },
      {
        "txt": "c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\"); } int fractLen = 0; if (c == '.') { // yes, fraction outBuf[outPtr++] = c; fract_loop: while (true) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0;"
      },
      {
        "txt": "if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') { if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; <extra_id_0> _textBuffer.setCurrentLength(outPtr); return reset(negative, intLen, fractLen, expLen); } private char _verifyNoLeadingZeroes() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd && !loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\");"
      },
      {
        "txt": "} ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0'; } ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return"
      },
      {
        "txt": "break; } } } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);"
      },
      {
        "txt": "} _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); }"
      },
      {
        "txt": "} reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected String _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } int ptr = _inputPtr;"
      },
      {
        "txt": "int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) {"
      },
      {
        "txt": "if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset();"
      },
      {
        "txt": "int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { // identifier, and not a number firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); } else { firstOk = Character.isJavaIdentifierPart((char) i); }"
      },
      {
        "txt": "if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr]; if (ch < maxCode) {"
      },
      {
        "txt": "if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); }"
      },
      {
        "txt": "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); } protected String _parseAposName() throws IOException {"
      },
      {
        "txt": "int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch == '\\'') { int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); }"
      },
      {
        "txt": "int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos();"
      },
      {
        "txt": "} break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I':"
      },
      {
        "txt": "_matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue();"
      },
      {
        "txt": "} } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; }"
      },
      {
        "txt": "protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break; } if (i < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) { break;"
      },
      {
        "txt": "} } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); }"
      },
      {
        "txt": "} @Override protected void _finishString() throws IOException { int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do {"
      },
      {
        "txt": "int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1; return; } break; } ++ptr;"
      },
      {
        "txt": "} while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2(); } protected void _finishString2() throws IOException { char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) {"
      },
      {
        "txt": "c = _decodeEscaped(); } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; int inputPtr = _inputPtr; int inputLen = _inputEnd; char[] inputBuffer = _inputBuffer; while (true) { if (inputPtr >= inputLen) { _inputPtr = inputPtr; if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); }"
      },
      {
        "txt": "inputPtr = _inputPtr; inputLen = _inputEnd; } char c = inputBuffer[inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inputPtr; c = _decodeEscaped(); inputPtr = _inputPtr;"
      },
      {
        "txt": "inputLen = _inputEnd; } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inputPtr; break; } if (i < INT_SPACE) { _inputPtr = inputPtr; _throwUnquotedSpace(i, \"string value\"); }"
      },
      {
        "txt": "} } } } protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') { ++_inputPtr; }"
      },
      {
        "txt": "} ++_currInputRow; _currInputRowStart = _inputPtr; } private int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) {"
      },
      {
        "txt": "return i; } switch (codes[i]) { case -1: _throwInvalidSpace(i); case 0: return i; case 1: continue; case '\\n':"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r': _skipCR(); break; case '/': _skipComment(); break; case '#':"
      },
      {
        "txt": "if (!_skipYAMLComment()) { return i; } break; } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException {"
      },
      {
        "txt": "final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) { return i; } switch (codes[i]) { case -1: _throwInvalidSpace(i); case 0:"
      },
      {
        "txt": "return i; case 1: continue; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r': _skipCR(); break;"
      },
      {
        "txt": "case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; } }"
      },
      {
        "txt": "_handleEOF(); return -1; } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\");"
      },
      {
        "txt": "} char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } }"
      },
      {
        "txt": "private void _skipCComment() throws IOException { main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !loadMore()) { break main_loop; }"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private void _skipLine() throws IOException {"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) { _skipCR(); break;"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t';"
      },
      {
        "txt": "case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/': case '\\\\': return c;"
      },
      {
        "txt": "case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\");"
      },
      {
        "txt": "} } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value;"
      },
      {
        "txt": "} protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i)); } }"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd) { if (!loadMore()) { return; } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } return; } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "} while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; }"
      },
      {
        "txt": "} int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4;"
      },
      {
        "txt": "builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "builder.appendThreeBytes(decodedData); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart);"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) { break; }"
      },
      {
        "txt": "++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"); }"
      }
    ]
  },
  {
    "id": 1214,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 1162,
    "end-bug-line": 1162,
    "bug": "",
    "fix": "private final void _verifyRootSpace(int ch) throws IOException {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.*; public final class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected Reader _reader; protected char[] _inputBuffer; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols;"
      },
      {
        "txt": "final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _objectCodec = codec; _symbols = st;"
      },
      {
        "txt": "_hashSeed = st.hashSeed(); } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }"
      },
      {
        "txt": "@Override public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count;"
      },
      {
        "txt": "} @Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd;"
      },
      {
        "txt": "if (_reader != null) { int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);"
      },
      {
        "txt": "} } return false; } protected char getNextChar(String eofMsg) throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg);"
      },
      {
        "txt": "} } return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close();"
      },
      {
        "txt": "} _reader = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); char[] buf = _inputBuffer;"
      },
      {
        "txt": "if (buf != null) { _inputBuffer = null; _ioContext.releaseTokenBuffer(buf); } } @Override public String getText() throws IOException, JsonParseException { JsonToken t = _currToken;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(t); } @Override"
      },
      {
        "txt": "public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null);"
      },
      {
        "txt": "} @Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString();"
      },
      {
        "txt": "} return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) {"
      },
      {
        "txt": "_nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } }"
      },
      {
        "txt": "return null; } @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length();"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length;"
      },
      {
        "txt": "} } return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME:"
      },
      {
        "txt": "return 0; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default:"
      },
      {
        "txt": "} } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {"
      },
      {
        "txt": "_reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion..."
      },
      {
        "txt": "if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try {"
      },
      {
        "txt": "return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3;"
      },
      {
        "txt": "int outputCount = 0; while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) {"
      },
      {
        "txt": "outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false;"
      },
      {
        "txt": "if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException {"
      },
      {
        "txt": "_numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); }"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); }"
      },
      {
        "txt": "if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } boolean inObject = _parsingContext.inObject(); if (inObject) { String name = _parseName(i); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "_currToken = JsonToken.FIELD_NAME; i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); } JsonToken t; switch (i) { case '\"':"
      },
      {
        "txt": "_tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break;"
      },
      {
        "txt": "case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8':"
      },
      {
        "txt": "case '9': t = _parseNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken;"
      },
      {
        "txt": "} _currToken = t; return t; } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException @Override"
      },
      {
        "txt": "public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE;"
      },
      {
        "txt": "} if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE:"
      },
      {
        "txt": "return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default: return null; } } @Override public void close() throws IOException {"
      },
      {
        "txt": "super.close(); _symbols.release(); } protected JsonToken _parseNumber(int ch) throws IOException { boolean negative = (ch == INT_MINUS); int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; dummy_loop:"
      },
      {
        "txt": "do { // dummy loop, to be able to break out if (negative) { // need to read the next digit if (ptr >= _inputEnd) { break dummy_loop; } ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); }"
      },
      {
        "txt": "} if (ch == INT_0) { break dummy_loop; } int intLen = 1; // already got one int_loop: while (true) { if (ptr >= _inputEnd) { break dummy_loop; }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) {"
      },
      {
        "txt": "if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now"
      },
      {
        "txt": "if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { break dummy_loop; }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; } if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len);"
      },
      {
        "txt": "return reset(negative, intLen, fractLen, expLen); } while (false); _inputPtr = negative ? (startPtr+1) : startPtr; return _parseNumber2(negative); } private JsonToken _parseNumber2(boolean negative) throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (negative) {"
      },
      {
        "txt": "outBuf[outPtr++] = '-'; } int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') {"
      },
      {
        "txt": "++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true; break int_loop;"
      },
      {
        "txt": "} c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\"); } int fractLen = 0; if (c == '.') { // yes, fraction outBuf[outPtr++] = c; fract_loop:"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } }"
      },
      {
        "txt": "int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') {"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); } exp_loop: while (c <= INT_9 && c >= INT_0) {"
      },
      {
        "txt": "++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; }"
      },
      {
        "txt": "c = _inputBuffer[_inputPtr++]; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return reset(negative, intLen, fractLen, expLen); } private char _verifyNoLeadingZeroes() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0';"
      },
      {
        "txt": "} if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0';"
      },
      {
        "txt": "} ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return break; } } } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException"
      },
      {
        "txt": "{ if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\";"
      },
      {
        "txt": "_matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);"
      },
      {
        "txt": "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } <extra_id_0> protected String _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } int ptr = _inputPtr;"
      },
      {
        "txt": "} int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) {"
      },
      {
        "txt": "if (ch == '\"') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen);"
      },
      {
        "txt": "} int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) {"
      },
      {
        "txt": "c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\"); } } }"
      },
      {
        "txt": "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer;"
      },
      {
        "txt": "char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName();"
      },
      {
        "txt": "} if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { // identifier, and not a number firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); } else {"
      },
      {
        "txt": "firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do {"
      },
      {
        "txt": "int ch = _inputBuffer[ptr]; if (ch < maxCode) { if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr;"
      },
      {
        "txt": "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); }"
      },
      {
        "txt": "protected String _parseAposName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr];"
      },
      {
        "txt": "if (ch == '\\'') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr;"
      },
      {
        "txt": "} while (ptr < inputLen); } int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'':"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");"
      },
      {
        "txt": "break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");"
      },
      {
        "txt": "return null; } protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\");"
      },
      {
        "txt": "} } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break;"
      },
      {
        "txt": "} if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) {"
      },
      {
        "txt": "if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size();"
      },
      {
        "txt": "return _symbols.findSymbol(buf, start, len, hash); } } @Override protected void _finishString() throws IOException { int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1;"
      },
      {
        "txt": "final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1; return; } break;"
      },
      {
        "txt": "} ++ptr; } while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2(); } protected void _finishString2() throws IOException {"
      },
      {
        "txt": "char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c;"
      },
      {
        "txt": "if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); }"
      },
      {
        "txt": "} } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); }"
      },
      {
        "txt": "protected void _skipString() throws IOException { _tokenIncomplete = false; int inputPtr = _inputPtr; int inputLen = _inputEnd; char[] inputBuffer = _inputBuffer; while (true) { if (inputPtr >= inputLen) { _inputPtr = inputPtr; if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing quote for a string value\"); } inputPtr = _inputPtr; inputLen = _inputEnd; } char c = inputBuffer[inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inputPtr;"
      },
      {
        "txt": "c = _decodeEscaped(); inputPtr = _inputPtr; inputLen = _inputEnd; } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inputPtr; break; } if (i < INT_SPACE) { _inputPtr = inputPtr;"
      },
      {
        "txt": "_throwUnquotedSpace(i, \"string value\"); } } } } } protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') {"
      },
      {
        "txt": "++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) { return i; } switch (codes[i]) { case -1: _throwInvalidSpace(i); case 0: return i; case 1:"
      },
      {
        "txt": "continue; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r': _skipCR(); break; case '/': _skipComment();"
      },
      {
        "txt": "break; case '#': if (!_skipYAMLComment()) { return i; } break; } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); }"
      },
      {
        "txt": "private int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) { return i; } switch (codes[i]) { case -1:"
      },
      {
        "txt": "_throwInvalidSpace(i); case 0: return i; case 1: continue; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r':"
      },
      {
        "txt": "_skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break;"
      },
      {
        "txt": "} } _handleEOF(); return -1; } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");"
      },
      {
        "txt": "} } private void _skipCComment() throws IOException { main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !loadMore()) {"
      },
      {
        "txt": "break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } }"
      },
      {
        "txt": "_reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; }"
      },
      {
        "txt": "private void _skipLine() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); break; } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b';"
      },
      {
        "txt": "case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/':"
      },
      {
        "txt": "case '\\\\': return c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit;"
      },
      {
        "txt": "} return (char) value; } protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i));"
      },
      {
        "txt": "} } if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd) { if (!loadMore()) { return;"
      },
      {
        "txt": "} } char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } return;"
      },
      {
        "txt": "} @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip"
      },
      {
        "txt": "continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2;"
      },
      {
        "txt": "builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      },
      {
        "txt": "{ StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "break; } ++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"); }"
      }
    ]
  },
  {
    "id": 1215,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 1163,
    "end-bug-line": 1163,
    "bug": "",
    "fix": "++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.*; public final class ReaderBasedJsonParser extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected Reader _reader; protected char[] _inputBuffer; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols;"
      },
      {
        "txt": "final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _objectCodec = codec; _symbols = st;"
      },
      {
        "txt": "_hashSeed = st.hashSeed(); } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }"
      },
      {
        "txt": "@Override public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count;"
      },
      {
        "txt": "} @Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd;"
      },
      {
        "txt": "if (_reader != null) { int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);"
      },
      {
        "txt": "} } return false; } protected char getNextChar(String eofMsg) throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg);"
      },
      {
        "txt": "} } return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close();"
      },
      {
        "txt": "} _reader = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); char[] buf = _inputBuffer;"
      },
      {
        "txt": "if (buf != null) { _inputBuffer = null; _ioContext.releaseTokenBuffer(buf); } } @Override public String getText() throws IOException, JsonParseException { JsonToken t = _currToken;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(t); } @Override"
      },
      {
        "txt": "public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null);"
      },
      {
        "txt": "} @Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString();"
      },
      {
        "txt": "} return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) {"
      },
      {
        "txt": "_nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } }"
      },
      {
        "txt": "return null; } @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length();"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length;"
      },
      {
        "txt": "} } return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME:"
      },
      {
        "txt": "return 0; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default:"
      },
      {
        "txt": "} } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {"
      },
      {
        "txt": "_reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion..."
      },
      {
        "txt": "if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try {"
      },
      {
        "txt": "return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3;"
      },
      {
        "txt": "int outputCount = 0; while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) {"
      },
      {
        "txt": "outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false;"
      },
      {
        "txt": "if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException {"
      },
      {
        "txt": "_numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); }"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); }"
      },
      {
        "txt": "if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } boolean inObject = _parsingContext.inObject(); if (inObject) { String name = _parseName(i); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "_currToken = JsonToken.FIELD_NAME; i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); } JsonToken t; switch (i) { case '\"':"
      },
      {
        "txt": "_tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break;"
      },
      {
        "txt": "case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8':"
      },
      {
        "txt": "case '9': t = _parseNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken;"
      },
      {
        "txt": "} _currToken = t; return t; } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException @Override"
      },
      {
        "txt": "public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE;"
      },
      {
        "txt": "} if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE:"
      },
      {
        "txt": "return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default: return null; } } @Override public void close() throws IOException {"
      },
      {
        "txt": "super.close(); _symbols.release(); } protected JsonToken _parseNumber(int ch) throws IOException { boolean negative = (ch == INT_MINUS); int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; dummy_loop:"
      },
      {
        "txt": "do { // dummy loop, to be able to break out if (negative) { // need to read the next digit if (ptr >= _inputEnd) { break dummy_loop; } ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); }"
      },
      {
        "txt": "} if (ch == INT_0) { break dummy_loop; } int intLen = 1; // already got one int_loop: while (true) { if (ptr >= _inputEnd) { break dummy_loop; }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) {"
      },
      {
        "txt": "if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now"
      },
      {
        "txt": "if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { break dummy_loop; }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; } if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len);"
      },
      {
        "txt": "return reset(negative, intLen, fractLen, expLen); } while (false); _inputPtr = negative ? (startPtr+1) : startPtr; return _parseNumber2(negative); } private JsonToken _parseNumber2(boolean negative) throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (negative) {"
      },
      {
        "txt": "outBuf[outPtr++] = '-'; } int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') {"
      },
      {
        "txt": "++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true; break int_loop;"
      },
      {
        "txt": "} c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\"); } int fractLen = 0; if (c == '.') { // yes, fraction outBuf[outPtr++] = c; fract_loop:"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } }"
      },
      {
        "txt": "int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') {"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); } exp_loop: while (c <= INT_9 && c >= INT_0) {"
      },
      {
        "txt": "++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; }"
      },
      {
        "txt": "c = _inputBuffer[_inputPtr++]; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return reset(negative, intLen, fractLen, expLen); } private char _verifyNoLeadingZeroes() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0';"
      },
      {
        "txt": "} if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0';"
      },
      {
        "txt": "} ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return break; } } } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException"
      },
      {
        "txt": "{ if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\";"
      },
      {
        "txt": "_matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);"
      },
      {
        "txt": "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } <extra_id_0> protected String _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } int ptr = _inputPtr;"
      },
      {
        "txt": "} int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) {"
      },
      {
        "txt": "if (ch == '\"') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen);"
      },
      {
        "txt": "} int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) {"
      },
      {
        "txt": "c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\"); } } }"
      },
      {
        "txt": "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer;"
      },
      {
        "txt": "char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName();"
      },
      {
        "txt": "} if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { // identifier, and not a number firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); } else {"
      },
      {
        "txt": "firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do {"
      },
      {
        "txt": "int ch = _inputBuffer[ptr]; if (ch < maxCode) { if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr;"
      },
      {
        "txt": "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); }"
      },
      {
        "txt": "protected String _parseAposName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr];"
      },
      {
        "txt": "if (ch == '\\'') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr;"
      },
      {
        "txt": "} while (ptr < inputLen); } int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'':"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");"
      },
      {
        "txt": "break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");"
      },
      {
        "txt": "return null; } protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\");"
      },
      {
        "txt": "} } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break;"
      },
      {
        "txt": "} if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) {"
      },
      {
        "txt": "if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size();"
      },
      {
        "txt": "return _symbols.findSymbol(buf, start, len, hash); } } @Override protected void _finishString() throws IOException { int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1;"
      },
      {
        "txt": "final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1; return; } break;"
      },
      {
        "txt": "} ++ptr; } while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2(); } protected void _finishString2() throws IOException {"
      },
      {
        "txt": "char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c;"
      },
      {
        "txt": "if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); }"
      },
      {
        "txt": "} } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); }"
      },
      {
        "txt": "protected void _skipString() throws IOException { _tokenIncomplete = false; int inputPtr = _inputPtr; int inputLen = _inputEnd; char[] inputBuffer = _inputBuffer; while (true) { if (inputPtr >= inputLen) { _inputPtr = inputPtr; if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing quote for a string value\"); } inputPtr = _inputPtr; inputLen = _inputEnd; } char c = inputBuffer[inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inputPtr;"
      },
      {
        "txt": "c = _decodeEscaped(); inputPtr = _inputPtr; inputLen = _inputEnd; } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inputPtr; break; } if (i < INT_SPACE) { _inputPtr = inputPtr;"
      },
      {
        "txt": "_throwUnquotedSpace(i, \"string value\"); } } } } } protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') {"
      },
      {
        "txt": "++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) { return i; } switch (codes[i]) { case -1: _throwInvalidSpace(i); case 0: return i; case 1:"
      },
      {
        "txt": "continue; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r': _skipCR(); break; case '/': _skipComment();"
      },
      {
        "txt": "break; case '#': if (!_skipYAMLComment()) { return i; } break; } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); }"
      },
      {
        "txt": "private int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i >= 64) { return i; } switch (codes[i]) { case -1:"
      },
      {
        "txt": "_throwInvalidSpace(i); case 0: return i; case 1: continue; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; break; case '\\r':"
      },
      {
        "txt": "_skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break;"
      },
      {
        "txt": "} } _handleEOF(); return -1; } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");"
      },
      {
        "txt": "} } private void _skipCComment() throws IOException { main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !loadMore()) {"
      },
      {
        "txt": "break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } }"
      },
      {
        "txt": "_reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; }"
      },
      {
        "txt": "private void _skipLine() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); break; } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b';"
      },
      {
        "txt": "case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/':"
      },
      {
        "txt": "case '\\\\': return c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit;"
      },
      {
        "txt": "} return (char) value; } protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i));"
      },
      {
        "txt": "} } if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd) { if (!loadMore()) { return;"
      },
      {
        "txt": "} } char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } return;"
      },
      {
        "txt": "} @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip"
      },
      {
        "txt": "continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2;"
      },
      {
        "txt": "builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      },
      {
        "txt": "{ StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "break; } ++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"); }"
      }
    ]
  },
  {
    "id": 1216,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1244,
    "end-bug-line": 1244,
    "bug": "",
    "fix": "if (_parsingContext.inRoot()) { _verifyRootSpace(c); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*; public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec;"
      },
      {
        "txt": "final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end,"
      },
      {
        "txt": "boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _bufferRecyclable = bufferRecyclable;"
      },
      {
        "txt": "} @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override"
      },
      {
        "txt": "public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; }"
      },
      {
        "txt": "@Override public Object getInputSource() { return _inputStream; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd;"
      },
      {
        "txt": "if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");"
      },
      {
        "txt": "} } return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; }"
      },
      {
        "txt": "int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0;"
      },
      {
        "txt": "while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count;"
      },
      {
        "txt": "} return true; } @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); }"
      },
      {
        "txt": "_inputStream = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) {"
      },
      {
        "txt": "_inputBuffer = null; _ioContext.releaseReadIOBuffer(buf); } } } @Override public String getText() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); }"
      },
      {
        "txt": "@Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); }"
      },
      {
        "txt": "return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName();"
      },
      {
        "txt": "case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);"
      },
      {
        "txt": "} else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null;"
      },
      {
        "txt": "} @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING:"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; }"
      },
      {
        "txt": "} return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME: return 0;"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: }"
      },
      {
        "txt": "} return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");"
      },
      {
        "txt": "} if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) {"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf);"
      },
      {
        "txt": "} finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3;"
      },
      {
        "txt": "int outputCount = 0; while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) {"
      },
      {
        "txt": "outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false;"
      },
      {
        "txt": "if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException {"
      },
      {
        "txt": "_numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); }"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); }"
      },
      {
        "txt": "if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); } Name n = _parseFieldName(i);"
      },
      {
        "txt": "_parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME; if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } }"
      },
      {
        "txt": "i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY;"
      },
      {
        "txt": "break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE;"
      },
      {
        "txt": "break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-':"
      },
      {
        "txt": "case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{':"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1);"
      },
      {
        "txt": "return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1': case '2': case '3': case '4':"
      },
      {
        "txt": "case '5': case '6': case '7': case '8': case '9': return (_currToken = _parseNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private JsonToken _nextAfterName()"
      },
      {
        "txt": "{ _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t);"
      },
      {
        "txt": "} @Override public void close() throws IOException { super.close(); _symbols.release(); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException"
      },
      {
        "txt": "{ _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd();"
      },
      {
        "txt": "if (i < 0) { // end-of-input close(); _currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) {"
      },
      {
        "txt": "if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS();"
      },
      {
        "txt": "} if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len;"
      },
      {
        "txt": "if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true;"
      },
      {
        "txt": "} if (nameBytes[offset] != _inputBuffer[ptr+offset]) { break; } ++offset; } } } } return _isNextTokenNameMaybe(i, str);"
      },
      {
        "txt": "} private void _isNextTokenNameYes() throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return; } if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return;"
      },
      {
        "txt": "} i &= 0xFF; if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon(); } switch (i) {"
      },
      {
        "txt": "case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return;"
      },
      {
        "txt": "case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE;"
      },
      {
        "txt": "return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2': case '3':"
      },
      {
        "txt": "case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return; } _nextToken = _handleUnexpectedValue(i);"
      },
      {
        "txt": "} private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue());"
      },
      {
        "txt": "} _currToken = JsonToken.FIELD_NAME; i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;"
      },
      {
        "txt": "return match; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break;"
      },
      {
        "txt": "case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE;"
      },
      {
        "txt": "break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3':"
      },
      {
        "txt": "case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i);"
      },
      {
        "txt": "} _nextToken = t; return match; } @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override"
      },
      {
        "txt": "public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue();"
      },
      {
        "txt": "} if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; }"
      },
      {
        "txt": "@Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;"
      },
      {
        "txt": "} @Override public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return null; } switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default: return null;"
      },
      {
        "txt": "} } protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-';"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) { c = _verifyNoLeadingZeroes();"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen);"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "} if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); <extra_id_0> return resetInt(negative, intLen); } private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException {"
      },
      {
        "txt": "throws IOException, JsonParseException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') {"
      },
      {
        "txt": "return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; ++intPartLength;"
      },
      {
        "txt": "} --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0;"
      },
      {
        "txt": "} int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) {"
      },
      {
        "txt": "while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break; } }"
      },
      {
        "txt": "} return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop;"
      },
      {
        "txt": "} ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");"
      },
      {
        "txt": "} } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");"
      },
      {
        "txt": "} } if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } protected Name _parseFieldName(int i) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i;"
      },
      {
        "txt": "i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4); } return parseName(q, i, 4); }"
      },
      {
        "txt": "if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2); } return parseName(q, i, 2); }"
      },
      {
        "txt": "if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseName(0, q, 0); // quoting or invalid char }"
      },
      {
        "txt": "protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException { int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char }"
      },
      {
        "txt": "q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes"
      },
      {
        "txt": "return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); } protected Name parseLongName(int q) throws IOException, JsonParseException"
      },
      {
        "txt": "{ final int[] codes = _icLatin1; int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) {"
      },
      {
        "txt": "return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); }"
      },
      {
        "txt": "q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen);"
      },
      {
        "txt": "} _quadBuffer[qlen++] = q; q = i; } } protected Name slowParseName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private Name parseName(int q1, int ch, int lastQuadBytes)"
      },
      {
        "txt": "throws IOException, JsonParseException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); }"
      },
      {
        "txt": "protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; }"
      },
      {
        "txt": "if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes;"
      },
      {
        "txt": "if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes;"
      },
      {
        "txt": "} ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); }"
      },
      {
        "txt": "if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0;"
      },
      {
        "txt": "int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) {"
      },
      {
        "txt": "break; } ++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; }"
      },
      {
        "txt": "Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer; int qlen = 0;"
      },
      {
        "txt": "int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\");"
      },
      {
        "txt": "} else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f);"
      },
      {
        "txt": "} } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1;"
      },
      {
        "txt": "return addName(_quadBuffer, 1, lastQuadBytes); } private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1;"
      },
      {
        "txt": "_quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad;"
      },
      {
        "txt": "Name name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes;"
      },
      {
        "txt": "int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) {"
      },
      {
        "txt": "int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)"
      },
      {
        "txt": "ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F);"
      },
      {
        "txt": "if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output)"
      },
      {
        "txt": "ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } }"
      },
      {
        "txt": "if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) {"
      },
      {
        "txt": "cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); }"
      },
      {
        "txt": "@Override protected void _finishString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();"
      },
      {
        "txt": "final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return;"
      },
      {
        "txt": "} break; } ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } private void _finishString2(char[] outBuf, int outPtr)"
      },
      {
        "txt": "throws IOException { int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr;"
      },
      {
        "txt": "if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) {"
      },
      {
        "txt": "c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) {"
      },
      {
        "txt": "break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF"
      },
      {
        "txt": "if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c);"
      },
      {
        "txt": "} } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); }"
      },
      {
        "txt": "protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) {"
      },
      {
        "txt": "int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) {"
      },
      {
        "txt": "_inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) {"
      },
      {
        "txt": "case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF"
      },
      {
        "txt": "_skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } }"
      },
      {
        "txt": "} protected JsonToken _handleUnexpectedValue(int c) throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break;"
      },
      {
        "txt": "case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {"
      },
      {
        "txt": "return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } }"
      },
      {
        "txt": "return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException"
      },
      {
        "txt": "{ int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr);"
      },
      {
        "txt": "if (max2 < max) { max = max2; } } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} } if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); }"
      },
      {
        "txt": "break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); }"
      },
      {
        "txt": "break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break;"
      },
      {
        "txt": "default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\";"
      },
      {
        "txt": "} else { break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");"
      },
      {
        "txt": "return null; } protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i));"
      },
      {
        "txt": "} ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; }"
      },
      {
        "txt": "char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); }"
      },
      {
        "txt": "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i);"
      },
      {
        "txt": "if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } private final int _skipWS() throws IOException { final int[] codes = _icWS;"
      },
      {
        "txt": "while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break;"
      },
      {
        "txt": "case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break;"
      },
      {
        "txt": "case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; }"
      },
      {
        "txt": "break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); }"
      },
      {
        "txt": "private int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue;"
      },
      {
        "txt": "case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF:"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#':"
      },
      {
        "txt": "if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); }"
      },
      {
        "txt": "} _handleEOF(); return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (i == INT_COLON) { if (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else { i &= 0xFF;"
      },
      {
        "txt": "space_loop: while (true) { switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break; case INT_LF:"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "break space_loop; } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); }"
      },
      {
        "txt": "} while (_inputPtr < _inputEnd || loadMore()) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException {"
      },
      {
        "txt": "final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop;"
      },
      {
        "txt": "} if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break;"
      },
      {
        "txt": "case INT_CR: _skipCR(); break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF"
      },
      {
        "txt": "_skipUtf8_4(i); break; default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment();"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR:"
      },
      {
        "txt": "_skipCR(); return; case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } }"
      },
      {
        "txt": "} @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r':"
      },
      {
        "txt": "return '\\r'; case '\"': case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); }"
      },
      {
        "txt": "int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) {"
      },
      {
        "txt": "_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is"
      },
      {
        "txt": "int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3;"
      },
      {
        "txt": "} else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total"
      },
      {
        "txt": "d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); } } } return c; } private int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_3fast(int c1) throws IOException {"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; }"
      },
      {
        "txt": "private void _skipUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } }"
      },
      {
        "txt": "private void _skipUtf8_3(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "} protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} private int nextByte() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidChar(int c) throws JsonParseException"
      },
      {
        "txt": "{ if (c < INT_SPACE) { _throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));"
      },
      {
        "txt": "} protected void _reportInvalidOther(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr;"
      },
      {
        "txt": "_reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; }"
      },
      {
        "txt": "} int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4;"
      },
      {
        "txt": "builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "builder.appendThreeBytes(decodedData); } }"
      }
    ]
  },
  {
    "id": 1217,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1280,
    "end-bug-line": 1280,
    "bug": "",
    "fix": "if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*; public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();"
      },
      {
        "txt": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable;"
      },
      {
        "txt": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer;"
      },
      {
        "txt": "_inputPtr = start; _inputEnd = end; _bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) {"
      },
      {
        "txt": "_objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr;"
      },
      {
        "txt": "out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _inputStream; } @Override protected boolean loadMore() throws IOException"
      },
      {
        "txt": "{ _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; }"
      },
      {
        "txt": "_closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } } return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException {"
      },
      {
        "txt": "if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else {"
      },
      {
        "txt": "_inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); }"
      },
      {
        "txt": "return false; } _inputEnd += count; } return true; } @Override protected void _closeInput() throws IOException { if (_inputStream != null) {"
      },
      {
        "txt": "if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers();"
      },
      {
        "txt": "if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf); } } } @Override public String getText()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken);"
      },
      {
        "txt": "} @Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString();"
      },
      {
        "txt": "} return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete"
      },
      {
        "txt": "} return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; }"
      },
      {
        "txt": "switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); }"
      },
      {
        "txt": "} @Override public char[] getTextCharacters() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName();"
      },
      {
        "txt": "int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer;"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray();"
      },
      {
        "txt": "} } return null; } @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) {"
      },
      {
        "txt": "case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size();"
      },
      {
        "txt": "default: return _currToken.asCharArray().length; } } return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) {"
      },
      {
        "txt": "switch (_currToken) { case FIELD_NAME: return 0; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT:"
      },
      {
        "txt": "return _textBuffer.getTextOffset(); default: } } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); }"
      },
      {
        "txt": "_tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue;"
      },
      {
        "txt": "} @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; }"
      },
      {
        "txt": "byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException"
      },
      {
        "txt": "{ int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue;"
      },
      {
        "txt": "} } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); }"
      },
      {
        "txt": "if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override"
      },
      {
        "txt": "public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial }"
      },
      {
        "txt": "int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) {"
      },
      {
        "txt": "if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); }"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "return _nextTokenNotInObject(i); } Name n = _parseFieldName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME; if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t;"
      },
      {
        "txt": "switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\");"
      },
      {
        "txt": "case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken;"
      },
      {
        "txt": "} private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[':"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return (_currToken = _parseNumber(i)); }"
      },
      {
        "txt": "return (_currToken = _handleUnexpectedValue(i)); } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public void close() throws IOException { super.close(); _symbols.release(); }"
      },
      {
        "txt": "@Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) {"
      },
      {
        "txt": "_skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); _currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow;"
      },
      {
        "txt": "_tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; }"
      },
      {
        "txt": "if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8();"
      },
      {
        "txt": "final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue());"
      },
      {
        "txt": "_currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) { break; } ++offset; } }"
      },
      {
        "txt": "} } return _isNextTokenNameMaybe(i, str); } private void _isNextTokenNameYes() throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; } if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; }"
      },
      {
        "txt": "if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF; if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else {"
      },
      {
        "txt": "i = _skipColon(); } switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return;"
      },
      {
        "txt": "case '{': _nextToken = JsonToken.START_OBJECT; return; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return;"
      },
      {
        "txt": "case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0':"
      },
      {
        "txt": "case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i);"
      },
      {
        "txt": "return; } _nextToken = _handleUnexpectedValue(i); } private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; {"
      },
      {
        "txt": "String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME; i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS();"
      },
      {
        "txt": "if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break;"
      },
      {
        "txt": "case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break;"
      },
      {
        "txt": "case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0':"
      },
      {
        "txt": "case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i);"
      },
      {
        "txt": "break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; } @Override public String nextTextValue() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString();"
      },
      {
        "txt": "} return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken;"
      },
      {
        "txt": "_nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE:"
      },
      {
        "txt": "return Boolean.FALSE; default: return null; } } protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0;"
      },
      {
        "txt": "boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); }"
      },
      {
        "txt": "} if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; }"
      },
      {
        "txt": "while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return resetInt(negative, intLen); } private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength);"
      },
      {
        "txt": "} int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; ++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); <extra_id_0> return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\");"
      },
      {
        "txt": "} ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return"
      },
      {
        "txt": "break; } } } return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {"
      },
      {
        "txt": "int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen);"
      },
      {
        "txt": "} protected Name _parseFieldName(int i) throws IOException, JsonParseException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); }"
      },
      {
        "txt": "final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i;"
      },
      {
        "txt": "i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4);"
      },
      {
        "txt": "} return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2);"
      },
      {
        "txt": "} return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName();"
      },
      {
        "txt": "} return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException { int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1);"
      },
      {
        "txt": "} return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2);"
      },
      {
        "txt": "} q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i;"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i);"
      },
      {
        "txt": "} protected Name parseLongName(int q) throws IOException, JsonParseException { final int[] codes = _icLatin1; int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); }"
      },
      {
        "txt": "int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3);"
      },
      {
        "txt": "} return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4);"
      },
      {
        "txt": "} if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q; q = i; } } protected Name slowParseName() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException {"
      },
      {
        "txt": "_quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) {"
      },
      {
        "txt": "if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes;"
      },
      {
        "txt": "} else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0;"
      },
      {
        "txt": "} currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch;"
      },
      {
        "txt": "} else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "} Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); }"
      },
      {
        "txt": "int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; } ++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName();"
      },
      {
        "txt": "} int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; }"
      },
      {
        "txt": "if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));"
      },
      {
        "txt": "++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));"
      },
      {
        "txt": "++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen);"
      },
      {
        "txt": "if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) {"
      },
      {
        "txt": "return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) {"
      },
      {
        "txt": "return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes)"
      },
      {
        "txt": "throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; }"
      },
      {
        "txt": "char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)"
      },
      {
        "txt": "ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch);"
      },
      {
        "txt": "needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2);"
      },
      {
        "txt": "} ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); }"
      },
      {
        "txt": "ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF);"
      },
      {
        "txt": "} } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad;"
      },
      {
        "txt": "} return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr;"
      },
      {
        "txt": "} int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) {"
      },
      {
        "txt": "_inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break; } ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr;"
      },
      {
        "txt": "_finishString2(outBuf, outPtr); } private void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) {"
      },
      {
        "txt": "ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "_inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) {"
      },
      {
        "txt": "int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; }"
      },
      {
        "txt": "while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; } if (c == INT_QUOTE) {"
      },
      {
        "txt": "break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF"
      },
      {
        "txt": "_skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c);"
      },
      {
        "txt": "} } } } protected JsonToken _handleUnexpectedValue(int c) throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {"
      },
      {
        "txt": "return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break;"
      },
      {
        "txt": "case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null;"
      },
      {
        "txt": "} protected JsonToken _handleApos() throws IOException { int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop:"
      },
      {
        "txt": "while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; } } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) {"
      },
      {
        "txt": "break ascii_loop; } outBuf[outPtr++] = (char) c; } } if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash"
      },
      {
        "txt": "if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c);"
      },
      {
        "txt": "} else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException"
      },
      {
        "txt": "{ while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') {"
      },
      {
        "txt": "match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); }"
      },
      {
        "txt": "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do {"
      },
      {
        "txt": "if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF;"
      },
      {
        "txt": "if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException"
      },
      {
        "txt": "{ _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break;"
      },
      {
        "txt": "} int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); }"
      },
      {
        "txt": "private final int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue;"
      },
      {
        "txt": "case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF:"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#':"
      },
      {
        "txt": "if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); }"
      },
      {
        "txt": "} throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done!"
      },
      {
        "txt": "return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF"
      },
      {
        "txt": "_skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/':"
      },
      {
        "txt": "_skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} _reportInvalidChar(i); } } _handleEOF(); return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; }"
      },
      {
        "txt": "} } else { i &= 0xFF; space_loop: while (true) { switch (i) { case ' ': case '\\t': break; case INT_CR:"
      },
      {
        "txt": "_skipCR(); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case '/': _skipComment(); break; default:"
      },
      {
        "txt": "if (i < INT_SPACE) { _throwInvalidSpace(i); } break space_loop; } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } while (_inputPtr < _inputEnd || loadMore()) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; }"
      },
      {
        "txt": "_skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); }"
      },
      {
        "txt": "} private void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) {"
      },
      {
        "txt": "case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } break; case INT_LF:"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF"
      },
      {
        "txt": "_skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 _reportInvalidChar(i); } } }"
      },
      {
        "txt": "_reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; }"
      },
      {
        "txt": "private void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow;"
      },
      {
        "txt": "_currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return; case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break;"
      },
      {
        "txt": "case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); }"
      },
      {
        "txt": "} } } } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\");"
      },
      {
        "txt": "} } int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n': return '\\n';"
      },
      {
        "txt": "case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break;"
      },
      {
        "txt": "default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } }"
      },
      {
        "txt": "int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException"
      },
      {
        "txt": "{ int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2;"
      },
      {
        "txt": "} else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte();"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); } } } return c; } private int _decodeUtf8_2(int c) throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); }"
      },
      {
        "txt": "private int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c;"
      },
      {
        "txt": "} private int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} return ((c << 6) | (d & 0x3F)) - 0x10000; } private void _skipUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_3(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } }"
      },
      {
        "txt": "private void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; }"
      },
      {
        "txt": "} ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) { _throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask)"
      },
      {
        "txt": "throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr)"
      },
      {
        "txt": "throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; }"
      },
      {
        "txt": "return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0);"
      },
      {
        "txt": "if (bits < 0) { // white space to skip continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } }"
      }
    ]
  },
  {
    "id": 1218,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1407,
    "end-bug-line": 1407,
    "bug": "",
    "fix": "if (_parsingContext.inRoot()) { _verifyRootSpace(c); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*; public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();"
      },
      {
        "txt": "private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,"
      },
      {
        "txt": "ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start;"
      },
      {
        "txt": "_inputEnd = end; _bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c;"
      },
      {
        "txt": "} @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count);"
      },
      {
        "txt": "return count; } @Override public Object getInputSource() { return _inputStream; } @Override protected boolean loadMore() throws IOException {"
      },
      {
        "txt": "_currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput();"
      },
      {
        "txt": "if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } } return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) {"
      },
      {
        "txt": "return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0;"
      },
      {
        "txt": "} _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false;"
      },
      {
        "txt": "} _inputEnd += count; } return true; } @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {"
      },
      {
        "txt": "_inputStream.close(); } _inputStream = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); if (_bufferRecyclable) {"
      },
      {
        "txt": "byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf); } } } @Override public String getText() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); }"
      },
      {
        "txt": "@Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); }"
      },
      {
        "txt": "return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) {"
      },
      {
        "txt": "case FIELD_NAME: return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } }"
      },
      {
        "txt": "@Override public char[] getTextCharacters() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length();"
      },
      {
        "txt": "if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING:"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); }"
      },
      {
        "txt": "} return null; } @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName().length(); case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default:"
      },
      {
        "txt": "return _currToken.asCharArray().length; } } return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) {"
      },
      {
        "txt": "case FIELD_NAME: return 0; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset();"
      },
      {
        "txt": "default: } } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING &&"
      },
      {
        "txt": "(_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false;"
      },
      {
        "txt": "} else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; }"
      },
      {
        "txt": "@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer();"
      },
      {
        "txt": "try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException {"
      },
      {
        "txt": "int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; }"
      },
      {
        "txt": "} if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); }"
      },
      {
        "txt": "if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "} _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken()"
      },
      {
        "txt": "throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd();"
      },
      {
        "txt": "if (i < 0) { // end-of-input close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) {"
      },
      {
        "txt": "_reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i);"
      },
      {
        "txt": "} Name n = _parseFieldName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME; if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");"
      },
      {
        "txt": "} } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) {"
      },
      {
        "txt": "case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't':"
      },
      {
        "txt": "_matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL;"
      },
      {
        "txt": "break; case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':"
      },
      {
        "txt": "case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; }"
      },
      {
        "txt": "private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE);"
      },
      {
        "txt": "case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1': case '2':"
      },
      {
        "txt": "case '3': case '4': case '5': case '6': case '7': case '8': case '9': return (_currToken = _parseNumber(i)); } return (_currToken = _handleUnexpectedValue(i));"
      },
      {
        "txt": "} private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return (_currToken = t); } @Override public void close() throws IOException { super.close(); _symbols.release(); } @Override"
      },
      {
        "txt": "public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString();"
      },
      {
        "txt": "} int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); _currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1;"
      },
      {
        "txt": "_binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) {"
      },
      {
        "txt": "if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length;"
      },
      {
        "txt": "if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "_isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) { break; } ++offset; } } }"
      },
      {
        "txt": "} return _isNextTokenNameMaybe(i, str); } private void _isNextTokenNameYes() throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr;"
      },
      {
        "txt": "if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; } if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) {"
      },
      {
        "txt": "_nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF; if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon();"
      },
      {
        "txt": "} switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{':"
      },
      {
        "txt": "_nextToken = JsonToken.START_OBJECT; return; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f':"
      },
      {
        "txt": "_matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return;"
      },
      {
        "txt": "} _nextToken = _handleUnexpectedValue(i); } private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; { String nameStr = n.getName();"
      },
      {
        "txt": "_parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME; i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f':"
      },
      {
        "txt": "_matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i); break;"
      },
      {
        "txt": "default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; } @Override public String nextTextValue() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); }"
      },
      {
        "txt": "return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;"
      },
      {
        "txt": "} @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken;"
      },
      {
        "txt": "_nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE;"
      },
      {
        "txt": "default: return null; } } protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS);"
      },
      {
        "txt": "if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } }"
      },
      {
        "txt": "if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) {"
      },
      {
        "txt": "if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intLen);"
      },
      {
        "txt": "} private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); }"
      },
      {
        "txt": "int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; ++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\");"
      },
      {
        "txt": "} ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return"
      },
      {
        "txt": "break; } } } return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {"
      },
      {
        "txt": "int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; <extra_id_0> _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } protected Name _parseFieldName(int i) throws IOException, JsonParseException {"
      },
      {
        "txt": "throws IOException, JsonParseException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer; final int[] codes = _icLatin1;"
      },
      {
        "txt": "int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) {"
      },
      {
        "txt": "q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4); } return parseName(q, i, 4);"
      },
      {
        "txt": "} if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2); } return parseName(q, i, 2);"
      },
      {
        "txt": "} if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseName(0, q, 0); // quoting or invalid char"
      },
      {
        "txt": "} protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException { int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char"
      },
      {
        "txt": "} q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i;"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); } protected Name parseLongName(int q)"
      },
      {
        "txt": "throws IOException, JsonParseException { final int[] codes = _icLatin1; int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2);"
      },
      {
        "txt": "} return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3);"
      },
      {
        "txt": "} q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) {"
      },
      {
        "txt": "_quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q; q = i; } } protected Name slowParseName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); }"
      },
      {
        "txt": "private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);"
      },
      {
        "txt": "} protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break;"
      },
      {
        "txt": "} if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));"
      },
      {
        "txt": "++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));"
      },
      {
        "txt": "++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen);"
      },
      {
        "txt": "if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName();"
      },
      {
        "txt": "} if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0;"
      },
      {
        "txt": "int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF;"
      },
      {
        "txt": "if (codes[ch] != 0) { break; } ++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "} Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer;"
      },
      {
        "txt": "int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') {"
      },
      {
        "txt": "_throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; }"
      },
      {
        "txt": "ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes);"
      },
      {
        "txt": "} return name; } private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) { return name; }"
      },
      {
        "txt": "_quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) { return name; }"
      },
      {
        "txt": "_quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException {"
      },
      {
        "txt": "int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0;"
      },
      {
        "txt": "for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1;"
      },
      {
        "txt": "} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far }"
      },
      {
        "txt": "if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); }"
      },
      {
        "txt": "ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F);"
      },
      {
        "txt": "if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); }"
      },
      {
        "txt": "} if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } }"
      },
      {
        "txt": "if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen);"
      },
      {
        "txt": "} @Override protected void _finishString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0;"
      },
      {
        "txt": "char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return; } break; } ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); }"
      },
      {
        "txt": "private void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) {"
      },
      {
        "txt": "int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));"
      },
      {
        "txt": "while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr; }"
      },
      {
        "txt": "if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break;"
      },
      {
        "txt": "case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10));"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else {"
      },
      {
        "txt": "_reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "} protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop:"
      },
      {
        "txt": "while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF;"
      },
      {
        "txt": "if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; }"
      },
      {
        "txt": "switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } }"
      },
      {
        "txt": "} } protected JsonToken _handleUnexpectedValue(int c) throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); }"
      },
      {
        "txt": "break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); }"
      },
      {
        "txt": "} return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos()"
      },
      {
        "txt": "throws IOException { int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop:"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; {"
      },
      {
        "txt": "int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; } } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } } if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped();"
      },
      {
        "txt": "} break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c);"
      },
      {
        "txt": "} break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF);"
      },
      {
        "txt": "break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') {"
      },
      {
        "txt": "match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); }"
      },
      {
        "txt": "reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return;"
      },
      {
        "txt": "} char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");"
      },
      {
        "txt": "} protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } private final int _skipWS() throws IOException {"
      },
      {
        "txt": "final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i;"
      },
      {
        "txt": "} break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} private int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip"
      },
      {
        "txt": "continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break;"
      },
      {
        "txt": "case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i);"
      },
      {
        "txt": "} } _handleEOF(); return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else {"
      },
      {
        "txt": "i &= 0xFF; space_loop: while (true) { switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break;"
      },
      {
        "txt": "case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} break space_loop; } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");"
      },
      {
        "txt": "} } while (_inputPtr < _inputEnd || loadMore()) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } }"
      },
      {
        "txt": "throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException"
      },
      {
        "txt": "{ final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case INT_CR: _skipCR(); break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private void _skipLine() throws IOException {"
      },
      {
        "txt": "final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return;"
      },
      {
        "txt": "case INT_CR: _skipCR(); return; case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i);"
      },
      {
        "txt": "break; case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } }"
      },
      {
        "txt": "} } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } }"
      },
      {
        "txt": "int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f';"
      },
      {
        "txt": "case 'r': return '\\r'; case '\"': case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));"
      },
      {
        "txt": "} int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch);"
      },
      {
        "txt": "if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte;"
      },
      {
        "txt": "if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07;"
      },
      {
        "txt": "needed = 3; } else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F);"
      },
      {
        "txt": "if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); } } } return c; } private int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private int _decodeUtf8_3(int c1) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_3fast(int c1) throws IOException"
      },
      {
        "txt": "{ c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000;"
      },
      {
        "txt": "} private void _skipUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); }"
      },
      {
        "txt": "} private void _skipUtf8_3(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_4(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} } protected void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow;"
      },
      {
        "txt": "_currInputRowStart = _inputPtr; } private int nextByte() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidChar(int c)"
      },
      {
        "txt": "throws JsonParseException { if (c < INT_SPACE) { _throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException {"
      },
      {
        "txt": "_reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {"
      },
      {
        "txt": "_inputPtr = ptr; _reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue;"
      },
      {
        "txt": "} } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData);"
      },
      {
        "txt": "return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } }"
      }
    ]
  },
  {
    "id": 1219,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1421,
    "end-bug-line": 1421,
    "bug": "",
    "fix": "private final void _verifyRootSpace(int ch) throws IOException {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*;"
      },
      {
        "txt": "public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16];"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {"
      },
      {
        "txt": "super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _bufferRecyclable = bufferRecyclable; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException {"
      },
      {
        "txt": "int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() {"
      },
      {
        "txt": "return _inputStream; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);"
      },
      {
        "txt": "if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } }"
      },
      {
        "txt": "return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) {"
      },
      {
        "txt": "_currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);"
      },
      {
        "txt": "if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; } return true;"
      },
      {
        "txt": "} @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; }"
      },
      {
        "txt": "} @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf);"
      },
      {
        "txt": "} } } @Override public String getText() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }"
      },
      {
        "txt": "protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen];"
      },
      {
        "txt": "} name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override"
      },
      {
        "txt": "public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0;"
      },
      {
        "txt": "} @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME: return 0; case VALUE_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0;"
      },
      {
        "txt": "} @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) {"
      },
      {
        "txt": "try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf);"
      },
      {
        "txt": "} } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) {"
      },
      {
        "txt": "int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) {"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr);"
      },
      {
        "txt": "outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); }"
      },
      {
        "txt": "_tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY);"
      },
      {
        "txt": "} if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); } Name n = _parseFieldName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } i = _skipWS(); if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f':"
      },
      {
        "txt": "_matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i); break;"
      },
      {
        "txt": "default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT);"
      },
      {
        "txt": "case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': return (_currToken = _parseNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override"
      },
      {
        "txt": "public void close() throws IOException { super.close(); _symbols.release(); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "_currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "_currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "_nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0;"
      },
      {
        "txt": "final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) {"
      },
      {
        "txt": "break; } ++offset; } } } } return _isNextTokenNameMaybe(i, str); } private void _isNextTokenNameYes()"
      },
      {
        "txt": "throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return;"
      },
      {
        "txt": "} if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF;"
      },
      {
        "txt": "if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon(); } switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private boolean _isNextTokenNameMaybe(int i, SerializableString str)"
      },
      {
        "txt": "throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t;"
      },
      {
        "txt": "return match; } @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override"
      },
      {
        "txt": "public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE;"
      },
      {
        "txt": "} if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default: return null; } }"
      },
      {
        "txt": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intLen); } private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException"
      },
      {
        "txt": "{ while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength);"
      },
      {
        "txt": "} break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; ++intPartLength; }"
      },
      {
        "txt": "--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; }"
      },
      {
        "txt": "int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break; } } }"
      },
      {
        "txt": "return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; }"
      },
      {
        "txt": "++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); }"
      },
      {
        "txt": "} int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); }"
      },
      {
        "txt": "if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } <extra_id_0> protected Name _parseFieldName(int i) throws IOException, JsonParseException { if (i != INT_QUOTE) { return _handleOddName(i); }"
      },
      {
        "txt": "return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) {"
      },
      {
        "txt": "_quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4); } return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3);"
      },
      {
        "txt": "} return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2); } return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1);"
      },
      {
        "txt": "} return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException"
      },
      {
        "txt": "{ int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes"
      },
      {
        "txt": "return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); }"
      },
      {
        "txt": "return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); } protected Name parseLongName(int q) throws IOException, JsonParseException { final int[] codes = _icLatin1;"
      },
      {
        "txt": "int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); }"
      },
      {
        "txt": "q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q;"
      },
      {
        "txt": "q = i; } } protected Name slowParseName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); }"
      },
      {
        "txt": "} int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException {"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes)"
      },
      {
        "txt": "throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\");"
      },
      {
        "txt": "} else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f);"
      },
      {
        "txt": "} } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");"
      },
      {
        "txt": "} final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) {"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; }"
      },
      {
        "txt": "++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\");"
      },
      {
        "txt": "} } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0;"
      },
      {
        "txt": "final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped();"
      },
      {
        "txt": "} if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; }"
      },
      {
        "txt": "if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } }"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; }"
      },
      {
        "txt": "private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); }"
      },
      {
        "txt": "private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes);"
      },
      {
        "txt": "} private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) {"
      },
      {
        "txt": "lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3);"
      },
      {
        "txt": "ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2;"
      },
      {
        "txt": "} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2];"
      },
      {
        "txt": "byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3);"
      },
      {
        "txt": "ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0"
      },
      {
        "txt": "if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); }"
      },
      {
        "txt": "cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException"
      },
      {
        "txt": "{ int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length));"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break;"
      },
      {
        "txt": "} ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } private void _finishString2(char[] outBuf, int outPtr) throws IOException {"
      },
      {
        "txt": "int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) {"
      },
      {
        "txt": "_inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; }"
      },
      {
        "txt": "switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c);"
      },
      {
        "txt": "} else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd;"
      },
      {
        "txt": "if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop;"
      },
      {
        "txt": "} } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break;"
      },
      {
        "txt": "default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c)"
      },
      {
        "txt": "throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); }"
      },
      {
        "txt": "_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); }"
      },
      {
        "txt": "if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { int c = 0;"
      },
      {
        "txt": "int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2;"
      },
      {
        "txt": "} } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; } }"
      },
      {
        "txt": "if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue();"
      },
      {
        "txt": "} } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break;"
      },
      {
        "txt": "} _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; }"
      },
      {
        "txt": "protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr;"
      },
      {
        "txt": "} while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      },
      {
        "txt": "{ StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break;"
      },
      {
        "txt": "} sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } private final int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i);"
      },
      {
        "txt": "break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1"
      },
      {
        "txt": "if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException {"
      },
      {
        "txt": "final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i;"
      },
      {
        "txt": "} break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } _handleEOF();"
      },
      {
        "txt": "return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else { i &= 0xFF; space_loop: while (true) {"
      },
      {
        "txt": "switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i); } break space_loop; }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private void _skipComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine();"
      },
      {
        "txt": "} else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop:"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) {"
      },
      {
        "txt": "++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {"
      },
      {
        "txt": "return false; } _skipLine(); return true; } private void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return;"
      },
      {
        "txt": "case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i);"
      },
      {
        "txt": "break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } } } @Override"
      },
      {
        "txt": "protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b':"
      },
      {
        "txt": "return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"':"
      },
      {
        "txt": "case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); }"
      },
      {
        "txt": "value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)"
      },
      {
        "txt": "c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF);"
      },
      {
        "txt": "needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); }"
      },
      {
        "txt": "} } return c; } private int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c;"
      },
      {
        "txt": "} private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; } private void _skipUtf8_2(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_3(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected void _skipCR() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask)"
      },
      {
        "txt": "throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); }"
      },
      {
        "txt": "public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {"
      },
      {
        "txt": "ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");"
      },
      {
        "txt": "} decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); }"
      }
    ]
  },
  {
    "id": 1220,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1422,
    "end-bug-line": 1422,
    "bug": "",
    "fix": "++_inputPtr;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*;"
      },
      {
        "txt": "public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16];"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {"
      },
      {
        "txt": "super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _bufferRecyclable = bufferRecyclable; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException {"
      },
      {
        "txt": "int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() {"
      },
      {
        "txt": "return _inputStream; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);"
      },
      {
        "txt": "if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } }"
      },
      {
        "txt": "return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) {"
      },
      {
        "txt": "_currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);"
      },
      {
        "txt": "if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; } return true;"
      },
      {
        "txt": "} @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; }"
      },
      {
        "txt": "} @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf);"
      },
      {
        "txt": "} } } @Override public String getText() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }"
      },
      {
        "txt": "protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen];"
      },
      {
        "txt": "} name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override"
      },
      {
        "txt": "public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0;"
      },
      {
        "txt": "} @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME: return 0; case VALUE_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0;"
      },
      {
        "txt": "} @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) {"
      },
      {
        "txt": "try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf);"
      },
      {
        "txt": "} } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) {"
      },
      {
        "txt": "int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) {"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr);"
      },
      {
        "txt": "outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); }"
      },
      {
        "txt": "_tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY);"
      },
      {
        "txt": "} if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); } Name n = _parseFieldName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } i = _skipWS(); if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f':"
      },
      {
        "txt": "_matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i); break;"
      },
      {
        "txt": "default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT);"
      },
      {
        "txt": "case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': return (_currToken = _parseNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override"
      },
      {
        "txt": "public void close() throws IOException { super.close(); _symbols.release(); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "_currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "_currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "_nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0;"
      },
      {
        "txt": "final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) {"
      },
      {
        "txt": "break; } ++offset; } } } } return _isNextTokenNameMaybe(i, str); } private void _isNextTokenNameYes()"
      },
      {
        "txt": "throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return;"
      },
      {
        "txt": "} if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF;"
      },
      {
        "txt": "if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon(); } switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private boolean _isNextTokenNameMaybe(int i, SerializableString str)"
      },
      {
        "txt": "throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t;"
      },
      {
        "txt": "return match; } @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override"
      },
      {
        "txt": "public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE;"
      },
      {
        "txt": "} if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default: return null; } }"
      },
      {
        "txt": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intLen); } private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException"
      },
      {
        "txt": "{ while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength);"
      },
      {
        "txt": "} break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; ++intPartLength; }"
      },
      {
        "txt": "--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; }"
      },
      {
        "txt": "int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break; } } }"
      },
      {
        "txt": "return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; }"
      },
      {
        "txt": "++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); }"
      },
      {
        "txt": "} int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); }"
      },
      {
        "txt": "if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } <extra_id_0> protected Name _parseFieldName(int i) throws IOException, JsonParseException { if (i != INT_QUOTE) { return _handleOddName(i); }"
      },
      {
        "txt": "return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) {"
      },
      {
        "txt": "_quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4); } return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3);"
      },
      {
        "txt": "} return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2); } return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1);"
      },
      {
        "txt": "} return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException"
      },
      {
        "txt": "{ int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes"
      },
      {
        "txt": "return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); }"
      },
      {
        "txt": "return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); } protected Name parseLongName(int q) throws IOException, JsonParseException { final int[] codes = _icLatin1;"
      },
      {
        "txt": "int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); }"
      },
      {
        "txt": "q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q;"
      },
      {
        "txt": "q = i; } } protected Name slowParseName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); }"
      },
      {
        "txt": "} int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException {"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes)"
      },
      {
        "txt": "throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\");"
      },
      {
        "txt": "} else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f);"
      },
      {
        "txt": "} } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");"
      },
      {
        "txt": "} final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) {"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; }"
      },
      {
        "txt": "++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\");"
      },
      {
        "txt": "} } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0;"
      },
      {
        "txt": "final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped();"
      },
      {
        "txt": "} if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; }"
      },
      {
        "txt": "if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } }"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; }"
      },
      {
        "txt": "private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); }"
      },
      {
        "txt": "private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes);"
      },
      {
        "txt": "} private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) {"
      },
      {
        "txt": "lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3);"
      },
      {
        "txt": "ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2;"
      },
      {
        "txt": "} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2];"
      },
      {
        "txt": "byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3);"
      },
      {
        "txt": "ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0"
      },
      {
        "txt": "if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); }"
      },
      {
        "txt": "cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException"
      },
      {
        "txt": "{ int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length));"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break;"
      },
      {
        "txt": "} ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } private void _finishString2(char[] outBuf, int outPtr) throws IOException {"
      },
      {
        "txt": "int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) {"
      },
      {
        "txt": "_inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; }"
      },
      {
        "txt": "switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c);"
      },
      {
        "txt": "} else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd;"
      },
      {
        "txt": "if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop;"
      },
      {
        "txt": "} } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break;"
      },
      {
        "txt": "default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c)"
      },
      {
        "txt": "throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); }"
      },
      {
        "txt": "_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); }"
      },
      {
        "txt": "if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { int c = 0;"
      },
      {
        "txt": "int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2;"
      },
      {
        "txt": "} } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; } }"
      },
      {
        "txt": "if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue();"
      },
      {
        "txt": "} } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break;"
      },
      {
        "txt": "} _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; }"
      },
      {
        "txt": "protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr;"
      },
      {
        "txt": "} while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      },
      {
        "txt": "{ StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break;"
      },
      {
        "txt": "} sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } private final int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i);"
      },
      {
        "txt": "break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1"
      },
      {
        "txt": "if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException {"
      },
      {
        "txt": "final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i;"
      },
      {
        "txt": "} break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } _handleEOF();"
      },
      {
        "txt": "return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else { i &= 0xFF; space_loop: while (true) {"
      },
      {
        "txt": "switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i); } break space_loop; }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private void _skipComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine();"
      },
      {
        "txt": "} else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop:"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) {"
      },
      {
        "txt": "++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {"
      },
      {
        "txt": "return false; } _skipLine(); return true; } private void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return;"
      },
      {
        "txt": "case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i);"
      },
      {
        "txt": "break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } } } @Override"
      },
      {
        "txt": "protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b':"
      },
      {
        "txt": "return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"':"
      },
      {
        "txt": "case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); }"
      },
      {
        "txt": "value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)"
      },
      {
        "txt": "c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF);"
      },
      {
        "txt": "needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); }"
      },
      {
        "txt": "} } return c; } private int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c;"
      },
      {
        "txt": "} private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; } private void _skipUtf8_2(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_3(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected void _skipCR() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask)"
      },
      {
        "txt": "throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); }"
      },
      {
        "txt": "public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {"
      },
      {
        "txt": "ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");"
      },
      {
        "txt": "} decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); }"
      }
    ]
  },
  {
    "id": 1221,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1423,
    "end-bug-line": 1423,
    "bug": "",
    "fix": "switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*;"
      },
      {
        "txt": "public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16];"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {"
      },
      {
        "txt": "super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _bufferRecyclable = bufferRecyclable; } @Override"
      },
      {
        "txt": "public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException {"
      },
      {
        "txt": "int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() {"
      },
      {
        "txt": "return _inputStream; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);"
      },
      {
        "txt": "if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } }"
      },
      {
        "txt": "return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) {"
      },
      {
        "txt": "_currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);"
      },
      {
        "txt": "if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; } return true;"
      },
      {
        "txt": "} @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; }"
      },
      {
        "txt": "} @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf);"
      },
      {
        "txt": "} } } @Override public String getText() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }"
      },
      {
        "txt": "protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME: return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT:"
      },
      {
        "txt": "case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen];"
      },
      {
        "txt": "} name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override"
      },
      {
        "txt": "public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length(); case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0;"
      },
      {
        "txt": "} @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME: return 0; case VALUE_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0;"
      },
      {
        "txt": "} @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) {"
      },
      {
        "txt": "try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf);"
      },
      {
        "txt": "} } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) {"
      },
      {
        "txt": "int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) {"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr);"
      },
      {
        "txt": "outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); }"
      },
      {
        "txt": "_tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY);"
      },
      {
        "txt": "} if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); } Name n = _parseFieldName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } i = _skipWS(); if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f':"
      },
      {
        "txt": "_matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i); break;"
      },
      {
        "txt": "default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT);"
      },
      {
        "txt": "case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': return (_currToken = _parseNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override"
      },
      {
        "txt": "public void close() throws IOException { super.close(); _symbols.release(); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "_currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "_currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "_nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0;"
      },
      {
        "txt": "final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) {"
      },
      {
        "txt": "break; } ++offset; } } } } return _isNextTokenNameMaybe(i, str); } private void _isNextTokenNameYes()"
      },
      {
        "txt": "throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return;"
      },
      {
        "txt": "} if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF;"
      },
      {
        "txt": "if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon(); } switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private boolean _isNextTokenNameMaybe(int i, SerializableString str)"
      },
      {
        "txt": "throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t;"
      },
      {
        "txt": "return match; } @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override"
      },
      {
        "txt": "public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE;"
      },
      {
        "txt": "} if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default: return null; } }"
      },
      {
        "txt": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intLen); } private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException"
      },
      {
        "txt": "{ while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength);"
      },
      {
        "txt": "} break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; ++intPartLength; }"
      },
      {
        "txt": "--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; }"
      },
      {
        "txt": "int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break; } } }"
      },
      {
        "txt": "return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; }"
      },
      {
        "txt": "++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); }"
      },
      {
        "txt": "} int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); }"
      },
      {
        "txt": "if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } <extra_id_0> protected Name _parseFieldName(int i) throws IOException, JsonParseException { if (i != INT_QUOTE) { return _handleOddName(i); }"
      },
      {
        "txt": "return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) {"
      },
      {
        "txt": "_quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4); } return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3);"
      },
      {
        "txt": "} return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2); } return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1);"
      },
      {
        "txt": "} return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException"
      },
      {
        "txt": "{ int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes"
      },
      {
        "txt": "return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); }"
      },
      {
        "txt": "return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); } protected Name parseLongName(int q) throws IOException, JsonParseException { final int[] codes = _icLatin1;"
      },
      {
        "txt": "int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); }"
      },
      {
        "txt": "q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q;"
      },
      {
        "txt": "q = i; } } protected Name slowParseName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); }"
      },
      {
        "txt": "} int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException {"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes)"
      },
      {
        "txt": "throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\");"
      },
      {
        "txt": "} else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f);"
      },
      {
        "txt": "} } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");"
      },
      {
        "txt": "} final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) {"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; }"
      },
      {
        "txt": "++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\");"
      },
      {
        "txt": "} } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0;"
      },
      {
        "txt": "final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped();"
      },
      {
        "txt": "} if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; }"
      },
      {
        "txt": "if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } }"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; }"
      },
      {
        "txt": "private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); }"
      },
      {
        "txt": "private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes);"
      },
      {
        "txt": "} private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) {"
      },
      {
        "txt": "lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3);"
      },
      {
        "txt": "ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2;"
      },
      {
        "txt": "} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2];"
      },
      {
        "txt": "byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3);"
      },
      {
        "txt": "ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0"
      },
      {
        "txt": "if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); }"
      },
      {
        "txt": "cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException"
      },
      {
        "txt": "{ int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length));"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break;"
      },
      {
        "txt": "} ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } private void _finishString2(char[] outBuf, int outPtr) throws IOException {"
      },
      {
        "txt": "int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) {"
      },
      {
        "txt": "_inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; }"
      },
      {
        "txt": "switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c);"
      },
      {
        "txt": "} else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd;"
      },
      {
        "txt": "if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop;"
      },
      {
        "txt": "} } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break;"
      },
      {
        "txt": "default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c)"
      },
      {
        "txt": "throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); }"
      },
      {
        "txt": "_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); }"
      },
      {
        "txt": "if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { int c = 0;"
      },
      {
        "txt": "int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2;"
      },
      {
        "txt": "} } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; } }"
      },
      {
        "txt": "if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF"
      },
      {
        "txt": "c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue();"
      },
      {
        "txt": "} } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break;"
      },
      {
        "txt": "} _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; }"
      },
      {
        "txt": "protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr;"
      },
      {
        "txt": "} while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      },
      {
        "txt": "{ StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break;"
      },
      {
        "txt": "} sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } private final int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i);"
      },
      {
        "txt": "break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1"
      },
      {
        "txt": "if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException {"
      },
      {
        "txt": "final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i;"
      },
      {
        "txt": "} break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } } _handleEOF();"
      },
      {
        "txt": "return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else { i &= 0xFF; space_loop: while (true) {"
      },
      {
        "txt": "switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i); } break space_loop; }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private void _skipComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine();"
      },
      {
        "txt": "} else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop:"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) {"
      },
      {
        "txt": "++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {"
      },
      {
        "txt": "return false; } _skipLine(); return true; } private void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return;"
      },
      {
        "txt": "case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i);"
      },
      {
        "txt": "break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } } } @Override"
      },
      {
        "txt": "protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b':"
      },
      {
        "txt": "return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"':"
      },
      {
        "txt": "case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); }"
      },
      {
        "txt": "value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)"
      },
      {
        "txt": "c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF);"
      },
      {
        "txt": "needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); }"
      },
      {
        "txt": "} } return c; } private int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c;"
      },
      {
        "txt": "} private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; } private void _skipUtf8_2(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_3(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected void _skipCR() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask)"
      },
      {
        "txt": "throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); }"
      },
      {
        "txt": "public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {"
      },
      {
        "txt": "ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");"
      },
      {
        "txt": "} decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); }"
      }
    ]
  },
  {
    "id": 1222,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 2575,
    "end-bug-line": 2577,
    "bug": "if (i < 32) { _throwInvalidSpace(i); }",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*; public final class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS();"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym,"
      },
      {
        "txt": "byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end;"
      },
      {
        "txt": "_bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }"
      },
      {
        "txt": "@Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count;"
      },
      {
        "txt": "} @Override public Object getInputSource() { return _inputStream; } @Override protected boolean loadMore() throws IOException { _currInputProcessed += _inputEnd;"
      },
      {
        "txt": "_currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) {"
      },
      {
        "txt": "throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } } return false; } protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false;"
      },
      {
        "txt": "} int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; }"
      },
      {
        "txt": "_inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; }"
      },
      {
        "txt": "_inputEnd += count; } return true; } @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close();"
      },
      {
        "txt": "} _inputStream = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); if (_bufferRecyclable) { byte[] buf = _inputBuffer;"
      },
      {
        "txt": "if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf); } } } @Override public String getText() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override"
      },
      {
        "txt": "public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null);"
      },
      {
        "txt": "} @Override public String getValueAsString(String defValue) throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString();"
      },
      {
        "txt": "} return super.getValueAsString(defValue); } protected String _getText2(JsonToken t) { if (t == null) { return null; } switch (t) { case FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName(); case VALUE_STRING: case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) {"
      },
      {
        "txt": "_nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case VALUE_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } }"
      },
      {
        "txt": "return null; } @Override public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken) { case FIELD_NAME: return _parsingContext.getCurrentName().length();"
      },
      {
        "txt": "case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length;"
      },
      {
        "txt": "} } return 0; } @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken) { case FIELD_NAME:"
      },
      {
        "txt": "return 0; case VALUE_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case VALUE_NUMBER_INT: case VALUE_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default:"
      },
      {
        "txt": "} } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {"
      },
      {
        "txt": "_reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion..."
      },
      {
        "txt": "if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try {"
      },
      {
        "txt": "return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0;"
      },
      {
        "txt": "final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE);"
      },
      {
        "txt": "int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } }"
      },
      {
        "txt": "if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; }"
      },
      {
        "txt": "_tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonToken nextToken() throws IOException, JsonParseException"
      },
      {
        "txt": "{ _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input"
      },
      {
        "txt": "close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT);"
      },
      {
        "txt": "} if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); }"
      },
      {
        "txt": "Name n = _parseFieldName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME; if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); }"
      },
      {
        "txt": "} i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '[':"
      },
      {
        "txt": "t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break;"
      },
      {
        "txt": "case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8':"
      },
      {
        "txt": "case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private JsonToken _nextTokenNotInObject(int i)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY);"
      },
      {
        "txt": "case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f':"
      },
      {
        "txt": "_matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1': case '2': case '3':"
      },
      {
        "txt": "case '4': case '5': case '6': case '7': case '8': case '9': return (_currToken = _parseNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); }"
      },
      {
        "txt": "private JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "return (_currToken = t); } @Override public void close() throws IOException { super.close(); _symbols.release(); } @Override public boolean nextFieldName(SerializableString str)"
      },
      {
        "txt": "throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); }"
      },
      {
        "txt": "int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); _currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null;"
      },
      {
        "txt": "if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "_reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); }"
      },
      {
        "txt": "i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe..."
      },
      {
        "txt": "final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes();"
      },
      {
        "txt": "return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) { break; } ++offset; } } } }"
      },
      {
        "txt": "return _isNextTokenNameMaybe(i, str); } private void _isNextTokenNameYes() throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; } if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY;"
      },
      {
        "txt": "return; } i &= 0xFF; if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon(); }"
      },
      {
        "txt": "switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT;"
      },
      {
        "txt": "return; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1);"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2':"
      },
      {
        "txt": "case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return; }"
      },
      {
        "txt": "_nextToken = _handleUnexpectedValue(i); } private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { Name n = _parseFieldName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr);"
      },
      {
        "txt": "match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME; i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT;"
      },
      {
        "txt": "break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2':"
      },
      {
        "txt": "case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default:"
      },
      {
        "txt": "t = _handleUnexpectedValue(i); } _nextToken = t; return match; } @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString();"
      },
      {
        "txt": "} if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; }"
      },
      {
        "txt": "@Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) {"
      },
      {
        "txt": "return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;"
      },
      {
        "txt": "} @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken()) { case VALUE_TRUE: return Boolean.TRUE; case VALUE_FALSE: return Boolean.FALSE; default:"
      },
      {
        "txt": "return null; } } protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) {"
      },
      {
        "txt": "outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) {"
      },
      {
        "txt": "c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) {"
      },
      {
        "txt": "return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intLen); }"
      },
      {
        "txt": "private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; ++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } private int _verifyNoLeadingZeroes() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); }"
      },
      {
        "txt": "++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break;"
      },
      {
        "txt": "} } } return ch; } private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { int fractLen = 0;"
      },
      {
        "txt": "boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); }"
      },
      {
        "txt": "protected Name _parseFieldName(int i) throws IOException, JsonParseException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer;"
      },
      {
        "txt": "final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4); }"
      },
      {
        "txt": "return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2); }"
      },
      {
        "txt": "return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); }"
      },
      {
        "txt": "return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException, JsonParseException { int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); }"
      },
      {
        "txt": "return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); }"
      },
      {
        "txt": "q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); }"
      },
      {
        "txt": "protected Name parseLongName(int q) throws IOException, JsonParseException { final int[] codes = _icLatin1; int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) {"
      },
      {
        "txt": "return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); }"
      },
      {
        "txt": "if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q; q = i; } } protected Name slowParseName() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0);"
      },
      {
        "txt": "} private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { _quadBuffer[0] = q1;"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done"
      },
      {
        "txt": "break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here"
      },
      {
        "txt": "currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; }"
      },
      {
        "txt": "currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\");"
      },
      {
        "txt": "} } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; }"
      },
      {
        "txt": "Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _handleOddName(int ch) throws IOException, JsonParseException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {"
      },
      {
        "txt": "return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer;"
      },
      {
        "txt": "int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; } ++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected Name _parseAposName() throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); }"
      },
      {
        "txt": "int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) {"
      },
      {
        "txt": "if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes;"
      },
      {
        "txt": "if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes;"
      },
      {
        "txt": "} ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } private Name findName(int q1, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1); if (name != null) { return name;"
      },
      {
        "txt": "} _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { Name name = _symbols.findName(q1, q2); if (name != null) { return name;"
      },
      {
        "txt": "} _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name; } private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException"
      },
      {
        "txt": "{ int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();"
      },
      {
        "txt": "int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F;"
      },
      {
        "txt": "needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far"
      },
      {
        "txt": "} if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2);"
      },
      {
        "txt": "} ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); }"
      },
      {
        "txt": "ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F);"
      },
      {
        "txt": "} } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); }"
      },
      {
        "txt": "} if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; }"
      },
      {
        "txt": "return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; }"
      },
      {
        "txt": "int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1;"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return; } break; } ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr);"
      },
      {
        "txt": "} private void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop:"
      },
      {
        "txt": "while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr;"
      },
      {
        "txt": "} if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c);"
      },
      {
        "txt": "outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\");"
      },
      {
        "txt": "} else { _reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c;"
      },
      {
        "txt": "ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) {"
      },
      {
        "txt": "c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop;"
      },
      {
        "txt": "} switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF _skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c);"
      },
      {
        "txt": "break; case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); }"
      },
      {
        "txt": "} } } protected JsonToken _handleUnexpectedValue(int c) throws IOException { switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos();"
      },
      {
        "txt": "} break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I':"
      },
      {
        "txt": "_matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue();"
      },
      {
        "txt": "} } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; }"
      },
      {
        "txt": "protected JsonToken _handleApos() throws IOException { int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) {"
      },
      {
        "txt": "ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd;"
      },
      {
        "txt": "{ int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; } } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } } if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here"
      },
      {
        "txt": "c = _decodeEscaped(); } break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else {"
      },
      {
        "txt": "c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException {"
      },
      {
        "txt": "while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\";"
      },
      {
        "txt": "} else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");"
      },
      {
        "txt": "} reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore())"
      },
      {
        "txt": "|| (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars"
      },
      {
        "txt": "return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } } protected void _reportInvalidToken(String matchedPart) throws IOException {"
      },
      {
        "txt": "_reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; }"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } private final int _skipWS() throws IOException"
      },
      {
        "txt": "{ final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF"
      },
      {
        "txt": "_skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow;"
      },
      {
        "txt": "_currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) {"
      },
      {
        "txt": "return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); } }"
      },
      {
        "txt": "throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i;"
      },
      {
        "txt": "case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i);"
      },
      {
        "txt": "break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment();"
      },
      {
        "txt": "case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 <extra_id_0> _reportInvalidChar(i); } } _handleEOF(); return -1; }"
      },
      {
        "txt": "return -1; } private int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else { i &= 0xFF; space_loop: while (true) {"
      },
      {
        "txt": "switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i); } break space_loop; }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private void _skipComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine();"
      },
      {
        "txt": "} else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop:"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) {"
      },
      {
        "txt": "++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {"
      },
      {
        "txt": "return false; } _skipLine(); return true; } private void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return;"
      },
      {
        "txt": "case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i);"
      },
      {
        "txt": "break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } } } @Override"
      },
      {
        "txt": "protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b':"
      },
      {
        "txt": "return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"':"
      },
      {
        "txt": "case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); }"
      },
      {
        "txt": "value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)"
      },
      {
        "txt": "c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF);"
      },
      {
        "txt": "needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); }"
      },
      {
        "txt": "} } return c; } private int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c;"
      },
      {
        "txt": "} private int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; } private void _skipUtf8_2(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_3(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected void _skipCR() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask)"
      },
      {
        "txt": "throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); }"
      },
      {
        "txt": "public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException {"
      },
      {
        "txt": "ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");"
      },
      {
        "txt": "} decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); }"
      }
    ]
  }
]