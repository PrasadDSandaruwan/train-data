[
  {
    "id": 1223,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 125,
    "end-bug-line": 125,
    "bug": "",
    "fix": "_currInputRowStart = start;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*;"
      },
      {
        "txt": "public class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16];"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {"
      },
      {
        "txt": "_inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; <extra_id_0> _bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() { return _objectCodec; }"
      },
      {
        "txt": "return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr;"
      },
      {
        "txt": "if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _inputStream;"
      },
      {
        "txt": "} @Override protected final boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) {"
      },
      {
        "txt": "_inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } } return false;"
      },
      {
        "txt": "} protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr;"
      },
      {
        "txt": "_currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) {"
      },
      {
        "txt": "_closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; } return true; }"
      },
      {
        "txt": "@Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; } }"
      },
      {
        "txt": "@Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf);"
      },
      {
        "txt": "} } } @Override public String getText() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); }"
      },
      {
        "txt": "protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT:"
      },
      {
        "txt": "case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters() throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen];"
      },
      {
        "txt": "} name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override"
      },
      {
        "txt": "public int getTextLength() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0;"
      },
      {
        "txt": "} @Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0;"
      },
      {
        "txt": "} @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) {"
      },
      {
        "txt": "try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf);"
      },
      {
        "txt": "} } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) {"
      },
      {
        "txt": "int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) {"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr);"
      },
      {
        "txt": "outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); } return outputCount; } @Override public JsonLocation getTokenLocation() { return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), -1L, // bytes, chars getTokenLineNr(),"
      },
      {
        "txt": "getTokenColumnNr()); } @Override public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr, -1L, // bytes, chars _currInputRow, col); }"
      },
      {
        "txt": "@Override public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial"
      },
      {
        "txt": "} int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null;"
      },
      {
        "txt": "if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); }"
      },
      {
        "txt": "if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); } Name n = _parseName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME; if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS();"
      },
      {
        "txt": "if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t;"
      },
      {
        "txt": "return _currToken; } private final JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) {"
      },
      {
        "txt": "case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't':"
      },
      {
        "txt": "_matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0':"
      },
      {
        "txt": "case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return (_currToken = _parseNumber(i));"
      },
      {
        "txt": "} return (_currToken = _handleUnexpectedValue(i)); } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "_currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "_currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "_nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0;"
      },
      {
        "txt": "final int ptr = _inputPtr; while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) {"
      },
      {
        "txt": "break; } ++offset; } } } } return _isNextTokenNameMaybe(i, str); } private final void _isNextTokenNameYes()"
      },
      {
        "txt": "throws IOException, JsonParseException { int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return;"
      },
      {
        "txt": "} if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF;"
      },
      {
        "txt": "if (i <= INT_SPACE || i == INT_SLASH) { --_inputPtr; i = _skipWS(); } } else { i = _skipColon(); } switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': _nextToken = _parseNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private final boolean _isNextTokenNameMaybe(int i, SerializableString str)"
      },
      {
        "txt": "throws IOException, JsonParseException { Name n = _parseName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipWS(); if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}':"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t;"
      },
      {
        "txt": "return match; } @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue)"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override"
      },
      {
        "txt": "public Boolean nextBooleanValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE;"
      },
      {
        "txt": "} if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} switch (nextToken().id()) { case ID_TRUE: return Boolean.TRUE; case ID_FALSE: return Boolean.FALSE; default: return null; } }"
      },
      {
        "txt": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "int intLen = 1; int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c < INT_0 || c > INT_9) { break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(negative, intLen); }"
      },
      {
        "txt": "private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c > INT_9 || c < INT_0) { if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; ++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } return resetInt(negative, intPartLength); }"
      },
      {
        "txt": "private final int _verifyNoLeadingZeroes() throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; }"
      },
      {
        "txt": "if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; }"
      },
      {
        "txt": "++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break; } } } return ch; } private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength)"
      },
      {
        "txt": "throws IOException, JsonParseException { int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true;"
      },
      {
        "txt": "break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop:"
      },
      {
        "txt": "while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop;"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) {"
      },
      {
        "txt": "_verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) {"
      },
      {
        "txt": "case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return;"
      },
      {
        "txt": "} _reportMissingRootWS(ch); } protected Name _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName();"
      },
      {
        "txt": "} final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) {"
      },
      {
        "txt": "q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken"
      },
      {
        "txt": "return findName(q, 4); } return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken"
      },
      {
        "txt": "return findName(q, 2); } return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\""
      },
      {
        "txt": "return BytesToNameCanonicalizer.getEmptyName(); } return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException { int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1);"
      },
      {
        "txt": "} return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2);"
      },
      {
        "txt": "} q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i;"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i);"
      },
      {
        "txt": "} protected Name parseLongName(int q) throws IOException { final int[] codes = _icLatin1; int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) {"
      },
      {
        "txt": "return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); }"
      },
      {
        "txt": "if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q; q = i; } } protected Name slowParseName() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); }"
      },
      {
        "txt": "private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,"
      },
      {
        "txt": "int currQuadBytes) throws IOException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\");"
      },
      {
        "txt": "} else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f);"
      },
      {
        "txt": "} } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected Name _handleOddName(int ch) throws IOException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\"); }"
      },
      {
        "txt": "final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) {"
      },
      {
        "txt": "++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; } ++_inputPtr;"
      },
      {
        "txt": "} if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes);"
      },
      {
        "txt": "} return name; } protected Name _parseAposName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } }"
      },
      {
        "txt": "int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) {"
      },
      {
        "txt": "if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) {"
      },
      {
        "txt": "if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));"
      },
      {
        "txt": "++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes;"
      },
      {
        "txt": "currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } private final Name findName(int q1, int lastQuadBytes) throws JsonParseException"
      },
      {
        "txt": "{ Name name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private final Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException"
      },
      {
        "txt": "{ Name name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)"
      },
      {
        "txt": "throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); }"
      },
      {
        "txt": "return name; } private final Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));"
      },
      {
        "txt": "} else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix;"
      },
      {
        "txt": "if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07;"
      },
      {
        "txt": "needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3);"
      },
      {
        "txt": "ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3));"
      },
      {
        "txt": "++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix;"
      },
      {
        "txt": "if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment();"
      },
      {
        "txt": "} cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; }"
      },
      {
        "txt": "String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) {"
      },
      {
        "txt": "int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break; } ++ptr;"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } private final void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8;"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash"
      },
      {
        "txt": "c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c);"
      },
      {
        "txt": "} break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF);"
      },
      {
        "txt": "break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8;"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } }"
      },
      {
        "txt": "_inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF"
      },
      {
        "txt": "_skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c) throws IOException {"
      },
      {
        "txt": "switch (c) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN);"
      },
      {
        "txt": "} _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break;"
      },
      {
        "txt": "case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");"
      },
      {
        "txt": "} _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();"
      },
      {
        "txt": "final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; } }"
      },
      {
        "txt": "while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; } } if (c == '\\'') { break main_loop;"
      },
      {
        "txt": "} switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break;"
      },
      {
        "txt": "case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10));"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); }"
      },
      {
        "txt": "_reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING;"
      },
      {
        "txt": "} protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break; } _matchToken(match, 3);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected void _matchToken(String matchStr, int i) throws IOException"
      },
      {
        "txt": "{ final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); }"
      },
      {
        "txt": "} private final int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip"
      },
      {
        "txt": "continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break;"
      },
      {
        "txt": "case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i);"
      },
      {
        "txt": "} } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) {"
      },
      {
        "txt": "case 0: // done! return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break;"
      },
      {
        "txt": "case '/': _skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 _reportInvalidChar(i);"
      },
      {
        "txt": "} } _handleEOF(); return -1; } private final int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int i = _inputBuffer[_inputPtr++]; if (i == INT_COLON) { if (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else {"
      },
      {
        "txt": "i &= 0xFF; space_loop: while (true) { switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break;"
      },
      {
        "txt": "case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} break space_loop; } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");"
      },
      {
        "txt": "} } while (_inputPtr < _inputEnd || loadMore()) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } }"
      },
      {
        "txt": "throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private final void _skipCComment() throws IOException"
      },
      {
        "txt": "{ final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "break; case INT_CR: _skipCR(); break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "private final boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private final void _skipLine() throws IOException {"
      },
      {
        "txt": "final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return;"
      },
      {
        "txt": "case INT_CR: _skipCR(); return; case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i);"
      },
      {
        "txt": "break; case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } }"
      },
      {
        "txt": "} } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } }"
      },
      {
        "txt": "int c = (int) _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f';"
      },
      {
        "txt": "case 'r': return '\\r'; case '\"': case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));"
      },
      {
        "txt": "} int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch);"
      },
      {
        "txt": "if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte;"
      },
      {
        "txt": "if (c < 0) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07;"
      },
      {
        "txt": "needed = 3; } else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F);"
      },
      {
        "txt": "if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); } } } return c; } private final int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private final int _decodeUtf8_3(int c1) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_3fast(int c1) throws IOException"
      },
      {
        "txt": "{ c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000;"
      },
      {
        "txt": "} private final void _skipUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); }"
      },
      {
        "txt": "} private final void _skipUtf8_3(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_4(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} } protected final void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow;"
      },
      {
        "txt": "_currInputRowStart = _inputPtr; } private int nextByte() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidToken(String matchedPart) throws IOException"
      },
      {
        "txt": "{ _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; }"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } protected void _reportInvalidChar(int c)"
      },
      {
        "txt": "throws JsonParseException { if (c < INT_SPACE) { _throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException {"
      },
      {
        "txt": "_reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {"
      },
      {
        "txt": "_inputPtr = ptr; _reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); }"
      },
      {
        "txt": "@SuppressWarnings(\"resource\") protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue;"
      },
      {
        "txt": "} } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData);"
      },
      {
        "txt": "return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } }"
      }
    ]
  },
  {
    "id": 1224,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 126,
    "end-bug-line": 126,
    "bug": "",
    "fix": "_currInputProcessed = -start;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.*; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*;"
      },
      {
        "txt": "public class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); private final static int[] _icWS = CharTypes.getInputCodeWS(); protected ObjectCodec _objectCodec; final protected BytesToNameCanonicalizer _symbols; protected int[] _quadBuffer = new int[16];"
      },
      {
        "txt": "protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {"
      },
      {
        "txt": "_inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; <extra_id_0> } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override"
      },
      {
        "txt": "} @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) {"
      },
      {
        "txt": "return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _inputStream; }"
      },
      {
        "txt": "@Override protected final boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0;"
      },
      {
        "txt": "_inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } } return false; }"
      },
      {
        "txt": "protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr;"
      },
      {
        "txt": "System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput();"
      },
      {
        "txt": "if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; } return true; } @Override"
      },
      {
        "txt": "protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; } } @Override"
      },
      {
        "txt": "protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseReadIOBuffer(buf); }"
      },
      {
        "txt": "} } @Override public String getText() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete"
      },
      {
        "txt": "} return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException, JsonParseException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); } protected final String _getText2(JsonToken t)"
      },
      {
        "txt": "{ if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT:"
      },
      {
        "txt": "return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters() throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document"
      },
      {
        "txt": "switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; }"
      },
      {
        "txt": "name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT:"
      },
      {
        "txt": "case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override public int getTextLength()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete"
      },
      {
        "txt": "} case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0; }"
      },
      {
        "txt": "@Override public int getTextOffset() throws IOException, JsonParseException { if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0; }"
      },
      {
        "txt": "@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try {"
      },
      {
        "txt": "_binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant);"
      },
      {
        "txt": "_binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); }"
      },
      {
        "txt": "} protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch;"
      },
      {
        "txt": "do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break;"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0;"
      },
      {
        "txt": "} int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr);"
      },
      {
        "txt": "} return outputCount; } @Override public JsonLocation getTokenLocation() { return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), -1L, // bytes, chars getTokenLineNr(), getTokenColumnNr());"
      },
      {
        "txt": "} @Override public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr, -1L, // bytes, chars _currInputRow, col); } @Override"
      },
      {
        "txt": "public JsonToken nextToken() throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial }"
      },
      {
        "txt": "int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) {"
      },
      {
        "txt": "if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); }"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "return _nextTokenNotInObject(i); } Name n = _parseName(i); _parsingContext.setCurrentName(n.getName()); _currToken = JsonToken.FIELD_NAME; if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') { ++_inputPtr; } else { i = _skipWS(); if (i != INT_COLON) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t;"
      },
      {
        "txt": "switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\");"
      },
      {
        "txt": "case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken;"
      },
      {
        "txt": "} private final JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[':"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return (_currToken = _parseNumber(i)); }"
      },
      {
        "txt": "return (_currToken = _handleUnexpectedValue(i)); } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name"
      },
      {
        "txt": "_nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); _currToken = null;"
      },
      {
        "txt": "return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); }"
      },
      {
        "txt": "_parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT;"
      },
      {
        "txt": "return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i);"
      },
      {
        "txt": "return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; final int ptr = _inputPtr;"
      },
      {
        "txt": "while (true) { if (offset == len) { // yes, match! _inputPtr = end+1; // skip current value first _parsingContext.setCurrentName(str.getValue()); _currToken = JsonToken.FIELD_NAME; _isNextTokenNameYes(); return true; } if (nameBytes[offset] != _inputBuffer[ptr+offset]) { break;"
      },
      {
        "txt": "} ++offset; } } } } return _isNextTokenNameMaybe(i, str); } private final void _isNextTokenNameYes() throws IOException, JsonParseException"
      },
      {
        "txt": "{ int i; if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first i = _inputBuffer[++_inputPtr]; ++_inputPtr; if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; }"
      },
      {
        "txt": "if (i == INT_LCURLY) { _nextToken = JsonToken.START_OBJECT; return; } if (i == INT_LBRACKET) { _nextToken = JsonToken.START_ARRAY; return; } i &= 0xFF; if (i <= INT_SPACE || i == INT_SLASH) {"
      },
      {
        "txt": "--_inputPtr; i = _skipWS(); } } else { i = _skipColon(); } switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;"
      },
      {
        "txt": "return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\");"
      },
      {
        "txt": "case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1);"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_NULL; return; case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': _nextToken = _parseNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException"
      },
      {
        "txt": "{ Name n = _parseName(i); final boolean match; { String nameStr = n.getName(); _parsingContext.setCurrentName(nameStr); match = nameStr.equals(str.getValue()); } _currToken = JsonToken.FIELD_NAME; i = _skipWS();"
      },
      {
        "txt": "if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } i = _skipWS(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t;"
      },
      {
        "txt": "switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\");"
      },
      {
        "txt": "case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_NULL; break; case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parseNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match;"
      },
      {
        "txt": "} @Override public String nextTextValue() throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException, JsonParseException {"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException, JsonParseException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; }"
      },
      {
        "txt": "if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; }"
      },
      {
        "txt": "switch (nextToken().id()) { case ID_TRUE: return Boolean.TRUE; case ID_FALSE: return Boolean.FALSE; default: return null; } } protected JsonToken _parseNumber(int c)"
      },
      {
        "txt": "throws IOException, JsonParseException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; boolean negative = (c == INT_MINUS); if (negative) { outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } } if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1;"
      },
      {
        "txt": "int end = _inputPtr + outBuf.length; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parserNumber2(outBuf, outPtr, negative, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) {"
      },
      {
        "txt": "break; } ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') {"
      },
      {
        "txt": "return _parseFloat(outBuf, outPtr, c, negative, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(negative, intLen); } private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,"
      },
      {
        "txt": "int intPartLength) throws IOException, JsonParseException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) {"
      },
      {
        "txt": "if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } return resetInt(negative, intPartLength); } private final int _verifyNoLeadingZeroes()"
      },
      {
        "txt": "throws IOException, JsonParseException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {"
      },
      {
        "txt": "reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes"
      },
      {
        "txt": "if (ch != INT_0) { // followed by other number; return break; } } } return ch; } private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException"
      },
      {
        "txt": "{ int fractLen = 0; boolean eof = false; if (c == '.') { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop;"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) {"
      },
      {
        "txt": "++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c);"
      },
      {
        "txt": "} } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ':"
      },
      {
        "txt": "case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; }"
      },
      {
        "txt": "_reportMissingRootWS(ch); } protected Name _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote) return slowParseName(); }"
      },
      {
        "txt": "final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i;"
      },
      {
        "txt": "i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i, codes); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 4);"
      },
      {
        "txt": "} return parseName(q, i, 4); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 2);"
      },
      {
        "txt": "} return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName();"
      },
      {
        "txt": "} return parseName(0, q, 0); // quoting or invalid char } protected Name parseMediumName(int q2, final int[] codes) throws IOException { int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); }"
      },
      {
        "txt": "return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); }"
      },
      {
        "txt": "q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; return parseLongName(i); }"
      },
      {
        "txt": "protected Name parseLongName(int q) throws IOException { final int[] codes = _icLatin1; int qlen = 2; while (true) { if ((_inputEnd - _inputPtr) < 4) { return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } int i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2);"
      },
      {
        "txt": "} return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3);"
      },
      {
        "txt": "} q = (q << 8) | i; i = _inputBuffer[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) {"
      },
      {
        "txt": "_quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q; q = i; } } protected Name slowParseName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return BytesToNameCanonicalizer.getEmptyName(); } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException"
      },
      {
        "txt": "{ return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException"
      },
      {
        "txt": "{ final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else {"
      },
      {
        "txt": "ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0;"
      },
      {
        "txt": "} if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); }"
      },
      {
        "txt": "} if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch;"
      },
      {
        "txt": "currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name;"
      },
      {
        "txt": "} protected Name _handleOddName(int ch) throws IOException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames();"
      },
      {
        "txt": "if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes;"
      },
      {
        "txt": "currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; } ++_inputPtr; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected Name _parseAposName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (ch == '\\'') { // special case, '' return BytesToNameCanonicalizer.getEmptyName(); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') {"
      },
      {
        "txt": "break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes;"
      },
      {
        "txt": "} else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0;"
      },
      {
        "txt": "} currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch;"
      },
      {
        "txt": "} else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "} Name name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } private final Name findName(int q1, int lastQuadBytes) throws JsonParseException {"
      },
      {
        "txt": "Name name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private final Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException {"
      },
      {
        "txt": "Name name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException"
      },
      {
        "txt": "{ if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = lastQuad; Name name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name;"
      },
      {
        "txt": "} private final Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else {"
      },
      {
        "txt": "lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte"
      },
      {
        "txt": "int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3;"
      },
      {
        "txt": "} else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3));"
      },
      {
        "txt": "++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix;"
      },
      {
        "txt": "if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); }"
      },
      {
        "txt": "cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix);"
      },
      {
        "txt": "if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF;"
      },
      {
        "txt": "if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break; } ++ptr; outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} _inputPtr = ptr; _finishString2(outBuf, outPtr); } private final void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer;"
      },
      {
        "txt": "main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); }"
      },
      {
        "txt": "break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break;"
      },
      {
        "txt": "default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer;"
      },
      {
        "txt": "main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr;"
      },
      {
        "txt": "max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr;"
      },
      {
        "txt": "} if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF _skipUtf8_2(c);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\");"
      },
      {
        "txt": "} else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c) throws IOException { switch (c) {"
      },
      {
        "txt": "case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); }"
      },
      {
        "txt": "_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); }"
      },
      {
        "txt": "_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8;"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; } } while (_inputPtr < max) {"
      },
      {
        "txt": "c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; } } if (c == '\\'') { break main_loop; }"
      },
      {
        "txt": "switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF"
      },
      {
        "txt": "if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c);"
      },
      {
        "txt": "} if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; }"
      },
      {
        "txt": "protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {"
      },
      {
        "txt": "return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected void _matchToken(String matchStr, int i) throws IOException {"
      },
      {
        "txt": "final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return;"
      },
      {
        "txt": "} int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars return; } char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } }"
      },
      {
        "txt": "private final int _skipWS() throws IOException { final int[] codes = _icWS; while (_inputPtr < _inputEnd || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done! return i; case 1: // skip continue;"
      },
      {
        "txt": "case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; case INT_LF:"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/': _skipComment(); break; case '#':"
      },
      {
        "txt": "if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 if (i < 32) { _throwInvalidSpace(i); } _reportInvalidChar(i); }"
      },
      {
        "txt": "} throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { final int[] codes = _icWS; while ((_inputPtr < _inputEnd) || loadMore()) { final int i = _inputBuffer[_inputPtr++] & 0xFF; switch (codes[i]) { case 0: // done!"
      },
      {
        "txt": "return i; case 1: // skip continue; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF"
      },
      {
        "txt": "_skipUtf8_4(i); break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break; case '/':"
      },
      {
        "txt": "_skipComment(); break; case '#': if (!_skipYAMLComment()) { return i; } break; default: // e.g. -1 _reportInvalidChar(i); }"
      },
      {
        "txt": "} _handleEOF(); return -1; } private final int _skipColon() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (i == INT_COLON) { if (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr] & 0xFF; if (i > INT_SPACE && i != INT_SLASH) { ++_inputPtr; return i; } } } else { i &= 0xFF;"
      },
      {
        "txt": "space_loop: while (true) { switch (i) { case ' ': case '\\t': break; case INT_CR: _skipCR(); break; case INT_LF:"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; break; case '/': _skipComment(); break; default: if (i < INT_SPACE) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "break space_loop; } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } i = _inputBuffer[_inputPtr++] & 0xFF; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); }"
      },
      {
        "txt": "} while (_inputPtr < _inputEnd || loadMore()) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i != INT_SLASH) { return i; } _skipComment(); } else if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} private final void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private final void _skipCComment() throws IOException {"
      },
      {
        "txt": "final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop;"
      },
      {
        "txt": "} if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break;"
      },
      {
        "txt": "case INT_CR: _skipCR(); break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF"
      },
      {
        "txt": "_skipUtf8_4(i); break; default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private final boolean _skipYAMLComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private final void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment();"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR:"
      },
      {
        "txt": "_skipCR(); return; case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } }"
      },
      {
        "txt": "} @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r':"
      },
      {
        "txt": "return '\\r'; case '\"': case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); }"
      },
      {
        "txt": "int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) {"
      },
      {
        "txt": "_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = (int) firstByte; if (c < 0) { // if >= 0, is ascii and fine as is"
      },
      {
        "txt": "int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3;"
      },
      {
        "txt": "} else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total"
      },
      {
        "txt": "d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); } } } return c; } private final int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private final int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_3fast(int c1) throws IOException {"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; }"
      },
      {
        "txt": "private final void _skipUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } }"
      },
      {
        "txt": "private final void _skipUtf8_3(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "} protected final void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} private int nextByte() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidToken(String matchedPart) throws IOException {"
      },
      {
        "txt": "_reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } protected void _reportInvalidChar(int c) throws JsonParseException"
      },
      {
        "txt": "{ if (c < INT_SPACE) { _throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));"
      },
      {
        "txt": "} protected void _reportInvalidOther(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr;"
      },
      {
        "txt": "_reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; }"
      },
      {
        "txt": "} int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4;"
      },
      {
        "txt": "builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "builder.appendThreeBytes(decodedData); } }"
      }
    ]
  }
]