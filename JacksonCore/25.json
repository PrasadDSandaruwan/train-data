[
  {
    "id": 1302,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 1963,
    "end-bug-line": 1963,
    "bug": "if (i <= maxCode) {",
    "fix": "if (i < maxCode) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*; public class ReaderBasedJsonParser // final in 2.3, earlier extends ParserBase { protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected Reader _reader; protected char[] _inputBuffer; protected boolean _bufferRecyclable;"
      },
      {
        "txt": "protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete; protected long _nameStartOffset; protected int _nameStartRow; protected int _nameStartCol; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st, char[] inputBuffer, int start, int end,"
      },
      {
        "txt": "boolean bufferRecyclable) { super(ctxt, features); _reader = r; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed();"
      },
      {
        "txt": "_bufferRecyclable = bufferRecyclable; } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _inputPtr = 0; _inputEnd = 0;"
      },
      {
        "txt": "_objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed(); _bufferRecyclable = true; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr;"
      },
      {
        "txt": "if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _reader; } @Deprecated // since 2.8 protected char getNextChar(String eofMsg) throws IOException { return getNextChar(eofMsg, null); }"
      },
      {
        "txt": "protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { _reportInvalidEOF(eofMsg, forToken); } } return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException {"
      },
      {
        "txt": "if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close(); } _reader = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers();"
      },
      {
        "txt": "_symbols.release(); if (_bufferRecyclable) { char[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseTokenBuffer(buf); } } } protected void _loadMoreGuaranteed() throws IOException {"
      },
      {
        "txt": "if (!_loadMore()) { _reportInvalidEOF(); } } protected boolean _loadMore() throws IOException { final int bufSize = _inputEnd; _currInputProcessed += bufSize; _currInputRowStart -= bufSize; _nameStartOffset -= bufSize; if (_reader != null) { int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);"
      },
      {
        "txt": "if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd); } }"
      },
      {
        "txt": "return false; } @Override public final String getText() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete"
      },
      {
        "txt": "} return _textBuffer.contentsAsString(); } return _getText2(t); } @Override // since 2.8 public int getText(Writer writer) throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsToWriter(writer); } if (t == JsonToken.FIELD_NAME) { String n = _parsingContext.getCurrentName(); writer.write(n); return n.length();"
      },
      {
        "txt": "} if (t != null) { if (t.isNumeric()) { return _textBuffer.contentsToWriter(writer); } char[] ch = t.asCharArray(); writer.write(ch); return ch.length; } return 0;"
      },
      {
        "txt": "} @Override public final String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString();"
      },
      {
        "txt": "} if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); } @Override public final String getValueAsString(String defValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(defValue); }"
      },
      {
        "txt": "protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT:"
      },
      {
        "txt": "return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public final char[] getTextCharacters() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) {"
      },
      {
        "txt": "case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0);"
      },
      {
        "txt": "_nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT:"
      },
      {
        "txt": "return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override public final int getTextLength() throws IOException {"
      },
      {
        "txt": "if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT:"
      },
      {
        "txt": "case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0; } @Override public final int getTextOffset() throws IOException"
      },
      {
        "txt": "{ if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException"
      },
      {
        "txt": "{ if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) { return _binaryValue; } if (_currToken != JsonToken.VALUE_STRING) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray();"
      },
      {
        "txt": "} } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b);"
      },
      {
        "txt": "return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException"
      },
      {
        "txt": "{ int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { char ch; do { if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue;"
      },
      {
        "txt": "} } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"') { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; if (b64variant.usesPadding()) { --_inputPtr; // to keep parser state bit more consistent _handleBase64MissingPadding(b64variant);"
      },
      {
        "txt": "} break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"') { decodedData >>= 2;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; if (b64variant.usesPadding()) { --_inputPtr; // to keep parser state bit more consistent _handleBase64MissingPadding(b64variant); } break; } bits = _decodeBase64Escape(b64variant, ch, 3); }"
      },
      {
        "txt": "if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override"
      },
      {
        "txt": "public final JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd();"
      },
      {
        "txt": "if (i < 0) { // end-of-input close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET || i == INT_RCURLY) { _closeScope(i); return _currToken; } if (_parsingContext.expectComma()) {"
      },
      {
        "txt": "i = _skipComma(i); if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) { if ((i == INT_RBRACKET) || (i == INT_RCURLY)) { _closeScope(i); return _currToken; } } } boolean inObject = _parsingContext.inObject(); if (inObject) {"
      },
      {
        "txt": "_updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } _updateLocation(); JsonToken t; switch (i) { case '\"':"
      },
      {
        "txt": "_tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchTrue(); t = JsonToken.VALUE_TRUE;"
      },
      {
        "txt": "break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case '-':"
      },
      {
        "txt": "t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':"
      },
      {
        "txt": "case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t;"
      },
      {
        "txt": "return _currToken; } _currToken = t; return t; } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public void finishToken() throws IOException { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } } @Override public boolean nextFieldName(SerializableString sstr) throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName();"
      },
      {
        "txt": "return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return false;"
      },
      {
        "txt": "} _binaryValue = null; if (i == INT_RBRACKET || i == INT_RCURLY) { _closeScope(i); return false; } if (_parsingContext.expectComma()) { i = _skipComma(i); if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) { if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {"
      },
      {
        "txt": "_closeScope(i); return false; } } } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return false; }"
      },
      {
        "txt": "_updateNameLocation(); if (i == INT_QUOTE) { char[] nameChars = sstr.asQuotedChars(); final int len = nameChars.length; if ((_inputPtr + len + 4) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == '\"') { int offset = 0; int ptr = _inputPtr; while (true) {"
      },
      {
        "txt": "if (ptr == end) { // yes, match! _parsingContext.setCurrentName(sstr.getValue()); _isNextTokenNameYes(_skipColonFast(ptr+1)); return true; } if (nameChars[offset] != _inputBuffer[ptr]) { break; } ++offset; ++ptr;"
      },
      {
        "txt": "} } } } return _isNextTokenNameMaybe(i, sstr.getValue()); } @Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close();"
      },
      {
        "txt": "_currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET || i == INT_RCURLY) { _closeScope(i); return null; } if (_parsingContext.expectComma()) { i = _skipComma(i);"
      },
      {
        "txt": "if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) { if ((i == INT_RBRACKET) || (i == INT_RCURLY)) { _closeScope(i); return null; } } } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i);"
      },
      {
        "txt": "return null; } _updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return name; } JsonToken t; switch (i) { case '-': t = _parseNegNumber(); break; case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break;"
      },
      {
        "txt": "case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue();"
      },
      {
        "txt": "t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i);"
      },
      {
        "txt": "break; } _nextToken = t; return name; } private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation(); switch (i) {"
      },
      {
        "txt": "case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return;"
      },
      {
        "txt": "case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1);"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4':"
      },
      {
        "txt": "case '5': case '6': case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleOddValue(i); }"
      },
      {
        "txt": "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;"
      },
      {
        "txt": "return nameToMatch.equals(name); } JsonToken t; switch (i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2':"
      },
      {
        "txt": "case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f':"
      },
      {
        "txt": "_matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE;"
      },
      {
        "txt": "break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break;"
      },
      {
        "txt": "} _nextToken = t; return nameToMatch.equals(name); } private final JsonToken _nextTokenNotInObject(int i) throws IOException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); }"
      },
      {
        "txt": "switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE);"
      },
      {
        "txt": "case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': return (_currToken = _parseNegNumber()); case '0': case '1':"
      },
      {
        "txt": "case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return (_currToken = _parsePosNumber(i)); case ',':"
      },
      {
        "txt": "case ']': if(isEnabled(Feature.ALLOW_MISSING_VALUES)) { _inputPtr--; return (_currToken = JsonToken.VALUE_NULL); } } return (_currToken = _handleOddValue(i)); } @Override public final String nextTextValue() throws IOException"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString();"
      },
      {
        "txt": "} return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public final int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public final long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; }"
      },
      {
        "txt": "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public final Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return null; } JsonToken t = nextToken(); if (t != null) { int id = t.id(); if (id == ID_TRUE) return Boolean.TRUE; if (id == ID_FALSE) return Boolean.FALSE; } return null;"
      },
      {
        "txt": "} protected final JsonToken _parsePosNumber(int ch) throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include digit already read final int inputLen = _inputEnd; if (ch == INT_0) { return _parseNumber2(false, startPtr); } int intLen = 1; // already got one"
      },
      {
        "txt": "int_loop: while (true) { if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(false, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; }"
      },
      {
        "txt": "++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, false, intLen); } --ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch);"
      },
      {
        "txt": "} int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(false, intLen); } private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd; int fractLen = 0;"
      },
      {
        "txt": "if (ch == '.') { // yes, fraction fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; }"
      },
      {
        "txt": "++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { _inputPtr = startPtr;"
      },
      {
        "txt": "return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; }"
      },
      {
        "txt": "while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; } if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");"
      },
      {
        "txt": "} } --ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetFloat(neg, intLen, fractLen, expLen);"
      },
      {
        "txt": "} protected final JsonToken _parseNegNumber() throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; if (ptr >= inputLen) { return _parseNumber2(true, startPtr); } int ch = _inputBuffer[ptr++];"
      },
      {
        "txt": "if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } if (ch == INT_0) { return _parseNumber2(true, startPtr); } int intLen = 1; // already got one int_loop: while (true) {"
      },
      {
        "txt": "if (ptr >= inputLen) { return _parseNumber2(true, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {"
      },
      {
        "txt": "_inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, true, intLen); } --ptr; _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len);"
      },
      {
        "txt": "return resetInt(true, intLen); } private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException { _inputPtr = neg ? (startPtr+1) : startPtr; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (neg) { outBuf[outPtr++] = '-'; }"
      },
      {
        "txt": "int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') { ++intLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !_loadMore()) { c = CHAR_NULL; eof = true; break int_loop; }"
      },
      {
        "txt": "c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { return _handleInvalidNumberStart(c, neg); } int fractLen = 0; if (c == '.') { // yes, fraction if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !_loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) {"
      },
      {
        "txt": "break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c;"
      },
      {
        "txt": "c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");"
      },
      {
        "txt": "} exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !_loadMore()) {"
      },
      {
        "txt": "eof = true; break exp_loop; } c = _inputBuffer[_inputPtr++]; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) {"
      },
      {
        "txt": "--_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); return reset(neg, intLen, fractLen, expLen); } private final char _verifyNoLeadingZeroes() throws IOException {"
      },
      {
        "txt": "if (_inputPtr < _inputEnd) { char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } } return _verifyNLZ2(); } private char _verifyNLZ2() throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !_loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); }"
      },
      {
        "txt": "++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || _loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0'; } ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return break;"
      },
      {
        "txt": "} } } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!_loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); }"
      },
      {
        "txt": "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } }"
      },
      {
        "txt": "reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return;"
      },
      {
        "txt": "case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); }"
      },
      {
        "txt": "protected final String _parseName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed; final int[] codes = _icLatin1; while (ptr < _inputEnd) { int ch = _inputBuffer[ptr]; if (ch < codes.length && codes[ch] != 0) { if (ch == '\"') { int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } int start = _inputPtr; _inputPtr = ptr;"
      },
      {
        "txt": "return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) {"
      },
      {
        "txt": "break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size();"
      },
      {
        "txt": "return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");"
      },
      {
        "txt": "} final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { // identifier, or a number ([Issue#102]) firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) {"
      },
      {
        "txt": "_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr]; if (ch < maxCode) { if (codes[ch] != 0) {"
      },
      {
        "txt": "int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;"
      },
      {
        "txt": "++ptr; } while (ptr < inputLen); } int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); } protected String _parseAposName() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch == '\\'') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote"
      },
      {
        "txt": "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr;"
      },
      {
        "txt": "_inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); }"
      },
      {
        "txt": "break; case ']': if (!_parsingContext.inArray()) { break; } case ',': if (isEnabled(Feature.ALLOW_MISSING_VALUES)) { --_inputPtr; return JsonToken.VALUE_NULL; }"
      },
      {
        "txt": "break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!_loadMore()) { _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT); }"
      },
      {
        "txt": "} return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException"
      },
      {
        "txt": "{ char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.VALUE_STRING); } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break; } if (i < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) {"
      },
      {
        "txt": "if (!_loadMore()) { // acceptable for now (will error out later) break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; <extra_id_0> if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; }"
      },
      {
        "txt": "break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } @Override"
      },
      {
        "txt": "protected final void _finishString() throws IOException { int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) {"
      },
      {
        "txt": "if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1; return; } break; } ++ptr; } while (ptr < inputLen); }"
      },
      {
        "txt": "_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2(); } protected void _finishString2() throws IOException { char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int[] codes = _icLatin1; final int maxCode = codes.length;"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.VALUE_STRING); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i < maxCode && codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { break; } else if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } // anything else? } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); } protected final void _skipString() throws IOException { _tokenIncomplete = false; int inPtr = _inputPtr;"
      },
      {
        "txt": "int inLen = _inputEnd; char[] inBuf = _inputBuffer; while (true) { if (inPtr >= inLen) { _inputPtr = inPtr; if (!_loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.VALUE_STRING); } inPtr = _inputPtr;"
      },
      {
        "txt": "inLen = _inputEnd; } char c = inBuf[inPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inPtr; inPtr = _inputPtr; inLen = _inputEnd; } else if (i <= INT_QUOTE) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { _inputPtr = inPtr; break; } if (i < INT_SPACE) { _inputPtr = inPtr; _throwUnquotedSpace(i, \"string value\"); } } }"
      },
      {
        "txt": "} } protected final void _skipCR() throws IOException { if (_inputPtr < _inputEnd || _loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} private final int _skipColon() throws IOException { if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } char c = _inputBuffer[_inputPtr]; if (c == ':') { // common case, no leading space int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { // nor trailing"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) {"
      },
      {
        "txt": "return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); // true -> skipped colon } if (c == ' ' || c == '\\t') { c = _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "} if (c == ':') { int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; }"
      },
      {
        "txt": "if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } }"
      },
      {
        "txt": "return _skipColon2(true); } return _skipColon2(false); } private final int _skipColon2(boolean gotColon) throws IOException { while (_inputPtr < _inputEnd || _loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) {"
      },
      {
        "txt": "_skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } if (gotColon) { return i;"
      },
      {
        "txt": "} if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; continue; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow;"
      },
      {
        "txt": "_currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\", null);"
      },
      {
        "txt": "return -1; } private final int _skipColonFast(int ptr) throws IOException { int i = (int) _inputBuffer[ptr++]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[ptr++]; if (i > INT_SPACE) { // nor trailing if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr;"
      },
      {
        "txt": "return i; } } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } }"
      },
      {
        "txt": "} _inputPtr = ptr-1; return _skipColon2(true); // true -> skipped colon } if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[ptr++]; } boolean gotColon = (i == INT_COLON); if (gotColon) { i = _inputBuffer[ptr++];"
      },
      {
        "txt": "if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr;"
      },
      {
        "txt": "return i; } } } } _inputPtr = ptr-1; return _skipColon2(gotColon); } private final int _skipComma(int i) throws IOException {"
      },
      {
        "txt": "if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\"); } while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipAfterComma2(); }"
      },
      {
        "txt": "return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} } } return _skipAfterComma2(); } private final int _skipAfterComma2() throws IOException { while (_inputPtr < _inputEnd || _loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } return i;"
      },
      {
        "txt": "} if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { return _eofAsNextChar(); }"
      },
      {
        "txt": "} int i = _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; } if (i != INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } while (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; } if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _skipWSOrEnd2();"
      },
      {
        "txt": "} private int _skipWSOrEnd2() throws IOException { while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { // We ran out of input... return _eofAsNextChar(); } } int i = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } }"
      },
      {
        "txt": "return i; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} } } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !_loadMore()) { _reportInvalidEOF(\" in a comment\", null);"
      },
      {
        "txt": "} char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } }"
      },
      {
        "txt": "private void _skipCComment() throws IOException { while ((_inputPtr < _inputEnd) || _loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !_loadMore()) { break; } if (_inputBuffer[_inputPtr] == INT_SLASH) {"
      },
      {
        "txt": "++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } _reportInvalidEOF(\" in a comment\", null); } private boolean _skipYAMLComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private void _skipLine() throws IOException { while ((_inputPtr < _inputEnd) || _loadMore()) {"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) { _skipCR(); break; } else if (i != INT_TAB) {"
      },
      {
        "txt": "_throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!_loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n':"
      },
      {
        "txt": "return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/': case '\\\\': return c; case 'u': // and finally hex-escaped"
      },
      {
        "txt": "break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING); }"
      },
      {
        "txt": "} int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; }"
      },
      {
        "txt": "private final void _matchTrue() throws IOException { int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; }"
      },
      {
        "txt": "} } _matchToken(\"true\", 1); } private final void _matchFalse() throws IOException { int ptr = _inputPtr; if ((ptr + 4) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') { char c = b[++ptr];"
      },
      {
        "txt": "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } } } _matchToken(\"false\", 1); } private final void _matchNull() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } } }"
      },
      {
        "txt": "_matchToken(\"null\", 1); } protected final void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); if ((_inputPtr + len) >= _inputEnd) { _matchToken2(matchStr, i); return; } do {"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); int ch = _inputBuffer[_inputPtr]; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } }"
      },
      {
        "txt": "private final void _matchToken2(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !_loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len);"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !_loadMore()) { return; } int ch = _inputBuffer[_inputPtr]; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException { char ch = (char) c;"
      },
      {
        "txt": "if (Character.isJavaIdentifierPart(ch)) { _reportInvalidToken(matchStr.substring(0, i)); } } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch;"
      },
      {
        "txt": "do { if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"') { decodedData >>= 4; builder.append(decodedData); if (b64variant.usesPadding()) { --_inputPtr; // to keep parser state bit more consistent _handleBase64MissingPadding(b64variant); }"
      },
      {
        "txt": "return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) {"
      },
      {
        "txt": "if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { _loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"') { decodedData >>= 2; builder.appendTwoBytes(decodedData);"
      },
      {
        "txt": "if (b64variant.usesPadding()) { --_inputPtr; // to keep parser state bit more consistent _handleBase64MissingPadding(b64variant); } return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2;"
      },
      {
        "txt": "builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } } @Override public JsonLocation getTokenLocation()"
      },
      {
        "txt": "{ if (_currToken == JsonToken.FIELD_NAME) { long total = _currInputProcessed + (_nameStartOffset-1); return new JsonLocation(_getSourceReference(), -1L, total, _nameStartRow, _nameStartCol); } return new JsonLocation(_getSourceReference(), -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol); } @Override"
      },
      {
        "txt": "public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_getSourceReference(), -1L, _currInputProcessed + _inputPtr, _currInputRow, col); } private final void _updateLocation() { int ptr = _inputPtr; _tokenInputTotal = _currInputProcessed + ptr;"
      },
      {
        "txt": "_tokenInputRow = _currInputRow; _tokenInputCol = ptr - _currInputRowStart; } private final void _updateNameLocation() { int ptr = _inputPtr; _nameStartOffset = ptr; _nameStartRow = _currInputRow; _nameStartCol = ptr - _currInputRowStart; }"
      },
      {
        "txt": "protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while ((_inputPtr < _inputEnd) || _loadMore()) { char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) { break;"
      },
      {
        "txt": "} ++_inputPtr; sb.append(c); if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) { sb.append(\"...\"); break; } } _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg); }"
      },
      {
        "txt": "private void _closeScope(int i) throws JsonParseException { if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_ARRAY; } if (i == INT_RCURLY) {"
      },
      {
        "txt": "_updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_OBJECT; } }"
      }
    ]
  }
]