[
  {
    "id": 1231,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
    "start-bug-line": 392,
    "end-bug-line": 392,
    "bug": "",
    "fix": "if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.IOException;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.JsonParser.Feature; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.VersionUtil; import static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser { protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n';"
      },
      {
        "txt": "protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"'; protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_COLON = ':';"
      },
      {
        "txt": "protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected JsonToken _currToken; protected JsonToken _lastClearedToken; protected ParserMinimalBase() { } protected ParserMinimalBase(int features) { super(features); } @Override public abstract JsonToken nextToken() throws IOException;"
      },
      {
        "txt": "@Override public JsonToken getCurrentToken() { return _currToken; } @Override public final int getCurrentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public boolean hasCurrentToken() { return _currToken != null; } @Override public boolean hasTokenId(int id) { final JsonToken t = _currToken; if (t == null) { return (JsonTokenId.ID_NO_TOKEN == id);"
      },
      {
        "txt": "} return t.id() == id; } @Override public final boolean hasToken(JsonToken t) { return (_currToken == t); } @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; } @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; } @Override public JsonToken nextValue() throws IOException {"
      },
      {
        "txt": "JsonToken t = nextToken(); if (t == JsonToken.FIELD_NAME) { t = nextToken(); } return t; } @Override public JsonParser skipChildren() throws IOException { if (_currToken != JsonToken.START_OBJECT"
      },
      {
        "txt": "&& _currToken != JsonToken.START_ARRAY) { return this; } int open = 1; while (true) { JsonToken t = nextToken(); if (t == null) { _handleEOF(); return this; }"
      },
      {
        "txt": "if (t.isStructStart()) { ++open; } else if (t.isStructEnd()) { if (--open == 0) { return this; } } } } protected abstract void _handleEOF() throws JsonParseException;"
      },
      {
        "txt": "@Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() { if (_currToken != null) { _lastClearedToken = _currToken; _currToken = null; } }"
      },
      {
        "txt": "@Override public JsonToken getLastClearedToken() { return _lastClearedToken; } @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException; @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException"
      },
      {
        "txt": "{ JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText().trim(); if (\"true\".equals(str)) { return true; } if (\"false\".equals(str)) {"
      },
      {
        "txt": "return false; } if (_hasTextualNull(str)) { return false; } break; case ID_NUMBER_INT: return getIntValue() != 0; case ID_TRUE: return true;"
      },
      {
        "txt": "case ID_FALSE: case ID_NULL: return false; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Boolean) { return (Boolean) value; } break; default:"
      },
      {
        "txt": "} } return defaultValue; } @Override public int getValueAsInt() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue();"
      },
      {
        "txt": "} if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getIntValue(); } return getValueAsInt(0); } @Override public int getValueAsInt(int defaultValue) throws IOException { JsonToken t = _currToken;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getIntValue(); } if (t != null) { switch (t.id()) { case ID_STRING: String str = getText();"
      },
      {
        "txt": "if (_hasTextualNull(str)) { return 0; } return NumberInput.parseAsInt(str, defaultValue); case ID_TRUE: return 1; case ID_FALSE: return 0; case ID_NULL: return 0;"
      },
      {
        "txt": "case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).intValue(); } } } return defaultValue; } @Override"
      },
      {
        "txt": "public long getValueAsLong() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getLongValue(); } return getValueAsLong(0L);"
      },
      {
        "txt": "} @Override public long getValueAsLong(long defaultValue) throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getLongValue();"
      },
      {
        "txt": "} if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsLong(str, defaultValue); case ID_TRUE:"
      },
      {
        "txt": "return 1L; case ID_FALSE: case ID_NULL: return 0L; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).longValue(); } }"
      },
      {
        "txt": "} return defaultValue; } @Override public double getValueAsDouble(double defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING:"
      },
      {
        "txt": "String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsDouble(str, defaultValue); case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return getDoubleValue(); case ID_TRUE: return 1.0;"
      },
      {
        "txt": "case ID_FALSE: case ID_NULL: return 0.0; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).doubleValue(); } } }"
      },
      {
        "txt": "} @Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } <extra_id_0> } @Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); }"
      },
      {
        "txt": "return getText(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; } return getText(); } protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException { try {"
      },
      {
        "txt": "b64variant.decode(str, builder); } catch (IllegalArgumentException e) { _reportError(e.getMessage()); } } @Deprecated protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { String base;"
      },
      {
        "txt": "if (ch <= INT_SPACE) { base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\"; } else if (b64variant.usesPaddingChar(ch)) { base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\"; } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } else { base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } if (msg != null) {"
      },
      {
        "txt": "base = base + \": \" + msg; } throw _constructError(base); } @Deprecated protected void _reportBase64EOF() throws JsonParseException { throw _constructError(\"Unexpected end-of-String in base64 content\"); } protected boolean _hasTextualNull(String value) { return \"null\".equals(value); } protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException"
      },
      {
        "txt": "{ if (ch < 0) { // sanity check _reportInvalidEOF(); } String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\"; if (comment != null) { msg += \": \"+comment; } _reportError(msg); }"
      },
      {
        "txt": "protected void _reportInvalidEOF() throws JsonParseException { _reportInvalidEOF(\" in \"+_currToken); } protected void _reportInvalidEOF(String msg) throws JsonParseException { _reportError(\"Unexpected end-of-input\"+msg); } protected void _reportInvalidEOFInValue() throws JsonParseException { _reportInvalidEOF(\" in a value\"); } protected void _reportMissingRootWS(int ch) throws JsonParseException {"
      },
      {
        "txt": "_reportUnexpectedChar(ch, \"Expected space separating root-level values\"); } protected void _throwInvalidSpace(int i) throws JsonParseException { char c = (char) i; String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\"; _reportError(msg); } protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) { char c = (char) i;"
      },
      {
        "txt": "String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc; _reportError(msg); } } protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { return ch; } if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return ch;"
      },
      {
        "txt": "} _reportError(\"Unrecognized character escape \"+_getCharDesc(ch)); return ch; } protected final static String _getCharDesc(int ch) { char c = (char) ch; if (Character.isISOControl(c)) { return \"(CTRL-CHAR, code \"+ch+\")\"; }"
      },
      {
        "txt": "if (ch > 255) { return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\"; } return \"'\"+c+\"' (code \"+ch+\")\"; } protected final void _reportError(String msg) throws JsonParseException { throw _constructError(msg); } protected final void _wrapError(String msg, Throwable t) throws JsonParseException { throw _constructError(msg, t);"
      },
      {
        "txt": "} protected final void _throwInternal() { VersionUtil.throwInternal(); } protected final JsonParseException _constructError(String msg, Throwable t) { return new JsonParseException(msg, getCurrentLocation(), t); } protected static byte[] _asciiBytes(String str) { byte[] b = new byte[str.length()]; for (int i = 0, len = str.length(); i < len; ++i) {"
      },
      {
        "txt": "b[i] = (byte) str.charAt(i); } return b; } protected static String _ascii(byte[] b) { try { return new String(b, \"US-ASCII\"); } catch (IOException e) { // never occurs throw new RuntimeException(e); }"
      }
    ]
  },
  {
    "id": 1232,
    "file_path": "src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java",
    "start-bug-line": 400,
    "end-bug-line": 400,
    "bug": "",
    "fix": "if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.base; import java.io.IOException; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.JsonParser.Feature; import com.fasterxml.jackson.core.io.NumberInput; import com.fasterxml.jackson.core.util.ByteArrayBuilder; import com.fasterxml.jackson.core.util.VersionUtil; import static com.fasterxml.jackson.core.JsonTokenId.*; public abstract class ParserMinimalBase extends JsonParser"
      },
      {
        "txt": "{ protected final static int INT_TAB = '\\t'; protected final static int INT_LF = '\\n'; protected final static int INT_CR = '\\r'; protected final static int INT_SPACE = 0x0020; protected final static int INT_LBRACKET = '['; protected final static int INT_RBRACKET = ']'; protected final static int INT_LCURLY = '{'; protected final static int INT_RCURLY = '}'; protected final static int INT_QUOTE = '\"';"
      },
      {
        "txt": "protected final static int INT_BACKSLASH = '\\\\'; protected final static int INT_SLASH = '/'; protected final static int INT_COLON = ':'; protected final static int INT_COMMA = ','; protected final static int INT_HASH = '#'; protected final static int INT_PERIOD = '.'; protected final static int INT_e = 'e'; protected final static int INT_E = 'E'; protected JsonToken _currToken; protected JsonToken _lastClearedToken;"
      },
      {
        "txt": "protected ParserMinimalBase() { } protected ParserMinimalBase(int features) { super(features); } @Override public abstract JsonToken nextToken() throws IOException; @Override public JsonToken getCurrentToken() { return _currToken; } @Override public final int getCurrentTokenId() { final JsonToken t = _currToken; return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id(); } @Override public boolean hasCurrentToken() { return _currToken != null; } @Override public boolean hasTokenId(int id) {"
      },
      {
        "txt": "final JsonToken t = _currToken; if (t == null) { return (JsonTokenId.ID_NO_TOKEN == id); } return t.id() == id; } @Override public final boolean hasToken(JsonToken t) { return (_currToken == t); } @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }"
      },
      {
        "txt": "@Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; } @Override public JsonToken nextValue() throws IOException { JsonToken t = nextToken(); if (t == JsonToken.FIELD_NAME) { t = nextToken(); } return t; } @Override"
      },
      {
        "txt": "public JsonParser skipChildren() throws IOException { if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { return this; } int open = 1; while (true) { JsonToken t = nextToken(); if (t == null) {"
      },
      {
        "txt": "_handleEOF(); return this; } if (t.isStructStart()) { ++open; } else if (t.isStructEnd()) { if (--open == 0) { return this; } }"
      },
      {
        "txt": "} } protected abstract void _handleEOF() throws JsonParseException; @Override public abstract String getCurrentName() throws IOException; @Override public abstract void close() throws IOException; @Override public abstract boolean isClosed(); @Override public abstract JsonStreamContext getParsingContext(); @Override public void clearCurrentToken() { if (_currToken != null) { _lastClearedToken = _currToken;"
      },
      {
        "txt": "_currToken = null; } } @Override public JsonToken getLastClearedToken() { return _lastClearedToken; } @Override public abstract void overrideCurrentName(String name); @Override public abstract String getText() throws IOException; @Override public abstract char[] getTextCharacters() throws IOException; @Override public abstract boolean hasTextCharacters(); @Override public abstract int getTextLength() throws IOException; @Override public abstract int getTextOffset() throws IOException;"
      },
      {
        "txt": "@Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException; @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { JsonToken t = _currToken; if (t != null) { switch (t.id()) { case ID_STRING: String str = getText().trim(); if (\"true\".equals(str)) {"
      },
      {
        "txt": "return true; } if (\"false\".equals(str)) { return false; } if (_hasTextualNull(str)) { return false; } break; case ID_NUMBER_INT:"
      },
      {
        "txt": "return getIntValue() != 0; case ID_TRUE: return true; case ID_FALSE: case ID_NULL: return false; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Boolean) { return (Boolean) value;"
      },
      {
        "txt": "} break; default: } } return defaultValue; } @Override public int getValueAsInt() throws IOException {"
      },
      {
        "txt": "JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getIntValue(); } return getValueAsInt(0); } @Override"
      },
      {
        "txt": "public int getValueAsInt(int defaultValue) throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getIntValue(); } if (t != null) {"
      },
      {
        "txt": "switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0; } return NumberInput.parseAsInt(str, defaultValue); case ID_TRUE: return 1; case ID_FALSE:"
      },
      {
        "txt": "return 0; case ID_NULL: return 0; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).intValue(); } } }"
      },
      {
        "txt": "return defaultValue; } @Override public long getValueAsLong() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.VALUE_NUMBER_FLOAT) {"
      },
      {
        "txt": "return getLongValue(); } return getValueAsLong(0L); } @Override public long getValueAsLong(long defaultValue) throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue();"
      },
      {
        "txt": "} if (t == JsonToken.VALUE_NUMBER_FLOAT) { return getLongValue(); } if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L;"
      },
      {
        "txt": "} return NumberInput.parseAsLong(str, defaultValue); case ID_TRUE: return 1L; case ID_FALSE: case ID_NULL: return 0L; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) {"
      },
      {
        "txt": "return ((Number) value).longValue(); } } } return defaultValue; } @Override public double getValueAsDouble(double defaultValue) throws IOException { JsonToken t = _currToken;"
      },
      {
        "txt": "if (t != null) { switch (t.id()) { case ID_STRING: String str = getText(); if (_hasTextualNull(str)) { return 0L; } return NumberInput.parseAsDouble(str, defaultValue); case ID_NUMBER_INT: case ID_NUMBER_FLOAT:"
      },
      {
        "txt": "return getDoubleValue(); case ID_TRUE: return 1.0; case ID_FALSE: case ID_NULL: return 0.0; case ID_EMBEDDED_OBJECT: Object value = this.getEmbeddedObject(); if (value instanceof Number) { return ((Number) value).doubleValue();"
      },
      {
        "txt": "} } } return defaultValue; } @Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); }"
      },
      {
        "txt": "} @Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } <extra_id_0> return defaultValue; } return getText(); } protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException {"
      },
      {
        "txt": "protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException { try { b64variant.decode(str, builder); } catch (IllegalArgumentException e) { _reportError(e.getMessage()); } } @Deprecated protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)"
      },
      {
        "txt": "throws JsonParseException { String base; if (ch <= INT_SPACE) { base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\"; } else if (b64variant.usesPaddingChar(ch)) { base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\"; } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } else {"
      },
      {
        "txt": "base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\"; } if (msg != null) { base = base + \": \" + msg; } throw _constructError(base); } @Deprecated protected void _reportBase64EOF() throws JsonParseException { throw _constructError(\"Unexpected end-of-String in base64 content\");"
      },
      {
        "txt": "} protected boolean _hasTextualNull(String value) { return \"null\".equals(value); } protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { if (ch < 0) { // sanity check _reportInvalidEOF(); } String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\"; if (comment != null) { msg += \": \"+comment;"
      },
      {
        "txt": "} _reportError(msg); } protected void _reportInvalidEOF() throws JsonParseException { _reportInvalidEOF(\" in \"+_currToken); } protected void _reportInvalidEOF(String msg) throws JsonParseException { _reportError(\"Unexpected end-of-input\"+msg); } protected void _reportInvalidEOFInValue() throws JsonParseException {"
      },
      {
        "txt": "_reportInvalidEOF(\" in a value\"); } protected void _reportMissingRootWS(int ch) throws JsonParseException { _reportUnexpectedChar(ch, \"Expected space separating root-level values\"); } protected void _throwInvalidSpace(int i) throws JsonParseException { char c = (char) i; String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\"; _reportError(msg); }"
      },
      {
        "txt": "protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) { char c = (char) i; String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc; _reportError(msg); } } protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { return ch;"
      },
      {
        "txt": "} if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return ch; } _reportError(\"Unrecognized character escape \"+_getCharDesc(ch)); return ch; } protected final static String _getCharDesc(int ch) { char c = (char) ch;"
      },
      {
        "txt": "if (Character.isISOControl(c)) { return \"(CTRL-CHAR, code \"+ch+\")\"; } if (ch > 255) { return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\"; } return \"'\"+c+\"' (code \"+ch+\")\"; } protected final void _reportError(String msg) throws JsonParseException { throw _constructError(msg);"
      },
      {
        "txt": "} protected final void _wrapError(String msg, Throwable t) throws JsonParseException { throw _constructError(msg, t); } protected final void _throwInternal() { VersionUtil.throwInternal(); } protected final JsonParseException _constructError(String msg, Throwable t) { return new JsonParseException(msg, getCurrentLocation(), t); }"
      },
      {
        "txt": "protected static byte[] _asciiBytes(String str) { byte[] b = new byte[str.length()]; for (int i = 0, len = str.length(); i < len; ++i) { b[i] = (byte) str.charAt(i); } return b; } protected static String _ascii(byte[] b) { try { return new String(b, \"US-ASCII\");"
      },
      {
        "txt": "} catch (IOException e) { // never occurs throw new RuntimeException(e); } }"
      }
    ]
  },
  {
    "id": 1233,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 253,
    "end-bug-line": 253,
    "bug": "",
    "fix": "if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*; public class ReaderBasedJsonParser // final in 2.3, earlier extends ParserBase"
      },
      {
        "txt": "{ protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected Reader _reader; protected char[] _inputBuffer; protected boolean _bufferRecyclable; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,"
      },
      {
        "txt": "ObjectCodec codec, CharsToNameCanonicalizer st, char[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _reader = r; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _objectCodec = codec;"
      },
      {
        "txt": "_symbols = st; _hashSeed = st.hashSeed(); _bufferRecyclable = bufferRecyclable; } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer();"
      },
      {
        "txt": "_inputPtr = 0; _inputEnd = 0; _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed(); _bufferRecyclable = true; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override"
      },
      {
        "txt": "public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException"
      },
      {
        "txt": "{ _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_reader != null) { int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; }"
      },
      {
        "txt": "_closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd); } } return false; } protected char getNextChar(String eofMsg) throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg); }"
      },
      {
        "txt": "} return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close(); } _reader = null;"
      },
      {
        "txt": "} } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { char[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null;"
      },
      {
        "txt": "_ioContext.releaseTokenBuffer(buf); } } } @Override public final String getText() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(t); } @Override public final String getValueAsString() throws IOException {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } <extra_id_0> } @Override public final String getValueAsString(String defValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); } protected final String _getText2(JsonToken t) { if (t == null) {"
      },
      {
        "txt": "return null; } switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default:"
      },
      {
        "txt": "return t.asString(); } } @Override public final char[] getTextCharacters() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) {"
      },
      {
        "txt": "String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; }"
      },
      {
        "txt": "return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default:"
      },
      {
        "txt": "return _currToken.asCharArray(); } } return null; } @Override public final int getTextLength() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) {"
      },
      {
        "txt": "case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size();"
      },
      {
        "txt": "default: return _currToken.asCharArray().length; } } return 0; } @Override public final int getTextOffset() throws IOException { if (_currToken != null) {"
      },
      {
        "txt": "switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT:"
      },
      {
        "txt": "return _textBuffer.getTextOffset(); default: } } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { if (_currToken != JsonToken.VALUE_STRING &&"
      },
      {
        "txt": "(_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false;"
      },
      {
        "txt": "} else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; }"
      },
      {
        "txt": "@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try {"
      },
      {
        "txt": "return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0;"
      },
      {
        "txt": "while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square?"
      },
      {
        "txt": "if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2;"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) {"
      },
      {
        "txt": "outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; } @Override public final JsonToken nextToken() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); }"
      },
      {
        "txt": "_tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY);"
      },
      {
        "txt": "} if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i);"
      },
      {
        "txt": "} boolean inObject = _parsingContext.inObject(); if (inObject) { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } JsonToken t; switch (i) {"
      },
      {
        "txt": "case '\"': _tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break;"
      },
      {
        "txt": "case '{': if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't':"
      },
      {
        "txt": "_matchTrue(); t = JsonToken.VALUE_TRUE; break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL;"
      },
      {
        "txt": "break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; }"
      },
      {
        "txt": "if (inObject) { _nextToken = t; return _currToken; } _currToken = t; return t; } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override"
      },
      {
        "txt": "public boolean nextFieldName(SerializableString str) throws IOException @Override public final String nextTextValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t;"
      },
      {
        "txt": "if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public final int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public final long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public final Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'"
      },
      {
        "txt": "_nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } JsonToken t = nextToken(); if (t != null) { int id = t.id();"
      },
      {
        "txt": "if (id == ID_TRUE) return Boolean.TRUE; if (id == ID_FALSE) return Boolean.FALSE; } return null; } protected final JsonToken _parsePosNumber(int ch) throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include digit already read final int inputLen = _inputEnd;"
      },
      {
        "txt": "if (ch == INT_0) { return _parseNumber2(false, startPtr); } int intLen = 1; // already got one int_loop: while (true) { if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(false, startPtr); }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, false, intLen); }"
      },
      {
        "txt": "--ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(false, intLen); } private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)"
      },
      {
        "txt": "throws IOException { final int inputLen = _inputEnd; int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\"); } }"
      },
      {
        "txt": "int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now if (ptr >= inputLen) { _inputPtr = startPtr;"
      },
      {
        "txt": "return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); }"
      },
      {
        "txt": "ch = (int) _inputBuffer[ptr++]; } if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch);"
      },
      {
        "txt": "} int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetFloat(neg, intLen, fractLen, expLen); } protected final JsonToken _parseNegNumber() throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd;"
      },
      {
        "txt": "if (ptr >= inputLen) { return _parseNumber2(true, startPtr); } int ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } if (ch == INT_0) { return _parseNumber2(true, startPtr);"
      },
      {
        "txt": "} int intLen = 1; // already got one int_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(true, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop;"
      },
      {
        "txt": "} ++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, true, intLen); } --ptr; _inputPtr = ptr; if (_parsingContext.inRoot()) {"
      },
      {
        "txt": "_verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(true, intLen); } private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException { _inputPtr = neg ? (startPtr+1) : startPtr; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();"
      },
      {
        "txt": "int outPtr = 0; if (neg) { outBuf[outPtr++] = '-'; } int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false;"
      },
      {
        "txt": "int_loop: while (c >= '0' && c <= '9') { ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL;"
      },
      {
        "txt": "eof = true; break int_loop; } c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { return _handleInvalidNumberStart(c, neg); } int fractLen = 0; if (c == '.') { // yes, fraction"
      },
      {
        "txt": "outBuf[outPtr++] = c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop;"
      },
      {
        "txt": "} ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");"
      },
      {
        "txt": "} } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]"
      },
      {
        "txt": ": getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); }"
      },
      {
        "txt": "exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true;"
      },
      {
        "txt": "break exp_loop; } c = _inputBuffer[_inputPtr++]; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr;"
      },
      {
        "txt": "if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); return reset(neg, intLen, fractLen, expLen); } private final char _verifyNoLeadingZeroes() throws IOException { if (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } } return _verifyNLZ2(); } private char _verifyNLZ2() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped"
      },
      {
        "txt": "if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0'; } ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return break; }"
      },
      {
        "txt": "} } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\";"
      },
      {
        "txt": "_matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; }"
      },
      {
        "txt": "private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return;"
      },
      {
        "txt": "case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } protected final String _parseName() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "int hash = _hashSeed; final int[] codes = _icLatin1; while (ptr < _inputEnd) { int ch = _inputBuffer[ptr]; if (ch < codes.length && codes[ch] != 0) { if (ch == '\"') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); }"
      },
      {
        "txt": "break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException"
      },
      {
        "txt": "{ _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(i, \"name\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }"
      },
      {
        "txt": "protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;"
      },
      {
        "txt": "boolean firstOk; if (i < maxCode) { // identifier, or a number ([Issue#102]) firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr;"
      },
      {
        "txt": "int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr]; if (ch < maxCode) { if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);"
      },
      {
        "txt": "} } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); }"
      },
      {
        "txt": "int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); } protected String _parseAposName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) {"
      },
      {
        "txt": "final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch == '\\'') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) {"
      },
      {
        "txt": "break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); }"
      },
      {
        "txt": "protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); }"
      },
      {
        "txt": "_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); }"
      },
      {
        "txt": "if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize();"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') {"
      },
      {
        "txt": "c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException"
      },
      {
        "txt": "{ _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; }"
      },
      {
        "txt": "} char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; }"
      },
      {
        "txt": "++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); {"
      },
      {
        "txt": "TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } @Override protected final void _finishString() throws IOException {"
      },
      {
        "txt": "int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));"
      },
      {
        "txt": "_inputPtr = ptr+1; return; } break; } ++ptr; } while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr;"
      },
      {
        "txt": "_finishString2(); } protected void _finishString2() throws IOException { char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int[] codes = _icLatin1; final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i < maxCode && codes[i] != 0) { if (i == INT_QUOTE) { break; } else if (i == INT_BACKSLASH) {"
      },
      {
        "txt": "c = _decodeEscaped(); } else if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } // anything else? } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c;"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); } protected final void _skipString() throws IOException { _tokenIncomplete = false; int inPtr = _inputPtr; int inLen = _inputEnd; char[] inBuf = _inputBuffer; while (true) {"
      },
      {
        "txt": "if (inPtr >= inLen) { _inputPtr = inPtr; if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } inPtr = _inputPtr; inLen = _inputEnd; } char c = inBuf[inPtr++]; int i = (int) c;"
      },
      {
        "txt": "if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inPtr; c = _decodeEscaped(); inPtr = _inputPtr; inLen = _inputEnd; } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inPtr; break;"
      },
      {
        "txt": "} if (i < INT_SPACE) { _inputPtr = inPtr; _throwUnquotedSpace(i, \"string value\"); } } } } } protected final void _skipCR() throws IOException {"
      },
      {
        "txt": "if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private final int _skipColon() throws IOException {"
      },
      {
        "txt": "if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } char c = _inputBuffer[_inputPtr]; if (c == ':') { // common case, no leading space int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { // nor trailing if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); }"
      },
      {
        "txt": "++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr;"
      },
      {
        "txt": "return i; } } return _skipColon2(true); // true -> skipped colon } if (c == ' ' || c == '\\t') { c = _inputBuffer[++_inputPtr]; } if (c == ':') { int i = _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); } return _skipColon2(false);"
      },
      {
        "txt": "} private final int _skipColon2(boolean gotColon) throws IOException { while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) {"
      },
      {
        "txt": "_skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } if (gotColon) { return i;"
      },
      {
        "txt": "} if (i != INT_COLON) { if (i < INT_SPACE) { _throwInvalidSpace(i); } _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; continue; }"
      },
      {
        "txt": "if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } }"
      },
      {
        "txt": "} } private final int _skipComma(int i) throws IOException { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipAfterComma2(); } return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _skipAfterComma2(); } private final int _skipAfterComma2() throws IOException"
      },
      {
        "txt": "{ while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) {"
      },
      {
        "txt": "continue; } } return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { return _eofAsNextChar(); } } int i = _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2();"
      },
      {
        "txt": "} return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) {"
      },
      {
        "txt": "_throwInvalidSpace(i); } } while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); }"
      },
      {
        "txt": "return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} } } return _skipWSOrEnd2(); } private int _skipWSOrEnd2() throws IOException { while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // We ran out of input..."
      },
      {
        "txt": "return _eofAsNextChar(); } } int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) {"
      },
      {
        "txt": "if (_skipYAMLComment()) { continue; } } return i; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) {"
      },
      {
        "txt": "_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment();"
      },
      {
        "txt": "} else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end?"
      },
      {
        "txt": "if ((_inputPtr >= _inputEnd) && !loadMore()) { break; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } }"
      },
      {
        "txt": "} _reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true;"
      },
      {
        "txt": "} private void _skipLine() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); break; } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override"
      },
      {
        "txt": "protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b':"
      },
      {
        "txt": "return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"':"
      },
      {
        "txt": "case '/': case '\\\\': return c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); }"
      },
      {
        "txt": "value = (value << 4) | digit; } return (char) value; } private final void _matchTrue() throws IOException { int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') { char c = b[++ptr];"
      },
      {
        "txt": "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } } } _matchToken(\"true\", 1); } private final void _matchFalse() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "if ((ptr + 4) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } } }"
      },
      {
        "txt": "_matchToken(\"false\", 1); } private final void _matchNull() throws IOException { int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr;"
      },
      {
        "txt": "return; } } } _matchToken(\"null\", 1); } protected final void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i)); } } if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len);"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { return; } } char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } return; } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch;"
      },
      {
        "txt": "do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); }"
      },
      {
        "txt": "if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData);"
      },
      {
        "txt": "continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2;"
      },
      {
        "txt": "builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");"
      },
      {
        "txt": "} protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); }"
      }
    ]
  },
  {
    "id": 1234,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 266,
    "end-bug-line": 266,
    "bug": "",
    "fix": "if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*; public class ReaderBasedJsonParser // final in 2.3, earlier extends ParserBase {"
      },
      {
        "txt": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected Reader _reader; protected char[] _inputBuffer; protected boolean _bufferRecyclable; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed; protected boolean _tokenIncomplete = false; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st,"
      },
      {
        "txt": "char[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _reader = r; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _objectCodec = codec; _symbols = st;"
      },
      {
        "txt": "_hashSeed = st.hashSeed(); _bufferRecyclable = bufferRecyclable; } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _inputPtr = 0;"
      },
      {
        "txt": "_inputEnd = 0; _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed(); _bufferRecyclable = true; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(Writer w) throws IOException {"
      },
      {
        "txt": "int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException {"
      },
      {
        "txt": "_currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_reader != null) { int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput();"
      },
      {
        "txt": "if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd); } } return false; } protected char getNextChar(String eofMsg) throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg); } }"
      },
      {
        "txt": "return _inputBuffer[_inputPtr++]; } @Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close(); } _reader = null; }"
      },
      {
        "txt": "} @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { char[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseTokenBuffer(buf);"
      },
      {
        "txt": "} } } @Override public final String getText() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(t); } @Override public final String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public final String getValueAsString(String defValue) throws IOException {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } <extra_id_0> } protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) {"
      },
      {
        "txt": "} switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString();"
      },
      {
        "txt": "} } @Override public final char[] getTextCharacters() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName();"
      },
      {
        "txt": "int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer;"
      },
      {
        "txt": "case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray();"
      },
      {
        "txt": "} } return null; } @Override public final int getTextLength() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default:"
      },
      {
        "txt": "return _currToken.asCharArray().length; } } return 0; } @Override public final int getTextOffset() throws IOException { if (_currToken != null) { switch (_currToken.id()) {"
      },
      {
        "txt": "case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset();"
      },
      {
        "txt": "default: } } return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {"
      },
      {
        "txt": "_reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion..."
      },
      {
        "txt": "if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override"
      },
      {
        "txt": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf);"
      },
      {
        "txt": "} finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) {"
      },
      {
        "txt": "char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == '\"') {"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr);"
      },
      {
        "txt": "outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1);"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) {"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr;"
      },
      {
        "txt": "out.write(buffer, 0, outputPtr); } return outputCount; } @Override public final JsonToken nextToken() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName();"
      },
      {
        "txt": "} if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1;"
      },
      {
        "txt": "_tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); }"
      },
      {
        "txt": "if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i); }"
      },
      {
        "txt": "boolean inObject = _parsingContext.inObject(); if (inObject) { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } JsonToken t; switch (i) { case '\"':"
      },
      {
        "txt": "_tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchTrue();"
      },
      {
        "txt": "t = JsonToken.VALUE_TRUE; break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break;"
      },
      {
        "txt": "case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) {"
      },
      {
        "txt": "_nextToken = t; return _currToken; } _currToken = t; return t; } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken;"
      },
      {
        "txt": "_nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str)"
      },
      {
        "txt": "throws IOException @Override public final String nextTextValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public final int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public final long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public final Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } JsonToken t = nextToken(); if (t != null) { int id = t.id(); if (id == ID_TRUE) return Boolean.TRUE;"
      },
      {
        "txt": "if (id == ID_FALSE) return Boolean.FALSE; } return null; } protected final JsonToken _parsePosNumber(int ch) throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include digit already read final int inputLen = _inputEnd; if (ch == INT_0) {"
      },
      {
        "txt": "return _parseNumber2(false, startPtr); } int intLen = 1; // already got one int_loop: while (true) { if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(false, startPtr); } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, false, intLen); } --ptr; // need to push back following separator"
      },
      {
        "txt": "_inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(false, intLen); } private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException"
      },
      {
        "txt": "{ final int inputLen = _inputEnd; int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\"); } } int expLen = 0;"
      },
      {
        "txt": "if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr);"
      },
      {
        "txt": "} ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "} if (expLen == 0) { reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); }"
      },
      {
        "txt": "int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetFloat(neg, intLen, fractLen, expLen); } protected final JsonToken _parseNegNumber() throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; if (ptr >= inputLen) {"
      },
      {
        "txt": "return _parseNumber2(true, startPtr); } int ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } if (ch == INT_0) { return _parseNumber2(true, startPtr); }"
      },
      {
        "txt": "int intLen = 1; // already got one int_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(true, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; }"
      },
      {
        "txt": "++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, true, intLen); } --ptr; _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch);"
      },
      {
        "txt": "} int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(true, intLen); } private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException { _inputPtr = neg ? (startPtr+1) : startPtr; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0;"
      },
      {
        "txt": "if (neg) { outBuf[outPtr++] = '-'; } int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop:"
      },
      {
        "txt": "while (c >= '0' && c <= '9') { ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true;"
      },
      {
        "txt": "break int_loop; } c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { return _handleInvalidNumberStart(c, neg); } int fractLen = 0; if (c == '.') { // yes, fraction outBuf[outPtr++] = c;"
      },
      {
        "txt": "fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; }"
      },
      {
        "txt": "++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); }"
      },
      {
        "txt": "} int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");"
      },
      {
        "txt": "if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); } exp_loop:"
      },
      {
        "txt": "while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop;"
      },
      {
        "txt": "} c = _inputBuffer[_inputPtr++]; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) {"
      },
      {
        "txt": "_verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); return reset(neg, intLen, fractLen, expLen); } private final char _verifyNoLeadingZeroes() throws IOException { if (_inputPtr < _inputEnd) { char ch = _inputBuffer[_inputPtr];"
      },
      {
        "txt": "if (ch < '0' || ch > '9') { return '0'; } } return _verifyNLZ2(); } private char _verifyNLZ2() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return '0';"
      },
      {
        "txt": "} char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) {"
      },
      {
        "txt": "while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0'; } ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return break; } }"
      },
      {
        "txt": "} return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } private final void _verifyRootSpace(int ch) throws IOException"
      },
      {
        "txt": "{ ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n':"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } protected final String _parseName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed;"
      },
      {
        "txt": "final int[] codes = _icLatin1; while (ptr < _inputEnd) { int ch = _inputBuffer[ptr]; if (ch < codes.length && codes[ch] != 0) { if (ch == '\"') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break;"
      },
      {
        "txt": "} hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException {"
      },
      {
        "txt": "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } } char c = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\");"
      },
      {
        "txt": "} } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException"
      },
      {
        "txt": "{ if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk;"
      },
      {
        "txt": "if (i < maxCode) { // identifier, or a number ([Issue#102]) firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed;"
      },
      {
        "txt": "final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr]; if (ch < maxCode) { if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); }"
      },
      {
        "txt": "} else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr-1;"
      },
      {
        "txt": "_inputPtr = ptr; return _handleOddName2(start, hash, codes); } protected String _parseAposName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1;"
      },
      {
        "txt": "final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch == '\\'') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break;"
      },
      {
        "txt": "} hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException"
      },
      {
        "txt": "{ switch (i) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {"
      },
      {
        "txt": "return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");"
      },
      {
        "txt": "break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) {"
      },
      {
        "txt": "_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped();"
      },
      {
        "txt": "} else if (i <= '\\'') { if (i == '\\'') { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException {"
      },
      {
        "txt": "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr;"
      },
      {
        "txt": "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer;"
      },
      {
        "txt": "char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } @Override protected final void _finishString() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1;"
      },
      {
        "txt": "return; } break; } ++ptr; } while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2();"
      },
      {
        "txt": "} protected void _finishString2() throws IOException { char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int[] codes = _icLatin1; final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i < maxCode && codes[i] != 0) { if (i == INT_QUOTE) { break; } else if (i == INT_BACKSLASH) { c = _decodeEscaped();"
      },
      {
        "txt": "} else if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } // anything else? } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; }"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); } protected final void _skipString() throws IOException { _tokenIncomplete = false; int inPtr = _inputPtr; int inLen = _inputEnd; char[] inBuf = _inputBuffer; while (true) { if (inPtr >= inLen) {"
      },
      {
        "txt": "_inputPtr = inPtr; if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } inPtr = _inputPtr; inLen = _inputEnd; } char c = inBuf[inPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) {"
      },
      {
        "txt": "if (i == INT_BACKSLASH) { _inputPtr = inPtr; c = _decodeEscaped(); inPtr = _inputPtr; inLen = _inputEnd; } else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inPtr; break; }"
      },
      {
        "txt": "if (i < INT_SPACE) { _inputPtr = inPtr; _throwUnquotedSpace(i, \"string value\"); } } } } } protected final void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] == '\\n') { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private final int _skipColon() throws IOException { if ((_inputPtr + 4) >= _inputEnd) {"
      },
      {
        "txt": "return _skipColon2(false); } char c = _inputBuffer[_inputPtr]; if (c == ':') { // common case, no leading space int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { // nor trailing if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr;"
      },
      {
        "txt": "return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i;"
      },
      {
        "txt": "} } return _skipColon2(true); // true -> skipped colon } if (c == ' ' || c == '\\t') { c = _inputBuffer[++_inputPtr]; } if (c == ':') { int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) {"
      },
      {
        "txt": "return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); } return _skipColon2(false); }"
      },
      {
        "txt": "private final int _skipColon2(boolean gotColon) throws IOException { while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment();"
      },
      {
        "txt": "continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } if (gotColon) { return i; }"
      },
      {
        "txt": "if (i != INT_COLON) { if (i < INT_SPACE) { _throwInvalidSpace(i); } _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; continue; } if (i < INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } }"
      },
      {
        "txt": "} private final int _skipComma(int i) throws IOException { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) {"
      },
      {
        "txt": "--_inputPtr; return _skipAfterComma2(); } return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _skipAfterComma2(); } private final int _skipAfterComma2() throws IOException {"
      },
      {
        "txt": "while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue;"
      },
      {
        "txt": "} } return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR();"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { return _eofAsNextChar(); } } int i = _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); }"
      },
      {
        "txt": "return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} } while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i;"
      },
      {
        "txt": "} if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} } return _skipWSOrEnd2(); } private int _skipWSOrEnd2() throws IOException { while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // We ran out of input... return _eofAsNextChar();"
      },
      {
        "txt": "} } int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) {"
      },
      {
        "txt": "continue; } } return i; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR();"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else {"
      },
      {
        "txt": "_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private void _skipCComment() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !loadMore()) {"
      },
      {
        "txt": "break; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } }"
      },
      {
        "txt": "_reportInvalidEOF(\" in a comment\"); } private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; }"
      },
      {
        "txt": "private void _skipLine() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); break; } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b';"
      },
      {
        "txt": "case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/':"
      },
      {
        "txt": "case '\\\\': return c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit;"
      },
      {
        "txt": "} return (char) value; } private final void _matchTrue() throws IOException { int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars"
      },
      {
        "txt": "_inputPtr = ptr; return; } } } _matchToken(\"true\", 1); } private final void _matchFalse() throws IOException { int ptr = _inputPtr; if ((ptr + 4) < _inputEnd) {"
      },
      {
        "txt": "final char[] b = _inputBuffer; if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } } } _matchToken(\"false\", 1);"
      },
      {
        "txt": "} private final void _matchNull() throws IOException { int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return;"
      },
      {
        "txt": "} } } _matchToken(\"null\", 1); } protected final void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i)); } } if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { return; } } char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i));"
      },
      {
        "txt": "} return; } @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray(); }"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue;"
      },
      {
        "txt": "} } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData);"
      },
      {
        "txt": "continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); }"
      },
      {
        "txt": "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } } char c = _inputBuffer[_inputPtr];"
      },
      {
        "txt": "if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); }"
      }
    ]
  },
  {
    "id": 1235,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 305,
    "end-bug-line": 305,
    "bug": "",
    "fix": "if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*;"
      },
      {
        "txt": "import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*; public class UTF8StreamJsonParser extends ParserBase"
      },
      {
        "txt": "{ final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected ObjectCodec _objectCodec; final protected ByteQuadsCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream;"
      },
      {
        "txt": "protected byte[] _inputBuffer; protected boolean _bufferRecyclable; public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, ByteQuadsCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec;"
      },
      {
        "txt": "_symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _currInputRowStart = start; _currInputProcessed = -start; _bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() {"
      },
      {
        "txt": "return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr;"
      },
      {
        "txt": "if (count < 1) { return 0; } int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _inputStream;"
      },
      {
        "txt": "} @Override protected final boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int space = _inputBuffer.length; if (space == 0) { // only occurs when we've been closed return false;"
      },
      {
        "txt": "} int count = _inputStream.read(_inputBuffer, 0, space); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");"
      },
      {
        "txt": "} } return false; } protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr;"
      },
      {
        "txt": "if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr; _currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) {"
      },
      {
        "txt": "int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; }"
      },
      {
        "txt": "return true; } @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null;"
      },
      {
        "txt": "} } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) {"
      },
      {
        "txt": "_inputBuffer = ByteArrayBuilder.NO_BYTES; _ioContext.releaseReadIOBuffer(buf); } } } @Override public String getText() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } <extra_id_0> } @Override public String getValueAsString(String defValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(defValue); } @Override"
      },
      {
        "txt": "public int getValueAsInt() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt();"
      },
      {
        "txt": "} } return _numberInt; } return super.getValueAsInt(0); } @Override public int getValueAsInt(int defValue) throws IOException { JsonToken t = _currToken;"
      },
      {
        "txt": "if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt(); } } return _numberInt;"
      },
      {
        "txt": "} return super.getValueAsInt(defValue); } protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);"
      },
      {
        "txt": "} else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null;"
      },
      {
        "txt": "} @Override public int getTextLength() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } }"
      },
      {
        "txt": "return 0; } @Override public int getTextOffset() throws IOException { if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING:"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } }"
      },
      {
        "txt": "return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) {"
      },
      {
        "txt": "try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); }"
      },
      {
        "txt": "} protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; }"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; }"
      },
      {
        "txt": "int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) {"
      },
      {
        "txt": "throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break;"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); }"
      },
      {
        "txt": "return outputCount; } @Override public JsonLocation getTokenLocation() { return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), -1L, // bytes, chars getTokenLineNr(), getTokenColumnNr()); }"
      },
      {
        "txt": "@Override public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr, -1L, // bytes, chars _currInputRow, col); } @Override public JsonToken nextToken() throws IOException"
      },
      {
        "txt": "{ _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input"
      },
      {
        "txt": "close(); return (_currToken = null); } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT);"
      },
      {
        "txt": "} if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); }"
      },
      {
        "txt": "String n = _parseName(i); _parsingContext.setCurrentName(n); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t;"
      },
      {
        "txt": "switch (i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break;"
      },
      {
        "txt": "case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY;"
      },
      {
        "txt": "break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; }"
      },
      {
        "txt": "private final JsonToken _nextTokenNotInObject(int i) throws IOException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY);"
      },
      {
        "txt": "case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': return (_currToken = _parseNegNumber()); case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': return (_currToken = _parsePosNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private final JsonToken _nextAfterName() {"
      },
      {
        "txt": "_nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); }"
      },
      {
        "txt": "@Override public boolean nextFieldName(SerializableString str) throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString();"
      },
      {
        "txt": "} int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); _currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1;"
      },
      {
        "txt": "_binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) {"
      },
      {
        "txt": "if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length;"
      },
      {
        "txt": "if ((_inputPtr + len + 4) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { // yes, match! _parsingContext.setCurrentName(str.getValue()); _isNextTokenNameYes(_skipColonFast(ptr+1)); return true;"
      },
      {
        "txt": "} if (nameBytes[offset] != _inputBuffer[ptr]) { break; } ++offset; ++ptr; } } } }"
      },
      {
        "txt": "return _isNextTokenNameMaybe(i, str); } @Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; }"
      },
      {
        "txt": "if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1;"
      },
      {
        "txt": "_tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null;"
      },
      {
        "txt": "} if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) {"
      },
      {
        "txt": "if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } final String nameStr = _parseName(i);"
      },
      {
        "txt": "_parsingContext.setCurrentName(nameStr); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch (i) {"
      },
      {
        "txt": "case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break;"
      },
      {
        "txt": "case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; } private final int _skipColonFast(int ptr) throws IOException"
      },
      {
        "txt": "{ int i = _inputBuffer[ptr++]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[ptr++]; if (i > INT_SPACE) { // nor trailing if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) {"
      },
      {
        "txt": "i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } } _inputPtr = ptr-1; return _skipColon2(true); // true -> skipped colon"
      },
      {
        "txt": "} if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[ptr++]; } if (i == INT_COLON) { i = _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i;"
      },
      {
        "txt": "} } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } }"
      },
      {
        "txt": "} _inputPtr = ptr-1; return _skipColon2(false); } private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; switch (i) { case '\"': _tokenIncomplete = true;"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "_nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return;"
      },
      {
        "txt": "case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException {"
      },
      {
        "txt": "String n = _parseName(i); _parsingContext.setCurrentName(n); final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case 't': _matchToken(\"true\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break;"
      },
      {
        "txt": "case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match;"
      },
      {
        "txt": "} @Override public String nextTextValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken().id()) { case ID_TRUE: return Boolean.TRUE; case ID_FALSE:"
      },
      {
        "txt": "return Boolean.FALSE; default: return null; } } protected JsonToken _parsePosNumber(int c) throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); if (c == INT_0) { c = _verifyNoLeadingZeroes();"
      },
      {
        "txt": "} outBuf[0] = (char) c; int intLen = 1; int outPtr = 1; int end = _inputPtr + outBuf.length - 1; // 1 == outPtr if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { // split across boundary, offline"
      },
      {
        "txt": "return _parseNumber2(outBuf, outPtr, false, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') {"
      },
      {
        "txt": "return _parseFloat(outBuf, outPtr, c, false, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(false, intLen); } protected JsonToken _parseNegNumber() throws IOException"
      },
      {
        "txt": "{ char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true);"
      },
      {
        "txt": "} if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1; int end = _inputPtr + outBuf.length - outPtr; if (end > _inputEnd) { end = _inputEnd; }"
      },
      {
        "txt": "while (true) { if (_inputPtr >= end) { return _parseNumber2(outBuf, outPtr, true, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, true, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(true, intLen);"
      },
      {
        "txt": "} private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c > INT_9 || c < INT_0) { if (c == INT_PERIOD || c == INT_e || c == INT_E) { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; ++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } return resetInt(negative, intPartLength); }"
      },
      {
        "txt": "private final int _verifyNoLeadingZeroes() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {"
      },
      {
        "txt": "reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes"
      },
      {
        "txt": "if (ch != INT_0) { // followed by other number; return break; } } } return ch; } private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException {"
      },
      {
        "txt": "int fractLen = 0; boolean eof = false; if (c == INT_PERIOD) { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == INT_e || c == INT_E) { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); }"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t':"
      },
      {
        "txt": "return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch);"
      },
      {
        "txt": "} protected final String _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer;"
      },
      {
        "txt": "final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i); } if (i == INT_QUOTE) { // 4 byte/char case or broken return findName(q, 4); }"
      },
      {
        "txt": "return parseName(q, i, 4); } if (i == INT_QUOTE) { // 3 byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // 2 byte/char case or broken return findName(q, 2); }"
      },
      {
        "txt": "return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return \"\"; }"
      },
      {
        "txt": "return parseName(0, q, 0); // quoting or invalid char } protected final String parseMediumName(int q2) throws IOException { final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1);"
      },
      {
        "txt": "} return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2);"
      },
      {
        "txt": "} q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i;"
      },
      {
        "txt": "i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } return parseMediumName2(i, q2); } protected final String parseMediumName2(int q3, final int q2) throws IOException"
      },
      {
        "txt": "{ final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 9 bytes return findName(_quad1, q2, q3, 1); } return parseName(_quad1, q2, q3, i, 1); }"
      },
      {
        "txt": "q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 10 bytes return findName(_quad1, q2, q3, 2); } return parseName(_quad1, q2, q3, i, 2); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 11 bytes return findName(_quad1, q2, q3, 3); } return parseName(_quad1, q2, q3, i, 3); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 12 bytes"
      },
      {
        "txt": "return findName(_quad1, q2, q3, 4); } return parseName(_quad1, q2, q3, i, 4); } return parseLongName(i, q2, q3); } protected final String parseLongName(int q, final int q2, int q3) throws IOException { _quadBuffer[0] = _quad1; _quadBuffer[1] = q2;"
      },
      {
        "txt": "_quadBuffer[2] = q3; final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int qlen = 3; while ((_inputPtr + 4) <= _inputEnd) { int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); }"
      },
      {
        "txt": "q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q;"
      },
      {
        "txt": "q = i; } return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } protected String slowParseName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); }"
      },
      {
        "txt": "} int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return \"\"; } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); }"
      },
      {
        "txt": "private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; _quadBuffer[1] = q2; return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes); } protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,"
      },
      {
        "txt": "int currQuadBytes) throws IOException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\");"
      },
      {
        "txt": "} else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0;"
      },
      {
        "txt": "currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f);"
      },
      {
        "txt": "} } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(currQuad, currQuadBytes); } String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected String _handleOddName(int ch) throws IOException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { char c = (char) _decodeCharForError(ch); _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");"
      },
      {
        "txt": "} final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) {"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; }"
      },
      {
        "txt": "++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } String name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } protected String _parseAposName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); }"
      },
      {
        "txt": "} int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return \"\"; } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1;"
      },
      {
        "txt": "while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); }"
      },
      {
        "txt": "if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte"
      },
      {
        "txt": "currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) {"
      },
      {
        "txt": "++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = pad(currQuad, currQuadBytes); } String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } private final String findName(int q1, int lastQuadBytes) throws JsonParseException"
      },
      {
        "txt": "{ q1 = pad(q1, lastQuadBytes); String name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException"
      },
      {
        "txt": "{ q2 = pad(q2, lastQuadBytes); String name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); }"
      },
      {
        "txt": "private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException { q3 = pad(q3, lastQuadBytes); String name = _symbols.findName(q1, q2, q3); if (name != null) { return name; } int[] quads = _quadBuffer; quads[0] = q1; quads[1] = q2;"
      },
      {
        "txt": "quads[2] = pad(q3, lastQuadBytes); return addName(quads, 3, lastQuadBytes); } private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(lastQuad, lastQuadBytes); String name = _symbols.findName(quads, qlen);"
      },
      {
        "txt": "if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name; } private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) {"
      },
      {
        "txt": "lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3);"
      },
      {
        "txt": "ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2;"
      },
      {
        "txt": "} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); }"
      },
      {
        "txt": "int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2];"
      },
      {
        "txt": "byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3);"
      },
      {
        "txt": "ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0"
      },
      {
        "txt": "if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); }"
      },
      {
        "txt": "cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException"
      },
      {
        "txt": "{ int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length));"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break;"
      },
      {
        "txt": "} ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } protected String _finishAndReturnString() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) {"
      },
      {
        "txt": "int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; return _textBuffer.setCurrentAndReturn(outPtr); } break; } ++ptr; outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} _inputPtr = ptr; _finishString2(outBuf, outPtr); return _textBuffer.contentsAsString(); } private final void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8;"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash"
      },
      {
        "txt": "c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c);"
      },
      {
        "txt": "} break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF);"
      },
      {
        "txt": "break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8;"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } }"
      },
      {
        "txt": "_inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF"
      },
      {
        "txt": "_skipUtf8_2(c); break; case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c) throws IOException {"
      },
      {
        "txt": "switch (c) { case ']': case '}': _reportUnexpectedChar(c, \"expected a value\"); case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N':"
      },
      {
        "txt": "_matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);"
      },
      {
        "txt": "} _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);"
      },
      {
        "txt": "} if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException {"
      },
      {
        "txt": "int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) {"
      },
      {
        "txt": "max = max2; } } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; }"
      },
      {
        "txt": "} if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break;"
      },
      {
        "txt": "case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break;"
      },
      {
        "txt": "case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default:"
      },
      {
        "txt": "if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else {"
      },
      {
        "txt": "break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null;"
      },
      {
        "txt": "} protected final void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); if ((_inputPtr + len) >= _inputEnd) { _matchToken2(matchStr, i); return; } do { if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _matchToken2(String matchStr, int i) throws IOException"
      },
      {
        "txt": "{ final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException { char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } } private final int _skipWS() throws IOException { while (_inputPtr < _inputEnd) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr;"
      },
      {
        "txt": "return _skipWS2(); } return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR();"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _skipWS2(); } private final int _skipWS2() throws IOException { while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; }"
      },
      {
        "txt": "} return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) {"
      },
      {
        "txt": "_throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "return _eofAsNextChar(); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i;"
      },
      {
        "txt": "} if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} while (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; }"
      },
      {
        "txt": "if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } }"
      },
      {
        "txt": "} return _skipWSOrEnd2(); } private final int _skipWSOrEnd2() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment();"
      },
      {
        "txt": "continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } return i; } else if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _eofAsNextChar();"
      },
      {
        "txt": "} private final int _skipColon() throws IOException { if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } int i = _inputBuffer[_inputPtr]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { // nor trailing"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) {"
      },
      {
        "txt": "return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); // true -> skipped colon } if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "} if (i == INT_COLON) { i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; }"
      },
      {
        "txt": "if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } }"
      },
      {
        "txt": "return _skipColon2(true); } return _skipColon2(false); } private final int _skipColon2(boolean gotColon) throws IOException { while (_inputPtr < _inputEnd || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) {"
      },
      {
        "txt": "_skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } if (gotColon) { return i;"
      },
      {
        "txt": "} if (i != INT_COLON) { if (i < INT_SPACE) { _throwInvalidSpace(i); } _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; } else if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} private final void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private final void _skipCComment() throws IOException {"
      },
      {
        "txt": "final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop;"
      },
      {
        "txt": "} if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break;"
      },
      {
        "txt": "case INT_CR: _skipCR(); break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF"
      },
      {
        "txt": "_skipUtf8_4(i); break; default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private final boolean _skipYAMLComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private final void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment();"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR:"
      },
      {
        "txt": "_skipCR(); return; case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break;"
      },
      {
        "txt": "case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } }"
      },
      {
        "txt": "} @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "switch (c) { case 'b': return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r':"
      },
      {
        "txt": "return '\\r'; case '\"': case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); }"
      },
      {
        "txt": "int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) {"
      },
      {
        "txt": "_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = firstByte & 0xFF; if (c > 0x7F) { // if >= 0, is ascii and fine as is"
      },
      {
        "txt": "int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3;"
      },
      {
        "txt": "} else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total"
      },
      {
        "txt": "d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); } } } return c; } private final int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private final int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_3fast(int c1) throws IOException {"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; }"
      },
      {
        "txt": "private final void _skipUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } }"
      },
      {
        "txt": "private final void _skipUtf8_3(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "} protected final void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} private int nextByte() throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidToken(String matchedPart) throws IOException {"
      },
      {
        "txt": "_reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } protected void _reportInvalidChar(int c) throws JsonParseException"
      },
      {
        "txt": "{ if (c < INT_SPACE) { _throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));"
      },
      {
        "txt": "} protected void _reportInvalidOther(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr;"
      },
      {
        "txt": "_reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\")"
      },
      {
        "txt": "protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "} while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; }"
      },
      {
        "txt": "} int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4;"
      },
      {
        "txt": "builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "builder.appendThreeBytes(decodedData); } } private final static int pad(int q, int bytes) { return (bytes == 4) ? q : (q | (-1 << (bytes << 3))); }"
      }
    ]
  },
  {
    "id": 1236,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 319,
    "end-bug-line": 319,
    "bug": "",
    "fix": "if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*; public class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n';"
      },
      {
        "txt": "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected ObjectCodec _objectCodec; final protected ByteQuadsCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete = false; private int _quad1; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable;"
      },
      {
        "txt": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, ByteQuadsCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer;"
      },
      {
        "txt": "_inputPtr = start; _inputEnd = end; _currInputRowStart = start; _currInputProcessed = -start; _bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() { return _objectCodec; }"
      },
      {
        "txt": "@Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0;"
      },
      {
        "txt": "} int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _inputStream; } @Override"
      },
      {
        "txt": "protected final boolean loadMore() throws IOException { _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; if (_inputStream != null) { int space = _inputBuffer.length; if (space == 0) { // only occurs when we've been closed return false; } int count = _inputStream.read(_inputBuffer, 0, space);"
      },
      {
        "txt": "if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\"); } }"
      },
      {
        "txt": "return false; } protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr; if (amount > 0 && _inputPtr > 0) { _currInputProcessed += _inputPtr;"
      },
      {
        "txt": "_currInputRowStart -= _inputPtr; System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; } _inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) {"
      },
      {
        "txt": "_closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; } _inputEnd += count; } return true; }"
      },
      {
        "txt": "@Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close(); } _inputStream = null; } }"
      },
      {
        "txt": "@Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = ByteArrayBuilder.NO_BYTES; _ioContext.releaseReadIOBuffer(buf);"
      },
      {
        "txt": "} } } @Override public String getText() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete"
      },
      {
        "txt": "} return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException {"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } <extra_id_0> } @Override public int getValueAsInt() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {"
      },
      {
        "txt": "JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt(); } }"
      },
      {
        "txt": "return _numberInt; } return super.getValueAsInt(0); } @Override public int getValueAsInt(int defValue) throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { if ((_numTypesValid & NR_INT) == 0) {"
      },
      {
        "txt": "if (_numTypesValid == NR_UNKNOWN) { return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt(); } } return _numberInt; } return super.getValueAsInt(defValue);"
      },
      {
        "txt": "} protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName(); case ID_STRING:"
      },
      {
        "txt": "case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public char[] getTextCharacters() throws IOException {"
      },
      {
        "txt": "if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen];"
      },
      {
        "txt": "} name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; } @Override"
      },
      {
        "txt": "public int getTextLength() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete"
      },
      {
        "txt": "} case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0; }"
      },
      {
        "txt": "@Override public int getTextOffset() throws IOException { if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0; }"
      },
      {
        "txt": "@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try { _binaryValue = _decodeBase64(b64variant);"
      },
      {
        "txt": "} catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray();"
      },
      {
        "txt": "} } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant); out.write(b);"
      },
      {
        "txt": "return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } } protected int _readBinary(Base64Variant b64variant, OutputStream out,"
      },
      {
        "txt": "byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip"
      },
      {
        "txt": "continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; }"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); }"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; }"
      },
      {
        "txt": "@Override public JsonLocation getTokenLocation() { return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), -1L, // bytes, chars getTokenLineNr(), getTokenColumnNr()); } @Override public JsonLocation getCurrentLocation()"
      },
      {
        "txt": "{ int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr, -1L, // bytes, chars _currInputRow, col); } @Override public JsonToken nextToken() throws IOException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } if (_tokenIncomplete) { _skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null);"
      },
      {
        "txt": "} _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent();"
      },
      {
        "txt": "return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) {"
      },
      {
        "txt": "if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { return _nextTokenNotInObject(i); } String n = _parseName(i); _parsingContext.setCurrentName(n);"
      },
      {
        "txt": "_currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '-':"
      },
      {
        "txt": "t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':"
      },
      {
        "txt": "case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1);"
      },
      {
        "txt": "t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private final JsonToken _nextTokenNotInObject(int i) throws IOException {"
      },
      {
        "txt": "if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "return (_currToken = JsonToken.START_OBJECT); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL);"
      },
      {
        "txt": "case '-': return (_currToken = _parseNegNumber()); case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':"
      },
      {
        "txt": "case '8': case '9': return (_currToken = _parsePosNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken;"
      },
      {
        "txt": "_nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException"
      },
      {
        "txt": "{ _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd();"
      },
      {
        "txt": "if (i < 0) { // end-of-input close(); _currToken = null; return false; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1; _binaryValue = null; if (i == INT_RBRACKET) {"
      },
      {
        "txt": "if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS();"
      },
      {
        "txt": "} if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len + 4) < _inputEnd) { // maybe... final int end = _inputPtr+len;"
      },
      {
        "txt": "if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { // yes, match! _parsingContext.setCurrentName(str.getValue()); _isNextTokenNameYes(_skipColonFast(ptr+1)); return true; } if (nameBytes[offset] != _inputBuffer[ptr]) {"
      },
      {
        "txt": "break; } ++offset; ++ptr; } } } } return _isNextTokenNameMaybe(i, str); }"
      },
      {
        "txt": "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString();"
      },
      {
        "txt": "} int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _tokenInputTotal = _currInputProcessed + _inputPtr - 1; _tokenInputRow = _currInputRow; _tokenInputCol = _inputPtr - _currInputRowStart - 1;"
      },
      {
        "txt": "_binaryValue = null; if (i == INT_RBRACKET) { if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) {"
      },
      {
        "txt": "if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");"
      },
      {
        "txt": "} i = _skipWS(); } if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } final String nameStr = _parseName(i); _parsingContext.setCurrentName(nameStr); _currToken = JsonToken.FIELD_NAME;"
      },
      {
        "txt": "i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch (i) { case '-': t = _parseNegNumber();"
      },
      {
        "txt": "break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8':"
      },
      {
        "txt": "case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL;"
      },
      {
        "txt": "break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT;"
      },
      {
        "txt": "break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; } private final int _skipColonFast(int ptr) throws IOException { int i = _inputBuffer[ptr++];"
      },
      {
        "txt": "if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[ptr++]; if (i > INT_SPACE) { // nor trailing if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } } _inputPtr = ptr-1; return _skipColon2(true); // true -> skipped colon } if (i == INT_SPACE || i == INT_TAB) {"
      },
      {
        "txt": "i = _inputBuffer[ptr++]; } if (i == INT_COLON) { i = _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) {"
      },
      {
        "txt": "i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } } } _inputPtr = ptr-1;"
      },
      {
        "txt": "return _skipColon2(false); } private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return;"
      },
      {
        "txt": "case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return;"
      },
      {
        "txt": "case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber();"
      },
      {
        "txt": "return; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8':"
      },
      {
        "txt": "case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleUnexpectedValue(i); } private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException { String n = _parseName(i); _parsingContext.setCurrentName(n);"
      },
      {
        "txt": "final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch (i) {"
      },
      {
        "txt": "case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break;"
      },
      {
        "txt": "case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber();"
      },
      {
        "txt": "break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8':"
      },
      {
        "txt": "case '9': t = _parsePosNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; } @Override"
      },
      {
        "txt": "public String nextTextValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "return _finishAndReturnString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } switch (nextToken().id()) { case ID_TRUE: return Boolean.TRUE; case ID_FALSE: return Boolean.FALSE; default:"
      },
      {
        "txt": "return null; } } protected JsonToken _parsePosNumber(int c) throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[0] = (char) c;"
      },
      {
        "txt": "int intLen = 1; int outPtr = 1; int end = _inputPtr + outBuf.length - 1; // 1 == outPtr if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { // split across boundary, offline return _parseNumber2(outBuf, outPtr, false, intLen); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, false, intLen); }"
      },
      {
        "txt": "--_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(false, intLen); } protected JsonToken _parseNegNumber() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();"
      },
      {
        "txt": "int outPtr = 0; outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } if (c == INT_0) {"
      },
      {
        "txt": "c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1; int end = _inputPtr + outBuf.length - outPtr; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) {"
      },
      {
        "txt": "return _parseNumber2(outBuf, outPtr, true, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; } ++intLen; outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') {"
      },
      {
        "txt": "return _parseFloat(outBuf, outPtr, c, true, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(true, intLen); } private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,"
      },
      {
        "txt": "int intPartLength) throws IOException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { _textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == INT_PERIOD || c == INT_e || c == INT_E) {"
      },
      {
        "txt": "return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; ++intPartLength;"
      },
      {
        "txt": "} --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } return resetInt(negative, intPartLength); } private final int _verifyNoLeadingZeroes() throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); }"
      },
      {
        "txt": "++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF; if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break;"
      },
      {
        "txt": "} } } return ch; } private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException { int fractLen = 0; boolean eof = false;"
      },
      {
        "txt": "if (c == INT_PERIOD) { // yes, fraction outBuf[outPtr++] = (char) c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) {"
      },
      {
        "txt": "break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } if (fractLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == INT_e || c == INT_E) { // exponent? if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return resetFloat(negative, integerPartLength, fractLen, expLen); } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ': case '\\t': return; case '\\r':"
      },
      {
        "txt": "_skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; } _reportMissingRootWS(ch); } protected final String _parseName(int i) throws IOException"
      },
      {
        "txt": "{ if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote) return slowParseName(); } final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i;"
      },
      {
        "txt": "i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i); } if (i == INT_QUOTE) { // 4 byte/char case or broken return findName(q, 4); } return parseName(q, i, 4); }"
      },
      {
        "txt": "if (i == INT_QUOTE) { // 3 byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // 2 byte/char case or broken return findName(q, 2); } return parseName(q, i, 2); }"
      },
      {
        "txt": "if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\" return \"\"; } return parseName(0, q, 0); // quoting or invalid char }"
      },
      {
        "txt": "protected final String parseMediumName(int q2) throws IOException { final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char"
      },
      {
        "txt": "} q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2); } return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i;"
      },
      {
        "txt": "i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3); } q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } return parseMediumName2(i, q2); } protected final String parseMediumName2(int q3, final int q2) throws IOException { final byte[] input = _inputBuffer;"
      },
      {
        "txt": "final int[] codes = _icLatin1; int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 9 bytes return findName(_quad1, q2, q3, 1); } return parseName(_quad1, q2, q3, i, 1); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 10 bytes return findName(_quad1, q2, q3, 2); } return parseName(_quad1, q2, q3, i, 2); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 11 bytes"
      },
      {
        "txt": "return findName(_quad1, q2, q3, 3); } return parseName(_quad1, q2, q3, i, 3); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 12 bytes return findName(_quad1, q2, q3, 4); }"
      },
      {
        "txt": "return parseName(_quad1, q2, q3, i, 4); } return parseLongName(i, q2, q3); } protected final String parseLongName(int q, final int q2, int q3) throws IOException { _quadBuffer[0] = _quad1; _quadBuffer[1] = q2; _quadBuffer[2] = q3; final byte[] input = _inputBuffer;"
      },
      {
        "txt": "final int[] codes = _icLatin1; int qlen = 3; while ((_inputPtr + 4) <= _inputEnd) { int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); }"
      },
      {
        "txt": "q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); } return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); } q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) {"
      },
      {
        "txt": "return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen); } _quadBuffer[qlen++] = q; q = i; }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } protected String slowParseName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (i == INT_QUOTE) { // special case, \"\" return \"\"; } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException { return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1;"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; _quadBuffer[1] = q2; return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes); } protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException {"
      },
      {
        "txt": "final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; } if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped();"
      },
      {
        "txt": "} if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; }"
      },
      {
        "txt": "if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } }"
      },
      {
        "txt": "if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1;"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) {"
      },
      {
        "txt": "_quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(currQuad, currQuadBytes); } String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; }"
      },
      {
        "txt": "protected String _handleOddName(int ch) throws IOException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { char c = (char) _decodeCharForError(ch); _reportUnexpectedChar(c, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames();"
      },
      {
        "txt": "if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes;"
      },
      {
        "txt": "currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; } ++_inputPtr; }"
      },
      {
        "txt": "if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); }"
      },
      {
        "txt": "return name; } protected String _parseAposName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (ch == '\\'') { // special case, '' return \"\"; } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') {"
      },
      {
        "txt": "break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes;"
      },
      {
        "txt": "} else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0;"
      },
      {
        "txt": "} currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch;"
      },
      {
        "txt": "} else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(currQuad, currQuadBytes);"
      },
      {
        "txt": "} String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } private final String findName(int q1, int lastQuadBytes) throws JsonParseException { q1 = pad(q1, lastQuadBytes);"
      },
      {
        "txt": "String name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes); } private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { q2 = pad(q2, lastQuadBytes);"
      },
      {
        "txt": "String name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2; return addName(_quadBuffer, 2, lastQuadBytes); } private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException {"
      },
      {
        "txt": "q3 = pad(q3, lastQuadBytes); String name = _symbols.findName(q1, q2, q3); if (name != null) { return name; } int[] quads = _quadBuffer; quads[0] = q1; quads[1] = q2; quads[2] = pad(q3, lastQuadBytes); return addName(quads, 3, lastQuadBytes);"
      },
      {
        "txt": "} private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(lastQuad, lastQuadBytes); String name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes);"
      },
      {
        "txt": "} return name; } private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes; int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));"
      },
      {
        "txt": "} else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) { int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix;"
      },
      {
        "txt": "if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07;"
      },
      {
        "txt": "needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) { _reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3);"
      },
      {
        "txt": "ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3));"
      },
      {
        "txt": "++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output) ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix;"
      },
      {
        "txt": "if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } } if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment();"
      },
      {
        "txt": "} cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; }"
      },
      {
        "txt": "String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); } @Override protected void _finishString() throws IOException { int ptr = _inputPtr;"
      },
      {
        "txt": "if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) {"
      },
      {
        "txt": "int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return; } break; } ++ptr;"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } protected String _finishAndReturnString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) {"
      },
      {
        "txt": "if (c == INT_QUOTE) { _inputPtr = ptr+1; return _textBuffer.setCurrentAndReturn(outPtr); } break; } ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr;"
      },
      {
        "txt": "_finishString2(outBuf, outPtr); return _textBuffer.contentsAsString(); } private final void _finishString2(char[] outBuf, int outPtr) throws IOException { int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop:"
      },
      {
        "txt": "while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break;"
      },
      {
        "txt": "case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break;"
      },
      {
        "txt": "case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default:"
      },
      {
        "txt": "if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop:"
      },
      {
        "txt": "while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd;"
      },
      {
        "txt": "} while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; }"
      },
      {
        "txt": "if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped(); break; case 2: // 2-byte UTF _skipUtf8_2(c); break;"
      },
      {
        "txt": "case 3: // 3-byte UTF _skipUtf8_3(c); break; case 4: // 4-byte UTF _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else {"
      },
      {
        "txt": "_reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c) throws IOException { switch (c) { case ']':"
      },
      {
        "txt": "case '}': _reportUnexpectedChar(c, \"expected a value\"); case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {"
      },
      {
        "txt": "return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");"
      },
      {
        "txt": "break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos() throws IOException { int c = 0; int outPtr = 0;"
      },
      {
        "txt": "char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; { int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; }"
      },
      {
        "txt": "} while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; } outBuf[outPtr++] = (char) c; } } if (c == '\\'') {"
      },
      {
        "txt": "break main_loop; } switch (codes[c]) { case 1: // backslash if (c != '\\'') { // marked as special, isn't here c = _decodeEscaped(); } break; case 2: // 2-byte UTF c = _decodeUtf8_2(c);"
      },
      {
        "txt": "break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c);"
      },
      {
        "txt": "outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\");"
      },
      {
        "txt": "} _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); }"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else { break; }"
      },
      {
        "txt": "_matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } protected final void _matchToken(String matchStr, int i) throws IOException"
      },
      {
        "txt": "{ final int len = matchStr.length(); if ((_inputPtr + len) >= _inputEnd) { _matchToken2(matchStr, i); return; } do { if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); }"
      },
      {
        "txt": "++_inputPtr; } while (++i < len); int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _matchToken2(String matchStr, int i) throws IOException { final int len = matchStr.length();"
      },
      {
        "txt": "do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) { return; }"
      },
      {
        "txt": "int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException { char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); }"
      },
      {
        "txt": "} private final int _skipWS() throws IOException { while (_inputPtr < _inputEnd) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWS2(); }"
      },
      {
        "txt": "return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} } } return _skipWS2(); } private final int _skipWS2() throws IOException { while (_inputPtr < _inputEnd || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } return i;"
      },
      {
        "txt": "} if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { return _eofAsNextChar(); }"
      },
      {
        "txt": "} int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; } if (i != INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } while (_inputPtr < _inputEnd) {"
      },
      {
        "txt": "i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; } if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _skipWSOrEnd2();"
      },
      {
        "txt": "} private final int _skipWSOrEnd2() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; }"
      },
      {
        "txt": "if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } return i; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _eofAsNextChar(); } private final int _skipColon() throws IOException"
      },
      {
        "txt": "{ if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } int i = _inputBuffer[_inputPtr]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { // nor trailing if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true);"
      },
      {
        "txt": "} ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); }"
      },
      {
        "txt": "++_inputPtr; return i; } } return _skipColon2(true); // true -> skipped colon } if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[++_inputPtr]; } if (i == INT_COLON) {"
      },
      {
        "txt": "i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); }"
      },
      {
        "txt": "return _skipColon2(false); } private final int _skipColon2(boolean gotColon) throws IOException { while (_inputPtr < _inputEnd || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue;"
      },
      {
        "txt": "} if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } if (gotColon) { return i; } if (i != INT_COLON) {"
      },
      {
        "txt": "if (i < INT_SPACE) { _throwInvalidSpace(i); } _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final void _skipComment() throws IOException"
      },
      {
        "txt": "{ if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine();"
      },
      {
        "txt": "} else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private final void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop:"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) {"
      },
      {
        "txt": "++_inputPtr; return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "default: // e.g. -1 _reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private final boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {"
      },
      {
        "txt": "return false; } _skipLine(); return true; } private final void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "int code = codes[i]; if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return;"
      },
      {
        "txt": "case '*': // nop for these comments break; case 2: // 2-byte UTF _skipUtf8_2(i); break; case 3: // 3-byte UTF _skipUtf8_3(i); break; case 4: // 4-byte UTF _skipUtf8_4(i);"
      },
      {
        "txt": "break; default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } } } @Override"
      },
      {
        "txt": "protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++]; switch (c) { case 'b':"
      },
      {
        "txt": "return '\\b'; case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"':"
      },
      {
        "txt": "case '/': case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); }"
      },
      {
        "txt": "value = (value << 4) | digit; } return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = firstByte & 0xFF; if (c > 0x7F) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)"
      },
      {
        "txt": "c &= 0x1F; needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF);"
      },
      {
        "txt": "needed = 1; // never gets here } int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); }"
      },
      {
        "txt": "} } return c; } private final int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private final int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c;"
      },
      {
        "txt": "} private final int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "c = ((c & 0x07) << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; } private final void _skipUtf8_2(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_3(int c) throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr);"
      },
      {
        "txt": "} if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected final void _skipCR() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); }"
      },
      {
        "txt": "protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "break; } sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) {"
      },
      {
        "txt": "_throwInvalidSpace(c); } _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask)"
      },
      {
        "txt": "throws JsonParseException { _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); }"
      },
      {
        "txt": "public static int[] growArrayBy(int[] arr, int more) { if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException {"
      },
      {
        "txt": "ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch);"
      },
      {
        "txt": "if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray();"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");"
      },
      {
        "txt": "} decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); }"
      },
      {
        "txt": "} private final static int pad(int q, int bytes) { return (bytes == 4) ? q : (q | (-1 << (bytes << 3))); }"
      }
    ]
  }
]