[
  {
    "id": 1280,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
    "start-bug-line": 1418,
    "end-bug-line": 1418,
    "bug": "",
    "fix": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*;"
      },
      {
        "txt": "public class ReaderBasedJsonParser // final in 2.3, earlier extends ParserBase { protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected Reader _reader; protected char[] _inputBuffer; protected boolean _bufferRecyclable; protected ObjectCodec _objectCodec; final protected CharsToNameCanonicalizer _symbols; final protected int _hashSeed;"
      },
      {
        "txt": "protected boolean _tokenIncomplete; protected long _nameStartOffset; protected int _nameStartRow; protected int _nameStartCol; public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st, char[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features);"
      },
      {
        "txt": "_reader = r; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed(); _bufferRecyclable = bufferRecyclable; } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,"
      },
      {
        "txt": "ObjectCodec codec, CharsToNameCanonicalizer st) { super(ctxt, features); _reader = r; _inputBuffer = ctxt.allocTokenBuffer(); _inputPtr = 0; _inputEnd = 0; _objectCodec = codec; _symbols = st; _hashSeed = st.hashSeed();"
      },
      {
        "txt": "_bufferRecyclable = true; } @Override public ObjectCodec getCodec() { return _objectCodec; } @Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(Writer w) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0; } int origPtr = _inputPtr; w.write(_inputBuffer, origPtr, count);"
      },
      {
        "txt": "return count; } @Override public Object getInputSource() { return _reader; } @Override protected boolean loadMore() throws IOException { final int bufSize = _inputEnd; _currInputProcessed += bufSize; _currInputRowStart -= bufSize; _nameStartOffset -= bufSize;"
      },
      {
        "txt": "if (_reader != null) { int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);"
      },
      {
        "txt": "} } return false; } protected char getNextChar(String eofMsg) throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(eofMsg); } } return _inputBuffer[_inputPtr++]; }"
      },
      {
        "txt": "@Override protected void _closeInput() throws IOException { if (_reader != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _reader.close(); } _reader = null; } } @Override"
      },
      {
        "txt": "protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) { char[] buf = _inputBuffer; if (buf != null) { _inputBuffer = null; _ioContext.releaseTokenBuffer(buf); } }"
      },
      {
        "txt": "} @Override public final String getText() throws IOException { JsonToken t = _currToken; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete }"
      },
      {
        "txt": "return _textBuffer.contentsAsString(); } return _getText2(t); } @Override public final String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); } @Override"
      },
      {
        "txt": "public final String getValueAsString(String defValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName();"
      },
      {
        "txt": "} return super.getValueAsString(defValue); } protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName();"
      },
      {
        "txt": "case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override public final char[] getTextCharacters() throws IOException"
      },
      {
        "txt": "{ if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); } else if (_nameCopyBuffer.length < nameLen) {"
      },
      {
        "txt": "_nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete"
      },
      {
        "txt": "} case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null; }"
      },
      {
        "txt": "@Override public final int getTextLength() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } } return 0;"
      },
      {
        "txt": "} @Override public final int getTextOffset() throws IOException { if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } } return 0;"
      },
      {
        "txt": "} @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) { try {"
      },
      {
        "txt": "_binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder(); _decodeBase64(getText(), builder, b64variant);"
      },
      {
        "txt": "_binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { byte[] b = getBinaryValue(b64variant);"
      },
      {
        "txt": "out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); } }"
      },
      {
        "txt": "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == '\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip"
      },
      {
        "txt": "continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; }"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); }"
      },
      {
        "txt": "decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3);"
      },
      {
        "txt": "} if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16);"
      },
      {
        "txt": "buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; }"
      },
      {
        "txt": "@Override public final JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); // only strings can be partial }"
      },
      {
        "txt": "int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.clearAndGetParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.clearAndGetParent();"
      },
      {
        "txt": "return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i); } boolean inObject = _parsingContext.inObject(); if (inObject) { _updateNameLocation(); String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name);"
      },
      {
        "txt": "_currToken = JsonToken.FIELD_NAME; i = _skipColon(); } _updateLocation(); JsonToken t; switch (i) { case '\"': _tokenIncomplete = true; t = JsonToken.VALUE_STRING; break;"
      },
      {
        "txt": "case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); }"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \"expected a value\"); case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case 'f':"
      },
      {
        "txt": "_matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break;"
      },
      {
        "txt": "case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; }"
      },
      {
        "txt": "_currToken = t; return t; } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "} else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString sstr) throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "_nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null;"
      },
      {
        "txt": "return false; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_ARRAY;"
      },
      {
        "txt": "return false; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_OBJECT; return false;"
      },
      {
        "txt": "} if (_parsingContext.expectComma()) { i = _skipComma(i); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return false; } _updateNameLocation();"
      },
      {
        "txt": "if (i == INT_QUOTE) { char[] nameChars = sstr.asQuotedChars(); final int len = nameChars.length; if ((_inputPtr + len + 4) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == '\"') { int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { // yes, match!"
      },
      {
        "txt": "_parsingContext.setCurrentName(sstr.getValue()); _isNextTokenNameYes(_skipColonFast(ptr+1)); return true; } if (nameChars[offset] != _inputBuffer[ptr]) { break; } ++offset; ++ptr; }"
      },
      {
        "txt": "} } } return _isNextTokenNameMaybe(i, sstr.getValue()); } @Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "_nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null;"
      },
      {
        "txt": "return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_ARRAY;"
      },
      {
        "txt": "return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_OBJECT; return null;"
      },
      {
        "txt": "} if (_parsingContext.expectComma()) { i = _skipComma(i); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation();"
      },
      {
        "txt": "String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return name; }"
      },
      {
        "txt": "JsonToken t; switch (i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4':"
      },
      {
        "txt": "case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE;"
      },
      {
        "txt": "break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[':"
      },
      {
        "txt": "t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t;"
      },
      {
        "txt": "return name; } private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation(); switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING;"
      },
      {
        "txt": "return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE;"
      },
      {
        "txt": "return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-':"
      },
      {
        "txt": "_nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':"
      },
      {
        "txt": "case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleOddValue(i); } protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);"
      },
      {
        "txt": "_parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameToMatch.equals(name); } JsonToken t;"
      },
      {
        "txt": "switch (i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5':"
      },
      {
        "txt": "case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break;"
      },
      {
        "txt": "case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY;"
      },
      {
        "txt": "break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return nameToMatch.equals(name);"
      },
      {
        "txt": "} private final JsonToken _nextTokenNotInObject(int i) throws IOException { if (i == INT_QUOTE) { _tokenIncomplete = true; return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"
      },
      {
        "txt": "return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case 't': _matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE);"
      },
      {
        "txt": "case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': return (_currToken = _parseNegNumber()); case '0': case '1': case '2': case '3': case '4':"
      },
      {
        "txt": "case '5': case '6': case '7': case '8': case '9': return (_currToken = _parsePosNumber(i)); } return (_currToken = _handleOddValue(i)); } @Override"
      },
      {
        "txt": "public final String nextTextValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); } return _textBuffer.contentsAsString(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override public final int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override public final long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue;"
      },
      {
        "txt": "} return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override public final Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null;"
      },
      {
        "txt": "_currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } JsonToken t = nextToken(); if (t != null) { int id = t.id(); if (id == ID_TRUE) return Boolean.TRUE; if (id == ID_FALSE) return Boolean.FALSE; }"
      },
      {
        "txt": "return null; } protected final JsonToken _parsePosNumber(int ch) throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include digit already read final int inputLen = _inputEnd; if (ch == INT_0) { return _parseNumber2(false, startPtr); }"
      },
      {
        "txt": "int intLen = 1; // already got one int_loop: while (true) { if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(false, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop;"
      },
      {
        "txt": "} ++intLen; } if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, false, intLen); } --ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) {"
      },
      {
        "txt": "_verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(false, intLen); } private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd;"
      },
      {
        "txt": "int fractLen = 0; if (ch == '.') { // yes, fraction fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop;"
      },
      {
        "txt": "} ++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { // and/or exponent if (ptr >= inputLen) {"
      },
      {
        "txt": "_inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++];"
      },
      {
        "txt": "} while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; } if (expLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\"); } } --ptr; // need to push back following separator _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len);"
      },
      {
        "txt": "return resetFloat(neg, intLen, fractLen, expLen); } protected final JsonToken _parseNegNumber() throws IOException { int ptr = _inputPtr; int startPtr = ptr-1; // to include sign/digit already read final int inputLen = _inputEnd; if (ptr >= inputLen) { return _parseNumber2(true, startPtr); }"
      },
      {
        "txt": "int ch = _inputBuffer[ptr++]; if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } if (ch == INT_0) { return _parseNumber2(true, startPtr); } int intLen = 1; // already got one int_loop:"
      },
      {
        "txt": "while (true) { if (ptr >= inputLen) { return _parseNumber2(true, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; }"
      },
      {
        "txt": "if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) { _inputPtr = ptr; return _parseFloat(ch, startPtr, ptr, true, intLen); } --ptr; _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr-startPtr;"
      },
      {
        "txt": "_textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetInt(true, intLen); } private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException { _inputPtr = neg ? (startPtr+1) : startPtr; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (neg) { outBuf[outPtr++] = '-';"
      },
      {
        "txt": "} int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') { ++intLen;"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true; break int_loop; }"
      },
      {
        "txt": "} if (intLen == 0) { return _handleInvalidNumberStart(c, neg); } int fractLen = 0; if (c == '.') { // yes, fraction <extra_id_0> fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; }"
      },
      {
        "txt": "break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == 'e' || c == 'E') { // exponent? if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\"); } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = _inputBuffer[_inputPtr++]; } if (expLen == 0) {"
      },
      {
        "txt": "reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "return reset(neg, intLen, fractLen, expLen); } private final char _verifyNoLeadingZeroes() throws IOException { if (_inputPtr < _inputEnd) { char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } }"
      },
      {
        "txt": "return _verifyNLZ2(); } private char _verifyNLZ2() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0';"
      },
      {
        "txt": "} if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { // followed by non-number; retain one zero return '0';"
      },
      {
        "txt": "} ++_inputPtr; // skip previous zero if (ch != '0') { // followed by other number; return break; } } } return ch; } protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException"
      },
      {
        "txt": "{ if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \"-INF\" :\"+INF\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {"
      },
      {
        "txt": "return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } else if (ch == 'n') { String match = negative ? \"-Infinity\" :\"+Infinity\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");"
      },
      {
        "txt": "} } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null; } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) { case ' ':"
      },
      {
        "txt": "case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return; }"
      },
      {
        "txt": "_reportMissingRootWS(ch); } protected final String _parseName() throws IOException { int ptr = _inputPtr; int hash = _hashSeed; final int[] codes = _icLatin1; while (ptr < _inputEnd) { int ch = _inputBuffer[ptr]; if (ch < codes.length && codes[ch] != 0) {"
      },
      {
        "txt": "if (ch == '\"') { int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; }"
      },
      {
        "txt": "int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, INT_QUOTE); } private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped();"
      },
      {
        "txt": "} else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \"name\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;"
      },
      {
        "txt": "outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer();"
      },
      {
        "txt": "int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); }"
      },
      {
        "txt": "if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { // identifier, or a number ([Issue#102]) firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i);"
      },
      {
        "txt": "} if (!firstOk) { _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr];"
      },
      {
        "txt": "if (ch < maxCode) { if (codes[ch] != 0) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr-1; // -1 to bring back first char _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);"
      },
      {
        "txt": "} hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); } protected String _parseAposName() throws IOException"
      },
      {
        "txt": "{ int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length; do { int ch = _inputBuffer[ptr]; if (ch == '\\'') {"
      },
      {
        "txt": "int start = _inputPtr; _inputPtr = ptr+1; // to skip the quote return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } if (ch < maxCode && codes[ch] != 0) { break; } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen);"
      },
      {
        "txt": "} int start = _inputPtr; _inputPtr = ptr; return _parseName2(start, hash, '\\''); } protected JsonToken _handleOddValue(int i) throws IOException { switch (i) { case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {"
      },
      {
        "txt": "return _handleApos(); } break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break;"
      },
      {
        "txt": "case 'I': _matchToken(\"Infinity\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOFInValue(); } } return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); } if (Character.isJavaIdentifierStart(i)) { _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null;"
      },
      {
        "txt": "} protected JsonToken _handleApos() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); }"
      },
      {
        "txt": "} char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= '\\\\') { if (i == '\\\\') { c = _decodeEscaped(); } else if (i <= '\\'') { if (i == '\\'') { break; }"
      },
      {
        "txt": "if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } } } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c;"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length;"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // acceptable for now (will error out later) break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; if (i <= maxCode) { if (codes[i] != 0) {"
      },
      {
        "txt": "break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment();"
      },
      {
        "txt": "outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash);"
      },
      {
        "txt": "} } @Override protected final void _finishString() throws IOException { int ptr = _inputPtr; final int inputLen = _inputEnd; if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length;"
      },
      {
        "txt": "do { int ch = _inputBuffer[ptr]; if (ch < maxCode && codes[ch] != 0) { if (ch == '\"') { _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr+1; return; } break; }"
      },
      {
        "txt": "++ptr; } while (ptr < inputLen); } _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); _inputPtr = ptr; _finishString2(); } protected void _finishString2() throws IOException { char[] outBuf = _textBuffer.getCurrentSegment();"
      },
      {
        "txt": "int outPtr = _textBuffer.getCurrentSegmentSize(); final int[] codes = _icLatin1; final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); } } char c = _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "int i = (int) c; if (i < maxCode && codes[i] != 0) { if (i == INT_QUOTE) { break; } else if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i < INT_SPACE) { _throwUnquotedSpace(i, \"string value\"); } // anything else? }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } _textBuffer.setCurrentLength(outPtr); } protected final void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; int inPtr = _inputPtr; int inLen = _inputEnd; char[] inBuf = _inputBuffer; while (true) { if (inPtr >= inLen) { _inputPtr = inPtr; if (!loadMore()) { _reportInvalidEOF(\": was expecting closing quote for a string value\"); }"
      },
      {
        "txt": "inPtr = _inputPtr; inLen = _inputEnd; } char c = inBuf[inPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { _inputPtr = inPtr; inPtr = _inputPtr; inLen = _inputEnd;"
      },
      {
        "txt": "} else if (i <= INT_QUOTE) { if (i == INT_QUOTE) { _inputPtr = inPtr; break; } if (i < INT_SPACE) { _inputPtr = inPtr; _throwUnquotedSpace(i, \"string value\"); } }"
      },
      {
        "txt": "} } } protected final void _skipCR() throws IOException { if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == '\\n') { ++_inputPtr; } } ++_currInputRow;"
      },
      {
        "txt": "_currInputRowStart = _inputPtr; } private final int _skipColon() throws IOException { if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } char c = _inputBuffer[_inputPtr]; if (c == ':') { // common case, no leading space int i = _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "if (i > INT_SPACE) { // nor trailing if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); // true -> skipped colon } if (c == ' ' || c == '\\t') {"
      },
      {
        "txt": "c = _inputBuffer[++_inputPtr]; } if (c == ':') { int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i;"
      },
      {
        "txt": "} if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; }"
      },
      {
        "txt": "} return _skipColon2(true); } return _skipColon2(false); } private final int _skipColon2(boolean gotColon) throws IOException { while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue;"
      },
      {
        "txt": "} } if (gotColon) { return i; } if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; continue;"
      },
      {
        "txt": "} if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} } } private final int _skipColonFast(int ptr) throws IOException { int i = (int) _inputBuffer[ptr++]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[ptr++]; if (i > INT_SPACE) { // nor trailing if (i != INT_SLASH && i != INT_HASH) {"
      },
      {
        "txt": "_inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; }"
      },
      {
        "txt": "} } _inputPtr = ptr-1; return _skipColon2(true); // true -> skipped colon } if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[ptr++]; } boolean gotColon = (i == INT_COLON); if (gotColon) {"
      },
      {
        "txt": "i = _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) {"
      },
      {
        "txt": "_inputPtr = ptr; return i; } } } } _inputPtr = ptr-1; return _skipColon2(gotColon); } private final int _skipComma(int i) throws IOException"
      },
      {
        "txt": "{ if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipAfterComma2();"
      },
      {
        "txt": "} return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) {"
      },
      {
        "txt": "_throwInvalidSpace(i); } } } return _skipAfterComma2(); } private final int _skipAfterComma2() throws IOException { while (_inputPtr < _inputEnd || loadMore()) { int i = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } }"
      },
      {
        "txt": "return i; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) { return _eofAsNextChar();"
      },
      {
        "txt": "} } int i = _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; }"
      },
      {
        "txt": "if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } }"
      },
      {
        "txt": "while (_inputPtr < _inputEnd) { i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; } if (i != INT_SPACE) {"
      },
      {
        "txt": "if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } }"
      },
      {
        "txt": "return _skipWSOrEnd2(); } private int _skipWSOrEnd2() throws IOException { while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { // We ran out of input... return _eofAsNextChar(); } }"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++]; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; }"
      },
      {
        "txt": "} return i; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i);"
      },
      {
        "txt": "} } } } private void _skipComment() throws IOException { if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in a comment\"); } char c = _inputBuffer[_inputPtr++]; if (c == '/') { _skipLine(); } else if (c == '*') { _skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); }"
      },
      {
        "txt": "} private void _skipCComment() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i <= '*') { if (i == '*') { // end? if ((_inputPtr >= _inputEnd) && !loadMore()) { break; }"
      },
      {
        "txt": "if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr; return; } continue; } if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr;"
      },
      {
        "txt": "} else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } _reportInvalidEOF(\" in a comment\"); }"
      },
      {
        "txt": "private boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false; } _skipLine(); return true; } private void _skipLine() throws IOException {"
      },
      {
        "txt": "while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++]; if (i < INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; break; } else if (i == INT_CR) { _skipCR(); break;"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } } @Override protected char _decodeEscaped() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } char c = _inputBuffer[_inputPtr++]; switch ((int) c) { case 'b': return '\\b'; case 't': return '\\t';"
      },
      {
        "txt": "case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/': case '\\\\': return c;"
      },
      {
        "txt": "case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape(c); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\");"
      },
      {
        "txt": "} } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit; } return (char) value;"
      },
      {
        "txt": "} private final void _matchTrue() throws IOException { int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return;"
      },
      {
        "txt": "} } } _matchToken(\"true\", 1); } private final void _matchFalse() throws IOException { int ptr = _inputPtr; if ((ptr + 4) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {"
      },
      {
        "txt": "char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } } } _matchToken(\"false\", 1); } private final void _matchNull() throws IOException {"
      },
      {
        "txt": "int ptr = _inputPtr; if ((ptr + 3) < _inputEnd) { final char[] b = _inputBuffer; if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') { char c = b[++ptr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars _inputPtr = ptr; return; } }"
      },
      {
        "txt": "} _matchToken(\"null\", 1); } protected final void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); do { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidToken(matchStr.substring(0, i));"
      },
      {
        "txt": "} } if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd) { if (!loadMore()) { return;"
      },
      {
        "txt": "} } char c = _inputBuffer[_inputPtr]; if (c < '0' || c == ']' || c == '}') { // expected/allowed chars return; } if (Character.isJavaIdentifierPart(c)) { _reportInvalidToken(matchStr.substring(0, i)); } return;"
      },
      {
        "txt": "} @SuppressWarnings(\"resource\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\"') { // reached the end, fair and square? return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip"
      },
      {
        "txt": "continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) {"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) {"
      },
      {
        "txt": "if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; builder.append(decodedData); continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2;"
      },
      {
        "txt": "builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; }"
      },
      {
        "txt": "} decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } } @Override public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "long total = _currInputProcessed + (_nameStartOffset-1); return new JsonLocation(src, -1L, total, _nameStartRow, _nameStartCol); } return new JsonLocation(src, -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol); } @Override public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based"
      },
      {
        "txt": "return new JsonLocation(_ioContext.getSourceReference(), -1L, _currInputProcessed + _inputPtr, _currInputRow, col); } private final void _updateLocation() { int ptr = _inputPtr; _tokenInputTotal = _currInputProcessed + ptr; _tokenInputRow = _currInputRow; _tokenInputCol = ptr - _currInputRowStart;"
      },
      {
        "txt": "} private final void _updateNameLocation() { int ptr = _inputPtr; _nameStartOffset = ptr; _nameStartRow = _currInputRow; _nameStartCol = ptr - _currInputRowStart; } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");"
      },
      {
        "txt": "} protected void _reportInvalidToken(String matchedPart, String msg) throws IOException { StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { break; } }"
      },
      {
        "txt": "char c = _inputBuffer[_inputPtr]; if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); }"
      }
    ]
  },
  {
    "id": 1281,
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
    "start-bug-line": 1544,
    "end-bug-line": 1544,
    "bug": "",
    "fix": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package com.fasterxml.jackson.core.json; import java.io.*; import java.util.Arrays; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.io.CharTypes; import com.fasterxml.jackson.core.io.IOContext;"
      },
      {
        "txt": "import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer; import com.fasterxml.jackson.core.util.*; import static com.fasterxml.jackson.core.JsonTokenId.*; public class UTF8StreamJsonParser extends ParserBase { final static byte BYTE_LF = (byte) '\\n'; private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8(); protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1(); protected ObjectCodec _objectCodec;"
      },
      {
        "txt": "final protected ByteQuadsCanonicalizer _symbols; protected int[] _quadBuffer = new int[16]; protected boolean _tokenIncomplete; private int _quad1; protected int _nameStartOffset; protected int _nameStartRow; protected int _nameStartCol; protected InputStream _inputStream; protected byte[] _inputBuffer; protected boolean _bufferRecyclable;"
      },
      {
        "txt": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, ByteQuadsCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer;"
      },
      {
        "txt": "_inputPtr = start; _inputEnd = end; _currInputRowStart = start; _currInputProcessed = -start; _bufferRecyclable = bufferRecyclable; } @Override public ObjectCodec getCodec() { return _objectCodec; }"
      },
      {
        "txt": "@Override public void setCodec(ObjectCodec c) { _objectCodec = c; } @Override public int releaseBuffered(OutputStream out) throws IOException { int count = _inputEnd - _inputPtr; if (count < 1) { return 0;"
      },
      {
        "txt": "} int origPtr = _inputPtr; out.write(_inputBuffer, origPtr, count); return count; } @Override public Object getInputSource() { return _inputStream; } @Override"
      },
      {
        "txt": "protected final boolean loadMore() throws IOException { final int bufSize = _inputEnd; _currInputProcessed += _inputEnd; _currInputRowStart -= _inputEnd; _nameStartOffset -= bufSize; if (_inputStream != null) { int space = _inputBuffer.length; if (space == 0) { // only occurs when we've been closed return false;"
      },
      {
        "txt": "} int count = _inputStream.read(_inputBuffer, 0, space); if (count > 0) { _inputPtr = 0; _inputEnd = count; return true; } _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");"
      },
      {
        "txt": "} } return false; } protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException { if (_inputStream == null) { return false; } int amount = _inputEnd - _inputPtr;"
      },
      {
        "txt": "if (amount > 0 && _inputPtr > 0) { final int ptr = _inputPtr; _currInputProcessed += ptr; _currInputRowStart -= ptr; _nameStartOffset -= ptr; System.arraycopy(_inputBuffer, ptr, _inputBuffer, 0, amount); _inputEnd = amount; } else { _inputEnd = 0; }"
      },
      {
        "txt": "_inputPtr = 0; while (_inputEnd < minAvailable) { int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); if (count < 1) { _closeInput(); if (count == 0) { throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\"); } return false; }"
      },
      {
        "txt": "_inputEnd += count; } return true; } @Override protected void _closeInput() throws IOException { if (_inputStream != null) { if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { _inputStream.close();"
      },
      {
        "txt": "} _inputStream = null; } } @Override protected void _releaseBuffers() throws IOException { super._releaseBuffers(); _symbols.release(); if (_bufferRecyclable) {"
      },
      {
        "txt": "byte[] buf = _inputBuffer; if (buf != null) { _inputBuffer = ByteArrayBuilder.NO_BYTES; _ioContext.releaseReadIOBuffer(buf); } } } @Override public String getText() throws IOException {"
      },
      {
        "txt": "if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } return _getText2(_currToken); } @Override"
      },
      {
        "txt": "public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) {"
      },
      {
        "txt": "return getCurrentName(); } return super.getValueAsString(null); } @Override public String getValueAsString(String defValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "return _finishAndReturnString(); // only strings can be incomplete } return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(defValue); } @Override"
      },
      {
        "txt": "public int getValueAsInt() throws IOException { JsonToken t = _currToken; if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt();"
      },
      {
        "txt": "} } return _numberInt; } return super.getValueAsInt(0); } @Override public int getValueAsInt(int defValue) throws IOException { JsonToken t = _currToken;"
      },
      {
        "txt": "if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) { if ((_numTypesValid & NR_INT) == 0) { if (_numTypesValid == NR_UNKNOWN) { return _parseIntValue(); } if ((_numTypesValid & NR_INT) == 0) { convertNumberToInt(); } } return _numberInt;"
      },
      {
        "txt": "} return super.getValueAsInt(defValue); } protected final String _getText2(JsonToken t) { if (t == null) { return null; } switch (t.id()) { case ID_FIELD_NAME:"
      },
      {
        "txt": "return _parsingContext.getCurrentName(); case ID_STRING: case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.contentsAsString(); default: return t.asString(); } } @Override"
      },
      {
        "txt": "public char[] getTextCharacters() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: if (!_nameCopied) { String name = _parsingContext.getCurrentName(); int nameLen = name.length(); if (_nameCopyBuffer == null) { _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);"
      },
      {
        "txt": "} else if (_nameCopyBuffer.length < nameLen) { _nameCopyBuffer = new char[nameLen]; } name.getChars(0, nameLen, _nameCopyBuffer, 0); _nameCopied = true; } return _nameCopyBuffer; case ID_STRING: if (_tokenIncomplete) { _tokenIncomplete = false;"
      },
      {
        "txt": "_finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextBuffer(); default: return _currToken.asCharArray(); } } return null;"
      },
      {
        "txt": "} @Override public int getTextLength() throws IOException { if (_currToken != null) { // null only before/after document switch (_currToken.id()) { case ID_FIELD_NAME: return _parsingContext.getCurrentName().length(); case ID_STRING: if (_tokenIncomplete) {"
      },
      {
        "txt": "_tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.size(); default: return _currToken.asCharArray().length; } }"
      },
      {
        "txt": "return 0; } @Override public int getTextOffset() throws IOException { if (_currToken != null) { switch (_currToken.id()) { case ID_FIELD_NAME: return 0; case ID_STRING:"
      },
      {
        "txt": "if (_tokenIncomplete) { _tokenIncomplete = false; _finishString(); // only strings can be incomplete } case ID_NUMBER_INT: case ID_NUMBER_FLOAT: return _textBuffer.getTextOffset(); default: } }"
      },
      {
        "txt": "return 0; } @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\"); } if (_tokenIncomplete) {"
      },
      {
        "txt": "try { _binaryValue = _decodeBase64(b64variant); } catch (IllegalArgumentException iae) { throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage()); } _tokenIncomplete = false; } else { // may actually require conversion... if (_binaryValue == null) { @SuppressWarnings(\"resource\") ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "_decodeBase64(getText(), builder, b64variant); _binaryValue = builder.toByteArray(); } } return _binaryValue; } @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {"
      },
      {
        "txt": "byte[] b = getBinaryValue(b64variant); out.write(b); return b.length; } byte[] buf = _ioContext.allocBase64Buffer(); try { return _readBinary(b64variant, out, buf); } finally { _ioContext.releaseBase64Buffer(buf); }"
      },
      {
        "txt": "} protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square? if (ch == INT_QUOTE) { break; }"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; }"
      },
      {
        "txt": "int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits;"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData;"
      },
      {
        "txt": "break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) {"
      },
      {
        "txt": "throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break;"
      },
      {
        "txt": "} bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } }"
      },
      {
        "txt": "decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); }"
      },
      {
        "txt": "return outputCount; } @Override public JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) {"
      },
      {
        "txt": "_skipString(); // only strings can be partial } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation();"
      },
      {
        "txt": "if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.clearAndGetParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']');"
      },
      {
        "txt": "} _parsingContext = _parsingContext.clearAndGetParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); }"
      },
      {
        "txt": "if (!_parsingContext.inObject()) { _updateLocation(); return _nextTokenNotInObject(i); } _updateNameLocation(); String n = _parseName(i); _parsingContext.setCurrentName(n); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation();"
      },
      {
        "txt": "if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch (i) { case '-': t = _parseNegNumber(); break;"
      },
      {
        "txt": "case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "t = _parsePosNumber(i); break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break;"
      },
      {
        "txt": "case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break;"
      },
      {
        "txt": "default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; } private final JsonToken _nextTokenNotInObject(int i) throws IOException { if (i == INT_QUOTE) { _tokenIncomplete = true;"
      },
      {
        "txt": "return (_currToken = JsonToken.VALUE_STRING); } switch (i) { case '[': _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_ARRAY); case '{': _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); return (_currToken = JsonToken.START_OBJECT); case 't':"
      },
      {
        "txt": "_matchToken(\"true\", 1); return (_currToken = JsonToken.VALUE_TRUE); case 'f': _matchToken(\"false\", 1); return (_currToken = JsonToken.VALUE_FALSE); case 'n': _matchToken(\"null\", 1); return (_currToken = JsonToken.VALUE_NULL); case '-': return (_currToken = _parseNegNumber());"
      },
      {
        "txt": "case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "return (_currToken = _parsePosNumber(i)); } return (_currToken = _handleUnexpectedValue(i)); } private final JsonToken _nextAfterName() { _nameCopied = false; // need to invalidate if it was copied JsonToken t = _nextToken; _nextToken = null; if (t == JsonToken.START_ARRAY) {"
      },
      {
        "txt": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return (_currToken = t); } @Override public boolean nextFieldName(SerializableString str) throws IOException { _numTypesValid = NR_UNKNOWN;"
      },
      {
        "txt": "if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { // end-of-input close();"
      },
      {
        "txt": "_currToken = null; return false; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.clearAndGetParent();"
      },
      {
        "txt": "_currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_OBJECT;"
      },
      {
        "txt": "return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation();"
      },
      {
        "txt": "_nextTokenNotInObject(i); return false; } _updateNameLocation(); if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len + 4) < _inputEnd) { // maybe... final int end = _inputPtr+len; if (_inputBuffer[end] == INT_QUOTE) {"
      },
      {
        "txt": "int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { // yes, match! _parsingContext.setCurrentName(str.getValue()); i = _skipColonFast(ptr+1); _isNextTokenNameYes(i); return true; } if (nameBytes[offset] != _inputBuffer[ptr]) {"
      },
      {
        "txt": "break; } ++offset; ++ptr; } } } } return _isNextTokenNameMaybe(i, str); }"
      },
      {
        "txt": "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString();"
      },
      {
        "txt": "} int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation();"
      },
      {
        "txt": "if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) {"
      },
      {
        "txt": "_reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.clearAndGetParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\"); }"
      },
      {
        "txt": "i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); final String nameStr = _parseName(i); _parsingContext.setCurrentName(nameStr);"
      },
      {
        "txt": "_currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch (i) {"
      },
      {
        "txt": "case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6':"
      },
      {
        "txt": "case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break;"
      },
      {
        "txt": "case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; } private final int _skipColonFast(int ptr) throws IOException"
      },
      {
        "txt": "{ int i = _inputBuffer[ptr++]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[ptr++]; if (i > INT_SPACE) { // nor trailing if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } else if (i == INT_SPACE || i == INT_TAB) {"
      },
      {
        "txt": "i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } } _inputPtr = ptr-1; return _skipColon2(true); // true -> skipped colon"
      },
      {
        "txt": "} if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[ptr++]; } if (i == INT_COLON) { i = _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i;"
      },
      {
        "txt": "} } else if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[ptr++]; if (i > INT_SPACE) { if (i != INT_SLASH && i != INT_HASH) { _inputPtr = ptr; return i; } } }"
      },
      {
        "txt": "_inputPtr = ptr-1; return _skipColon2(true); } _inputPtr = ptr-1; return _skipColon2(false); } private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation();"
      },
      {
        "txt": "switch (i) { case '\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT;"
      },
      {
        "txt": "return; case 't': _matchToken(\"true\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\"false\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n':"
      },
      {
        "txt": "_matchToken(\"null\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3':"
      },
      {
        "txt": "case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleUnexpectedValue(i);"
      },
      {
        "txt": "} private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException { String n = _parseName(i); _parsingContext.setCurrentName(n); final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) {"
      },
      {
        "txt": "_tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch (i) { case '[': t = JsonToken.START_ARRAY; break; case '{':"
      },
      {
        "txt": "t = JsonToken.START_OBJECT; break; case 't': _matchToken(\"true\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\"false\", 1); t = JsonToken.VALUE_FALSE; break;"
      },
      {
        "txt": "case 'n': _matchToken(\"null\", 1); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2':"
      },
      {
        "txt": "case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default:"
      },
      {
        "txt": "t = _handleUnexpectedValue(i); } _nextToken = t; return match; } @Override public String nextTextValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false;"
      },
      {
        "txt": "JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); } return _textBuffer.contentsAsString(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; } return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; } @Override"
      },
      {
        "txt": "public int nextIntValue(int defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getIntValue(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; } @Override"
      },
      {
        "txt": "public long nextLongValue(long defaultValue) throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_NUMBER_INT) { return getLongValue(); }"
      },
      {
        "txt": "if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return defaultValue; } return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; } @Override"
      },
      {
        "txt": "public Boolean nextBooleanValue() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName' _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; }"
      },
      {
        "txt": "if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; }"
      },
      {
        "txt": "JsonToken t = nextToken(); if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } return null; } protected JsonToken _parsePosNumber(int c) throws IOException"
      },
      {
        "txt": "{ char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[0] = (char) c; int intLen = 1; int outPtr = 1; int end = _inputPtr + outBuf.length - 1; // 1 == outPtr if (end > _inputEnd) {"
      },
      {
        "txt": "end = _inputEnd; } while (true) { if (_inputPtr >= end) { // split across boundary, offline return _parseNumber2(outBuf, outPtr, false, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break; }"
      },
      {
        "txt": "++intLen; outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, false, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) { _verifyRootSpace(c);"
      },
      {
        "txt": "} return resetInt(false, intLen); } protected JsonToken _parseNegNumber() throws IOException { char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; outBuf[outPtr++] = '-'; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { return _handleInvalidNumberStart(c, true); } if (c == INT_0) { c = _verifyNoLeadingZeroes(); } outBuf[outPtr++] = (char) c; int intLen = 1;"
      },
      {
        "txt": "int end = _inputPtr + outBuf.length - outPtr; if (end > _inputEnd) { end = _inputEnd; } while (true) { if (_inputPtr >= end) { return _parseNumber2(outBuf, outPtr, true, intLen); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) {"
      },
      {
        "txt": "break; } ++intLen; outBuf[outPtr++] = (char) c; } if (c == '.' || c == 'e' || c == 'E') { return _parseFloat(outBuf, outPtr, c, true, intLen); } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr);"
      },
      {
        "txt": "if (_parsingContext.inRoot()) { _verifyRootSpace(c); } return resetInt(true, intLen); } private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException { while (true) { if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "_textBuffer.setCurrentLength(outPtr); return resetInt(negative, intPartLength); } int c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c > INT_9 || c < INT_0) { if (c == INT_PERIOD || c == INT_e || c == INT_E) { return _parseFloat(outBuf, outPtr, c, negative, intPartLength); } break; }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; ++intPartLength; } --_inputPtr; // to push back trailing char (comma etc) _textBuffer.setCurrentLength(outPtr); if (_parsingContext.inRoot()) {"
      },
      {
        "txt": "_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF); } return resetInt(negative, intPartLength); } private final int _verifyNoLeadingZeroes() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return INT_0; } int ch = _inputBuffer[_inputPtr] & 0xFF;"
      },
      {
        "txt": "if (ch < INT_0 || ch > INT_9) { return INT_0; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\"Leading zeroes not allowed\"); } ++_inputPtr; // Leading zero to be skipped if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr] & 0xFF;"
      },
      {
        "txt": "if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero return INT_0; } ++_inputPtr; // skip previous zeroes if (ch != INT_0) { // followed by other number; return break; } } } return ch;"
      },
      {
        "txt": "private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException { int fractLen = 0; boolean eof = false; if (c == INT_PERIOD) { // yes, fraction <extra_id_0> fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; }"
      },
      {
        "txt": "break fract_loop; } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} outBuf[outPtr++] = (char) c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\"); } } int expLen = 0; if (c == INT_e || c == INT_E) { // exponent? if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; if (c == '-' || c == '+') { if (outPtr >= outBuf.length) {"
      },
      {
        "txt": "outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++] & 0xFF; } exp_loop:"
      },
      {
        "txt": "while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop;"
      },
      {
        "txt": "} c = (int) _inputBuffer[_inputPtr++] & 0xFF; } if (expLen == 0) { reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) {"
      },
      {
        "txt": "_verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); return resetFloat(negative, integerPartLength, fractLen, expLen); } private final void _verifyRootSpace(int ch) throws IOException { ++_inputPtr; switch (ch) {"
      },
      {
        "txt": "case ' ': case '\\t': return; case '\\r': _skipCR(); return; case '\\n': ++_currInputRow; _currInputRowStart = _inputPtr; return;"
      },
      {
        "txt": "} _reportMissingRootWS(ch); } protected final String _parseName(int i) throws IOException { if (i != INT_QUOTE) { return _handleOddName(i); } if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote) return slowParseName();"
      },
      {
        "txt": "} final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int q = input[_inputPtr++] & 0xFF; if (codes[q] == 0) { i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) {"
      },
      {
        "txt": "q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] == 0) { _quad1 = q; return parseMediumName(i); } if (i == INT_QUOTE) { // 4 byte/char case or broken"
      },
      {
        "txt": "return findName(q, 4); } return parseName(q, i, 4); } if (i == INT_QUOTE) { // 3 byte/char case or broken return findName(q, 3); } return parseName(q, i, 3); } if (i == INT_QUOTE) { // 2 byte/char case or broken"
      },
      {
        "txt": "return findName(q, 2); } return parseName(q, i, 2); } if (i == INT_QUOTE) { // one byte/char case or broken return findName(q, 1); } return parseName(q, i, 1); } if (q == INT_QUOTE) { // special case, \"\""
      },
      {
        "txt": "return \"\"; } return parseName(0, q, 0); // quoting or invalid char } protected final String parseMediumName(int q2) throws IOException { final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) {"
      },
      {
        "txt": "if (i == INT_QUOTE) { // 5 bytes return findName(_quad1, q2, 1); } return parseName(_quad1, q2, i, 1); // quoting or invalid char } q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 6 bytes return findName(_quad1, q2, 2);"
      },
      {
        "txt": "} return parseName(_quad1, q2, i, 2); } q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 7 bytes return findName(_quad1, q2, 3); } return parseName(_quad1, q2, i, 3);"
      },
      {
        "txt": "} q2 = (q2 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 8 bytes return findName(_quad1, q2, 4); } return parseName(_quad1, q2, i, 4); } return parseMediumName2(i, q2);"
      },
      {
        "txt": "} protected final String parseMediumName2(int q3, final int q2) throws IOException { final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 9 bytes return findName(_quad1, q2, q3, 1); }"
      },
      {
        "txt": "return parseName(_quad1, q2, q3, i, 1); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 10 bytes return findName(_quad1, q2, q3, 2); } return parseName(_quad1, q2, q3, i, 2); }"
      },
      {
        "txt": "q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { // 11 bytes return findName(_quad1, q2, q3, 3); } return parseName(_quad1, q2, q3, i, 3); } q3 = (q3 << 8) | i; i = input[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "if (codes[i] != 0) { if (i == INT_QUOTE) { // 12 bytes return findName(_quad1, q2, q3, 4); } return parseName(_quad1, q2, q3, i, 4); } return parseLongName(i, q2, q3); } protected final String parseLongName(int q, final int q2, int q3) throws IOException {"
      },
      {
        "txt": "_quadBuffer[0] = _quad1; _quadBuffer[1] = q2; _quadBuffer[2] = q3; final byte[] input = _inputBuffer; final int[] codes = _icLatin1; int qlen = 3; while ((_inputPtr + 4) <= _inputEnd) { int i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) {"
      },
      {
        "txt": "return findName(_quadBuffer, qlen, q, 1); } return parseEscapedName(_quadBuffer, qlen, q, i, 1); } q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 2); }"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, qlen, q, i, 2); } q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 3); } return parseEscapedName(_quadBuffer, qlen, q, i, 3); }"
      },
      {
        "txt": "q = (q << 8) | i; i = input[_inputPtr++] & 0xFF; if (codes[i] != 0) { if (i == INT_QUOTE) { return findName(_quadBuffer, qlen, q, 4); } return parseEscapedName(_quadBuffer, qlen, q, i, 4); } if (qlen >= _quadBuffer.length) { _quadBuffer = growArrayBy(_quadBuffer, qlen);"
      },
      {
        "txt": "} _quadBuffer[qlen++] = q; q = i; } return parseEscapedName(_quadBuffer, qlen, 0, q, 0); } protected String slowParseName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing '\\\"' for name\"); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i == INT_QUOTE) { // special case, \"\" return \"\"; } return parseEscapedName(_quadBuffer, 0, 0, i, 0); } private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {"
      },
      {
        "txt": "return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes); } private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes); } private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException { _quadBuffer[0] = q1; _quadBuffer[1] = q2; return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);"
      },
      {
        "txt": "} protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException { final int[] codes = _icLatin1; while (true) { if (codes[ch] != 0) { if (ch == INT_QUOTE) { // we are done break; }"
      },
      {
        "txt": "if (ch != INT_BACKSLASH) { _throwUnquotedSpace(ch, \"name\"); } else { ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes;"
      },
      {
        "txt": "if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes;"
      },
      {
        "txt": "} ch = 0x80 | (ch & 0x3f); } } if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } }"
      },
      {
        "txt": "ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(currQuad, currQuadBytes); } String name = _symbols.findName(quads, qlen); if (name == null) {"
      },
      {
        "txt": "name = addName(quads, qlen, currQuadBytes); } return name; } protected String _handleOddName(int ch) throws IOException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {"
      },
      {
        "txt": "char c = (char) _decodeCharForError(ch); _reportUnexpectedChar(c, \"was expecting double-quote to start field name\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0;"
      },
      {
        "txt": "int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad;"
      },
      {
        "txt": "currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) {"
      },
      {
        "txt": "break; } ++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; }"
      },
      {
        "txt": "String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; } protected String _parseAposName() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOF(\": was expecting closing '\\'' for name\"); } } int ch = _inputBuffer[_inputPtr++] & 0xFF; if (ch == '\\'') { // special case, '' return \"\"; } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0;"
      },
      {
        "txt": "int currQuadBytes = 0; final int[] codes = _icLatin1; while (true) { if (ch == '\\'') { break; } if (ch != '\"' && codes[ch] != 0) { if (ch != '\\\\') { _throwUnquotedSpace(ch, \"name\"); } else {"
      },
      {
        "txt": "ch = _decodeEscaped(); } if (ch > 127) { if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0;"
      },
      {
        "txt": "} if (ch < 0x800) { // 2-byte currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); ++currQuadBytes; } else { // 3 bytes; no need to worry about surrogates here currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); ++currQuadBytes; if (currQuadBytes >= 4) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length);"
      },
      {
        "txt": "} quads[qlen++] = currQuad; currQuad = 0; currQuadBytes = 0; } currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); ++currQuadBytes; } ch = 0x80 | (ch & 0x3f); }"
      },
      {
        "txt": "} if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch;"
      },
      {
        "txt": "currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in field name\"); } } ch = _inputBuffer[_inputPtr++] & 0xFF; } if (currQuadBytes > 0) {"
      },
      {
        "txt": "if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = pad(currQuad, currQuadBytes); } String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name;"
      },
      {
        "txt": "} private final String findName(int q1, int lastQuadBytes) throws JsonParseException { q1 = pad(q1, lastQuadBytes); String name = _symbols.findName(q1); if (name != null) { return name; } _quadBuffer[0] = q1; return addName(_quadBuffer, 1, lastQuadBytes);"
      },
      {
        "txt": "} private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { q2 = pad(q2, lastQuadBytes); String name = _symbols.findName(q1, q2); if (name != null) { return name; } _quadBuffer[0] = q1; _quadBuffer[1] = q2;"
      },
      {
        "txt": "return addName(_quadBuffer, 2, lastQuadBytes); } private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException { q3 = pad(q3, lastQuadBytes); String name = _symbols.findName(q1, q2, q3); if (name != null) { return name; } int[] quads = _quadBuffer;"
      },
      {
        "txt": "quads[0] = q1; quads[1] = q2; quads[2] = pad(q3, lastQuadBytes); return addName(quads, 3, lastQuadBytes); } private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); }"
      },
      {
        "txt": "quads[qlen++] = pad(lastQuad, lastQuadBytes); String name = _symbols.findName(quads, qlen); if (name == null) { return addName(quads, qlen, lastQuadBytes); } return name; } private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { int byteLen = (qlen << 2) - 4 + lastQuadBytes;"
      },
      {
        "txt": "int lastQuad; if (lastQuadBytes < 4) { lastQuad = quads[qlen-1]; quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3)); } else { lastQuad = 0; } char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); int cix = 0; for (int ix = 0; ix < byteLen; ) {"
      },
      {
        "txt": "int ch = quads[ix >> 2]; // current quad, need to shift+mask int byteIx = (ix & 3); ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; ++ix; if (ch > 127) { // multi-byte int needed; if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) ch &= 0x1F; needed = 1; } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)"
      },
      {
        "txt": "ch &= 0x0F; needed = 2; } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all... ch &= 0x07; needed = 3; } else { // 5- and 6-byte chars not valid xml chars _reportInvalidInitial(ch); needed = ch = 1; // never really gets this far } if ((ix + needed) > byteLen) {"
      },
      {
        "txt": "_reportInvalidEOF(\" in field name\"); } int ch2 = quads[ix >> 2]; // current quad, need to shift+mask byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F);"
      },
      {
        "txt": "if (needed > 1) { ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2); } ch = (ch << 6) | (ch2 & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates on output)"
      },
      {
        "txt": "ch2 = quads[ix >> 2]; byteIx = (ix & 3); ch2 = (ch2 >> ((3 - byteIx) << 3)); ++ix; if ((ch2 & 0xC0) != 0x080) { _reportInvalidOther(ch2 & 0xFF); } ch = (ch << 6) | (ch2 & 0x3F); } }"
      },
      {
        "txt": "if (needed > 2) { // surrogate pair? once again, let's output one here, one later on ch -= 0x10000; // to normalize it starting with 0x0 if (cix >= cbuf.length) { cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) (0xD800 + (ch >> 10)); ch = 0xDC00 | (ch & 0x03FF); } } if (cix >= cbuf.length) {"
      },
      {
        "txt": "cbuf = _textBuffer.expandCurrentSegment(); } cbuf[cix++] = (char) ch; } String baseName = new String(cbuf, 0, cix); if (lastQuadBytes < 4) { quads[qlen-1] = lastQuad; } return _symbols.addName(baseName, quads, qlen); }"
      },
      {
        "txt": "@Override protected void _finishString() throws IOException { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();"
      },
      {
        "txt": "final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length)); final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; _textBuffer.setCurrentLength(outPtr); return;"
      },
      {
        "txt": "} break; } ++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); } protected String _finishAndReturnString() throws IOException"
      },
      {
        "txt": "{ int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed(); ptr = _inputPtr; } int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final int max = Math.min(_inputEnd, (ptr + outBuf.length));"
      },
      {
        "txt": "final byte[] inputBuffer = _inputBuffer; while (ptr < max) { int c = (int) inputBuffer[ptr] & 0xFF; if (codes[c] != 0) { if (c == INT_QUOTE) { _inputPtr = ptr+1; return _textBuffer.setCurrentAndReturn(outPtr); } break; }"
      },
      {
        "txt": "++ptr; outBuf[outPtr++] = (char) c; } _inputPtr = ptr; _finishString2(outBuf, outPtr); return _textBuffer.contentsAsString(); } private final void _finishString2(char[] outBuf, int outPtr) throws IOException {"
      },
      {
        "txt": "int c; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop: while (true) { int ptr = _inputPtr; if (ptr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "ptr = _inputPtr; } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) {"
      },
      {
        "txt": "_inputPtr = ptr; break ascii_loop; } outBuf[outPtr++] = (char) c; } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; }"
      },
      {
        "txt": "switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break; case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c);"
      },
      {
        "txt": "} else { c = _decodeUtf8_3(c); } break; case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0;"
      },
      {
        "txt": "} c = 0xDC00 | (c & 0x3FF); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } }"
      },
      {
        "txt": "if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c; } _textBuffer.setCurrentLength(outPtr); } protected void _skipString() throws IOException {"
      },
      {
        "txt": "_tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd;"
      },
      {
        "txt": "if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop;"
      },
      {
        "txt": "} } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch (codes[c]) { case 1: // backslash _decodeEscaped();"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(); break; case 3: // 3-byte UTF _skipUtf8_3(); break; case 4: // 4-byte UTF _skipUtf8_4(c); break;"
      },
      {
        "txt": "default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } else { _reportInvalidChar(c); } } } } protected JsonToken _handleUnexpectedValue(int c)"
      },
      {
        "txt": "throws IOException { switch (c) { case ']': case '}': _reportUnexpectedChar(c, \"expected a value\"); case '\\'': if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApos(); }"
      },
      {
        "txt": "break; case 'N': _matchToken(\"NaN\", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"NaN\", Double.NaN); } _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case 'I': _matchToken(\"Infinity\", 1);"
      },
      {
        "txt": "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); break; case '+': // note: '-' is taken as number if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); }"
      },
      {
        "txt": "} return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); } if (Character.isJavaIdentifierStart(c)) { _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\"); } _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\"); return null; } protected JsonToken _handleApos()"
      },
      {
        "txt": "throws IOException { int c = 0; int outPtr = 0; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { ascii_loop:"
      },
      {
        "txt": "while (true) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } int max = _inputEnd; {"
      },
      {
        "txt": "int max2 = _inputPtr + (outBuf.length - outPtr); if (max2 < max) { max = max2; } } while (_inputPtr < max) { c = (int) inputBuffer[_inputPtr++] & 0xFF; if (c == '\\'' || codes[c] != 0) { break ascii_loop; }"
      },
      {
        "txt": "outBuf[outPtr++] = (char) c; } } if (c == '\\'') { break main_loop; } switch (codes[c]) { case 1: // backslash c = _decodeEscaped(); break;"
      },
      {
        "txt": "case 2: // 2-byte UTF c = _decodeUtf8_2(c); break; case 3: // 3-byte UTF if ((_inputEnd - _inputPtr) >= 2) { c = _decodeUtf8_3fast(c); } else { c = _decodeUtf8_3(c); } break;"
      },
      {
        "txt": "case 4: // 4-byte UTF c = _decodeUtf8_4(c); outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } c = 0xDC00 | (c & 0x3FF); break; default:"
      },
      {
        "txt": "if (c < INT_SPACE) { _throwUnquotedSpace(c, \"string value\"); } _reportInvalidChar(c); } if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = (char) c;"
      },
      {
        "txt": "} _textBuffer.setCurrentLength(outPtr); return JsonToken.VALUE_STRING; } protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException { while (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "_reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; String match; if (ch == 'N') { match = neg ? \"-INF\" :\"+INF\"; } else if (ch == 'n') { match = neg ? \"-Infinity\" :\"+Infinity\"; } else {"
      },
      {
        "txt": "break; } _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\"); } reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\"); return null;"
      },
      {
        "txt": "} protected final void _matchToken(String matchStr, int i) throws IOException { final int len = matchStr.length(); if ((_inputPtr + len) >= _inputEnd) { _matchToken2(matchStr, i); return; } do { if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _matchToken2(String matchStr, int i) throws IOException"
      },
      {
        "txt": "{ final int len = matchStr.length(); do { if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { _reportInvalidToken(matchStr.substring(0, i)); } ++_inputPtr; } while (++i < len); if (_inputPtr >= _inputEnd && !loadMore()) {"
      },
      {
        "txt": "return; } int ch = _inputBuffer[_inputPtr] & 0xFF; if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars _checkMatchEnd(matchStr, i, ch); } } private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException { char c = (char) _decodeCharForError(ch); if (Character.isJavaIdentifierPart(c)) {"
      },
      {
        "txt": "_reportInvalidToken(matchStr.substring(0, i)); } } private final int _skipWS() throws IOException { while (_inputPtr < _inputEnd) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr;"
      },
      {
        "txt": "return _skipWS2(); } return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR();"
      },
      {
        "txt": "} else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _skipWS2(); } private final int _skipWS2() throws IOException { while (_inputPtr < _inputEnd || loadMore()) {"
      },
      {
        "txt": "int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; }"
      },
      {
        "txt": "} return i; } if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) {"
      },
      {
        "txt": "_throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final int _skipWSOrEnd() throws IOException { if (_inputPtr >= _inputEnd) { if (!loadMore()) {"
      },
      {
        "txt": "return _eofAsNextChar(); } } int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i;"
      },
      {
        "txt": "} if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); }"
      },
      {
        "txt": "} while (_inputPtr < _inputEnd) { i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { --_inputPtr; return _skipWSOrEnd2(); } return i; }"
      },
      {
        "txt": "if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } }"
      },
      {
        "txt": "} return _skipWSOrEnd2(); } private final int _skipWSOrEnd2() throws IOException { while ((_inputPtr < _inputEnd) || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) { _skipComment();"
      },
      {
        "txt": "continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } return i; } else if (i != INT_SPACE) { if (i == INT_LF) {"
      },
      {
        "txt": "++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) { _skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } return _eofAsNextChar();"
      },
      {
        "txt": "} private final int _skipColon() throws IOException { if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } int i = _inputBuffer[_inputPtr]; if (i == INT_COLON) { // common case, no leading space i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { // nor trailing"
      },
      {
        "txt": "if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) {"
      },
      {
        "txt": "return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); // true -> skipped colon } if (i == INT_SPACE || i == INT_TAB) { i = _inputBuffer[++_inputPtr];"
      },
      {
        "txt": "} if (i == INT_COLON) { i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; }"
      },
      {
        "txt": "if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } }"
      },
      {
        "txt": "return _skipColon2(true); } return _skipColon2(false); } private final int _skipColon2(boolean gotColon) throws IOException { while (_inputPtr < _inputEnd || loadMore()) { int i = _inputBuffer[_inputPtr++] & 0xFF; if (i > INT_SPACE) { if (i == INT_SLASH) {"
      },
      {
        "txt": "_skipComment(); continue; } if (i == INT_HASH) { if (_skipYAMLComment()) { continue; } } if (gotColon) { return i;"
      },
      {
        "txt": "} if (i != INT_COLON) { _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\"); } gotColon = true; } else if (i != INT_SPACE) { if (i == INT_LF) { ++_currInputRow; _currInputRowStart = _inputPtr; } else if (i == INT_CR) {"
      },
      {
        "txt": "_skipCR(); } else if (i != INT_TAB) { _throwInvalidSpace(i); } } } throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\"); } private final void _skipComment() throws IOException {"
      },
      {
        "txt": "if (!isEnabled(Feature.ALLOW_COMMENTS)) { _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\"); } if (_inputPtr >= _inputEnd && !loadMore()) { _reportInvalidEOF(\" in a comment\"); } int c = _inputBuffer[_inputPtr++] & 0xFF; if (c == '/') { _skipLine(); } else if (c == '*') {"
      },
      {
        "txt": "_skipCComment(); } else { _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\"); } } private final void _skipCComment() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); main_loop: while ((_inputPtr < _inputEnd) || loadMore()) {"
      },
      {
        "txt": "int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i]; if (code != 0) { switch (code) { case '*': if (_inputPtr >= _inputEnd && !loadMore()) { break main_loop; } if (_inputBuffer[_inputPtr] == INT_SLASH) { ++_inputPtr;"
      },
      {
        "txt": "return; } break; case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; break; case INT_CR: _skipCR(); break;"
      },
      {
        "txt": "case 2: // 2-byte UTF _skipUtf8_2(); break; case 3: // 3-byte UTF _skipUtf8_3(); break; case 4: // 4-byte UTF _skipUtf8_4(i); break; default: // e.g. -1"
      },
      {
        "txt": "_reportInvalidChar(i); } } } _reportInvalidEOF(\" in a comment\"); } private final boolean _skipYAMLComment() throws IOException { if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) { return false;"
      },
      {
        "txt": "} _skipLine(); return true; } private final void _skipLine() throws IOException { final int[] codes = CharTypes.getInputCodeComment(); while ((_inputPtr < _inputEnd) || loadMore()) { int i = (int) _inputBuffer[_inputPtr++] & 0xFF; int code = codes[i];"
      },
      {
        "txt": "if (code != 0) { switch (code) { case INT_LF: ++_currInputRow; _currInputRowStart = _inputPtr; return; case INT_CR: _skipCR(); return; case '*': // nop for these comments"
      },
      {
        "txt": "break; case 2: // 2-byte UTF _skipUtf8_2(); break; case 3: // 3-byte UTF _skipUtf8_3(); break; case 4: // 4-byte UTF _skipUtf8_4(i); break;"
      },
      {
        "txt": "default: // e.g. -1 if (code < 0) { _reportInvalidChar(i); } } } } } @Override protected char _decodeEscaped() throws IOException"
      },
      {
        "txt": "{ if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int c = (int) _inputBuffer[_inputPtr++]; switch (c) { case 'b': return '\\b';"
      },
      {
        "txt": "case 't': return '\\t'; case 'n': return '\\n'; case 'f': return '\\f'; case 'r': return '\\r'; case '\"': case '/':"
      },
      {
        "txt": "case '\\\\': return (char) c; case 'u': // and finally hex-escaped break; default: return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); } int value = 0; for (int i = 0; i < 4; ++i) { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "if (!loadMore()) { _reportInvalidEOF(\" in character escape sequence\"); } } int ch = (int) _inputBuffer[_inputPtr++]; int digit = CharTypes.charToHex(ch); if (digit < 0) { _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\"); } value = (value << 4) | digit;"
      },
      {
        "txt": "} return (char) value; } protected int _decodeCharForError(int firstByte) throws IOException { int c = firstByte & 0xFF; if (c > 0x7F) { // if >= 0, is ascii and fine as is int needed; if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) c &= 0x1F;"
      },
      {
        "txt": "needed = 1; } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) c &= 0x0F; needed = 2; } else if ((c & 0xF8) == 0xF0) { c &= 0x07; needed = 3; } else { _reportInvalidInitial(c & 0xFF); needed = 1; // never gets here"
      },
      {
        "txt": "} int d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); if (needed > 1) { // needed == 1 means 2 bytes total d = nextByte(); // 3rd byte if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF);"
      },
      {
        "txt": "} c = (c << 6) | (d & 0x3F); if (needed > 2) { // 4 bytes? (need surrogates) d = nextByte(); if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF); } c = (c << 6) | (d & 0x3F); } }"
      },
      {
        "txt": "} return c; } private final int _decodeUtf8_2(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF, _inputPtr); } return ((c & 0x1F) << 6) | (d & 0x3F); } private final int _decodeUtf8_3(int c1) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c1 &= 0x0F;"
      },
      {
        "txt": "int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; } private final int _decodeUtf8_3fast(int c1) throws IOException { c1 &= 0x0F; int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) {"
      },
      {
        "txt": "_reportInvalidOther(d & 0xFF, _inputPtr); } int c = (c1 << 6) | (d & 0x3F); d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); return c; }"
      },
      {
        "txt": "private final int _decodeUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = ((c & 0x07) << 6) | (d & 0x3F);"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } c = (c << 6) | (d & 0x3F); if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } return ((c << 6) | (d & 0x3F)) - 0x10000; } private final void _skipUtf8_2() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_3() throws IOException { if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } int c = (int) _inputBuffer[_inputPtr++]; if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } c = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((c & 0xC0) != 0x080) { _reportInvalidOther(c & 0xFF, _inputPtr); } } private final void _skipUtf8_4(int c) throws IOException { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } int d = (int) _inputBuffer[_inputPtr++];"
      },
      {
        "txt": "if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); }"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } d = (int) _inputBuffer[_inputPtr++]; if ((d & 0xC0) != 0x080) { _reportInvalidOther(d & 0xFF, _inputPtr); } } protected final void _skipCR() throws IOException {"
      },
      {
        "txt": "if (_inputPtr < _inputEnd || loadMore()) { if (_inputBuffer[_inputPtr] == BYTE_LF) { ++_inputPtr; } } ++_currInputRow; _currInputRowStart = _inputPtr; } private int nextByte() throws IOException {"
      },
      {
        "txt": "if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } return _inputBuffer[_inputPtr++] & 0xFF; } protected void _reportInvalidToken(String matchedPart) throws IOException { _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\"); } protected void _reportInvalidToken(String matchedPart, String msg) throws IOException"
      },
      {
        "txt": "{ StringBuilder sb = new StringBuilder(matchedPart); while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { break; } int i = (int) _inputBuffer[_inputPtr++]; char c = (char) _decodeCharForError(i); if (!Character.isJavaIdentifierPart(c)) { break;"
      },
      {
        "txt": "} sb.append(c); } _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg); } protected void _reportInvalidChar(int c) throws JsonParseException { if (c < INT_SPACE) { _throwInvalidSpace(c);"
      },
      {
        "txt": "} _reportInvalidInitial(c); } protected void _reportInvalidInitial(int mask) throws JsonParseException { _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask) throws JsonParseException"
      },
      {
        "txt": "{ _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask)); } protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { _inputPtr = ptr; _reportInvalidOther(mask); } public static int[] growArrayBy(int[] arr, int more)"
      },
      {
        "txt": "{ if (arr == null) { return new int[more]; } return Arrays.copyOf(arr, arr.length + more); } @SuppressWarnings(\"resource\") protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder();"
      },
      {
        "txt": "while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { // reached the end, fair and square?"
      },
      {
        "txt": "if (ch == INT_QUOTE) { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { // white space to skip continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) {"
      },
      {
        "txt": "loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed();"
      },
      {
        "txt": "} ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); }"
      },
      {
        "txt": "bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\"); }"
      },
      {
        "txt": "decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF;"
      },
      {
        "txt": "bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); }"
      },
      {
        "txt": "if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } }"
      },
      {
        "txt": "@Override public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) { long total = _currInputProcessed + (_nameStartOffset-1); return new JsonLocation(src, total, -1L, _nameStartRow, _nameStartCol); } return new JsonLocation(src,"
      },
      {
        "txt": "_tokenInputTotal-1, -1L, _tokenInputRow, _tokenInputCol); } @Override public JsonLocation getCurrentLocation() { int col = _inputPtr - _currInputRowStart + 1; // 1-based return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr, -1L, // bytes, chars _currInputRow, col); }"
      },
      {
        "txt": "private final void _updateLocation() { _tokenInputRow = _currInputRow; final int ptr = _inputPtr; _tokenInputTotal = _currInputProcessed + ptr; _tokenInputCol = ptr - _currInputRowStart; } private final void _updateNameLocation() { _nameStartRow = _currInputRow;"
      },
      {
        "txt": "final int ptr = _inputPtr; _nameStartOffset = ptr; _nameStartCol = ptr - _currInputRowStart; } private final static int pad(int q, int bytes) { return (bytes == 4) ? q : (q | (-1 << (bytes << 3))); }"
      }
    ]
  }
]