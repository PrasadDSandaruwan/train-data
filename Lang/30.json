[
  {
    "id": 2342,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1376,
    "end-bug-line": 1376,
    "bug": "",
    "fix": "int csLast = csLen - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super();"
      },
      {
        "txt": "} public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) {"
      },
      {
        "txt": "return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) {"
      },
      {
        "txt": "return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) {"
      },
      {
        "txt": "return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null);"
      },
      {
        "txt": "return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars);"
      },
      {
        "txt": "return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {"
      },
      {
        "txt": "start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start);"
      },
      {
        "txt": "} public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; }"
      },
      {
        "txt": "} else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) {"
      },
      {
        "txt": "return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars);"
      },
      {
        "txt": "} return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);"
      },
      {
        "txt": "Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);"
      },
      {
        "txt": "} catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);"
      },
      {
        "txt": "} } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);"
      },
      {
        "txt": "} public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1);"
      },
      {
        "txt": "} else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index; }"
      },
      {
        "txt": "public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; }"
      },
      {
        "txt": "int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i;"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos);"
      },
      {
        "txt": "} public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; }"
      },
      {
        "txt": "for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false;"
      },
      {
        "txt": "} return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } }"
      },
      {
        "txt": "} public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); <extra_id_0> for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; }"
      },
      {
        "txt": "return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1;"
      },
      {
        "txt": "for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true;"
      },
      {
        "txt": "} } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }"
      },
      {
        "txt": "return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; }"
      },
      {
        "txt": "if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray());"
      },
      {
        "txt": "} public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) {"
      },
      {
        "txt": "if (searchChars[j] == ch) { return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true;"
      },
      {
        "txt": "} return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) {"
      },
      {
        "txt": "ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length;"
      },
      {
        "txt": "int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp;"
      },
      {
        "txt": "} } return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative"
      },
      {
        "txt": "} if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) {"
      },
      {
        "txt": "if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) {"
      },
      {
        "txt": "end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0;"
      },
      {
        "txt": "} return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; }"
      },
      {
        "txt": "if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) {"
      },
      {
        "txt": "return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null;"
      },
      {
        "txt": "} if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); }"
      },
      {
        "txt": "return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator);"
      },
      {
        "txt": "if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) {"
      },
      {
        "txt": "return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) {"
      },
      {
        "txt": "return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length());"
      },
      {
        "txt": "} public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null;"
      },
      {
        "txt": "} int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) {"
      },
      {
        "txt": "int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end));"
      },
      {
        "txt": "pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); }"
      },
      {
        "txt": "public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) {"
      },
      {
        "txt": "return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true);"
      },
      {
        "txt": "} private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) {"
      },
      {
        "txt": "end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength;"
      },
      {
        "txt": "} } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); }"
      },
      {
        "txt": "} beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; }"
      },
      {
        "txt": "int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); }"
      },
      {
        "txt": "public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; }"
      },
      {
        "txt": "if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) {"
      },
      {
        "txt": "continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart));"
      },
      {
        "txt": "tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); }"
      },
      {
        "txt": "public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; }"
      },
      {
        "txt": "int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); }"
      },
      {
        "txt": "if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; }"
      },
      {
        "txt": "return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex);"
      },
      {
        "txt": "if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); }"
      },
      {
        "txt": "if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; }"
      },
      {
        "txt": "if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first);"
      },
      {
        "txt": "} while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); }"
      },
      {
        "txt": "public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first);"
      },
      {
        "txt": "} StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next();"
      },
      {
        "txt": "if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; }"
      },
      {
        "txt": "return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } }"
      },
      {
        "txt": "if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){"
      },
      {
        "txt": "return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length());"
      },
      {
        "txt": "} return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str;"
      },
      {
        "txt": "} public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); }"
      },
      {
        "txt": "public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; }"
      },
      {
        "txt": "int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase);"
      },
      {
        "txt": "while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString();"
      },
      {
        "txt": "} public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)"
      },
      {
        "txt": "{ if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length;"
      },
      {
        "txt": "int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1;"
      },
      {
        "txt": "int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true;"
      },
      {
        "txt": "} else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; }"
      },
      {
        "txt": "int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches }"
      },
      {
        "txt": "} increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1;"
      },
      {
        "txt": "replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) {"
      },
      {
        "txt": "noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length();"
      },
      {
        "txt": "for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) {"
      },
      {
        "txt": "replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) {"
      },
      {
        "txt": "modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString();"
      },
      {
        "txt": "} return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; }"
      },
      {
        "txt": "int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; }"
      },
      {
        "txt": "if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start))"
      },
      {
        "txt": ".append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0);"
      },
      {
        "txt": "if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--;"
      },
      {
        "txt": "} } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; }"
      },
      {
        "txt": "if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length();"
      },
      {
        "txt": "if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); }"
      },
      {
        "txt": "} return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; }"
      },
      {
        "txt": "int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 :"
      },
      {
        "txt": "char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength];"
      },
      {
        "txt": "for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); }"
      },
      {
        "txt": "return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); }"
      },
      {
        "txt": "} private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf);"
      },
      {
        "txt": "} public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null;"
      },
      {
        "txt": "} if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray();"
      },
      {
        "txt": "for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) {"
      },
      {
        "txt": "if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); }"
      },
      {
        "txt": "return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length();"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str);"
      },
      {
        "txt": "} else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); }"
      },
      {
        "txt": "} public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str;"
      },
      {
        "txt": "} int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; }"
      },
      {
        "txt": "public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) {"
      },
      {
        "txt": "return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); }"
      },
      {
        "txt": "public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0)))"
      },
      {
        "txt": ".append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString();"
      },
      {
        "txt": "} return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str;"
      },
      {
        "txt": "} StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) {"
      },
      {
        "txt": "ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; }"
      },
      {
        "txt": "int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str;"
      },
      {
        "txt": "} public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar);"
      },
      {
        "txt": "} public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");"
      },
      {
        "txt": "} if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); }"
      },
      {
        "txt": "final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); }"
      },
      {
        "txt": "return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length();"
      },
      {
        "txt": "int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) {"
      },
      {
        "txt": "return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at);"
      },
      {
        "txt": "} public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {"
      },
      {
        "txt": "if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) {"
      },
      {
        "txt": "if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) {"
      },
      {
        "txt": "anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos;"
      },
      {
        "txt": "break; } } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; }"
      },
      {
        "txt": "return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY;"
      },
      {
        "txt": "} return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left"
      },
      {
        "txt": "of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) {"
      },
      {
        "txt": "return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally"
      },
      {
        "txt": "int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) {"
      },
      {
        "txt": "t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; }"
      },
      {
        "txt": "return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a;"
      },
      {
        "txt": "} public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null);"
      },
      {
        "txt": "} if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; }"
      },
      {
        "txt": "for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false);"
      },
      {
        "txt": "} public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false;"
      },
      {
        "txt": "} int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2343,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1377,
    "end-bug-line": 1377,
    "bug": "",
    "fix": "int searchLast = searchLen - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); }"
      },
      {
        "txt": "public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true;"
      },
      {
        "txt": "} for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs);"
      },
      {
        "txt": "} public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim();"
      },
      {
        "txt": "} public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str;"
      },
      {
        "txt": "} public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars);"
      },
      {
        "txt": "} public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++;"
      },
      {
        "txt": "} } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); }"
      },
      {
        "txt": "public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) {"
      },
      {
        "txt": "return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null);"
      },
      {
        "txt": "} public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); }"
      },
      {
        "txt": "return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);"
      },
      {
        "txt": "java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) {"
      },
      {
        "txt": "throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); }"
      },
      {
        "txt": "} else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); }"
      },
      {
        "txt": "public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else {"
      },
      {
        "txt": "index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1;"
      },
      {
        "txt": "if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr);"
      },
      {
        "txt": "} public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); }"
      },
      {
        "txt": "public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; }"
      },
      {
        "txt": "return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; <extra_id_0> char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } }"
      },
      {
        "txt": "} } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray());"
      },
      {
        "txt": "} public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; }"
      },
      {
        "txt": "} } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray());"
      },
      {
        "txt": "} public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i);"
      },
      {
        "txt": "for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) {"
      },
      {
        "txt": "return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); }"
      },
      {
        "txt": "public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; }"
      },
      {
        "txt": "return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp;"
      },
      {
        "txt": "} } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND;"
      },
      {
        "txt": "int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; }"
      },
      {
        "txt": "} return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative }"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) {"
      },
      {
        "txt": "return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length();"
      },
      {
        "txt": "} if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; }"
      },
      {
        "txt": "return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) {"
      },
      {
        "txt": "return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY;"
      },
      {
        "txt": "} if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len);"
      },
      {
        "txt": "} public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY;"
      },
      {
        "txt": "} int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str;"
      },
      {
        "txt": "} int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); }"
      },
      {
        "txt": "public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length());"
      },
      {
        "txt": "if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; }"
      },
      {
        "txt": "int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos);"
      },
      {
        "txt": "if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen;"
      },
      {
        "txt": "} if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) {"
      },
      {
        "txt": "return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ;"
      },
      {
        "txt": "} public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); }"
      },
      {
        "txt": "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg);"
      },
      {
        "txt": "if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; }"
      },
      {
        "txt": "} else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } }"
      },
      {
        "txt": "beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) {"
      },
      {
        "txt": "return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length();"
      },
      {
        "txt": "if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) {"
      },
      {
        "txt": "return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue;"
      },
      {
        "txt": "} if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos;"
      },
      {
        "txt": "} currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) {"
      },
      {
        "txt": "if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex);"
      },
      {
        "txt": "if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) {"
      },
      {
        "txt": "buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length);"
      },
      {
        "txt": "} public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) {"
      },
      {
        "txt": "return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) {"
      },
      {
        "txt": "buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) {"
      },
      {
        "txt": "return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); }"
      },
      {
        "txt": "while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) {"
      },
      {
        "txt": "if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); }"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) {"
      },
      {
        "txt": "buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator);"
      },
      {
        "txt": "} public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) {"
      },
      {
        "txt": "return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length());"
      },
      {
        "txt": "} return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; }"
      },
      {
        "txt": "public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; }"
      },
      {
        "txt": "char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) {"
      },
      {
        "txt": "return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0;"
      },
      {
        "txt": "int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); }"
      },
      {
        "txt": "public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {"
      },
      {
        "txt": "if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length;"
      },
      {
        "txt": "if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1;"
      },
      {
        "txt": "for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else {"
      },
      {
        "txt": "if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0;"
      },
      {
        "txt": "int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } }"
      },
      {
        "txt": "increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1;"
      },
      {
        "txt": "tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true;"
      },
      {
        "txt": "} else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) {"
      },
      {
        "txt": "buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY;"
      },
      {
        "txt": "} boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true;"
      },
      {
        "txt": "if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString(); }"
      },
      {
        "txt": "return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length();"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) {"
      },
      {
        "txt": "end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay)"
      },
      {
        "txt": ".append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) {"
      },
      {
        "txt": "return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; }"
      },
      {
        "txt": "} else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) {"
      },
      {
        "txt": "return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) {"
      },
      {
        "txt": "return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } }"
      },
      {
        "txt": "return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length();"
      },
      {
        "txt": "if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0);"
      },
      {
        "txt": "char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) {"
      },
      {
        "txt": "output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString();"
      },
      {
        "txt": "} } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } }"
      },
      {
        "txt": "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); }"
      },
      {
        "txt": "public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; }"
      },
      {
        "txt": "if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) {"
      },
      {
        "txt": "return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) {"
      },
      {
        "txt": "padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) {"
      },
      {
        "txt": "return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str);"
      },
      {
        "txt": "} public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) {"
      },
      {
        "txt": "return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } }"
      },
      {
        "txt": "public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; }"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) {"
      },
      {
        "txt": "if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str;"
      },
      {
        "txt": "} str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase();"
      },
      {
        "txt": "} public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1))"
      },
      {
        "txt": ".toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); }"
      },
      {
        "txt": "return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; }"
      },
      {
        "txt": "StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch);"
      },
      {
        "txt": "} buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0;"
      },
      {
        "txt": "int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; }"
      },
      {
        "txt": "public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); }"
      },
      {
        "txt": "public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); }"
      },
      {
        "txt": "if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\";"
      },
      {
        "txt": "if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3));"
      },
      {
        "txt": "} public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2;"
      },
      {
        "txt": "int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2;"
      },
      {
        "txt": "} if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); }"
      },
      {
        "txt": "public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) {"
      },
      {
        "txt": "break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true;"
      },
      {
        "txt": "shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break;"
      },
      {
        "txt": "} } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff;"
      },
      {
        "txt": "} public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; }"
      },
      {
        "txt": "return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\");"
      },
      {
        "txt": "} The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really"
      },
      {
        "txt": "copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n;"
      },
      {
        "txt": "} if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally"
      },
      {
        "txt": "int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1);"
      },
      {
        "txt": "d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n];"
      },
      {
        "txt": "} private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; }"
      },
      {
        "txt": "public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); }"
      },
      {
        "txt": "if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) {"
      },
      {
        "txt": "String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); }"
      },
      {
        "txt": "public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; }"
      },
      {
        "txt": "int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2344,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1381,
    "end-bug-line": 1381,
    "bug": "",
    "fix": "if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils {"
      },
      {
        "txt": "public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) {"
      },
      {
        "txt": "return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); }"
      },
      {
        "txt": "public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); }"
      },
      {
        "txt": "public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); }"
      },
      {
        "txt": "public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) {"
      },
      {
        "txt": "return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else {"
      },
      {
        "txt": "while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str;"
      },
      {
        "txt": "} if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--;"
      },
      {
        "txt": "} } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) {"
      },
      {
        "txt": "return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) {"
      },
      {
        "txt": "return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");"
      },
      {
        "txt": "return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } }"
      },
      {
        "txt": "public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); }"
      },
      {
        "txt": "public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; }"
      },
      {
        "txt": "int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index;"
      },
      {
        "txt": "} found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) {"
      },
      {
        "txt": "return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos);"
      },
      {
        "txt": "} public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len;"
      },
      {
        "txt": "for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { <extra_id_0> return i; } } } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; } } } }"
      },
      {
        "txt": "return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer;"
      },
      {
        "txt": "} } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) {"
      },
      {
        "txt": "if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true;"
      },
      {
        "txt": "} int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } }"
      },
      {
        "txt": "} return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) {"
      },
      {
        "txt": "if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue;"
      },
      {
        "txt": "} tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;"
      },
      {
        "txt": "} public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i];"
      },
      {
        "txt": "if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; }"
      },
      {
        "txt": "public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; }"
      },
      {
        "txt": "if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) {"
      },
      {
        "txt": "end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY;"
      },
      {
        "txt": "} if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) {"
      },
      {
        "txt": "if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len);"
      },
      {
        "txt": "} public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str;"
      },
      {
        "txt": "} return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; }"
      },
      {
        "txt": "if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) {"
      },
      {
        "txt": "return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos);"
      },
      {
        "txt": "} public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY;"
      },
      {
        "txt": "} int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); }"
      },
      {
        "txt": "public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); }"
      },
      {
        "txt": "} return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; }"
      },
      {
        "txt": "start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null;"
      },
      {
        "txt": "} return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false);"
      },
      {
        "txt": "} public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {"
      },
      {
        "txt": "if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); }"
      },
      {
        "txt": "int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1;"
      },
      {
        "txt": "if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1;"
      },
      {
        "txt": "if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else {"
      },
      {
        "txt": "substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) {"
      },
      {
        "txt": "return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i));"
      },
      {
        "txt": "} return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {"
      },
      {
        "txt": "if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0;"
      },
      {
        "txt": "boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false;"
      },
      {
        "txt": "} list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false;"
      },
      {
        "txt": "} list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) {"
      },
      {
        "txt": "return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray();"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1;"
      },
      {
        "txt": "if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; }"
      },
      {
        "txt": "list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; }"
      },
      {
        "txt": "return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; }"
      },
      {
        "txt": "bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) {"
      },
      {
        "txt": "return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())"
      },
      {
        "txt": "+ separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next();"
      },
      {
        "txt": "if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next();"
      },
      {
        "txt": "if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; }"
      },
      {
        "txt": "if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first);"
      },
      {
        "txt": "} while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) {"
      },
      {
        "txt": "return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz];"
      },
      {
        "txt": "int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count);"
      },
      {
        "txt": "} public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; }"
      },
      {
        "txt": "public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) {"
      },
      {
        "txt": "if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) {"
      },
      {
        "txt": "return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text;"
      },
      {
        "txt": "} int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) {"
      },
      {
        "txt": "break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); }"
      },
      {
        "txt": "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {"
      },
      {
        "txt": "return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength"
      },
      {
        "txt": "+ \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null)"
      },
      {
        "txt": "{ continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i;"
      },
      {
        "txt": "} } } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) {"
      },
      {
        "txt": "continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) {"
      },
      {
        "txt": "for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||"
      },
      {
        "txt": "searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex;"
      },
      {
        "txt": "replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString();"
      },
      {
        "txt": "if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar);"
      },
      {
        "txt": "} public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length();"
      },
      {
        "txt": "int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); }"
      },
      {
        "txt": "} else { buf.append(ch); } } if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) {"
      },
      {
        "txt": "if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; }"
      },
      {
        "txt": "if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) {"
      },
      {
        "txt": "int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); }"
      },
      {
        "txt": "public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str;"
      },
      {
        "txt": "} int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; }"
      },
      {
        "txt": "return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str;"
      },
      {
        "txt": "} public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1;"
      },
      {
        "txt": "String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) {"
      },
      {
        "txt": "if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; }"
      },
      {
        "txt": "if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch;"
      },
      {
        "txt": "} return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; }"
      },
      {
        "txt": "return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) {"
      },
      {
        "txt": "if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);"
      },
      {
        "txt": "} final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); }"
      },
      {
        "txt": "public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar));"
      },
      {
        "txt": "} return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; }"
      },
      {
        "txt": "int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) {"
      },
      {
        "txt": "return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding));"
      },
      {
        "txt": "} } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length();"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) {"
      },
      {
        "txt": "return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads];"
      },
      {
        "txt": "char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); }"
      },
      {
        "txt": "public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) {"
      },
      {
        "txt": "return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; }"
      },
      {
        "txt": "if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr);"
      },
      {
        "txt": "return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); }"
      },
      {
        "txt": "public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; }"
      },
      {
        "txt": "int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1))"
      },
      {
        "txt": ".toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) {"
      },
      {
        "txt": "ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); }"
      },
      {
        "txt": "return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++;"
      },
      {
        "txt": "idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; }"
      },
      {
        "txt": "public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) {"
      },
      {
        "txt": "if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); }"
      },
      {
        "txt": "public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; }"
      },
      {
        "txt": "if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; }"
      },
      {
        "txt": "if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) {"
      },
      {
        "txt": "return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset));"
      },
      {
        "txt": "builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1;"
      },
      {
        "txt": "} int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } }"
      },
      {
        "txt": "if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false;"
      },
      {
        "txt": "boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false;"
      },
      {
        "txt": "shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; }"
      },
      {
        "txt": "int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) {"
      },
      {
        "txt": "break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) {"
      },
      {
        "txt": "return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY;"
      },
      {
        "txt": "} else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1,"
      },
      {
        "txt": "we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not"
      },
      {
        "txt": "cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s;"
      },
      {
        "txt": "s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t"
      },
      {
        "txt": "char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1;"
      },
      {
        "txt": "d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) {"
      },
      {
        "txt": "a = b; } if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); }"
      },
      {
        "txt": "public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; }"
      },
      {
        "txt": "return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true;"
      },
      {
        "txt": "} } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); }"
      },
      {
        "txt": "private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2345,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1382,
    "end-bug-line": 1382,
    "bug": "",
    "fix": "if (searchChars[j + 1] == cs.charAt(i + 1)) { return i; } } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils {"
      },
      {
        "txt": "public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) {"
      },
      {
        "txt": "return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); }"
      },
      {
        "txt": "public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); }"
      },
      {
        "txt": "public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); }"
      },
      {
        "txt": "public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) {"
      },
      {
        "txt": "return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else {"
      },
      {
        "txt": "while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str;"
      },
      {
        "txt": "} if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--;"
      },
      {
        "txt": "} } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) {"
      },
      {
        "txt": "return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) {"
      },
      {
        "txt": "return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");"
      },
      {
        "txt": "return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) {"
      },
      {
        "txt": "throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } }"
      },
      {
        "txt": "public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); }"
      },
      {
        "txt": "public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; }"
      },
      {
        "txt": "int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index;"
      },
      {
        "txt": "} found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) {"
      },
      {
        "txt": "return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos);"
      },
      {
        "txt": "} public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len;"
      },
      {
        "txt": "for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { <extra_id_0> } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) {"
      },
      {
        "txt": "} public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false;"
      },
      {
        "txt": "} int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {"
      },
      {
        "txt": "if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; } } } } return false;"
      },
      {
        "txt": "} public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; }"
      },
      {
        "txt": "} return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length();"
      },
      {
        "txt": "for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) {"
      },
      {
        "txt": "return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; }"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } } }"
      },
      {
        "txt": "return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; }"
      },
      {
        "txt": "tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; }"
      },
      {
        "txt": "public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) {"
      },
      {
        "txt": "continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) {"
      },
      {
        "txt": "if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative"
      },
      {
        "txt": "} if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; }"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); }"
      },
      {
        "txt": "public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; }"
      },
      {
        "txt": "return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) {"
      },
      {
        "txt": "pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str;"
      },
      {
        "txt": "} if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); }"
      },
      {
        "txt": "public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY;"
      },
      {
        "txt": "} return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) {"
      },
      {
        "txt": "if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } }"
      },
      {
        "txt": "return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen;"
      },
      {
        "txt": "int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; }"
      },
      {
        "txt": "return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false);"
      },
      {
        "txt": "} public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); }"
      },
      {
        "txt": "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length();"
      },
      {
        "txt": "ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) {"
      },
      {
        "txt": "end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) {"
      },
      {
        "txt": "end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg));"
      },
      {
        "txt": "end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true);"
      },
      {
        "txt": "} private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); }"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false;"
      },
      {
        "txt": "boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } }"
      },
      {
        "txt": "if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true);"
      },
      {
        "txt": "} private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) {"
      },
      {
        "txt": "list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart));"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length);"
      },
      {
        "txt": "} public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null;"
      },
      {
        "txt": "} if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) {"
      },
      {
        "txt": "return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) {"
      },
      {
        "txt": "buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) {"
      },
      {
        "txt": "return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); }"
      },
      {
        "txt": "while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null;"
      },
      {
        "txt": "} return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count); }"
      },
      {
        "txt": "public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) {"
      },
      {
        "txt": "chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1);"
      },
      {
        "txt": "} public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; }"
      },
      {
        "txt": "int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break;"
      },
      {
        "txt": "} end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {"
      },
      {
        "txt": "int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text;"
      },
      {
        "txt": "} if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \""
      },
      {
        "txt": "+ replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {"
      },
      {
        "txt": "continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; }"
      },
      {
        "txt": "} } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue;"
      },
      {
        "txt": "} int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) {"
      },
      {
        "txt": "buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null)"
      },
      {
        "txt": "{ continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i;"
      },
      {
        "txt": "} } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) {"
      },
      {
        "txt": "return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); }"
      },
      {
        "txt": "public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length();"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else {"
      },
      {
        "txt": "buf.append(ch); } } if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) {"
      },
      {
        "txt": "return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) {"
      },
      {
        "txt": "start = len; } if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start;"
      },
      {
        "txt": "start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; }"
      },
      {
        "txt": "int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx);"
      },
      {
        "txt": "} public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; }"
      },
      {
        "txt": "public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx);"
      },
      {
        "txt": "char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) {"
      },
      {
        "txt": "return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) {"
      },
      {
        "txt": "return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; }"
      },
      {
        "txt": "return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2);"
      },
      {
        "txt": "default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) {"
      },
      {
        "txt": "return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); }"
      },
      {
        "txt": "final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) {"
      },
      {
        "txt": "if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); }"
      },
      {
        "txt": "return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length();"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr);"
      },
      {
        "txt": "} else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); }"
      },
      {
        "txt": "} public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null;"
      },
      {
        "txt": "} if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray();"
      },
      {
        "txt": "for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) {"
      },
      {
        "txt": "return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str;"
      },
      {
        "txt": "} str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str;"
      },
      {
        "txt": "} public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen;"
      },
      {
        "txt": "if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) {"
      },
      {
        "txt": "return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString();"
      },
      {
        "txt": "} public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i);"
      },
      {
        "txt": "if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString();"
      },
      {
        "txt": "} public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length();"
      },
      {
        "txt": "} return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {"
      },
      {
        "txt": "return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) {"
      },
      {
        "txt": "return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) {"
      },
      {
        "txt": "if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) {"
      },
      {
        "txt": "offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str;"
      },
      {
        "txt": "} if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle);"
      },
      {
        "txt": "builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; }"
      },
      {
        "txt": "int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) {"
      },
      {
        "txt": "return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true;"
      },
      {
        "txt": "int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen);"
      },
      {
        "txt": "longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1;"
      },
      {
        "txt": "for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break;"
      },
      {
        "txt": "} } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY;"
      },
      {
        "txt": "} int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else {"
      },
      {
        "txt": "return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d,"
      },
      {
        "txt": "is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings."
      },
      {
        "txt": "int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t;"
      },
      {
        "txt": "t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t"
      },
      {
        "txt": "int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost);"
      },
      {
        "txt": "} _d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b;"
      },
      {
        "txt": "} if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) {"
      },
      {
        "txt": "return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());"
      },
      {
        "txt": "} public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; }"
      },
      {
        "txt": "} return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) {"
      },
      {
        "txt": "if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2346,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1383,
    "end-bug-line": 1383,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\";"
      },
      {
        "txt": "public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs);"
      },
      {
        "txt": "} public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) {"
      },
      {
        "txt": "String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str;"
      },
      {
        "txt": "} int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {"
      },
      {
        "txt": "start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; }"
      },
      {
        "txt": "if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; }"
      },
      {
        "txt": "} return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs;"
      },
      {
        "txt": "} String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null;"
      },
      {
        "txt": "} if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\");"
      },
      {
        "txt": "} catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);"
      },
      {
        "txt": "} catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) {"
      },
      {
        "txt": "return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar);"
      },
      {
        "txt": "} public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) {"
      },
      {
        "txt": "return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0;"
      },
      {
        "txt": "int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; }"
      },
      {
        "txt": "found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos;"
      },
      {
        "txt": "} for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length());"
      },
      {
        "txt": "} public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false;"
      },
      {
        "txt": "} return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; <extra_id_0> } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) {"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; }"
      },
      {
        "txt": "int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) {"
      },
      {
        "txt": "return true; } } else { return true; } } } } return false; }"
      },
      {
        "txt": "public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } }"
      },
      {
        "txt": "return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) {"
      },
      {
        "txt": "char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false;"
      },
      {
        "txt": "} if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) {"
      },
      {
        "txt": "if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length();"
      },
      {
        "txt": "int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } } } return true;"
      },
      {
        "txt": "} public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search);"
      },
      {
        "txt": "if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) {"
      },
      {
        "txt": "if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue;"
      },
      {
        "txt": "} tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) { if (str == null) {"
      },
      {
        "txt": "return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY;"
      },
      {
        "txt": "} return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative }"
      },
      {
        "txt": "if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null;"
      },
      {
        "txt": "} if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) {"
      },
      {
        "txt": "if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len);"
      },
      {
        "txt": "} public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0;"
      },
      {
        "txt": "} if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; }"
      },
      {
        "txt": "if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; }"
      },
      {
        "txt": "return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; }"
      },
      {
        "txt": "return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator);"
      },
      {
        "txt": "if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) {"
      },
      {
        "txt": "return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null;"
      },
      {
        "txt": "} public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length();"
      },
      {
        "txt": "int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start);"
      },
      {
        "txt": "if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]);"
      },
      {
        "txt": "} public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); }"
      },
      {
        "txt": "public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {"
      },
      {
        "txt": "return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null;"
      },
      {
        "txt": "} int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>();"
      },
      {
        "txt": "int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len;"
      },
      {
        "txt": "substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len;"
      },
      {
        "txt": "substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len;"
      },
      {
        "txt": "} } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); }"
      },
      {
        "txt": "private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0;"
      },
      {
        "txt": "boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i;"
      },
      {
        "txt": "continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null;"
      },
      {
        "txt": "} int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false;"
      },
      {
        "txt": "if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) {"
      },
      {
        "txt": "char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } } else {"
      },
      {
        "txt": "while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) {"
      },
      {
        "txt": "list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); }"
      },
      {
        "txt": "private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0;"
      },
      {
        "txt": "int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart));"
      },
      {
        "txt": "tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]);"
      },
      {
        "txt": "} public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); }"
      },
      {
        "txt": "public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize);"
      },
      {
        "txt": "for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); }"
      },
      {
        "txt": "public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; }"
      },
      {
        "txt": "if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize);"
      },
      {
        "txt": "for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); }"
      },
      {
        "txt": "public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first);"
      },
      {
        "txt": "} StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY;"
      },
      {
        "txt": "} Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) {"
      },
      {
        "txt": "if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); }"
      },
      {
        "txt": "public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; }"
      },
      {
        "txt": "return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1);"
      },
      {
        "txt": "} public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i];"
      },
      {
        "txt": "} } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); }"
      },
      {
        "txt": "public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length();"
      },
      {
        "txt": "int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; }"
      },
      {
        "txt": "end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length;"
      },
      {
        "txt": "return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; }"
      },
      {
        "txt": "if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);"
      },
      {
        "txt": "} boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue;"
      },
      {
        "txt": "} tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } }"
      },
      {
        "txt": "} if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; }"
      },
      {
        "txt": "int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i));"
      },
      {
        "txt": "} buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {"
      },
      {
        "txt": "continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; }"
      },
      {
        "txt": "} } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result;"
      },
      {
        "txt": "} return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength);"
      },
      {
        "txt": "for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch);"
      },
      {
        "txt": "} } if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null;"
      },
      {
        "txt": "} if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len;"
      },
      {
        "txt": "} if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start; start = end;"
      },
      {
        "txt": "end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1;"
      },
      {
        "txt": "char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); }"
      },
      {
        "txt": "public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx);"
      },
      {
        "txt": "if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null;"
      },
      {
        "txt": "} if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0));"
      },
      {
        "txt": "} int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1);"
      },
      {
        "txt": "case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default :"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat);"
      },
      {
        "txt": "} else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat];"
      },
      {
        "txt": "for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) {"
      },
      {
        "txt": "return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar));"
      },
      {
        "txt": "} public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) {"
      },
      {
        "txt": "return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } }"
      },
      {
        "txt": "public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; }"
      },
      {
        "txt": "if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) {"
      },
      {
        "txt": "return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) {"
      },
      {
        "txt": "padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' ');"
      },
      {
        "txt": "} public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; }"
      },
      {
        "txt": "str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \";"
      },
      {
        "txt": "} int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; }"
      },
      {
        "txt": "public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) {"
      },
      {
        "txt": "return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null;"
      },
      {
        "txt": "} int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); }"
      },
      {
        "txt": "public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) {"
      },
      {
        "txt": "ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); }"
      },
      {
        "txt": "public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); }"
      },
      {
        "txt": "return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str;"
      },
      {
        "txt": "} public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null;"
      },
      {
        "txt": "} String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) {"
      },
      {
        "txt": "return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length();"
      },
      {
        "txt": "} if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");"
      },
      {
        "txt": "} if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; }"
      },
      {
        "txt": "if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset));"
      },
      {
        "txt": "return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2);"
      },
      {
        "txt": "if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) {"
      },
      {
        "txt": "return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i;"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length;"
      },
      {
        "txt": "int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen);"
      },
      {
        "txt": "} } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {"
      },
      {
        "txt": "char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break; }"
      },
      {
        "txt": "} if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; }"
      },
      {
        "txt": "int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff);"
      },
      {
        "txt": "} } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost"
      },
      {
        "txt": "counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s"
      },
      {
        "txt": "int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp;"
      },
      {
        "txt": "n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost"
      },
      {
        "txt": "for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); }"
      },
      {
        "txt": "_d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; }"
      },
      {
        "txt": "if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true);"
      },
      {
        "txt": "} private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); }"
      },
      {
        "txt": "public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } }"
      },
      {
        "txt": "return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) {"
      },
      {
        "txt": "return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2347,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1443,
    "end-bug-line": 1443,
    "bug": "public static boolean containsAny(CharSequence cs, char[] searchChars) {",
    "fix": "public static boolean containsAny(String cs, char[] searchChars) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1;"
      },
      {
        "txt": "private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); }"
      },
      {
        "txt": "public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str);"
      },
      {
        "txt": "return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; }"
      },
      {
        "txt": "int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++;"
      },
      {
        "txt": "} } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) {"
      },
      {
        "txt": "while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } }"
      },
      {
        "txt": "return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; }"
      },
      {
        "txt": "String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null; }"
      },
      {
        "txt": "if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) {"
      },
      {
        "txt": "throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) {"
      },
      {
        "txt": "throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2);"
      },
      {
        "txt": "} public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); }"
      },
      {
        "txt": "public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false);"
      },
      {
        "txt": "} private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND;"
      },
      {
        "txt": "do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++;"
      },
      {
        "txt": "} while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; }"
      },
      {
        "txt": "for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); }"
      },
      {
        "txt": "public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; }"
      },
      {
        "txt": "return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) {"
      },
      {
        "txt": "return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length();"
      },
      {
        "txt": "int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } <extra_id_0> if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1;"
      },
      {
        "txt": "int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true;"
      },
      {
        "txt": "} } else { return true; } } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) {"
      },
      {
        "txt": "if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length();"
      },
      {
        "txt": "int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i;"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i);"
      },
      {
        "txt": "if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; }"
      },
      {
        "txt": "if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) {"
      },
      {
        "txt": "return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length;"
      },
      {
        "txt": "for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } } } return true; }"
      },
      {
        "txt": "public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; }"
      },
      {
        "txt": "tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) { if (str == null) { return null;"
      },
      {
        "txt": "} if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; }"
      },
      {
        "txt": "return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) {"
      },
      {
        "txt": "start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0;"
      },
      {
        "txt": "} if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); }"
      },
      {
        "txt": "public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; }"
      },
      {
        "txt": "if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) {"
      },
      {
        "txt": "return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length());"
      },
      {
        "txt": "} public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos);"
      },
      {
        "txt": "} public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null;"
      },
      {
        "txt": "} int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; }"
      },
      {
        "txt": "public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length();"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) {"
      },
      {
        "txt": "break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); }"
      },
      {
        "txt": "public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true);"
      },
      {
        "txt": "} public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; }"
      },
      {
        "txt": "int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0;"
      },
      {
        "txt": "int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg));"
      },
      {
        "txt": "} else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg));"
      },
      {
        "txt": "} else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; }"
      },
      {
        "txt": "} return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {"
      },
      {
        "txt": "if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false;"
      },
      {
        "txt": "boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; }"
      },
      {
        "txt": "int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) {"
      },
      {
        "txt": "while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0);"
      },
      {
        "txt": "while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } } else { while (i < len) {"
      },
      {
        "txt": "if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i));"
      },
      {
        "txt": "} return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) {"
      },
      {
        "txt": "if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]);"
      },
      {
        "txt": "for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart;"
      },
      {
        "txt": "} } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); }"
      },
      {
        "txt": "public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) {"
      },
      {
        "txt": "if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) {"
      },
      {
        "txt": "if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) {"
      },
      {
        "txt": "if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) {"
      },
      {
        "txt": "separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) {"
      },
      {
        "txt": "if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) {"
      },
      {
        "txt": "if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); }"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); }"
      },
      {
        "txt": "} return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; }"
      },
      {
        "txt": "Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) {"
      },
      {
        "txt": "buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) {"
      },
      {
        "txt": "if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator);"
      },
      {
        "txt": "} public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) {"
      },
      {
        "txt": "chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) {"
      },
      {
        "txt": "return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); }"
      },
      {
        "txt": "public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; }"
      },
      {
        "txt": "} return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) {"
      },
      {
        "txt": "if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength;"
      },
      {
        "txt": "increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start);"
      },
      {
        "txt": "} buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive);"
      },
      {
        "txt": "} private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) {"
      },
      {
        "txt": "throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); }"
      },
      {
        "txt": "boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; }"
      },
      {
        "txt": "tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } }"
      },
      {
        "txt": "if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length();"
      },
      {
        "txt": "if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); }"
      },
      {
        "txt": "buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue;"
      },
      {
        "txt": "} tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } }"
      },
      {
        "txt": "} } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; }"
      },
      {
        "txt": "return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) {"
      },
      {
        "txt": "return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) {"
      },
      {
        "txt": "char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); }"
      },
      {
        "txt": "} if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; }"
      },
      {
        "txt": "if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; }"
      },
      {
        "txt": "if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp;"
      },
      {
        "txt": "} return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx);"
      },
      {
        "txt": "if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) {"
      },
      {
        "txt": "if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; }"
      },
      {
        "txt": "if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); }"
      },
      {
        "txt": "int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 :"
      },
      {
        "txt": "char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength);"
      },
      {
        "txt": "for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else {"
      },
      {
        "txt": "String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) {"
      },
      {
        "txt": "buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null;"
      },
      {
        "txt": "} int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); }"
      },
      {
        "txt": "public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads));"
      },
      {
        "txt": "} else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) {"
      },
      {
        "txt": "return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0));"
      },
      {
        "txt": "} if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen];"
      },
      {
        "txt": "} return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); }"
      },
      {
        "txt": "public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar);"
      },
      {
        "txt": "str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; }"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale);"
      },
      {
        "txt": "} public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString();"
      },
      {
        "txt": "} return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; }"
      },
      {
        "txt": "int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) {"
      },
      {
        "txt": "int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch);"
      },
      {
        "txt": "} else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count;"
      },
      {
        "txt": "} public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; }"
      },
      {
        "txt": "public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; }"
      },
      {
        "txt": "String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null;"
      },
      {
        "txt": "} if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); }"
      },
      {
        "txt": "if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); }"
      },
      {
        "txt": "if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) {"
      },
      {
        "txt": "return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString();"
      },
      {
        "txt": "} public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0;"
      },
      {
        "txt": "} int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE;"
      },
      {
        "txt": "int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); }"
      },
      {
        "txt": "} if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos);"
      },
      {
        "txt": "for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break; } }"
      },
      {
        "txt": "if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs);"
      },
      {
        "txt": "if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); }"
      },
      {
        "txt": "} public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment"
      },
      {
        "txt": "the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t"
      },
      {
        "txt": "if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m;"
      },
      {
        "txt": "m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) {"
      },
      {
        "txt": "p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p;"
      },
      {
        "txt": "p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) {"
      },
      {
        "txt": "a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); }"
      },
      {
        "txt": "private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) {"
      },
      {
        "txt": "if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false;"
      },
      {
        "txt": "} public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null;"
      },
      {
        "txt": "} if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2348,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1455,
    "end-bug-line": 1455,
    "bug": "if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {",
    "fix": "if (Character.isHighSurrogate(ch)) { if (j == searchLast) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() {"
      },
      {
        "txt": "super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen;"
      },
      {
        "txt": "if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; }"
      },
      {
        "txt": "public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) {"
      },
      {
        "txt": "while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } }"
      },
      {
        "txt": "return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--;"
      },
      {
        "txt": "} } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); }"
      },
      {
        "txt": "public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) {"
      },
      {
        "txt": "newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try {"
      },
      {
        "txt": "Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) {"
      },
      {
        "txt": "throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) {"
      },
      {
        "txt": "throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) {"
      },
      {
        "txt": "return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }"
      },
      {
        "txt": "public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {"
      },
      {
        "txt": "if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) {"
      },
      {
        "txt": "index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index;"
      },
      {
        "txt": "} public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0;"
      },
      {
        "txt": "} int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {"
      },
      {
        "txt": "return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar);"
      },
      {
        "txt": "} public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos;"
      },
      {
        "txt": "} for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) {"
      },
      {
        "txt": "return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; }"
      },
      {
        "txt": "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; }"
      },
      {
        "txt": "} return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) {"
      },
      {
        "txt": "if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length();"
      },
      {
        "txt": "int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { <extra_id_0> if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; }"
      },
      {
        "txt": "return true; } } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false;"
      },
      {
        "txt": "} return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer:"
      },
      {
        "txt": "for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i;"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true;"
      },
      {
        "txt": "} if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; }"
      },
      {
        "txt": "return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i);"
      },
      {
        "txt": "for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) {"
      },
      {
        "txt": "return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE;"
      },
      {
        "txt": "int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; }"
      },
      {
        "txt": "if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) {"
      },
      {
        "txt": "ret = tmp; } } return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) {"
      },
      {
        "txt": "start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); }"
      },
      {
        "txt": "public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative }"
      },
      {
        "txt": "if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) {"
      },
      {
        "txt": "end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY;"
      },
      {
        "txt": "} if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos);"
      },
      {
        "txt": "} return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; }"
      },
      {
        "txt": "return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open);"
      },
      {
        "txt": "if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) {"
      },
      {
        "txt": "return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0;"
      },
      {
        "txt": "while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; }"
      },
      {
        "txt": "list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1);"
      },
      {
        "txt": "} public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); }"
      },
      {
        "txt": "public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {"
      },
      {
        "txt": "return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0;"
      },
      {
        "txt": "while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end));"
      },
      {
        "txt": "beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY);"
      },
      {
        "txt": "} } beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null;"
      },
      {
        "txt": "} int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) {"
      },
      {
        "txt": "if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i;"
      },
      {
        "txt": "continue; } lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i;"
      },
      {
        "txt": "continue; } lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]);"
      },
      {
        "txt": "} public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null;"
      },
      {
        "txt": "} if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]);"
      },
      {
        "txt": "if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else {"
      },
      {
        "txt": "list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null);"
      },
      {
        "txt": "} public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null;"
      },
      {
        "txt": "} int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator);"
      },
      {
        "txt": "} if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null;"
      },
      {
        "txt": "} return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; }"
      },
      {
        "txt": "int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator);"
      },
      {
        "txt": "} if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null;"
      },
      {
        "txt": "} if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) {"
      },
      {
        "txt": "buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) {"
      },
      {
        "txt": "return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); }"
      },
      {
        "txt": "Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null;"
      },
      {
        "txt": "} return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); }"
      },
      {
        "txt": "} if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) {"
      },
      {
        "txt": "return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length());"
      },
      {
        "txt": "} return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); }"
      },
      {
        "txt": "return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos);"
      },
      {
        "txt": "} public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text;"
      },
      {
        "txt": "} int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start));"
      },
      {
        "txt": "return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList,"
      },
      {
        "txt": "boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); }"
      },
      {
        "txt": "int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1;"
      },
      {
        "txt": "int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) {"
      },
      {
        "txt": "noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text;"
      },
      {
        "txt": "} int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches"
      },
      {
        "txt": "} } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length();"
      },
      {
        "txt": "textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start);"
      },
      {
        "txt": "if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } }"
      },
      {
        "txt": "int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); }"
      },
      {
        "txt": "public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; }"
      },
      {
        "txt": "if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch);"
      },
      {
        "txt": "if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) {"
      },
      {
        "txt": "return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY;"
      },
      {
        "txt": "} int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0;"
      },
      {
        "txt": "} if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1)"
      },
      {
        "txt": ".append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) {"
      },
      {
        "txt": "char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) {"
      },
      {
        "txt": "lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str;"
      },
      {
        "txt": "} if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1);"
      },
      {
        "txt": "} } return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY;"
      },
      {
        "txt": "} int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) {"
      },
      {
        "txt": "case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1);"
      },
      {
        "txt": "char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str);"
      },
      {
        "txt": "} return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator);"
      },
      {
        "txt": "} } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; }"
      },
      {
        "txt": "return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length();"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) {"
      },
      {
        "txt": "return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads];"
      },
      {
        "txt": "char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); }"
      },
      {
        "txt": "public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar));"
      },
      {
        "txt": "} return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; }"
      },
      {
        "txt": "int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) {"
      },
      {
        "txt": "return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str);"
      },
      {
        "txt": "} } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) {"
      },
      {
        "txt": "return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str;"
      },
      {
        "txt": "} public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale);"
      },
      {
        "txt": "} public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen)"
      },
      {
        "txt": ".append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) {"
      },
      {
        "txt": "return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) {"
      },
      {
        "txt": "return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch);"
      },
      {
        "txt": "} else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0;"
      },
      {
        "txt": "} int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) {"
      },
      {
        "txt": "return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs);"
      },
      {
        "txt": "return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3);"
      },
      {
        "txt": "} final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);"
      },
      {
        "txt": "} return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; }"
      },
      {
        "txt": "int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) {"
      },
      {
        "txt": "if (str1 == null) { return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; }"
      },
      {
        "txt": "return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i;"
      },
      {
        "txt": "for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) {"
      },
      {
        "txt": "if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) {"
      },
      {
        "txt": "firstDiff = stringPos; break; } } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen;"
      },
      {
        "txt": "} return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) {"
      },
      {
        "txt": "return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) {"
      },
      {
        "txt": "if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking"
      },
      {
        "txt": "the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m;"
      },
      {
        "txt": "} else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); }"
      },
      {
        "txt": "int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; }"
      },
      {
        "txt": "for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d;"
      },
      {
        "txt": "} return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; }"
      },
      {
        "txt": "return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) {"
      },
      {
        "txt": "return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false;"
      },
      {
        "txt": "} for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) {"
      },
      {
        "txt": "return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) {"
      },
      {
        "txt": "return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2349,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1457,
    "end-bug-line": 1457,
    "bug": "if (searchChars[j + 1] == cs.charAt(i + 1)) {",
    "fix": "return true; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super();"
      },
      {
        "txt": "} public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) {"
      },
      {
        "txt": "return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) {"
      },
      {
        "txt": "return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) {"
      },
      {
        "txt": "return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null);"
      },
      {
        "txt": "return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars);"
      },
      {
        "txt": "return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {"
      },
      {
        "txt": "start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start);"
      },
      {
        "txt": "} public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; }"
      },
      {
        "txt": "} else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) {"
      },
      {
        "txt": "return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars);"
      },
      {
        "txt": "} return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);"
      },
      {
        "txt": "Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);"
      },
      {
        "txt": "} catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);"
      },
      {
        "txt": "} } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);"
      },
      {
        "txt": "} public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1);"
      },
      {
        "txt": "} else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index; }"
      },
      {
        "txt": "public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; }"
      },
      {
        "txt": "int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i;"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos);"
      },
      {
        "txt": "} public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; }"
      },
      {
        "txt": "for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false;"
      },
      {
        "txt": "} return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } }"
      },
      {
        "txt": "return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i);"
      },
      {
        "txt": "for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length;"
      },
      {
        "txt": "int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { <extra_id_0> return true; } } else { return true; } }"
      },
      {
        "txt": "} } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }"
      },
      {
        "txt": "return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; }"
      },
      {
        "txt": "if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray());"
      },
      {
        "txt": "} public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) {"
      },
      {
        "txt": "if (searchChars[j] == ch) { return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true;"
      },
      {
        "txt": "} return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) {"
      },
      {
        "txt": "ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length;"
      },
      {
        "txt": "int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp;"
      },
      {
        "txt": "} } return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative"
      },
      {
        "txt": "} if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) {"
      },
      {
        "txt": "if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) {"
      },
      {
        "txt": "end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0;"
      },
      {
        "txt": "} return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; }"
      },
      {
        "txt": "if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) {"
      },
      {
        "txt": "return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null;"
      },
      {
        "txt": "} if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); }"
      },
      {
        "txt": "return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator);"
      },
      {
        "txt": "if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) {"
      },
      {
        "txt": "return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) {"
      },
      {
        "txt": "return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length());"
      },
      {
        "txt": "} public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null;"
      },
      {
        "txt": "} int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) {"
      },
      {
        "txt": "int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end));"
      },
      {
        "txt": "pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); }"
      },
      {
        "txt": "public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) {"
      },
      {
        "txt": "return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true);"
      },
      {
        "txt": "} private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) {"
      },
      {
        "txt": "end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength;"
      },
      {
        "txt": "} } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); }"
      },
      {
        "txt": "} beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; }"
      },
      {
        "txt": "int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); }"
      },
      {
        "txt": "public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; }"
      },
      {
        "txt": "if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) {"
      },
      {
        "txt": "continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart));"
      },
      {
        "txt": "tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); }"
      },
      {
        "txt": "public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; }"
      },
      {
        "txt": "int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); }"
      },
      {
        "txt": "if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; }"
      },
      {
        "txt": "return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex);"
      },
      {
        "txt": "if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); }"
      },
      {
        "txt": "if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; }"
      },
      {
        "txt": "if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first);"
      },
      {
        "txt": "} while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); }"
      },
      {
        "txt": "public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first);"
      },
      {
        "txt": "} StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next();"
      },
      {
        "txt": "if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; }"
      },
      {
        "txt": "return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } }"
      },
      {
        "txt": "if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){"
      },
      {
        "txt": "return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length());"
      },
      {
        "txt": "} return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str;"
      },
      {
        "txt": "} public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); }"
      },
      {
        "txt": "public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; }"
      },
      {
        "txt": "int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase);"
      },
      {
        "txt": "while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString();"
      },
      {
        "txt": "} public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive)"
      },
      {
        "txt": "{ if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length;"
      },
      {
        "txt": "int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1;"
      },
      {
        "txt": "int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true;"
      },
      {
        "txt": "} else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; }"
      },
      {
        "txt": "int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches }"
      },
      {
        "txt": "} increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1;"
      },
      {
        "txt": "replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) {"
      },
      {
        "txt": "noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length();"
      },
      {
        "txt": "for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) {"
      },
      {
        "txt": "replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) {"
      },
      {
        "txt": "modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString();"
      },
      {
        "txt": "} return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; }"
      },
      {
        "txt": "int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; }"
      },
      {
        "txt": "if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start))"
      },
      {
        "txt": ".append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0);"
      },
      {
        "txt": "if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--;"
      },
      {
        "txt": "} } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; }"
      },
      {
        "txt": "if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length();"
      },
      {
        "txt": "if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); }"
      },
      {
        "txt": "} return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; }"
      },
      {
        "txt": "int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 :"
      },
      {
        "txt": "char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength];"
      },
      {
        "txt": "for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); }"
      },
      {
        "txt": "return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); }"
      },
      {
        "txt": "} private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf);"
      },
      {
        "txt": "} public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null;"
      },
      {
        "txt": "} if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray();"
      },
      {
        "txt": "for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) {"
      },
      {
        "txt": "if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); }"
      },
      {
        "txt": "return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length();"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str);"
      },
      {
        "txt": "} else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); }"
      },
      {
        "txt": "} public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str;"
      },
      {
        "txt": "} int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; }"
      },
      {
        "txt": "public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) {"
      },
      {
        "txt": "return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); }"
      },
      {
        "txt": "public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0)))"
      },
      {
        "txt": ".append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString();"
      },
      {
        "txt": "} return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str;"
      },
      {
        "txt": "} StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) {"
      },
      {
        "txt": "ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; }"
      },
      {
        "txt": "int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str;"
      },
      {
        "txt": "} public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar);"
      },
      {
        "txt": "} public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");"
      },
      {
        "txt": "} if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); }"
      },
      {
        "txt": "final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); }"
      },
      {
        "txt": "return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length();"
      },
      {
        "txt": "int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) {"
      },
      {
        "txt": "return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at);"
      },
      {
        "txt": "} public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {"
      },
      {
        "txt": "if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) {"
      },
      {
        "txt": "if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) {"
      },
      {
        "txt": "anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos;"
      },
      {
        "txt": "break; } } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; }"
      },
      {
        "txt": "return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY;"
      },
      {
        "txt": "} return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left"
      },
      {
        "txt": "of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) {"
      },
      {
        "txt": "return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally"
      },
      {
        "txt": "int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) {"
      },
      {
        "txt": "t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; }"
      },
      {
        "txt": "return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a;"
      },
      {
        "txt": "} public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null);"
      },
      {
        "txt": "} if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; }"
      },
      {
        "txt": "for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false);"
      },
      {
        "txt": "} public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false;"
      },
      {
        "txt": "} int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2350,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1497,
    "end-bug-line": 1497,
    "bug": "public static boolean containsAny(CharSequence cs, String searchChars) {",
    "fix": "public static boolean containsAny(String cs, String searchChars) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); }"
      },
      {
        "txt": "public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true;"
      },
      {
        "txt": "} for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs);"
      },
      {
        "txt": "} public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim();"
      },
      {
        "txt": "} public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str;"
      },
      {
        "txt": "} public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars);"
      },
      {
        "txt": "} public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++;"
      },
      {
        "txt": "} } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); }"
      },
      {
        "txt": "public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) {"
      },
      {
        "txt": "return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null);"
      },
      {
        "txt": "} public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); }"
      },
      {
        "txt": "return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);"
      },
      {
        "txt": "java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) {"
      },
      {
        "txt": "throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); }"
      },
      {
        "txt": "} else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); }"
      },
      {
        "txt": "public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else {"
      },
      {
        "txt": "index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1;"
      },
      {
        "txt": "if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr);"
      },
      {
        "txt": "} public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); }"
      },
      {
        "txt": "public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; }"
      },
      {
        "txt": "return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;"
      },
      {
        "txt": "} public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) {"
      },
      {
        "txt": "if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1;"
      },
      {
        "txt": "int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else {"
      },
      {
        "txt": "} } } } return false; } <extra_id_0> if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {"
      },
      {
        "txt": "} public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i);"
      },
      {
        "txt": "for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) {"
      },
      {
        "txt": "return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); }"
      },
      {
        "txt": "public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; }"
      },
      {
        "txt": "return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp;"
      },
      {
        "txt": "} } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND;"
      },
      {
        "txt": "int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; }"
      },
      {
        "txt": "} return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative }"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) {"
      },
      {
        "txt": "return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length();"
      },
      {
        "txt": "} if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; }"
      },
      {
        "txt": "return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) {"
      },
      {
        "txt": "return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY;"
      },
      {
        "txt": "} if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len);"
      },
      {
        "txt": "} public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY;"
      },
      {
        "txt": "} int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str;"
      },
      {
        "txt": "} int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); }"
      },
      {
        "txt": "public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length());"
      },
      {
        "txt": "if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; }"
      },
      {
        "txt": "int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos);"
      },
      {
        "txt": "if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen;"
      },
      {
        "txt": "} if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) {"
      },
      {
        "txt": "return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ;"
      },
      {
        "txt": "} public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); }"
      },
      {
        "txt": "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg);"
      },
      {
        "txt": "if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; }"
      },
      {
        "txt": "} else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } }"
      },
      {
        "txt": "beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) {"
      },
      {
        "txt": "return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length();"
      },
      {
        "txt": "if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) {"
      },
      {
        "txt": "return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue;"
      },
      {
        "txt": "} if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos;"
      },
      {
        "txt": "} currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) {"
      },
      {
        "txt": "if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex);"
      },
      {
        "txt": "if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) {"
      },
      {
        "txt": "buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length);"
      },
      {
        "txt": "} public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) {"
      },
      {
        "txt": "return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) {"
      },
      {
        "txt": "buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) {"
      },
      {
        "txt": "return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); }"
      },
      {
        "txt": "while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) {"
      },
      {
        "txt": "if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); }"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) {"
      },
      {
        "txt": "buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator);"
      },
      {
        "txt": "} public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) {"
      },
      {
        "txt": "return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length());"
      },
      {
        "txt": "} return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; }"
      },
      {
        "txt": "public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; }"
      },
      {
        "txt": "char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) {"
      },
      {
        "txt": "return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0;"
      },
      {
        "txt": "int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); }"
      },
      {
        "txt": "public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {"
      },
      {
        "txt": "if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length;"
      },
      {
        "txt": "if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1;"
      },
      {
        "txt": "for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else {"
      },
      {
        "txt": "if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0;"
      },
      {
        "txt": "int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } }"
      },
      {
        "txt": "increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1;"
      },
      {
        "txt": "tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true;"
      },
      {
        "txt": "} else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) {"
      },
      {
        "txt": "buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY;"
      },
      {
        "txt": "} boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true;"
      },
      {
        "txt": "if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString(); }"
      },
      {
        "txt": "return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length();"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) {"
      },
      {
        "txt": "end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay)"
      },
      {
        "txt": ".append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) {"
      },
      {
        "txt": "return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; }"
      },
      {
        "txt": "} else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) {"
      },
      {
        "txt": "return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) {"
      },
      {
        "txt": "return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } }"
      },
      {
        "txt": "return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length();"
      },
      {
        "txt": "if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0);"
      },
      {
        "txt": "char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) {"
      },
      {
        "txt": "output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString();"
      },
      {
        "txt": "} } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } }"
      },
      {
        "txt": "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); }"
      },
      {
        "txt": "public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; }"
      },
      {
        "txt": "if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) {"
      },
      {
        "txt": "return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) {"
      },
      {
        "txt": "padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) {"
      },
      {
        "txt": "return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str);"
      },
      {
        "txt": "} public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) {"
      },
      {
        "txt": "return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } }"
      },
      {
        "txt": "public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; }"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) {"
      },
      {
        "txt": "if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str;"
      },
      {
        "txt": "} str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase();"
      },
      {
        "txt": "} public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1))"
      },
      {
        "txt": ".toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); }"
      },
      {
        "txt": "return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; }"
      },
      {
        "txt": "StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch);"
      },
      {
        "txt": "} buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0;"
      },
      {
        "txt": "int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; }"
      },
      {
        "txt": "public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); }"
      },
      {
        "txt": "public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); }"
      },
      {
        "txt": "if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\";"
      },
      {
        "txt": "if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3));"
      },
      {
        "txt": "} public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2;"
      },
      {
        "txt": "int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2;"
      },
      {
        "txt": "} if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); }"
      },
      {
        "txt": "public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) {"
      },
      {
        "txt": "break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true;"
      },
      {
        "txt": "shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break;"
      },
      {
        "txt": "} } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff;"
      },
      {
        "txt": "} public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; }"
      },
      {
        "txt": "return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\");"
      },
      {
        "txt": "} The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really"
      },
      {
        "txt": "copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n;"
      },
      {
        "txt": "} if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally"
      },
      {
        "txt": "int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1);"
      },
      {
        "txt": "d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n];"
      },
      {
        "txt": "} private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; }"
      },
      {
        "txt": "public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); }"
      },
      {
        "txt": "if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) {"
      },
      {
        "txt": "String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); }"
      },
      {
        "txt": "public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; }"
      },
      {
        "txt": "int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2351,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1533,
    "end-bug-line": 1533,
    "bug": "",
    "fix": "int csLast = csLen - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) {"
      },
      {
        "txt": "return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; }"
      },
      {
        "txt": "for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); }"
      },
      {
        "txt": "public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); }"
      },
      {
        "txt": "public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; }"
      },
      {
        "txt": "public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); }"
      },
      {
        "txt": "public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; }"
      },
      {
        "txt": "} else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) {"
      },
      {
        "txt": "int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str;"
      },
      {
        "txt": "} else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); }"
      },
      {
        "txt": "public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr;"
      },
      {
        "txt": "} public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );"
      },
      {
        "txt": "java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);"
      },
      {
        "txt": "} catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos);"
      },
      {
        "txt": "} public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1);"
      },
      {
        "txt": "} if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0);"
      },
      {
        "txt": "} public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }"
      },
      {
        "txt": "public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) {"
      },
      {
        "txt": "startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {"
      },
      {
        "txt": "return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0;"
      },
      {
        "txt": "} public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false;"
      },
      {
        "txt": "} int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; }"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1;"
      },
      {
        "txt": "for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true;"
      },
      {
        "txt": "} } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }"
      },
      {
        "txt": "} public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); <extra_id_0> outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer;"
      },
      {
        "txt": "if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false;"
      },
      {
        "txt": "} return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) {"
      },
      {
        "txt": "if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false;"
      },
      {
        "txt": "} } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray());"
      },
      {
        "txt": "} public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i];"
      },
      {
        "txt": "if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; }"
      },
      {
        "txt": "} return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } }"
      },
      {
        "txt": "return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null;"
      },
      {
        "txt": "} if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); }"
      },
      {
        "txt": "if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end);"
      },
      {
        "txt": "} public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str;"
      },
      {
        "txt": "} return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; }"
      },
      {
        "txt": "if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) {"
      },
      {
        "txt": "return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); }"
      },
      {
        "txt": "public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; }"
      },
      {
        "txt": "int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) {"
      },
      {
        "txt": "return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length();"
      },
      {
        "txt": "if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) {"
      },
      {
        "txt": "break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; }"
      },
      {
        "txt": "if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false);"
      },
      {
        "txt": "} public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; }"
      },
      {
        "txt": "public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max,"
      },
      {
        "txt": "boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) {"
      },
      {
        "txt": "return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) {"
      },
      {
        "txt": "if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else {"
      },
      {
        "txt": "if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength;"
      },
      {
        "txt": "} } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true);"
      },
      {
        "txt": "} private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len;"
      },
      {
        "txt": "lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false);"
      },
      {
        "txt": "} public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; }"
      },
      {
        "txt": "if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; }"
      },
      {
        "txt": "currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) {"
      },
      {
        "txt": "return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) {"
      },
      {
        "txt": "return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); }"
      },
      {
        "txt": "public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY;"
      },
      {
        "txt": "} bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY;"
      },
      {
        "txt": "} Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) {"
      },
      {
        "txt": "buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) {"
      },
      {
        "txt": "return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small"
      },
      {
        "txt": "if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); }"
      },
      {
        "txt": "public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str;"
      },
      {
        "txt": "} return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; }"
      },
      {
        "txt": "public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray();"
      },
      {
        "txt": "int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1);"
      },
      {
        "txt": "} public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start);"
      },
      {
        "txt": "if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement);"
      },
      {
        "txt": "start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) {"
      },
      {
        "txt": "return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null ||"
      },
      {
        "txt": "searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) {"
      },
      {
        "txt": "if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) {"
      },
      {
        "txt": "textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0; int increase = 0;"
      },
      {
        "txt": "for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5);"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1;"
      },
      {
        "txt": "for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else {"
      },
      {
        "txt": "if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i));"
      },
      {
        "txt": "} String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; }"
      },
      {
        "txt": "boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) {"
      },
      {
        "txt": "buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString(); } return str;"
      },
      {
        "txt": "} public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) { end = len;"
      },
      {
        "txt": "} if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end))"
      },
      {
        "txt": ".toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY;"
      },
      {
        "txt": "} return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) {"
      },
      {
        "txt": "lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length());"
      },
      {
        "txt": "} return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY;"
      },
      {
        "txt": "} int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret;"
      },
      {
        "txt": "} public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) {"
      },
      {
        "txt": "return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength];"
      },
      {
        "txt": "for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0;"
      },
      {
        "txt": "output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); }"
      },
      {
        "txt": "} public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {"
      },
      {
        "txt": "if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) {"
      },
      {
        "txt": "return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0));"
      },
      {
        "txt": "} if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen];"
      },
      {
        "txt": "} return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null;"
      },
      {
        "txt": "} int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); }"
      },
      {
        "txt": "public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str);"
      },
      {
        "txt": "} else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) {"
      },
      {
        "txt": "return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) {"
      },
      {
        "txt": "return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; }"
      },
      {
        "txt": "str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); }"
      },
      {
        "txt": "public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) {"
      },
      {
        "txt": "return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString();"
      },
      {
        "txt": "} public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen)"
      },
      {
        "txt": ".append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen);"
      },
      {
        "txt": "char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); }"
      },
      {
        "txt": "buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0;"
      },
      {
        "txt": "while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) {"
      },
      {
        "txt": "return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString();"
      },
      {
        "txt": "} public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) {"
      },
      {
        "txt": "return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) {"
      },
      {
        "txt": "return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) {"
      },
      {
        "txt": "return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); }"
      },
      {
        "txt": "public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2;"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; }"
      },
      {
        "txt": "if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {"
      },
      {
        "txt": "if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break;"
      },
      {
        "txt": "} } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0;"
      },
      {
        "txt": "} else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) {"
      },
      {
        "txt": "return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; }"
      },
      {
        "txt": "} if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; }"
      },
      {
        "txt": "public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0];"
      },
      {
        "txt": "} else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); }"
      },
      {
        "txt": "The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array"
      },
      {
        "txt": "or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; }"
      },
      {
        "txt": "if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d"
      },
      {
        "txt": "int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j;"
      },
      {
        "txt": "for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n]; }"
      },
      {
        "txt": "private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) {"
      },
      {
        "txt": "return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) {"
      },
      {
        "txt": "return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i];"
      },
      {
        "txt": "if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) {"
      },
      {
        "txt": "return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length();"
      },
      {
        "txt": "return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2352,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1534,
    "end-bug-line": 1534,
    "bug": "",
    "fix": "int searchLast = searchLen - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale;"
      },
      {
        "txt": "import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0;"
      },
      {
        "txt": "} public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) {"
      },
      {
        "txt": "if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) {"
      },
      {
        "txt": "return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) {"
      },
      {
        "txt": "return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) {"
      },
      {
        "txt": "return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) {"
      },
      {
        "txt": "int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) {"
      },
      {
        "txt": "return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end;"
      },
      {
        "txt": "if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else {"
      },
      {
        "txt": "while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) {"
      },
      {
        "txt": "int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; }"
      },
      {
        "txt": "public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");"
      },
      {
        "txt": "String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) {"
      },
      {
        "txt": "throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");"
      },
      {
        "txt": "} } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); }"
      },
      {
        "txt": "public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) {"
      },
      {
        "txt": "return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); }"
      },
      {
        "txt": "if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); }"
      },
      {
        "txt": "public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {"
      },
      {
        "txt": "return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length();"
      },
      {
        "txt": "} if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i;"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; }"
      },
      {
        "txt": "public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; }"
      },
      {
        "txt": "int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) {"
      },
      {
        "txt": "if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i;"
      },
      {
        "txt": "} } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray());"
      },
      {
        "txt": "} public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; }"
      },
      {
        "txt": "} } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray());"
      },
      {
        "txt": "public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; <extra_id_0> for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; }"
      },
      {
        "txt": "continue outer; } } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; }"
      },
      {
        "txt": "return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) {"
      },
      {
        "txt": "return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; }"
      },
      {
        "txt": "} } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); }"
      },
      {
        "txt": "public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) {"
      },
      {
        "txt": "continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } }"
      },
      {
        "txt": "return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret;"
      },
      {
        "txt": "} public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0;"
      },
      {
        "txt": "} if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; }"
      },
      {
        "txt": "if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) {"
      },
      {
        "txt": "return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); }"
      },
      {
        "txt": "public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; }"
      },
      {
        "txt": "return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) {"
      },
      {
        "txt": "return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY;"
      },
      {
        "txt": "} if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; }"
      },
      {
        "txt": "return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator);"
      },
      {
        "txt": "if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator);"
      },
      {
        "txt": "if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) {"
      },
      {
        "txt": "return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag);"
      },
      {
        "txt": "} public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end);"
      },
      {
        "txt": "} } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break;"
      },
      {
        "txt": "} start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) {"
      },
      {
        "txt": "return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); }"
      },
      {
        "txt": "public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) {"
      },
      {
        "txt": "return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens)"
      },
      {
        "txt": "{ if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens);"
      },
      {
        "txt": "} int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) {"
      },
      {
        "txt": "numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) {"
      },
      {
        "txt": "numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; }"
      },
      {
        "txt": "} else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false;"
      },
      {
        "txt": "lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) {"
      },
      {
        "txt": "list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); }"
      },
      {
        "txt": "private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1;"
      },
      {
        "txt": "int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len;"
      },
      {
        "txt": "lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len;"
      },
      {
        "txt": "lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false;"
      },
      {
        "txt": "} list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); }"
      },
      {
        "txt": "public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {"
      },
      {
        "txt": "int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type;"
      },
      {
        "txt": "} list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null;"
      },
      {
        "txt": "} return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY;"
      },
      {
        "txt": "} bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); }"
      },
      {
        "txt": "} return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) {"
      },
      {
        "txt": "if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; }"
      },
      {
        "txt": "bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); }"
      },
      {
        "txt": "} return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; }"
      },
      {
        "txt": "Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator);"
      },
      {
        "txt": "Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null;"
      },
      {
        "txt": "} if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) {"
      },
      {
        "txt": "buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); }"
      },
      {
        "txt": "} return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) {"
      },
      {
        "txt": "if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length();"
      },
      {
        "txt": "char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; }"
      },
      {
        "txt": "return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; }"
      },
      {
        "txt": "public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0;"
      },
      {
        "txt": "for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); }"
      },
      {
        "txt": "public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength;"
      },
      {
        "txt": "if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0);"
      },
      {
        "txt": "} public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0)"
      },
      {
        "txt": "{ return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \""
      },
      {
        "txt": "+ searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||"
      },
      {
        "txt": "searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex;"
      },
      {
        "txt": "replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) {"
      },
      {
        "txt": "if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase);"
      },
      {
        "txt": "while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) {"
      },
      {
        "txt": "if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) {"
      },
      {
        "txt": "textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); }"
      },
      {
        "txt": "String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false;"
      },
      {
        "txt": "int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index));"
      },
      {
        "txt": "} } else { buf.append(ch); } } if (modified) { return buf.toString(); } return str; }"
      },
      {
        "txt": "public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0;"
      },
      {
        "txt": "} if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) { end = len; }"
      },
      {
        "txt": "if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString();"
      },
      {
        "txt": "} public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; }"
      },
      {
        "txt": "return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++;"
      },
      {
        "txt": "} return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); }"
      },
      {
        "txt": "return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; }"
      },
      {
        "txt": "int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; }"
      },
      {
        "txt": "public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str;"
      },
      {
        "txt": "} if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) {"
      },
      {
        "txt": "output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1;"
      },
      {
        "txt": "} return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } }"
      },
      {
        "txt": "public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) {"
      },
      {
        "txt": "throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' ');"
      },
      {
        "txt": "} public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) {"
      },
      {
        "txt": "return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \";"
      },
      {
        "txt": "} int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); }"
      },
      {
        "txt": "if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; }"
      },
      {
        "txt": "return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; }"
      },
      {
        "txt": "int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) {"
      },
      {
        "txt": "if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else {"
      },
      {
        "txt": "char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs);"
      },
      {
        "txt": "} public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str;"
      },
      {
        "txt": "} if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr);"
      },
      {
        "txt": "str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase();"
      },
      {
        "txt": "} public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null;"
      },
      {
        "txt": "} int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); }"
      },
      {
        "txt": "public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0)))"
      },
      {
        "txt": ".append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0;"
      },
      {
        "txt": "for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch);"
      },
      {
        "txt": "} return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str;"
      },
      {
        "txt": "} public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); }"
      },
      {
        "txt": "public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth);"
      },
      {
        "txt": "} public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str;"
      },
      {
        "txt": "} if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker;"
      },
      {
        "txt": "} if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length);"
      },
      {
        "txt": "builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) {"
      },
      {
        "txt": "return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; }"
      },
      {
        "txt": "} if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else {"
      },
      {
        "txt": "allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0;"
      },
      {
        "txt": "} int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } }"
      },
      {
        "txt": "if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) {"
      },
      {
        "txt": "if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) {"
      },
      {
        "txt": "return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather"
      },
      {
        "txt": "than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.)"
      },
      {
        "txt": "Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) {"
      },
      {
        "txt": "CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s"
      },
      {
        "txt": "int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) {"
      },
      {
        "txt": "cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) {"
      },
      {
        "txt": "if (b < a) { a = b; } if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false);"
      },
      {
        "txt": "} public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false;"
      },
      {
        "txt": "} return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) {"
      },
      {
        "txt": "return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true);"
      },
      {
        "txt": "} private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());"
      }
    ]
  },
  {
    "id": 2353,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1539,
    "end-bug-line": 1539,
    "bug": "",
    "fix": "if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { if (searchChars[j + 1] == cs.charAt(i + 1)) { continue outer; } } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192;"
      },
      {
        "txt": "public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) {"
      },
      {
        "txt": "int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts;"
      },
      {
        "txt": "} public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0;"
      },
      {
        "txt": "if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; }"
      },
      {
        "txt": "} return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {"
      },
      {
        "txt": "end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end);"
      },
      {
        "txt": "} public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen];"
      },
      {
        "txt": "for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) {"
      },
      {
        "txt": "try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);"
      },
      {
        "txt": "} catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);"
      },
      {
        "txt": "} catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); }"
      },
      {
        "txt": "public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr);"
      },
      {
        "txt": "} public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); }"
      },
      {
        "txt": "private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do {"
      },
      {
        "txt": "if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal);"
      },
      {
        "txt": "return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) {"
      },
      {
        "txt": "startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) {"
      },
      {
        "txt": "return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) {"
      },
      {
        "txt": "if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0;"
      },
      {
        "txt": "} public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true;"
      },
      {
        "txt": "} } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length;"
      },
      {
        "txt": "for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; }"
      },
      {
        "txt": "int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) {"
      },
      {
        "txt": "return true; } } else { return true; } } } } return false; }"
      },
      {
        "txt": "public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { <extra_id_0> } } return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) {"
      },
      {
        "txt": "return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) {"
      },
      {
        "txt": "return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false;"
      },
      {
        "txt": "} return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) {"
      },
      {
        "txt": "if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length;"
      },
      {
        "txt": "int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue;"
      },
      {
        "txt": "} if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search);"
      },
      {
        "txt": "if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) { if (str == null) { return null; }"
      },
      {
        "txt": "if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start);"
      },
      {
        "txt": "} public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative"
      },
      {
        "txt": "} if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; }"
      },
      {
        "txt": "if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) {"
      },
      {
        "txt": "return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null;"
      },
      {
        "txt": "} if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) {"
      },
      {
        "txt": "if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) {"
      },
      {
        "txt": "return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY;"
      },
      {
        "txt": "} int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); }"
      },
      {
        "txt": "public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); }"
      },
      {
        "txt": "public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY;"
      },
      {
        "txt": "} return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; }"
      },
      {
        "txt": "int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) {"
      },
      {
        "txt": "if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break;"
      },
      {
        "txt": "} list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) {"
      },
      {
        "txt": "return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false);"
      },
      {
        "txt": "} public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); }"
      },
      {
        "txt": "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length();"
      },
      {
        "txt": "if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0;"
      },
      {
        "txt": "int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else {"
      },
      {
        "txt": "substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else {"
      },
      {
        "txt": "substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } }"
      },
      {
        "txt": "return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false;"
      },
      {
        "txt": "while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length();"
      },
      {
        "txt": "if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) {"
      },
      {
        "txt": "if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) {"
      },
      {
        "txt": "if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i;"
      },
      {
        "txt": "continue; } lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); }"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) {"
      },
      {
        "txt": "return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) {"
      },
      {
        "txt": "int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; }"
      },
      {
        "txt": "} else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) {"
      },
      {
        "txt": "return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) {"
      },
      {
        "txt": "return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {"
      },
      {
        "txt": "buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) {"
      },
      {
        "txt": "return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY;"
      },
      {
        "txt": "} int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) {"
      },
      {
        "txt": "buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) {"
      },
      {
        "txt": "return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small"
      },
      {
        "txt": "if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next();"
      },
      {
        "txt": "if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator);"
      },
      {
        "txt": "} Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) {"
      },
      {
        "txt": "return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); }"
      },
      {
        "txt": "public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i);"
      },
      {
        "txt": "} } if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) {"
      },
      {
        "txt": "return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length());"
      },
      {
        "txt": "} return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) {"
      },
      {
        "txt": "if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } }"
      },
      {
        "txt": "return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {"
      },
      {
        "txt": "return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase);"
      },
      {
        "txt": "increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); }"
      },
      {
        "txt": "buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); }"
      },
      {
        "txt": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);"
      },
      {
        "txt": "} int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];"
      },
      {
        "txt": "int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]);"
      },
      {
        "txt": "if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) {"
      },
      {
        "txt": "return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) {"
      },
      {
        "txt": "increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]);"
      },
      {
        "txt": "start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; }"
      },
      {
        "txt": "tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } }"
      },
      {
        "txt": "} int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);"
      },
      {
        "txt": "} public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str;"
      },
      {
        "txt": "} if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i);"
      },
      {
        "txt": "int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } }"
      },
      {
        "txt": "if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) {"
      },
      {
        "txt": "overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) {"
      },
      {
        "txt": "end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp; }"
      },
      {
        "txt": "return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) {"
      },
      {
        "txt": "if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) {"
      },
      {
        "txt": "return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) {"
      },
      {
        "txt": "return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) {"
      },
      {
        "txt": "return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat;"
      },
      {
        "txt": "switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0);"
      },
      {
        "txt": "char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) {"
      },
      {
        "txt": "buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat);"
      },
      {
        "txt": "return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar;"
      },
      {
        "txt": "} return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; }"
      },
      {
        "txt": "int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) {"
      },
      {
        "txt": "if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else {"
      },
      {
        "txt": "char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' ');"
      },
      {
        "txt": "} public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) {"
      },
      {
        "txt": "return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \";"
      },
      {
        "txt": "} int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); }"
      },
      {
        "txt": "if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; }"
      },
      {
        "txt": "return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) {"
      },
      {
        "txt": "if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar);"
      },
      {
        "txt": "return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); }"
      },
      {
        "txt": "public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); }"
      },
      {
        "txt": "return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen;"
      },
      {
        "txt": "if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen;"
      },
      {
        "txt": "if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) {"
      },
      {
        "txt": "ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) {"
      },
      {
        "txt": "return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; }"
      },
      {
        "txt": "public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar);"
      },
      {
        "txt": "ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; }"
      },
      {
        "txt": "if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) {"
      },
      {
        "txt": "offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) {"
      },
      {
        "txt": "return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str;"
      },
      {
        "txt": "} int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); }"
      },
      {
        "txt": "public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY;"
      },
      {
        "txt": "} return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; }"
      },
      {
        "txt": "int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0;"
      },
      {
        "txt": "for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } }"
      },
      {
        "txt": "if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {"
      },
      {
        "txt": "if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) {"
      },
      {
        "txt": "return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } }"
      },
      {
        "txt": "public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so"
      },
      {
        "txt": "allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) {"
      },
      {
        "txt": "return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length();"
      },
      {
        "txt": "} int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i;"
      },
      {
        "txt": "} for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d;"
      },
      {
        "txt": "d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c;"
      },
      {
        "txt": "} return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) {"
      },
      {
        "txt": "if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {"
      },
      {
        "txt": "return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; }"
      },
      {
        "txt": "public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; }"
      },
      {
        "txt": "if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2354,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1540,
    "end-bug-line": 1540,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() {"
      },
      {
        "txt": "super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen;"
      },
      {
        "txt": "if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; }"
      },
      {
        "txt": "public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) {"
      },
      {
        "txt": "while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } }"
      },
      {
        "txt": "return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--;"
      },
      {
        "txt": "} } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); }"
      },
      {
        "txt": "public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) {"
      },
      {
        "txt": "newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try {"
      },
      {
        "txt": "Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) {"
      },
      {
        "txt": "throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) {"
      },
      {
        "txt": "throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) {"
      },
      {
        "txt": "return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); }"
      },
      {
        "txt": "public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {"
      },
      {
        "txt": "if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) {"
      },
      {
        "txt": "index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index;"
      },
      {
        "txt": "} public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0;"
      },
      {
        "txt": "} int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {"
      },
      {
        "txt": "return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar);"
      },
      {
        "txt": "} public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos;"
      },
      {
        "txt": "} for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) {"
      },
      {
        "txt": "return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; }"
      },
      {
        "txt": "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; }"
      },
      {
        "txt": "} return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) {"
      },
      {
        "txt": "if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length();"
      },
      {
        "txt": "int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true;"
      },
      {
        "txt": "} } else { return true; } } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) {"
      },
      {
        "txt": "if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length();"
      },
      {
        "txt": "outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; <extra_id_0> } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) {"
      },
      {
        "txt": "} public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i;"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true;"
      },
      {
        "txt": "} if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; }"
      },
      {
        "txt": "return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i);"
      },
      {
        "txt": "for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) {"
      },
      {
        "txt": "return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE;"
      },
      {
        "txt": "int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; }"
      },
      {
        "txt": "if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) {"
      },
      {
        "txt": "ret = tmp; } } return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) {"
      },
      {
        "txt": "start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); }"
      },
      {
        "txt": "public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative }"
      },
      {
        "txt": "if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) {"
      },
      {
        "txt": "end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY;"
      },
      {
        "txt": "} if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos);"
      },
      {
        "txt": "} return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; }"
      },
      {
        "txt": "return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open);"
      },
      {
        "txt": "if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) {"
      },
      {
        "txt": "return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0;"
      },
      {
        "txt": "while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; }"
      },
      {
        "txt": "list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1);"
      },
      {
        "txt": "} public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); }"
      },
      {
        "txt": "public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {"
      },
      {
        "txt": "return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0;"
      },
      {
        "txt": "while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end));"
      },
      {
        "txt": "beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY);"
      },
      {
        "txt": "} } beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null;"
      },
      {
        "txt": "} int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) {"
      },
      {
        "txt": "if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i;"
      },
      {
        "txt": "continue; } lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) {"
      },
      {
        "txt": "if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i;"
      },
      {
        "txt": "continue; } lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]);"
      },
      {
        "txt": "} public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null;"
      },
      {
        "txt": "} if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]);"
      },
      {
        "txt": "if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else {"
      },
      {
        "txt": "list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null);"
      },
      {
        "txt": "} public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null;"
      },
      {
        "txt": "} int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator);"
      },
      {
        "txt": "} if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null;"
      },
      {
        "txt": "} return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; }"
      },
      {
        "txt": "int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator);"
      },
      {
        "txt": "} if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null;"
      },
      {
        "txt": "} if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) {"
      },
      {
        "txt": "buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) {"
      },
      {
        "txt": "return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); }"
      },
      {
        "txt": "Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null;"
      },
      {
        "txt": "} return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); }"
      },
      {
        "txt": "} if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) {"
      },
      {
        "txt": "return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length());"
      },
      {
        "txt": "} return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); }"
      },
      {
        "txt": "return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos);"
      },
      {
        "txt": "} public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text;"
      },
      {
        "txt": "} int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start));"
      },
      {
        "txt": "return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList,"
      },
      {
        "txt": "boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); }"
      },
      {
        "txt": "int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1;"
      },
      {
        "txt": "int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) {"
      },
      {
        "txt": "noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text;"
      },
      {
        "txt": "} int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches"
      },
      {
        "txt": "} } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length();"
      },
      {
        "txt": "textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start);"
      },
      {
        "txt": "if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } }"
      },
      {
        "txt": "int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); }"
      },
      {
        "txt": "public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; }"
      },
      {
        "txt": "if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch);"
      },
      {
        "txt": "if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) {"
      },
      {
        "txt": "return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY;"
      },
      {
        "txt": "} int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0;"
      },
      {
        "txt": "} if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1)"
      },
      {
        "txt": ".append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) {"
      },
      {
        "txt": "char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) {"
      },
      {
        "txt": "lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str;"
      },
      {
        "txt": "} if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1);"
      },
      {
        "txt": "} } return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY;"
      },
      {
        "txt": "} int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) {"
      },
      {
        "txt": "case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1);"
      },
      {
        "txt": "char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str);"
      },
      {
        "txt": "} return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator);"
      },
      {
        "txt": "} } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; }"
      },
      {
        "txt": "return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length();"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) {"
      },
      {
        "txt": "return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads];"
      },
      {
        "txt": "char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); }"
      },
      {
        "txt": "public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar));"
      },
      {
        "txt": "} return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; }"
      },
      {
        "txt": "int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) {"
      },
      {
        "txt": "return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str);"
      },
      {
        "txt": "} } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) {"
      },
      {
        "txt": "return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str;"
      },
      {
        "txt": "} public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale);"
      },
      {
        "txt": "} public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen)"
      },
      {
        "txt": ".append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) {"
      },
      {
        "txt": "return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) {"
      },
      {
        "txt": "return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch);"
      },
      {
        "txt": "} else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0;"
      },
      {
        "txt": "} int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) {"
      },
      {
        "txt": "return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs);"
      },
      {
        "txt": "return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3);"
      },
      {
        "txt": "} final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);"
      },
      {
        "txt": "} return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; }"
      },
      {
        "txt": "int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) {"
      },
      {
        "txt": "if (str1 == null) { return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; }"
      },
      {
        "txt": "return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i;"
      },
      {
        "txt": "for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) {"
      },
      {
        "txt": "if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) {"
      },
      {
        "txt": "firstDiff = stringPos; break; } } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen;"
      },
      {
        "txt": "} return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) {"
      },
      {
        "txt": "return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) {"
      },
      {
        "txt": "if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking"
      },
      {
        "txt": "the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m;"
      },
      {
        "txt": "} else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); }"
      },
      {
        "txt": "int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; }"
      },
      {
        "txt": "for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d;"
      },
      {
        "txt": "} return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; }"
      },
      {
        "txt": "return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) {"
      },
      {
        "txt": "return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false;"
      },
      {
        "txt": "} for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) {"
      },
      {
        "txt": "return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) {"
      },
      {
        "txt": "return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2355,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1576,
    "end-bug-line": 1576,
    "bug": "if (searchChars.indexOf(ch) < 0) {",
    "fix": "boolean chFound = searchChars.indexOf(ch) >= 0; if (i + 1 < strLen && Character.isHighSurrogate(ch)) { char ch2 = str.charAt(i + 1); if (chFound && searchChars.indexOf(ch2) < 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) {"
      },
      {
        "txt": "return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; }"
      },
      {
        "txt": "for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); }"
      },
      {
        "txt": "public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); }"
      },
      {
        "txt": "public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; }"
      },
      {
        "txt": "public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); }"
      },
      {
        "txt": "public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; }"
      },
      {
        "txt": "} else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) {"
      },
      {
        "txt": "int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str;"
      },
      {
        "txt": "} else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); }"
      },
      {
        "txt": "public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr;"
      },
      {
        "txt": "} public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );"
      },
      {
        "txt": "java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);"
      },
      {
        "txt": "} catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos);"
      },
      {
        "txt": "} public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1);"
      },
      {
        "txt": "} if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0);"
      },
      {
        "txt": "} public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }"
      },
      {
        "txt": "public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) {"
      },
      {
        "txt": "startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {"
      },
      {
        "txt": "return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0;"
      },
      {
        "txt": "} public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false;"
      },
      {
        "txt": "} int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; }"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1;"
      },
      {
        "txt": "for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true;"
      },
      {
        "txt": "} } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }"
      },
      {
        "txt": "return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); <extra_id_0> return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) {"
      },
      {
        "txt": "} public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false;"
      },
      {
        "txt": "} return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) {"
      },
      {
        "txt": "if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false;"
      },
      {
        "txt": "} } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray());"
      },
      {
        "txt": "} public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i];"
      },
      {
        "txt": "if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; }"
      },
      {
        "txt": "} return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } }"
      },
      {
        "txt": "return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null;"
      },
      {
        "txt": "} if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); }"
      },
      {
        "txt": "if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end);"
      },
      {
        "txt": "} public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str;"
      },
      {
        "txt": "} return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; }"
      },
      {
        "txt": "if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) {"
      },
      {
        "txt": "return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); }"
      },
      {
        "txt": "public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; }"
      },
      {
        "txt": "int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) {"
      },
      {
        "txt": "return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length();"
      },
      {
        "txt": "if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) {"
      },
      {
        "txt": "break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; }"
      },
      {
        "txt": "if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false);"
      },
      {
        "txt": "} public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; }"
      },
      {
        "txt": "public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max,"
      },
      {
        "txt": "boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) {"
      },
      {
        "txt": "return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) {"
      },
      {
        "txt": "if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else {"
      },
      {
        "txt": "if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength;"
      },
      {
        "txt": "} } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true);"
      },
      {
        "txt": "} private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len;"
      },
      {
        "txt": "lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false);"
      },
      {
        "txt": "} public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; }"
      },
      {
        "txt": "if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; }"
      },
      {
        "txt": "currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) {"
      },
      {
        "txt": "return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) {"
      },
      {
        "txt": "return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); }"
      },
      {
        "txt": "public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY;"
      },
      {
        "txt": "} bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY;"
      },
      {
        "txt": "} Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) {"
      },
      {
        "txt": "buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) {"
      },
      {
        "txt": "return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small"
      },
      {
        "txt": "if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); }"
      },
      {
        "txt": "public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str;"
      },
      {
        "txt": "} return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; }"
      },
      {
        "txt": "public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray();"
      },
      {
        "txt": "int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1);"
      },
      {
        "txt": "} public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start);"
      },
      {
        "txt": "if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement);"
      },
      {
        "txt": "start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) {"
      },
      {
        "txt": "return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null ||"
      },
      {
        "txt": "searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) {"
      },
      {
        "txt": "if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) {"
      },
      {
        "txt": "textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0; int increase = 0;"
      },
      {
        "txt": "for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5);"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1;"
      },
      {
        "txt": "for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else {"
      },
      {
        "txt": "if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i));"
      },
      {
        "txt": "} String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; }"
      },
      {
        "txt": "boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) {"
      },
      {
        "txt": "buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString(); } return str;"
      },
      {
        "txt": "} public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) { end = len;"
      },
      {
        "txt": "} if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end))"
      },
      {
        "txt": ".toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY;"
      },
      {
        "txt": "} return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) {"
      },
      {
        "txt": "lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length());"
      },
      {
        "txt": "} return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY;"
      },
      {
        "txt": "} int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret;"
      },
      {
        "txt": "} public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) {"
      },
      {
        "txt": "return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength];"
      },
      {
        "txt": "for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0;"
      },
      {
        "txt": "output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); }"
      },
      {
        "txt": "} public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {"
      },
      {
        "txt": "if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) {"
      },
      {
        "txt": "return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0));"
      },
      {
        "txt": "} if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen];"
      },
      {
        "txt": "} return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null;"
      },
      {
        "txt": "} int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); }"
      },
      {
        "txt": "public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str);"
      },
      {
        "txt": "} else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) {"
      },
      {
        "txt": "return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) {"
      },
      {
        "txt": "return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; }"
      },
      {
        "txt": "str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); }"
      },
      {
        "txt": "public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) {"
      },
      {
        "txt": "return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString();"
      },
      {
        "txt": "} public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen)"
      },
      {
        "txt": ".append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen);"
      },
      {
        "txt": "char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); }"
      },
      {
        "txt": "buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0;"
      },
      {
        "txt": "while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) {"
      },
      {
        "txt": "return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString();"
      },
      {
        "txt": "} public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) {"
      },
      {
        "txt": "return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) {"
      },
      {
        "txt": "return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) {"
      },
      {
        "txt": "return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); }"
      },
      {
        "txt": "public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2;"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; }"
      },
      {
        "txt": "if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {"
      },
      {
        "txt": "if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break;"
      },
      {
        "txt": "} } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0;"
      },
      {
        "txt": "} else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) {"
      },
      {
        "txt": "return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; }"
      },
      {
        "txt": "} if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; }"
      },
      {
        "txt": "public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0];"
      },
      {
        "txt": "} else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); }"
      },
      {
        "txt": "The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array"
      },
      {
        "txt": "or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; }"
      },
      {
        "txt": "if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d"
      },
      {
        "txt": "int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j;"
      },
      {
        "txt": "for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n]; }"
      },
      {
        "txt": "private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) {"
      },
      {
        "txt": "return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) {"
      },
      {
        "txt": "return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i];"
      },
      {
        "txt": "if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) {"
      },
      {
        "txt": "return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length();"
      },
      {
        "txt": "return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2356,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1578,
    "end-bug-line": 1578,
    "bug": "",
    "fix": "} } else { if (!chFound) { return i; }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils;"
      },
      {
        "txt": "public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; }"
      },
      {
        "txt": "public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim();"
      },
      {
        "txt": "} public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null);"
      },
      {
        "txt": "} public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null);"
      },
      {
        "txt": "} public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen;"
      },
      {
        "txt": "if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str;"
      },
      {
        "txt": "} else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) {"
      },
      {
        "txt": "return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {"
      },
      {
        "txt": "end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen;"
      },
      {
        "txt": "if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) {"
      },
      {
        "txt": "if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) );"
      },
      {
        "txt": "java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);"
      },
      {
        "txt": "} catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); }"
      },
      {
        "txt": "} public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos);"
      },
      {
        "txt": "} public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0;"
      },
      {
        "txt": "} int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) {"
      },
      {
        "txt": "return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true);"
      },
      {
        "txt": "} public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); }"
      },
      {
        "txt": "if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length();"
      },
      {
        "txt": "int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; }"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); }"
      },
      {
        "txt": "public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i);"
      },
      {
        "txt": "for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; } }"
      },
      {
        "txt": "} } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); }"
      },
      {
        "txt": "public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) {"
      },
      {
        "txt": "if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) {"
      },
      {
        "txt": "} int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; <extra_id_0> } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false;"
      },
      {
        "txt": "if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true;"
      },
      {
        "txt": "} int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } }"
      },
      {
        "txt": "} return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) {"
      },
      {
        "txt": "if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue;"
      },
      {
        "txt": "} tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;"
      },
      {
        "txt": "} public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i];"
      },
      {
        "txt": "if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; }"
      },
      {
        "txt": "public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; }"
      },
      {
        "txt": "if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) {"
      },
      {
        "txt": "end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY;"
      },
      {
        "txt": "} if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) {"
      },
      {
        "txt": "if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len);"
      },
      {
        "txt": "} public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str;"
      },
      {
        "txt": "} return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; }"
      },
      {
        "txt": "if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) {"
      },
      {
        "txt": "return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos);"
      },
      {
        "txt": "} public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY;"
      },
      {
        "txt": "} int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); }"
      },
      {
        "txt": "public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); }"
      },
      {
        "txt": "} return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; }"
      },
      {
        "txt": "start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null;"
      },
      {
        "txt": "} return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false);"
      },
      {
        "txt": "} public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {"
      },
      {
        "txt": "if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); }"
      },
      {
        "txt": "int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1;"
      },
      {
        "txt": "if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1;"
      },
      {
        "txt": "if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else {"
      },
      {
        "txt": "substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) {"
      },
      {
        "txt": "return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i));"
      },
      {
        "txt": "} return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {"
      },
      {
        "txt": "if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0;"
      },
      {
        "txt": "boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false;"
      },
      {
        "txt": "} list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false;"
      },
      {
        "txt": "} list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) {"
      },
      {
        "txt": "return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray();"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1;"
      },
      {
        "txt": "if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; }"
      },
      {
        "txt": "list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; }"
      },
      {
        "txt": "return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; }"
      },
      {
        "txt": "bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) {"
      },
      {
        "txt": "return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())"
      },
      {
        "txt": "+ separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next();"
      },
      {
        "txt": "if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next();"
      },
      {
        "txt": "if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; }"
      },
      {
        "txt": "if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first);"
      },
      {
        "txt": "} while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } }"
      },
      {
        "txt": "return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) {"
      },
      {
        "txt": "return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz];"
      },
      {
        "txt": "int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count);"
      },
      {
        "txt": "} public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; }"
      },
      {
        "txt": "public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) {"
      },
      {
        "txt": "if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) {"
      },
      {
        "txt": "return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text;"
      },
      {
        "txt": "} int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) {"
      },
      {
        "txt": "break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); }"
      },
      {
        "txt": "public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {"
      },
      {
        "txt": "return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength"
      },
      {
        "txt": "+ \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null)"
      },
      {
        "txt": "{ continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i;"
      },
      {
        "txt": "} } } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) {"
      },
      {
        "txt": "continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) {"
      },
      {
        "txt": "for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||"
      },
      {
        "txt": "searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex;"
      },
      {
        "txt": "replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString();"
      },
      {
        "txt": "if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar);"
      },
      {
        "txt": "} public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length();"
      },
      {
        "txt": "int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); }"
      },
      {
        "txt": "} else { buf.append(ch); } } if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) {"
      },
      {
        "txt": "if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; }"
      },
      {
        "txt": "if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) {"
      },
      {
        "txt": "int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); }"
      },
      {
        "txt": "public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str;"
      },
      {
        "txt": "} int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; }"
      },
      {
        "txt": "return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str;"
      },
      {
        "txt": "} public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1;"
      },
      {
        "txt": "String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) {"
      },
      {
        "txt": "if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; }"
      },
      {
        "txt": "if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch;"
      },
      {
        "txt": "} return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; }"
      },
      {
        "txt": "return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) {"
      },
      {
        "txt": "if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);"
      },
      {
        "txt": "} final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); }"
      },
      {
        "txt": "public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar));"
      },
      {
        "txt": "} return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; }"
      },
      {
        "txt": "int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) {"
      },
      {
        "txt": "return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding));"
      },
      {
        "txt": "} } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length();"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) {"
      },
      {
        "txt": "return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads];"
      },
      {
        "txt": "char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); }"
      },
      {
        "txt": "public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) {"
      },
      {
        "txt": "return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; }"
      },
      {
        "txt": "if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr);"
      },
      {
        "txt": "return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); }"
      },
      {
        "txt": "public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; }"
      },
      {
        "txt": "int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1))"
      },
      {
        "txt": ".toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) {"
      },
      {
        "txt": "ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); }"
      },
      {
        "txt": "return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++;"
      },
      {
        "txt": "idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; }"
      },
      {
        "txt": "public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) {"
      },
      {
        "txt": "if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); }"
      },
      {
        "txt": "public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; }"
      },
      {
        "txt": "if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; }"
      },
      {
        "txt": "if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) {"
      },
      {
        "txt": "return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset));"
      },
      {
        "txt": "builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1;"
      },
      {
        "txt": "} int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } }"
      },
      {
        "txt": "if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false;"
      },
      {
        "txt": "boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false;"
      },
      {
        "txt": "shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; }"
      },
      {
        "txt": "int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) {"
      },
      {
        "txt": "break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) {"
      },
      {
        "txt": "return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY;"
      },
      {
        "txt": "} else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1,"
      },
      {
        "txt": "we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not"
      },
      {
        "txt": "cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s;"
      },
      {
        "txt": "s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t"
      },
      {
        "txt": "char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1;"
      },
      {
        "txt": "d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) {"
      },
      {
        "txt": "a = b; } if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); }"
      },
      {
        "txt": "public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; }"
      },
      {
        "txt": "return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true;"
      },
      {
        "txt": "} } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); }"
      },
      {
        "txt": "private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2357,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1678,
    "end-bug-line": 1678,
    "bug": "",
    "fix": "int csLast = csLen - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); }"
      },
      {
        "txt": "public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true;"
      },
      {
        "txt": "} for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs);"
      },
      {
        "txt": "} public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim();"
      },
      {
        "txt": "} public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str;"
      },
      {
        "txt": "} public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars);"
      },
      {
        "txt": "} public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++;"
      },
      {
        "txt": "} } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); }"
      },
      {
        "txt": "public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) {"
      },
      {
        "txt": "return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null);"
      },
      {
        "txt": "} public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); }"
      },
      {
        "txt": "return newArr; } public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);"
      },
      {
        "txt": "java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) {"
      },
      {
        "txt": "throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); }"
      },
      {
        "txt": "} else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); }"
      },
      {
        "txt": "public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else {"
      },
      {
        "txt": "index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1;"
      },
      {
        "txt": "if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr);"
      },
      {
        "txt": "} public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); }"
      },
      {
        "txt": "public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; }"
      },
      {
        "txt": "return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;"
      },
      {
        "txt": "} public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) {"
      },
      {
        "txt": "if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1;"
      },
      {
        "txt": "int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else {"
      },
      {
        "txt": "return true; } } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false;"
      },
      {
        "txt": "} return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer:"
      },
      {
        "txt": "for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i;"
      },
      {
        "txt": "} } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true;"
      },
      {
        "txt": "} if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; }"
      },
      {
        "txt": "} public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); <extra_id_0> for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; }"
      },
      {
        "txt": "return false; } } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; }"
      },
      {
        "txt": "return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp;"
      },
      {
        "txt": "} } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND;"
      },
      {
        "txt": "int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; }"
      },
      {
        "txt": "} return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative }"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) {"
      },
      {
        "txt": "return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length();"
      },
      {
        "txt": "} if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; }"
      },
      {
        "txt": "return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) {"
      },
      {
        "txt": "return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY;"
      },
      {
        "txt": "} if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len);"
      },
      {
        "txt": "} public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY;"
      },
      {
        "txt": "} int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str;"
      },
      {
        "txt": "} int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); }"
      },
      {
        "txt": "public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length());"
      },
      {
        "txt": "if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; }"
      },
      {
        "txt": "int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos);"
      },
      {
        "txt": "if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen;"
      },
      {
        "txt": "} if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) {"
      },
      {
        "txt": "return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ;"
      },
      {
        "txt": "} public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); }"
      },
      {
        "txt": "private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg);"
      },
      {
        "txt": "if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; }"
      },
      {
        "txt": "} else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } }"
      },
      {
        "txt": "beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) {"
      },
      {
        "txt": "return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length();"
      },
      {
        "txt": "if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) {"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++;"
      },
      {
        "txt": "} if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true;"
      },
      {
        "txt": "if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; }"
      },
      {
        "txt": "lastMatch = false; match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) {"
      },
      {
        "txt": "return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue;"
      },
      {
        "txt": "} if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos;"
      },
      {
        "txt": "} currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) {"
      },
      {
        "txt": "if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex);"
      },
      {
        "txt": "if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) {"
      },
      {
        "txt": "buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length);"
      },
      {
        "txt": "} public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) {"
      },
      {
        "txt": "return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) {"
      },
      {
        "txt": "buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) {"
      },
      {
        "txt": "return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); }"
      },
      {
        "txt": "while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) {"
      },
      {
        "txt": "if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); }"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) {"
      },
      {
        "txt": "buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator);"
      },
      {
        "txt": "} public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) {"
      },
      {
        "txt": "return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length());"
      },
      {
        "txt": "} return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; }"
      },
      {
        "txt": "public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; }"
      },
      {
        "txt": "char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) {"
      },
      {
        "txt": "return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0;"
      },
      {
        "txt": "int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); }"
      },
      {
        "txt": "public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {"
      },
      {
        "txt": "if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length;"
      },
      {
        "txt": "if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1;"
      },
      {
        "txt": "for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else {"
      },
      {
        "txt": "if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0;"
      },
      {
        "txt": "int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } }"
      },
      {
        "txt": "increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1;"
      },
      {
        "txt": "tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true;"
      },
      {
        "txt": "} else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) {"
      },
      {
        "txt": "buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) {"
      },
      {
        "txt": "return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY;"
      },
      {
        "txt": "} boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true;"
      },
      {
        "txt": "if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString(); }"
      },
      {
        "txt": "return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length();"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) {"
      },
      {
        "txt": "end = len; } if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay)"
      },
      {
        "txt": ".append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) {"
      },
      {
        "txt": "return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; }"
      },
      {
        "txt": "} else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) {"
      },
      {
        "txt": "return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) {"
      },
      {
        "txt": "return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } }"
      },
      {
        "txt": "return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length();"
      },
      {
        "txt": "if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0);"
      },
      {
        "txt": "char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) {"
      },
      {
        "txt": "output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString();"
      },
      {
        "txt": "} } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } }"
      },
      {
        "txt": "private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); }"
      },
      {
        "txt": "public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible"
      },
      {
        "txt": "} if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; }"
      },
      {
        "txt": "if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) {"
      },
      {
        "txt": "return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) {"
      },
      {
        "txt": "padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) {"
      },
      {
        "txt": "return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str);"
      },
      {
        "txt": "} public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) {"
      },
      {
        "txt": "return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } }"
      },
      {
        "txt": "public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; }"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) {"
      },
      {
        "txt": "if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str;"
      },
      {
        "txt": "} str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase();"
      },
      {
        "txt": "} public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1))"
      },
      {
        "txt": ".toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); }"
      },
      {
        "txt": "return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; }"
      },
      {
        "txt": "StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch);"
      },
      {
        "txt": "} buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0;"
      },
      {
        "txt": "int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; }"
      },
      {
        "txt": "public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); }"
      },
      {
        "txt": "public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); }"
      },
      {
        "txt": "if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\";"
      },
      {
        "txt": "if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3));"
      },
      {
        "txt": "} public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2;"
      },
      {
        "txt": "int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2;"
      },
      {
        "txt": "} if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); }"
      },
      {
        "txt": "public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) {"
      },
      {
        "txt": "break; } } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true;"
      },
      {
        "txt": "shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break;"
      },
      {
        "txt": "} } if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff;"
      },
      {
        "txt": "} public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; }"
      },
      {
        "txt": "return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\");"
      },
      {
        "txt": "} The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really"
      },
      {
        "txt": "copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n;"
      },
      {
        "txt": "} if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally"
      },
      {
        "txt": "int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1);"
      },
      {
        "txt": "d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n];"
      },
      {
        "txt": "} private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; }"
      },
      {
        "txt": "public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); }"
      },
      {
        "txt": "if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) {"
      },
      {
        "txt": "String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); }"
      },
      {
        "txt": "public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; }"
      },
      {
        "txt": "int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2358,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1679,
    "end-bug-line": 1679,
    "bug": "",
    "fix": "int searchLast = searchLen - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List;"
      },
      {
        "txt": "import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) {"
      },
      {
        "txt": "return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); } public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; }"
      },
      {
        "txt": "for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); }"
      },
      {
        "txt": "public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); }"
      },
      {
        "txt": "public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; }"
      },
      {
        "txt": "public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); }"
      },
      {
        "txt": "public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; }"
      },
      {
        "txt": "} else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) {"
      },
      {
        "txt": "int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str;"
      },
      {
        "txt": "} else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } } return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); }"
      },
      {
        "txt": "public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; } String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr;"
      },
      {
        "txt": "} public static String stripAccents(String input) { if(input == null) { return null; } if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );"
      },
      {
        "txt": "java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);"
      },
      {
        "txt": "} catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else {"
      },
      {
        "txt": "throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) {"
      },
      {
        "txt": "if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); } public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos);"
      },
      {
        "txt": "} public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1);"
      },
      {
        "txt": "} if (index < 0) { return index; } found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0);"
      },
      {
        "txt": "} public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); }"
      },
      {
        "txt": "public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); } public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) {"
      },
      {
        "txt": "startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {"
      },
      {
        "txt": "return i; } } return INDEX_NOT_FOUND; } public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0;"
      },
      {
        "txt": "} public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; } return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false;"
      },
      {
        "txt": "} int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; }"
      },
      {
        "txt": "public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "return i; } } } return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1;"
      },
      {
        "txt": "for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true;"
      },
      {
        "txt": "} } } } return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; }"
      },
      {
        "txt": "return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) {"
      },
      {
        "txt": "char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; } } return i; } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; }"
      },
      {
        "txt": "} return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; }"
      },
      {
        "txt": "if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray());"
      },
      {
        "txt": "public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; <extra_id_0> char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; } }"
      },
      {
        "txt": "} } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray());"
      },
      {
        "txt": "} public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i];"
      },
      {
        "txt": "if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; }"
      },
      {
        "txt": "} return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } }"
      },
      {
        "txt": "return ret; } public static String substring(String str, int start) { if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (start > str.length()) { return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null;"
      },
      {
        "txt": "} if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); }"
      },
      {
        "txt": "if (start > end) { return EMPTY; } if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end);"
      },
      {
        "txt": "} public static String left(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str;"
      },
      {
        "txt": "} return str.substring(0, len); } public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; }"
      },
      {
        "txt": "if (str.length() <= len) { return str; } return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) {"
      },
      {
        "txt": "return EMPTY; } if (pos < 0) { pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); }"
      },
      {
        "txt": "public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; }"
      },
      {
        "txt": "int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) {"
      },
      {
        "txt": "return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return str.substring(start + open.length(), end); } } return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length();"
      },
      {
        "txt": "if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) {"
      },
      {
        "txt": "break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; }"
      },
      {
        "txt": "if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false);"
      },
      {
        "txt": "} public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; }"
      },
      {
        "txt": "public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max,"
      },
      {
        "txt": "boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) {"
      },
      {
        "txt": "return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) {"
      },
      {
        "txt": "if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else {"
      },
      {
        "txt": "if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength;"
      },
      {
        "txt": "} } else { substrings.add(str.substring(beg)); end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true);"
      },
      {
        "txt": "} public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) {"
      },
      {
        "txt": "return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; lastMatch = true; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true);"
      },
      {
        "txt": "} private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) {"
      },
      {
        "txt": "i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false;"
      },
      {
        "txt": "match = true; i++; } } else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len;"
      },
      {
        "txt": "lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true;"
      },
      {
        "txt": "i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false);"
      },
      {
        "txt": "} public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY;"
      },
      {
        "txt": "} char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; }"
      },
      {
        "txt": "if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; }"
      },
      {
        "txt": "currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) {"
      },
      {
        "txt": "return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) {"
      },
      {
        "txt": "return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); }"
      },
      {
        "txt": "public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY;"
      },
      {
        "txt": "} bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY;"
      },
      {
        "txt": "} Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) {"
      },
      {
        "txt": "buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) {"
      },
      {
        "txt": "return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small"
      },
      {
        "txt": "if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj);"
      },
      {
        "txt": "} } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); }"
      },
      {
        "txt": "public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; }"
      },
      {
        "txt": "int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str;"
      },
      {
        "txt": "} return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); }"
      },
      {
        "txt": "return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str;"
      },
      {
        "txt": "} public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; }"
      },
      {
        "txt": "public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray();"
      },
      {
        "txt": "int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1);"
      },
      {
        "txt": "} public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start);"
      },
      {
        "txt": "if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement);"
      },
      {
        "txt": "start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) {"
      },
      {
        "txt": "return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null ||"
      },
      {
        "txt": "searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) {"
      },
      {
        "txt": "if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) {"
      },
      {
        "txt": "textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0; int increase = 0;"
      },
      {
        "txt": "for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5);"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1;"
      },
      {
        "txt": "for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else {"
      },
      {
        "txt": "if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i));"
      },
      {
        "txt": "} String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; }"
      },
      {
        "txt": "boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) {"
      },
      {
        "txt": "buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); } } if (modified) { return buf.toString(); } return str;"
      },
      {
        "txt": "} public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) {"
      },
      {
        "txt": "start = 0; } if (start > len) { start = len; } if (end < 0) { end = 0; } if (end > len) { end = len;"
      },
      {
        "txt": "} if (start > end) { int temp = start; start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end))"
      },
      {
        "txt": ".toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY;"
      },
      {
        "txt": "} return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) {"
      },
      {
        "txt": "lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length());"
      },
      {
        "txt": "} return str; } public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY;"
      },
      {
        "txt": "} int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret;"
      },
      {
        "txt": "} public static String repeat(String str, int repeat) { if (str == null) { return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) {"
      },
      {
        "txt": "return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength];"
      },
      {
        "txt": "for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0;"
      },
      {
        "txt": "output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); }"
      },
      {
        "txt": "} public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {"
      },
      {
        "txt": "if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) {"
      },
      {
        "txt": "return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0));"
      },
      {
        "txt": "} if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen];"
      },
      {
        "txt": "} return str.concat(new String(padding)); } } public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null;"
      },
      {
        "txt": "} int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); }"
      },
      {
        "txt": "public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str);"
      },
      {
        "txt": "} else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) {"
      },
      {
        "txt": "return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length();"
      },
      {
        "txt": "int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) {"
      },
      {
        "txt": "return str; } if (isEmpty(padStr)) { padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; }"
      },
      {
        "txt": "str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); }"
      },
      {
        "txt": "public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) {"
      },
      {
        "txt": "return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString();"
      },
      {
        "txt": "} public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen)"
      },
      {
        "txt": ".append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen);"
      },
      {
        "txt": "char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); }"
      },
      {
        "txt": "buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0;"
      },
      {
        "txt": "while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; }"
      },
      {
        "txt": "int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) {"
      },
      {
        "txt": "return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; }"
      },
      {
        "txt": "public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false;"
      },
      {
        "txt": "} } return true; } public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) {"
      },
      {
        "txt": "if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) {"
      },
      {
        "txt": "return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString();"
      },
      {
        "txt": "} public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) {"
      },
      {
        "txt": "return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) {"
      },
      {
        "txt": "return str; } if (offset > str.length()) { offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) {"
      },
      {
        "txt": "return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); }"
      },
      {
        "txt": "public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2;"
      },
      {
        "txt": "StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; }"
      },
      {
        "txt": "if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {"
      },
      {
        "txt": "if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break;"
      },
      {
        "txt": "} } if (i < cs2.length() || i < cs1.length()) { return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0;"
      },
      {
        "txt": "} else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) {"
      },
      {
        "txt": "return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; }"
      },
      {
        "txt": "} if (firstDiff != -1) { break; } } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; }"
      },
      {
        "txt": "public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0];"
      },
      {
        "txt": "} else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); }"
      },
      {
        "txt": "The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array"
      },
      {
        "txt": "or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; }"
      },
      {
        "txt": "if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d"
      },
      {
        "txt": "int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j;"
      },
      {
        "txt": "for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p; p = d; d = _d; } return p[n]; }"
      },
      {
        "txt": "private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) {"
      },
      {
        "txt": "return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) {"
      },
      {
        "txt": "return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i];"
      },
      {
        "txt": "if (StringUtils.startsWith(string, searchString)) { return true; } } return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) {"
      },
      {
        "txt": "return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length();"
      },
      {
        "txt": "return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2359,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1683,
    "end-bug-line": 1683,
    "bug": "",
    "fix": "if (Character.isHighSurrogate(ch)) { if (j == searchLast) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\";"
      },
      {
        "txt": "public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs);"
      },
      {
        "txt": "} public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) {"
      },
      {
        "txt": "String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str;"
      },
      {
        "txt": "} int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {"
      },
      {
        "txt": "start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; }"
      },
      {
        "txt": "if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; }"
      },
      {
        "txt": "} return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs;"
      },
      {
        "txt": "} String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null;"
      },
      {
        "txt": "} if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\");"
      },
      {
        "txt": "} catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);"
      },
      {
        "txt": "} catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) {"
      },
      {
        "txt": "return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar);"
      },
      {
        "txt": "} public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) {"
      },
      {
        "txt": "return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0;"
      },
      {
        "txt": "int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; }"
      },
      {
        "txt": "found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos;"
      },
      {
        "txt": "} for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length());"
      },
      {
        "txt": "} public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false;"
      },
      {
        "txt": "} return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; } } } }"
      },
      {
        "txt": "return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer;"
      },
      {
        "txt": "} } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) {"
      },
      {
        "txt": "if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true;"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { <extra_id_0> return false; } } } return true; }"
      },
      {
        "txt": "return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; }"
      },
      {
        "txt": "tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; }"
      },
      {
        "txt": "public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) {"
      },
      {
        "txt": "continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) {"
      },
      {
        "txt": "if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative"
      },
      {
        "txt": "} if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; }"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); }"
      },
      {
        "txt": "public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; }"
      },
      {
        "txt": "return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) {"
      },
      {
        "txt": "pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str;"
      },
      {
        "txt": "} if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); }"
      },
      {
        "txt": "public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY;"
      },
      {
        "txt": "} return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) {"
      },
      {
        "txt": "if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } }"
      },
      {
        "txt": "return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen;"
      },
      {
        "txt": "int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; }"
      },
      {
        "txt": "return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false);"
      },
      {
        "txt": "} public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); }"
      },
      {
        "txt": "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length();"
      },
      {
        "txt": "ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) {"
      },
      {
        "txt": "end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) {"
      },
      {
        "txt": "end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg));"
      },
      {
        "txt": "end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true);"
      },
      {
        "txt": "} private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); }"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false;"
      },
      {
        "txt": "boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } }"
      },
      {
        "txt": "if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true);"
      },
      {
        "txt": "} private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) {"
      },
      {
        "txt": "list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart));"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length);"
      },
      {
        "txt": "} public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null;"
      },
      {
        "txt": "} if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) {"
      },
      {
        "txt": "return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) {"
      },
      {
        "txt": "buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) {"
      },
      {
        "txt": "return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); }"
      },
      {
        "txt": "while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null;"
      },
      {
        "txt": "} return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count); }"
      },
      {
        "txt": "public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) {"
      },
      {
        "txt": "chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1);"
      },
      {
        "txt": "} public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; }"
      },
      {
        "txt": "int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break;"
      },
      {
        "txt": "} end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {"
      },
      {
        "txt": "int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text;"
      },
      {
        "txt": "} if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \""
      },
      {
        "txt": "+ replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {"
      },
      {
        "txt": "continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; }"
      },
      {
        "txt": "} } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue;"
      },
      {
        "txt": "} int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) {"
      },
      {
        "txt": "buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null)"
      },
      {
        "txt": "{ continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i;"
      },
      {
        "txt": "} } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) {"
      },
      {
        "txt": "return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); }"
      },
      {
        "txt": "public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length();"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else {"
      },
      {
        "txt": "buf.append(ch); } } if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) {"
      },
      {
        "txt": "return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) {"
      },
      {
        "txt": "start = len; } if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start;"
      },
      {
        "txt": "start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; }"
      },
      {
        "txt": "int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx);"
      },
      {
        "txt": "} public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; }"
      },
      {
        "txt": "public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx);"
      },
      {
        "txt": "char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) {"
      },
      {
        "txt": "return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) {"
      },
      {
        "txt": "return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; }"
      },
      {
        "txt": "return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2);"
      },
      {
        "txt": "default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) {"
      },
      {
        "txt": "return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); }"
      },
      {
        "txt": "final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) {"
      },
      {
        "txt": "if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); }"
      },
      {
        "txt": "return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length();"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr);"
      },
      {
        "txt": "} else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); }"
      },
      {
        "txt": "} public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null;"
      },
      {
        "txt": "} if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray();"
      },
      {
        "txt": "for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) {"
      },
      {
        "txt": "return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str;"
      },
      {
        "txt": "} str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str;"
      },
      {
        "txt": "} public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen;"
      },
      {
        "txt": "if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) {"
      },
      {
        "txt": "return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString();"
      },
      {
        "txt": "} public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i);"
      },
      {
        "txt": "if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString();"
      },
      {
        "txt": "} public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length();"
      },
      {
        "txt": "} return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {"
      },
      {
        "txt": "return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) {"
      },
      {
        "txt": "return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) {"
      },
      {
        "txt": "if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) {"
      },
      {
        "txt": "offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str;"
      },
      {
        "txt": "} if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle);"
      },
      {
        "txt": "builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; }"
      },
      {
        "txt": "int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) {"
      },
      {
        "txt": "return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true;"
      },
      {
        "txt": "int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen);"
      },
      {
        "txt": "longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1;"
      },
      {
        "txt": "for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break;"
      },
      {
        "txt": "} } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY;"
      },
      {
        "txt": "} int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else {"
      },
      {
        "txt": "return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d,"
      },
      {
        "txt": "is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings."
      },
      {
        "txt": "int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t;"
      },
      {
        "txt": "t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t"
      },
      {
        "txt": "int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost);"
      },
      {
        "txt": "} _d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b;"
      },
      {
        "txt": "} if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) {"
      },
      {
        "txt": "return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());"
      },
      {
        "txt": "} public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; }"
      },
      {
        "txt": "} return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) {"
      },
      {
        "txt": "if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2360,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1684,
    "end-bug-line": 1684,
    "bug": "",
    "fix": "return false; } if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { return false; } } else {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\";"
      },
      {
        "txt": "public static final int INDEX_NOT_FOUND = -1; private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs);"
      },
      {
        "txt": "} public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) {"
      },
      {
        "txt": "String ts = trim(str); return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str;"
      },
      {
        "txt": "} int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {"
      },
      {
        "txt": "start++; } } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; }"
      },
      {
        "txt": "if (stripChars == null) { while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; }"
      },
      {
        "txt": "} return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs;"
      },
      {
        "txt": "} String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null;"
      },
      {
        "txt": "} if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\");"
      },
      {
        "txt": "} catch(ClassNotFoundException cnfe) { throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);"
      },
      {
        "txt": "} catch(java.lang.reflect.InvocationTargetException ite) { throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) {"
      },
      {
        "txt": "return cs1 == null ? cs2 == null : cs1.equals(cs2); } public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar);"
      },
      {
        "txt": "} public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) {"
      },
      {
        "txt": "return ordinalIndexOf(str, searchStr, ordinal, false); } private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0;"
      },
      {
        "txt": "int index = lastIndex ? str.length() : INDEX_NOT_FOUND; do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; }"
      },
      {
        "txt": "found++; } while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos;"
      },
      {
        "txt": "} for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); }"
      },
      {
        "txt": "public static int lastIndexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length());"
      },
      {
        "txt": "} public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false;"
      },
      {
        "txt": "} return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) {"
      },
      {
        "txt": "if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return false; } int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) {"
      },
      {
        "txt": "if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; } } } }"
      },
      {
        "txt": "return false; } public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer;"
      },
      {
        "txt": "} } return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) {"
      },
      {
        "txt": "if (valid == null || cs == null) { return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true;"
      },
      {
        "txt": "int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { <extra_id_0> return false; } } } return true; }"
      },
      {
        "txt": "return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; }"
      },
      {
        "txt": "tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; }"
      },
      {
        "txt": "public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) {"
      },
      {
        "txt": "continue; } tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) {"
      },
      {
        "txt": "if (str == null) { return null; } if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative"
      },
      {
        "txt": "} if (start < 0) { start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; }"
      },
      {
        "txt": "if (start < 0) { start = 0; } if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); }"
      },
      {
        "txt": "public static String right(String str, int len) { if (str == null) { return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; }"
      },
      {
        "txt": "return str.substring(str.length() - len); } public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) {"
      },
      {
        "txt": "pos = 0; } if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str;"
      },
      {
        "txt": "} if (separator.length() == 0) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); }"
      },
      {
        "txt": "public static String substringAfter(String str, String separator) { if (isEmpty(str)) { return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY;"
      },
      {
        "txt": "} return str.substring(pos + separator.length()); } public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str;"
      },
      {
        "txt": "} return str.substring(0, pos); } public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; }"
      },
      {
        "txt": "int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) { return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) {"
      },
      {
        "txt": "if (str == null || open == null || close == null) { return null; } int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } }"
      },
      {
        "txt": "return null; } public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; }"
      },
      {
        "txt": "int closeLen = close.length(); int openLen = open.length(); List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen;"
      },
      {
        "txt": "int end = str.indexOf(close, start); if (end < 0) { break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; }"
      },
      {
        "txt": "return list.toArray(new String [list.size()]); } public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false);"
      },
      {
        "txt": "} public static String[] split(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); }"
      },
      {
        "txt": "public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length();"
      },
      {
        "txt": "ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0; int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) {"
      },
      {
        "txt": "end = len; substrings.add(str.substring(beg)); } else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) {"
      },
      {
        "txt": "end = len; substrings.add(str.substring(beg)); } else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg));"
      },
      {
        "txt": "end = len; } } return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true);"
      },
      {
        "txt": "} private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) { if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int i = 0, start = 0; boolean match = false; boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); }"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) {"
      },
      {
        "txt": "return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false;"
      },
      {
        "txt": "boolean lastMatch = false; if (separatorChars == null) { while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0); while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; }"
      },
      {
        "txt": "list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; }"
      },
      {
        "txt": "} else { while (i < len) { if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i));"
      },
      {
        "txt": "match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } }"
      },
      {
        "txt": "if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true);"
      },
      {
        "txt": "} private static String[] splitByCharacterType(String str, boolean camelCase) { if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>();"
      },
      {
        "txt": "int tokenStart = 0; int currentType = Character.getType(c[tokenStart]); for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) {"
      },
      {
        "txt": "list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart; } } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart));"
      },
      {
        "txt": "return list.toArray(new String[list.size()]); } public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length);"
      },
      {
        "txt": "} public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Object[] array, String separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null;"
      },
      {
        "txt": "} if (separator == null) { separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterator<?> iterator, char separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) {"
      },
      {
        "txt": "return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) {"
      },
      {
        "txt": "buf.append(obj); } } return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) {"
      },
      {
        "txt": "return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); }"
      },
      {
        "txt": "while (iterator.hasNext()) { if (separator != null) { buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString();"
      },
      {
        "txt": "} public static String join(Iterable<?> iterable, char separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null;"
      },
      {
        "txt": "} return join(iterable.iterator(), separator); } public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0;"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) { chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count); }"
      },
      {
        "txt": "public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(remove)) { return str; } if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (endsWithIgnoreCase(str, remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "return replace(str, remove, EMPTY, -1); } public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) {"
      },
      {
        "txt": "chars[pos++] = chars[i]; } } return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1);"
      },
      {
        "txt": "} public static String replace(String text, String searchString, String replacement, int max) { if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; }"
      },
      {
        "txt": "int replLength = searchString.length(); int increase = replacement.length() - replLength; increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break;"
      },
      {
        "txt": "} end = text.indexOf(searchString, start); } buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {"
      },
      {
        "txt": "int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive); } private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text;"
      },
      {
        "txt": "} if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \""
      },
      {
        "txt": "+ replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {"
      },
      {
        "txt": "continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; }"
      },
      {
        "txt": "} } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue;"
      },
      {
        "txt": "} int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) {"
      },
      {
        "txt": "buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null)"
      },
      {
        "txt": "{ continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i;"
      },
      {
        "txt": "} } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) {"
      },
      {
        "txt": "return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); }"
      },
      {
        "txt": "public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) { return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length();"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) { char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else {"
      },
      {
        "txt": "buf.append(ch); } } if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) {"
      },
      {
        "txt": "return null; } if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) {"
      },
      {
        "txt": "start = len; } if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start;"
      },
      {
        "txt": "start = end; end = temp; } return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) {"
      },
      {
        "txt": "if (isEmpty(str)) { return str; } if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; }"
      },
      {
        "txt": "int lastIdx = str.length() - 1; char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx);"
      },
      {
        "txt": "} public static String chomp(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; }"
      },
      {
        "txt": "public static String chop(String str) { if (str == null) { return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx);"
      },
      {
        "txt": "char last = str.charAt(lastIdx); if (last == CharUtils.LF) { if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) {"
      },
      {
        "txt": "return null; } if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) {"
      },
      {
        "txt": "return padding(repeat, str.charAt(0)); } int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; }"
      },
      {
        "txt": "return new String(output1); case 2 : char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2);"
      },
      {
        "txt": "default : StringBuilder buf = new StringBuilder(outputLength); for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) {"
      },
      {
        "txt": "return repeat(str, repeat); } else { String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); }"
      },
      {
        "txt": "final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) { buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) {"
      },
      {
        "txt": "if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); }"
      },
      {
        "txt": "return str.concat(padding(pads, padChar)); } public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length();"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr);"
      },
      {
        "txt": "} else if (pads < padLen) { return str.concat(padStr.substring(0, pads)); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); }"
      },
      {
        "txt": "} public static String leftPad(String str, int size) { return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) {"
      },
      {
        "txt": "return str; // returns original String when possible } if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null;"
      },
      {
        "txt": "} if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray();"
      },
      {
        "txt": "for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) {"
      },
      {
        "txt": "return center(str, size, ' '); } public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str;"
      },
      {
        "txt": "} str = leftPad(str, strLen + pads / 2, padChar); str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str;"
      },
      {
        "txt": "} public static String upperCase(String str) { if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toUpperCase(locale); } public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen;"
      },
      {
        "txt": "if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) {"
      },
      {
        "txt": "return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString();"
      },
      {
        "txt": "} public static String swapCase(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i);"
      },
      {
        "txt": "if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString();"
      },
      {
        "txt": "} public static int countMatches(String str, String sub) { if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length();"
      },
      {
        "txt": "} return count; } public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAsciiPrintable(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAllUpperCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {"
      },
      {
        "txt": "return StringUtils.isEmpty(str) ? defaultStr : str; } public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) {"
      },
      {
        "txt": "return null; } String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) {"
      },
      {
        "txt": "if (str == null) { return null; } if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) {"
      },
      {
        "txt": "offset = str.length(); } if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); } if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str;"
      },
      {
        "txt": "} if (length >= str.length() || length < (middle.length()+2)) { return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle);"
      },
      {
        "txt": "builder.append(str.substring(endOffset)); return builder.toString(); } public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; }"
      },
      {
        "txt": "int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) { return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (cs1 == null || cs2 == null) { return 0; } int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) {"
      },
      {
        "txt": "return i; } return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true;"
      },
      {
        "txt": "int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE; int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen);"
      },
      {
        "txt": "longestStrLen = Math.max(css[i].length(), longestStrLen); } } if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1;"
      },
      {
        "txt": "for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos); for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break;"
      },
      {
        "txt": "} } if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY;"
      },
      {
        "txt": "} int smallestIndexOfDiff = indexOfDifference(strs); if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else {"
      },
      {
        "txt": "return strs[0].substring(0, smallestIndexOfDiff); } } public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d,"
      },
      {
        "txt": "is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings."
      },
      {
        "txt": "int n = s.length(); // length of s int m = t.length(); // length of t if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t;"
      },
      {
        "txt": "t = tmp; n = m; m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t"
      },
      {
        "txt": "int cost; // cost for (i = 0; i<=n; i++) { p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost);"
      },
      {
        "txt": "} _d = p; p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b;"
      },
      {
        "txt": "} if (c < a) { a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) {"
      },
      {
        "txt": "return startsWith(str, prefix, true); } private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());"
      },
      {
        "txt": "} public static boolean startsWithAny(String string, String[] searchStrings) { if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; }"
      },
      {
        "txt": "} return false; } public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) {"
      },
      {
        "txt": "if (str == null || suffix == null) { return str == null && suffix == null; } if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  },
  {
    "id": 2361,
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java",
    "start-bug-line": 1686,
    "end-bug-line": 1686,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Locale; import org.apache.commons.lang3.text.WordUtils; public class StringUtils { public static final String EMPTY = \"\"; public static final int INDEX_NOT_FOUND = -1;"
      },
      {
        "txt": "private static final int PAD_LIMIT = 8192; public StringUtils() { super(); } public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; } public static boolean isNotEmpty(CharSequence cs) { return !StringUtils.isEmpty(cs); }"
      },
      {
        "txt": "public static boolean isBlank(CharSequence cs) { int strLen; if (cs == null || (strLen = cs.length()) == 0) { return true; } for (int i = 0; i < strLen; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isNotBlank(CharSequence cs) { return !StringUtils.isBlank(cs); } public static String trim(String str) { return str == null ? null : str.trim(); } public static String trimToNull(String str) { String ts = trim(str);"
      },
      {
        "txt": "return isEmpty(ts) ? null : ts; } public static String trimToEmpty(String str) { return str == null ? EMPTY : str.trim(); } public static String strip(String str) { return strip(str, null); } public static String stripToNull(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } str = strip(str, null); return str.length() == 0 ? null : str; } public static String stripToEmpty(String str) { return str == null ? EMPTY : strip(str, null); } public static String strip(String str, String stripChars) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } str = stripStart(str, stripChars); return stripEnd(str, stripChars); } public static String stripStart(String str, String stripChars) { int strLen; if (str == null || (strLen = str.length()) == 0) { return str; }"
      },
      {
        "txt": "int start = 0; if (stripChars == null) { while ((start != strLen) && Character.isWhitespace(str.charAt(start))) { start++; } } else if (stripChars.length() == 0) { return str; } else { while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) { start++;"
      },
      {
        "txt": "} } return str.substring(start); } public static String stripEnd(String str, String stripChars) { int end; if (str == null || (end = str.length()) == 0) { return str; } if (stripChars == null) {"
      },
      {
        "txt": "while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) { end--; } } else if (stripChars.length() == 0) { return str; } else { while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) { end--; } }"
      },
      {
        "txt": "return str.substring(0, end); } public static String[] stripAll(String[] strs) { return stripAll(strs, null); } public static String[] stripAll(String[] strs, String stripChars) { int strsLen; if (strs == null || (strsLen = strs.length) == 0) { return strs; }"
      },
      {
        "txt": "String[] newArr = new String[strsLen]; for (int i = 0; i < strsLen; i++) { newArr[i] = strip(strs[i], stripChars); } return newArr; } public static String stripAccents(String input) { if(input == null) { return null; }"
      },
      {
        "txt": "if(SystemUtils.isJavaVersionAtLeast(1.6f)) { try { Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false); Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false); java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass ); java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\"); String decomposed = (String) method.invoke( null, input, nfd.get(null) ); java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\"); return accentPattern.matcher(decomposed).replaceAll(\"\"); } catch(ClassNotFoundException cnfe) {"
      },
      {
        "txt": "throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe); } catch(NoSuchMethodException nsme) { throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme); } catch(NoSuchFieldException nsfe) { throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe); } catch(IllegalAccessException iae) { throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae); } catch(IllegalArgumentException iae) { throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae); } catch(java.lang.reflect.InvocationTargetException ite) {"
      },
      {
        "txt": "throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite); } catch(SecurityException se) { throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se); } } else { throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\"); } } public static boolean equals(CharSequence cs1, CharSequence cs2) { return cs1 == null ? cs2 == null : cs1.equals(cs2);"
      },
      {
        "txt": "} public static boolean equalsIgnoreCase(String str1, String str2) { return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2); } public static int indexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar); }"
      },
      {
        "txt": "public static int indexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.indexOf(searchChar, startPos); } public static int indexOf(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "return str.indexOf(searchStr); } public static int indexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.indexOf(searchStr, startPos); } public static int ordinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, false);"
      },
      {
        "txt": "} private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) { if (str == null || searchStr == null || ordinal <= 0) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return lastIndex ? str.length() : 0; } int found = 0; int index = lastIndex ? str.length() : INDEX_NOT_FOUND;"
      },
      {
        "txt": "do { if(lastIndex) { index = str.lastIndexOf(searchStr, index - 1); } else { index = str.indexOf(searchStr, index + 1); } if (index < 0) { return index; } found++;"
      },
      {
        "txt": "} while (found < ordinal); return index; } public static int indexOfIgnoreCase(String str, String searchStr) { return indexOfIgnoreCase(str, searchStr, 0); } public static int indexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (startPos < 0) { startPos = 0; } int endLimit = (str.length() - searchStr.length()) + 1; if (startPos > endLimit) { return INDEX_NOT_FOUND; } if (searchStr.length() == 0) { return startPos; }"
      },
      {
        "txt": "for (int i = startPos; i < endLimit; i++) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; } public static int lastIndexOf(String str, char searchChar) { if (isEmpty(str)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} return str.lastIndexOf(searchChar); } public static int lastIndexOf(String str, char searchChar, int startPos) { if (isEmpty(str)) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchChar, startPos); } public static int lastIndexOf(String str, String searchStr) {"
      },
      {
        "txt": "if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr); } public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) { return ordinalIndexOf(str, searchStr, ordinal, true); } public static int lastIndexOf(String str, String searchStr, int startPos) { if (str == null || searchStr == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } return str.lastIndexOf(searchStr, startPos); } public static int lastIndexOfIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } return lastIndexOfIgnoreCase(str, searchStr, str.length()); }"
      },
      {
        "txt": "public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) { if (str == null || searchStr == null) { return INDEX_NOT_FOUND; } if (startPos > (str.length() - searchStr.length())) { startPos = str.length() - searchStr.length(); } if (startPos < 0) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "if (searchStr.length() == 0) { return startPos; } for (int i = startPos; i >= 0; i--) { if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) { return i; } } return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static boolean contains(String str, char searchChar) { if (isEmpty(str)) { return false; } return str.indexOf(searchChar) >= 0; } public static boolean contains(String str, String searchStr) { if (str == null || searchStr == null) { return false; }"
      },
      {
        "txt": "return str.indexOf(searchStr) >= 0; } public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) {"
      },
      {
        "txt": "return true; } } return false; } public static int indexOfAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int csLen = cs.length();"
      },
      {
        "txt": "int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return i; } } } return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} public static int indexOfAny(CharSequence cs, String searchChars) { if (isEmpty(cs) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } return indexOfAny(cs, searchChars.toCharArray()); } public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false;"
      },
      {
        "txt": "} int csLength = cs.length(); int searchLength = searchChars.length; int csLast = csLength - 1; int searchLast = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {"
      },
      {
        "txt": "if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { return true; } } } } return false;"
      },
      {
        "txt": "} public static boolean containsAny(CharSequence cs, String searchChars) { if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); } public static int indexOfAnyBut(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return INDEX_NOT_FOUND;"
      },
      {
        "txt": "} int csLen = cs.length(); int searchLen = searchChars.length; outer: for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { continue outer; }"
      },
      {
        "txt": "} return i; } return INDEX_NOT_FOUND; } public static int indexOfAnyBut(String str, String searchChars) { if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length();"
      },
      {
        "txt": "for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; } public static boolean containsOnly(CharSequence cs, char[] valid) { if (valid == null || cs == null) {"
      },
      {
        "txt": "return false; } if (cs.length() == 0) { return true; } if (valid.length == 0) { return false; } return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND; }"
      },
      {
        "txt": "public static boolean containsOnly(CharSequence cs, String validChars) { if (cs == null || validChars == null) { return false; } return containsOnly(cs, validChars.toCharArray()); } public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; }"
      },
      {
        "txt": "int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { return false; <extra_id_0> } } return true; } public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) {"
      },
      {
        "txt": "public static boolean containsNone(CharSequence cs, String invalidChars) { if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); } public static int indexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; }"
      },
      {
        "txt": "int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; } public static int lastIndexOfAny(String str, String[] searchStrs) { if (str == null || searchStrs == null) {"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = INDEX_NOT_FOUND; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; }"
      },
      {
        "txt": "tmp = str.lastIndexOf(search); if (tmp > ret) { ret = tmp; } } return ret; } public static String substring(String str, int start) { if (str == null) { return null;"
      },
      {
        "txt": "} if (start < 0) { start = str.length() + start; // remember start is negative } if (start < 0) { start = 0; } if (start > str.length()) { return EMPTY; }"
      },
      {
        "txt": "return str.substring(start); } public static String substring(String str, int start, int end) { if (str == null) { return null; } if (end < 0) { end = str.length() + end; // remember end is negative } if (start < 0) {"
      },
      {
        "txt": "start = str.length() + start; // remember start is negative } if (end > str.length()) { end = str.length(); } if (start > end) { return EMPTY; } if (start < 0) { start = 0;"
      },
      {
        "txt": "} if (end < 0) { end = 0; } return str.substring(start, end); } public static String left(String str, int len) { if (str == null) { return null; }"
      },
      {
        "txt": "if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(0, len); } public static String right(String str, int len) { if (str == null) {"
      },
      {
        "txt": "return null; } if (len < 0) { return EMPTY; } if (str.length() <= len) { return str; } return str.substring(str.length() - len); }"
      },
      {
        "txt": "public static String mid(String str, int pos, int len) { if (str == null) { return null; } if (len < 0 || pos > str.length()) { return EMPTY; } if (pos < 0) { pos = 0; }"
      },
      {
        "txt": "if (str.length() <= (pos + len)) { return str.substring(pos); } return str.substring(pos, pos + len); } public static String substringBefore(String str, String separator) { if (isEmpty(str) || separator == null) { return str; } if (separator.length() == 0) {"
      },
      {
        "txt": "return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos); } public static String substringAfter(String str, String separator) { if (isEmpty(str)) {"
      },
      {
        "txt": "return str; } if (separator == null) { return EMPTY; } int pos = str.indexOf(separator); if (pos == INDEX_NOT_FOUND) { return EMPTY; } return str.substring(pos + separator.length());"
      },
      {
        "txt": "} public static String substringBeforeLast(String str, String separator) { if (isEmpty(str) || isEmpty(separator)) { return str; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND) { return str; } return str.substring(0, pos);"
      },
      {
        "txt": "} public static String substringAfterLast(String str, String separator) { if (isEmpty(str)) { return str; } if (isEmpty(separator)) { return EMPTY; } int pos = str.lastIndexOf(separator); if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {"
      },
      {
        "txt": "return EMPTY; } return str.substring(pos + separator.length()); } public static String substringBetween(String str, String tag) { return substringBetween(str, tag, tag); } public static String substringBetween(String str, String open, String close) { if (str == null || open == null || close == null) { return null;"
      },
      {
        "txt": "} int start = str.indexOf(open); if (start != INDEX_NOT_FOUND) { int end = str.indexOf(close, start + open.length()); if (end != INDEX_NOT_FOUND) { return str.substring(start + open.length(), end); } } return null; }"
      },
      {
        "txt": "public static String[] substringsBetween(String str, String open, String close) { if (str == null || isEmpty(open) || isEmpty(close)) { return null; } int strLen = str.length(); if (strLen == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } int closeLen = close.length(); int openLen = open.length();"
      },
      {
        "txt": "List<String> list = new ArrayList<String>(); int pos = 0; while (pos < (strLen - closeLen)) { int start = str.indexOf(open, pos); if (start < 0) { break; } start += openLen; int end = str.indexOf(close, start); if (end < 0) {"
      },
      {
        "txt": "break; } list.add(str.substring(start, end)); pos = end + closeLen; } if (list.isEmpty()) { return null; } return list.toArray(new String [list.size()]); }"
      },
      {
        "txt": "public static String[] split(String str) { return split(str, null, -1); } public static String[] split(String str, char separatorChar) { return splitWorker(str, separatorChar, false); } public static String[] split(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, false); } public static String[] split(String str, String separatorChars, int max) {"
      },
      {
        "txt": "return splitWorker(str, separatorChars, max, false); } public static String[] splitByWholeSeparator(String str, String separator) { return splitByWholeSeparatorWorker( str, separator, -1, false ) ; } public static String[] splitByWholeSeparator( String str, String separator, int max ) { return splitByWholeSeparatorWorker(str, separator, max, false); } public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) { return splitByWholeSeparatorWorker(str, separator, -1, true);"
      },
      {
        "txt": "} public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) { return splitByWholeSeparatorWorker(str, separator, max, true); } private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) { if (str == null) { return null; }"
      },
      {
        "txt": "int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } if ((separator == null) || (EMPTY.equals(separator))) { return splitWorker(str, null, max, preserveAllTokens); } int separatorLength = separator.length(); ArrayList<String> substrings = new ArrayList<String>(); int numberOfSubstrings = 0;"
      },
      {
        "txt": "int beg = 0; int end = 0; while (end < len) { end = str.indexOf(separator, beg); if (end > -1) { if (end > beg) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg));"
      },
      {
        "txt": "} else { substrings.add(str.substring(beg, end)); beg = end + separatorLength; } } else { if (preserveAllTokens) { numberOfSubstrings += 1; if (numberOfSubstrings == max) { end = len; substrings.add(str.substring(beg));"
      },
      {
        "txt": "} else { substrings.add(EMPTY); } } beg = end + separatorLength; } } else { substrings.add(str.substring(beg)); end = len; }"
      },
      {
        "txt": "} return substrings.toArray(new String[substrings.size()]); } public static String[] splitPreserveAllTokens(String str) { return splitWorker(str, null, -1, true); } public static String[] splitPreserveAllTokens(String str, char separatorChar) { return splitWorker(str, separatorChar, true); } private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {"
      },
      {
        "txt": "if (str == null) { return null; } int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int i = 0, start = 0; boolean match = false;"
      },
      {
        "txt": "boolean lastMatch = false; while (i < len) { if (str.charAt(i) == separatorChar) { if (match || preserveAllTokens) { list.add(str.substring(start, i)); match = false; lastMatch = true; } start = ++i; continue;"
      },
      {
        "txt": "} lastMatch = false; match = true; i++; } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i)); } return list.toArray(new String[list.size()]); }"
      },
      {
        "txt": "public static String[] splitPreserveAllTokens(String str, String separatorChars) { return splitWorker(str, separatorChars, -1, true); } public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) { return splitWorker(str, separatorChars, max, true); } private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) { if (str == null) { return null; }"
      },
      {
        "txt": "int len = str.length(); if (len == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } List<String> list = new ArrayList<String>(); int sizePlus1 = 1; int i = 0, start = 0; boolean match = false; boolean lastMatch = false; if (separatorChars == null) {"
      },
      {
        "txt": "while (i < len) { if (Character.isWhitespace(str.charAt(i))) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } } else if (separatorChars.length() == 1) { char sep = separatorChars.charAt(0);"
      },
      {
        "txt": "while (i < len) { if (str.charAt(i) == sep) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false;"
      },
      {
        "txt": "} start = ++i; continue; } lastMatch = false; match = true; i++; } } else { while (i < len) {"
      },
      {
        "txt": "if (separatorChars.indexOf(str.charAt(i)) >= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; }"
      },
      {
        "txt": "start = ++i; continue; } lastMatch = false; match = true; i++; } } if (match || (preserveAllTokens && lastMatch)) { list.add(str.substring(start, i));"
      },
      {
        "txt": "} return list.toArray(new String[list.size()]); } public static String[] splitByCharacterType(String str) { return splitByCharacterType(str, false); } public static String[] splitByCharacterTypeCamelCase(String str) { return splitByCharacterType(str, true); } private static String[] splitByCharacterType(String str, boolean camelCase) {"
      },
      {
        "txt": "if (str == null) { return null; } if (str.length() == 0) { return ArrayUtils.EMPTY_STRING_ARRAY; } char[] c = str.toCharArray(); List<String> list = new ArrayList<String>(); int tokenStart = 0; int currentType = Character.getType(c[tokenStart]);"
      },
      {
        "txt": "for (int pos = tokenStart + 1; pos < c.length; pos++) { int type = Character.getType(c[pos]); if (type == currentType) { continue; } if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) { int newTokenStart = pos - 1; if (newTokenStart != tokenStart) { list.add(new String(c, tokenStart, newTokenStart - tokenStart)); tokenStart = newTokenStart;"
      },
      {
        "txt": "} } else { list.add(new String(c, tokenStart, pos - tokenStart)); tokenStart = pos; } currentType = type; } list.add(new String(c, tokenStart, c.length - tokenStart)); return list.toArray(new String[list.size()]); }"
      },
      {
        "txt": "public static String join(Object[] array) { return join(array, null); } public static String join(Object[] array, char separator) { if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, char separator, int startIndex, int endIndex) {"
      },
      {
        "txt": "if (array == null) { return null; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) {"
      },
      {
        "txt": "if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Object[] array, String separator) {"
      },
      {
        "txt": "if (array == null) { return null; } return join(array, separator, 0, array.length); } public static String join(Object[] array, String separator, int startIndex, int endIndex) { if (array == null) { return null; } if (separator == null) {"
      },
      {
        "txt": "separator = EMPTY; } int bufSize = (endIndex - startIndex); if (bufSize <= 0) { return EMPTY; } bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); StringBuilder buf = new StringBuilder(bufSize); for (int i = startIndex; i < endIndex; i++) {"
      },
      {
        "txt": "if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); } public static String join(Iterator<?> iterator, char separator) {"
      },
      {
        "txt": "if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; } Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); }"
      },
      {
        "txt": "StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { buf.append(separator); Object obj = iterator.next(); if (obj != null) { buf.append(obj); }"
      },
      {
        "txt": "} return buf.toString(); } public static String join(Iterator<?> iterator, String separator) { if (iterator == null) { return null; } if (!iterator.hasNext()) { return EMPTY; }"
      },
      {
        "txt": "Object first = iterator.next(); if (!iterator.hasNext()) { return ObjectUtils.toString(first); } StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small if (first != null) { buf.append(first); } while (iterator.hasNext()) { if (separator != null) {"
      },
      {
        "txt": "buf.append(separator); } Object obj = iterator.next(); if (obj != null) { buf.append(obj); } } return buf.toString(); } public static String join(Iterable<?> iterable, char separator) {"
      },
      {
        "txt": "if (iterable == null) { return null; } return join(iterable.iterator(), separator); } public static String join(Iterable<?> iterable, String separator) { if (iterable == null) { return null; } return join(iterable.iterator(), separator);"
      },
      {
        "txt": "} public static String deleteWhitespace(String str) { if (isEmpty(str)) { return str; } int sz = str.length(); char[] chs = new char[sz]; int count = 0; for (int i = 0; i < sz; i++) { if (!Character.isWhitespace(str.charAt(i))) {"
      },
      {
        "txt": "chs[count++] = str.charAt(i); } } if (count == sz) { return str; } return new String(chs, 0, count); } public static String removeStart(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) {"
      },
      {
        "txt": "return str; } if (str.startsWith(remove)){ return str.substring(remove.length()); } return str; } public static String removeStartIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str;"
      },
      {
        "txt": "} if (startsWithIgnoreCase(str, remove)) { return str.substring(remove.length()); } return str; } public static String removeEnd(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; }"
      },
      {
        "txt": "if (str.endsWith(remove)) { return str.substring(0, str.length() - remove.length()); } return str; } public static String removeEndIgnoreCase(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } if (endsWithIgnoreCase(str, remove)) {"
      },
      {
        "txt": "return str.substring(0, str.length() - remove.length()); } return str; } public static String remove(String str, String remove) { if (isEmpty(str) || isEmpty(remove)) { return str; } return replace(str, remove, EMPTY, -1); }"
      },
      {
        "txt": "public static String remove(String str, char remove) { if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) { return str; } char[] chars = str.toCharArray(); int pos = 0; for (int i = 0; i < chars.length; i++) { if (chars[i] != remove) { chars[pos++] = chars[i]; }"
      },
      {
        "txt": "} return new String(chars, 0, pos); } public static String replaceOnce(String text, String searchString, String replacement) { return replace(text, searchString, replacement, 1); } public static String replace(String text, String searchString, String replacement) { return replace(text, searchString, replacement, -1); } public static String replace(String text, String searchString, String replacement, int max) {"
      },
      {
        "txt": "if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { return text; } int start = 0; int end = text.indexOf(searchString, start); if (end == INDEX_NOT_FOUND) { return text; } int replLength = searchString.length(); int increase = replacement.length() - replLength;"
      },
      {
        "txt": "increase = (increase < 0 ? 0 : increase); increase *= (max < 0 ? 16 : (max > 64 ? 64 : max)); StringBuilder buf = new StringBuilder(text.length() + increase); while (end != INDEX_NOT_FOUND) { buf.append(text.substring(start, end)).append(replacement); start = end + replLength; if (--max == 0) { break; } end = text.indexOf(searchString, start);"
      },
      {
        "txt": "} buf.append(text.substring(start)); return buf.toString(); } public static String replaceEach(String text, String[] searchList, String[] replacementList) { return replaceEach(text, searchList, replacementList, false, 0); } public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) { int timeToLive = searchList == null ? 0 : searchList.length; return replaceEach(text, searchList, replacementList, true, timeToLive);"
      },
      {
        "txt": "} private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) {"
      },
      {
        "txt": "throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); }"
      },
      {
        "txt": "boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; }"
      },
      {
        "txt": "tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } }"
      },
      {
        "txt": "if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { if (searchList[i] == null || replacementList[i] == null) { continue; } int greater = replacementList[i].length() - searchList[i].length();"
      },
      {
        "txt": "if (greater > 0) { increase += 3 * greater; // assume 3 matches } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); }"
      },
      {
        "txt": "buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue;"
      },
      {
        "txt": "} tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } }"
      },
      {
        "txt": "} } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; }"
      },
      {
        "txt": "return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } public static String replaceChars(String str, char searchChar, char replaceChar) { if (str == null) { return null; } return str.replace(searchChar, replaceChar); } public static String replaceChars(String str, String searchChars, String replaceChars) { if (isEmpty(str) || isEmpty(searchChars)) {"
      },
      {
        "txt": "return str; } if (replaceChars == null) { replaceChars = EMPTY; } boolean modified = false; int replaceCharsLength = replaceChars.length(); int strLength = str.length(); StringBuilder buf = new StringBuilder(strLength); for (int i = 0; i < strLength; i++) {"
      },
      {
        "txt": "char ch = str.charAt(i); int index = searchChars.indexOf(ch); if (index >= 0) { modified = true; if (index < replaceCharsLength) { buf.append(replaceChars.charAt(index)); } } else { buf.append(ch); }"
      },
      {
        "txt": "} if (modified) { return buf.toString(); } return str; } public static String overlay(String str, String overlay, int start, int end) { if (str == null) { return null; }"
      },
      {
        "txt": "if (overlay == null) { overlay = EMPTY; } int len = str.length(); if (start < 0) { start = 0; } if (start > len) { start = len; }"
      },
      {
        "txt": "if (end < 0) { end = 0; } if (end > len) { end = len; } if (start > end) { int temp = start; start = end; end = temp;"
      },
      {
        "txt": "} return new StringBuilder(len + start - end + overlay.length() + 1) .append(str.substring(0, start)) .append(overlay) .append(str.substring(end)) .toString(); } public static String chomp(String str) { if (isEmpty(str)) { return str;"
      },
      {
        "txt": "} if (str.length() == 1) { char ch = str.charAt(0); if (ch == CharUtils.CR || ch == CharUtils.LF) { return EMPTY; } return str; } int lastIdx = str.length() - 1; char last = str.charAt(lastIdx);"
      },
      {
        "txt": "if (last == CharUtils.LF) { if (str.charAt(lastIdx - 1) == CharUtils.CR) { lastIdx--; } } else if (last != CharUtils.CR) { lastIdx++; } return str.substring(0, lastIdx); } public static String chomp(String str, String separator) {"
      },
      {
        "txt": "if (isEmpty(str) || separator == null) { return str; } if (str.endsWith(separator)) { return str.substring(0, str.length() - separator.length()); } return str; } public static String chop(String str) { if (str == null) {"
      },
      {
        "txt": "return null; } int strLen = str.length(); if (strLen < 2) { return EMPTY; } int lastIdx = strLen - 1; String ret = str.substring(0, lastIdx); char last = str.charAt(lastIdx); if (last == CharUtils.LF) {"
      },
      {
        "txt": "if (ret.charAt(lastIdx - 1) == CharUtils.CR) { return ret.substring(0, lastIdx - 1); } } return ret; } public static String repeat(String str, int repeat) { if (str == null) { return null; }"
      },
      {
        "txt": "if (repeat <= 0) { return EMPTY; } int inputLength = str.length(); if (repeat == 1 || inputLength == 0) { return str; } if (inputLength == 1 && repeat <= PAD_LIMIT) { return padding(repeat, str.charAt(0)); }"
      },
      {
        "txt": "int outputLength = inputLength * repeat; switch (inputLength) { case 1 : char ch = str.charAt(0); char[] output1 = new char[outputLength]; for (int i = repeat - 1; i >= 0; i--) { output1[i] = ch; } return new String(output1); case 2 :"
      },
      {
        "txt": "char ch0 = str.charAt(0); char ch1 = str.charAt(1); char[] output2 = new char[outputLength]; for (int i = repeat * 2 - 2; i >= 0; i--, i--) { output2[i] = ch0; output2[i + 1] = ch1; } return new String(output2); default : StringBuilder buf = new StringBuilder(outputLength);"
      },
      {
        "txt": "for (int i = 0; i < repeat; i++) { buf.append(str); } return buf.toString(); } } public static String repeat(String str, String separator, int repeat) { if(str == null || separator == null) { return repeat(str, repeat); } else {"
      },
      {
        "txt": "String result = repeat(str + separator, repeat); return removeEnd(result, separator); } } private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException { if (repeat < 0) { throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat); } final char[] buf = new char[repeat]; for (int i = 0; i < buf.length; i++) {"
      },
      {
        "txt": "buf[i] = padChar; } return new String(buf); } public static String rightPad(String str, int size) { return rightPad(str, size, ' '); } public static String rightPad(String str, int size, char padChar) { if (str == null) { return null;"
      },
      {
        "txt": "} int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible } if (pads > PAD_LIMIT) { return rightPad(str, size, String.valueOf(padChar)); } return str.concat(padding(pads, padChar)); }"
      },
      {
        "txt": "public static String rightPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) { padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen;"
      },
      {
        "txt": "if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return rightPad(str, size, padStr.charAt(0)); } if (pads == padLen) { return str.concat(padStr); } else if (pads < padLen) { return str.concat(padStr.substring(0, pads));"
      },
      {
        "txt": "} else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen]; } return str.concat(new String(padding)); } } public static String leftPad(String str, int size) {"
      },
      {
        "txt": "return leftPad(str, size, ' '); } public static String leftPad(String str, int size, char padChar) { if (str == null) { return null; } int pads = size - str.length(); if (pads <= 0) { return str; // returns original String when possible }"
      },
      {
        "txt": "if (pads > PAD_LIMIT) { return leftPad(str, size, String.valueOf(padChar)); } return padding(pads, padChar).concat(str); } public static String leftPad(String str, int size, String padStr) { if (str == null) { return null; } if (isEmpty(padStr)) {"
      },
      {
        "txt": "padStr = \" \"; } int padLen = padStr.length(); int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; // returns original String when possible } if (padLen == 1 && pads <= PAD_LIMIT) { return leftPad(str, size, padStr.charAt(0));"
      },
      {
        "txt": "} if (pads == padLen) { return padStr.concat(str); } else if (pads < padLen) { return padStr.substring(0, pads).concat(str); } else { char[] padding = new char[pads]; char[] padChars = padStr.toCharArray(); for (int i = 0; i < pads; i++) { padding[i] = padChars[i % padLen];"
      },
      {
        "txt": "} return new String(padding).concat(str); } } public static int length(CharSequence cs) { return CharSequenceUtils.length(cs); } public static String center(String str, int size) { return center(str, size, ' '); }"
      },
      {
        "txt": "public static String center(String str, int size, char padChar) { if (str == null || size <= 0) { return str; } int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padChar);"
      },
      {
        "txt": "str = rightPad(str, size, padChar); return str; } public static String center(String str, int size, String padStr) { if (str == null || size <= 0) { return str; } if (isEmpty(padStr)) { padStr = \" \"; }"
      },
      {
        "txt": "int strLen = str.length(); int pads = size - strLen; if (pads <= 0) { return str; } str = leftPad(str, strLen + pads / 2, padStr); str = rightPad(str, size, padStr); return str; } public static String upperCase(String str) {"
      },
      {
        "txt": "if (str == null) { return null; } return str.toUpperCase(); } public static String upperCase(String str, Locale locale) { if (str == null) { return null; } return str.toUpperCase(locale);"
      },
      {
        "txt": "} public static String lowerCase(String str) { if (str == null) { return null; } return str.toLowerCase(); } public static String lowerCase(String str, Locale locale) { if (str == null) { return null;"
      },
      {
        "txt": "} return str.toLowerCase(locale); } public static String capitalize(CharSequence cs) { if (cs == null ) { return null; } int strLen; if ((strLen = cs.length()) == 0) { return cs.toString();"
      },
      {
        "txt": "} return new StringBuilder(strLen) .append(Character.toTitleCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String uncapitalize(CharSequence cs) { if (cs == null ) { return null; }"
      },
      {
        "txt": "int strLen; if ((strLen = cs.length()) == 0) { return cs.toString(); } return new StringBuilder(strLen) .append(Character.toLowerCase(cs.charAt(0))) .append(CharSequenceUtils.subSequence(cs, 1)) .toString(); } public static String swapCase(String str) {"
      },
      {
        "txt": "int strLen; if (str == null || (strLen = str.length()) == 0) { return str; } StringBuilder buffer = new StringBuilder(strLen); char ch = 0; for (int i = 0; i < strLen; i++) { ch = str.charAt(i); if (Character.isUpperCase(ch)) { ch = Character.toLowerCase(ch);"
      },
      {
        "txt": "} else if (Character.isTitleCase(ch)) { ch = Character.toLowerCase(ch); } else if (Character.isLowerCase(ch)) { ch = Character.toUpperCase(ch); } buffer.append(ch); } return buffer.toString(); } public static int countMatches(String str, String sub) {"
      },
      {
        "txt": "if (isEmpty(str) || isEmpty(sub)) { return 0; } int count = 0; int idx = 0; while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) { count++; idx += sub.length(); } return count;"
      },
      {
        "txt": "} public static boolean isAlpha(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLetter(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAlphaSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isAlphanumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if (Character.isLetterOrDigit(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAlphanumericSpace(CharSequence cs) { if (cs == null) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) { return false; } } return true; } public static boolean isAsciiPrintable(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isNumeric(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isDigit(cs.charAt(i)) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isNumericSpace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {"
      },
      {
        "txt": "return false; } } return true; } public static boolean isWhitespace(CharSequence cs) { if (cs == null) { return false; } int sz = cs.length();"
      },
      {
        "txt": "for (int i = 0; i < sz; i++) { if ((Character.isWhitespace(cs.charAt(i)) == false)) { return false; } } return true; } public static boolean isAllLowerCase(CharSequence cs) { if (cs == null || isEmpty(cs)) { return false;"
      },
      {
        "txt": "} int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isLowerCase(cs.charAt(i)) == false) { return false; } } return true; } public static boolean isAllUpperCase(CharSequence cs) {"
      },
      {
        "txt": "if (cs == null || isEmpty(cs)) { return false; } int sz = cs.length(); for (int i = 0; i < sz; i++) { if (Character.isUpperCase(cs.charAt(i)) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static String defaultString(String str) { return str == null ? EMPTY : str; } public static String defaultString(String str, String defaultStr) { return str == null ? defaultStr : str; } public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) { return StringUtils.isEmpty(str) ? defaultStr : str; }"
      },
      {
        "txt": "public static String reverse(String str) { if (str == null) { return null; } return new StringBuilder(str).reverse().toString(); } public static String reverseDelimited(String str, char separatorChar) { if (str == null) { return null; }"
      },
      {
        "txt": "String[] strs = split(str, separatorChar); ArrayUtils.reverse(strs); return join(strs, separatorChar); } public static String abbreviate(String str, int maxWidth) { return abbreviate(str, 0, maxWidth); } public static String abbreviate(String str, int offset, int maxWidth) { if (str == null) { return null;"
      },
      {
        "txt": "} if (maxWidth < 4) { throw new IllegalArgumentException(\"Minimum abbreviation width is 4\"); } if (str.length() <= maxWidth) { return str; } if (offset > str.length()) { offset = str.length(); }"
      },
      {
        "txt": "if ((str.length() - offset) < (maxWidth - 3)) { offset = str.length() - (maxWidth - 3); } final String abrevMarker = \"...\"; if (offset <= 4) { return str.substring(0, maxWidth - 3) + abrevMarker; } if (maxWidth < 7) { throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\"); }"
      },
      {
        "txt": "if ((offset + (maxWidth - 3)) < str.length()) { return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3); } return abrevMarker + str.substring(str.length() - (maxWidth - 3)); } public static String abbreviateMiddle(String str, String middle, int length) { if (isEmpty(str) || isEmpty(middle)) { return str; } if (length >= str.length() || length < (middle.length()+2)) {"
      },
      {
        "txt": "return str; } int targetSting = length-middle.length(); int startOffset = targetSting/2+targetSting%2; int endOffset = str.length()-targetSting/2; StringBuilder builder = new StringBuilder(length); builder.append(str.substring(0,startOffset)); builder.append(middle); builder.append(str.substring(endOffset)); return builder.toString();"
      },
      {
        "txt": "} public static String difference(String str1, String str2) { if (str1 == null) { return str2; } if (str2 == null) { return str1; } int at = indexOfDifference(str1, str2); if (at == INDEX_NOT_FOUND) {"
      },
      {
        "txt": "return EMPTY; } return str2.substring(at); } public static int indexOfDifference(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return INDEX_NOT_FOUND; } if (cs1 == null || cs2 == null) { return 0;"
      },
      {
        "txt": "} int i; for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { if (cs1.charAt(i) != cs2.charAt(i)) { break; } } if (i < cs2.length() || i < cs1.length()) { return i; }"
      },
      {
        "txt": "return INDEX_NOT_FOUND; } public static int indexOfDifference(CharSequence[] css) { if (css == null || css.length <= 1) { return INDEX_NOT_FOUND; } boolean anyStringNull = false; boolean allStringsNull = true; int arrayLen = css.length; int shortestStrLen = Integer.MAX_VALUE;"
      },
      {
        "txt": "int longestStrLen = 0; for (int i = 0; i < arrayLen; i++) { if (css[i] == null) { anyStringNull = true; shortestStrLen = 0; } else { allStringsNull = false; shortestStrLen = Math.min(css[i].length(), shortestStrLen); longestStrLen = Math.max(css[i].length(), longestStrLen); }"
      },
      {
        "txt": "} if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) { return INDEX_NOT_FOUND; } if (shortestStrLen == 0) { return 0; } int firstDiff = -1; for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) { char comparisonChar = css[0].charAt(stringPos);"
      },
      {
        "txt": "for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) { if (css[arrayPos].charAt(stringPos) != comparisonChar) { firstDiff = stringPos; break; } } if (firstDiff != -1) { break; } }"
      },
      {
        "txt": "if (firstDiff == -1 && shortestStrLen != longestStrLen) { return shortestStrLen; } return firstDiff; } public static String getCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) { return EMPTY; } int smallestIndexOfDiff = indexOfDifference(strs);"
      },
      {
        "txt": "if (smallestIndexOfDiff == INDEX_NOT_FOUND) { if (strs[0] == null) { return EMPTY; } return strs[0]; } else if (smallestIndexOfDiff == 0) { return EMPTY; } else { return strs[0].substring(0, smallestIndexOfDiff); }"
      },
      {
        "txt": "} public static int getLevenshteinDistance(CharSequence s, CharSequence t) { if (s == null || t == null) { throw new IllegalArgumentException(\"Strings must not be null\"); } The difference between this impl. and the previous is that, rather than creating and retaining a matrix of size s.length()+1 by t.length()+1, we maintain two single-dimensional arrays of length s.length()+1. The first, d, is the 'current working' distance array that maintains the newest distance cost counts as we iterate through the characters of String s. Each time we increment"
      },
      {
        "txt": "the index of String t we are comparing, d is copied to p, the second int[]. Doing so allows us to retain the previous cost counts as required by the algorithm (taking the minimum of the cost count to the left, up one, and diagonally up and to the left of the current cost count being calculated). (Note that the arrays aren't really copied anymore, just switched...this is clearly much better than cloning an array or doing a System.arraycopy() each time through the outer loop.) Effectively, the difference between the two implementations is this one does not cause an out of memory condition when calculating the LD over two very large strings. int n = s.length(); // length of s int m = t.length(); // length of t"
      },
      {
        "txt": "if (n == 0) { return m; } else if (m == 0) { return n; } if (n > m) { CharSequence tmp = s; s = t; t = tmp; n = m;"
      },
      {
        "txt": "m = t.length(); } int p[] = new int[n+1]; //'previous' cost array, horizontally int d[] = new int[n+1]; // cost array, horizontally int _d[]; //placeholder to assist in swapping p and d int i; // iterates through s int j; // iterates through t char t_j; // jth character of t int cost; // cost for (i = 0; i<=n; i++) {"
      },
      {
        "txt": "p[i] = i; } for (j = 1; j<=m; j++) { t_j = t.charAt(j-1); d[0] = j; for (i=1; i<=n; i++) { cost = s.charAt(i-1)==t_j ? 0 : 1; d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1), p[i-1]+cost); } _d = p;"
      },
      {
        "txt": "p = d; d = _d; } return p[n]; } private static int min(int a, int b, int c) { if (b < a) { a = b; } if (c < a) {"
      },
      {
        "txt": "a = c; } return a; } public static boolean startsWith(String str, String prefix) { return startsWith(str, prefix, false); } public static boolean startsWithIgnoreCase(String str, String prefix) { return startsWith(str, prefix, true); }"
      },
      {
        "txt": "private static boolean startsWith(String str, String prefix, boolean ignoreCase) { if (str == null || prefix == null) { return (str == null && prefix == null); } if (prefix.length() > str.length()) { return false; } return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length()); } public static boolean startsWithAny(String string, String[] searchStrings) {"
      },
      {
        "txt": "if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) { return false; } for (int i = 0; i < searchStrings.length; i++) { String searchString = searchStrings[i]; if (StringUtils.startsWith(string, searchString)) { return true; } } return false;"
      },
      {
        "txt": "} public static boolean endsWith(String str, String suffix) { return endsWith(str, suffix, false); } public static boolean endsWithIgnoreCase(String str, String suffix) { return endsWith(str, suffix, true); } private static boolean endsWith(String str, String suffix, boolean ignoreCase) { if (str == null || suffix == null) { return str == null && suffix == null;"
      },
      {
        "txt": "} if (suffix.length() > str.length()) { return false; } int strOffset = str.length() - suffix.length(); return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length()); }"
      }
    ]
  }
]