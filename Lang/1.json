[
  {
    "id": 2278,
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
    "start-bug-line": 467,
    "end-bug-line": 467,
    "bug": "",
    "fix": "char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3.math; import java.lang.reflect.Array; import java.math.BigDecimal; import java.math.BigInteger;"
      },
      {
        "txt": "import org.apache.commons.lang3.StringUtils; public class NumberUtils { public static final Long LONG_ZERO = Long.valueOf(0L); public static final Long LONG_ONE = Long.valueOf(1L); public static final Long LONG_MINUS_ONE = Long.valueOf(-1L); public static final Integer INTEGER_ZERO = Integer.valueOf(0); public static final Integer INTEGER_ONE = Integer.valueOf(1); public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1); public static final Short SHORT_ZERO = Short.valueOf((short) 0); public static final Short SHORT_ONE = Short.valueOf((short) 1);"
      },
      {
        "txt": "public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1); public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1); public static final Double DOUBLE_ZERO = Double.valueOf(0.0d); public static final Double DOUBLE_ONE = Double.valueOf(1.0d); public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d); public static final Float FLOAT_ZERO = Float.valueOf(0.0f); public static final Float FLOAT_ONE = Float.valueOf(1.0f); public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);"
      },
      {
        "txt": "public NumberUtils() { super(); } public static int toInt(final String str) { return toInt(str, 0); } public static int toInt(final String str, final int defaultValue) { if(str == null) { return defaultValue; }"
      },
      {
        "txt": "try { return Integer.parseInt(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static long toLong(final String str) { return toLong(str, 0L); } public static long toLong(final String str, final long defaultValue) {"
      },
      {
        "txt": "if (str == null) { return defaultValue; } try { return Long.parseLong(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static float toFloat(final String str) {"
      },
      {
        "txt": "return toFloat(str, 0.0f); } public static float toFloat(final String str, final float defaultValue) { if (str == null) { return defaultValue; } try { return Float.parseFloat(str); } catch (final NumberFormatException nfe) { return defaultValue;"
      },
      {
        "txt": "} } public static double toDouble(final String str) { return toDouble(str, 0.0d); } public static double toDouble(final String str, final double defaultValue) { if (str == null) { return defaultValue; } try {"
      },
      {
        "txt": "return Double.parseDouble(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static byte toByte(final String str) { return toByte(str, (byte) 0); } public static byte toByte(final String str, final byte defaultValue) { if(str == null) {"
      },
      {
        "txt": "return defaultValue; } try { return Byte.parseByte(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static short toShort(final String str) { return toShort(str, (short) 0);"
      },
      {
        "txt": "} public static short toShort(final String str, final short defaultValue) { if(str == null) { return defaultValue; } try { return Short.parseShort(str); } catch (final NumberFormatException nfe) { return defaultValue; }"
      },
      {
        "txt": "} public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"}; int pfxLen = 0;"
      },
      {
        "txt": "if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { // we have a hex number <extra_id_0> if (hexDigits > 16) { // too many for Long return createBigInteger(str); } if (hexDigits > 8) { // too many for an int return createLong(str); }"
      },
      {
        "txt": "return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; final int decPos = str.indexOf('.'); final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present"
      },
      {
        "txt": "int numDecimals = 0; // Check required precision (LANG-693) if (decPos > -1) { // there is a decimal point if (expPos > -1) { // there is an exponent if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); }"
      },
      {
        "txt": "mant = str.substring(0, decPos); numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers. } else { if (expPos > -1) { if (expPos > str.length()) { // prevents double exponent causing IOOBE throw new NumberFormatException(str + \" is not a valid number.\"); } mant = str.substring(0, expPos); } else { mant = str;"
      },
      {
        "txt": "} dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } final String numeric = str.substring(0, str.length() - 1);"
      },
      {
        "txt": "final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (final NumberFormatException nfe) { // NOPMD"
      },
      {
        "txt": "} return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { final Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f;"
      },
      {
        "txt": "} } catch (final NumberFormatException nfe) { // NOPMD } case 'd' : case 'D' : try { final Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; }"
      },
      {
        "txt": "} catch (final NumberFormatException nfe) { // NOPMD } try { return createBigDecimal(numeric); } catch (final NumberFormatException e) { // NOPMD } default : throw new NumberFormatException(str + \" is not a valid number.\"); } }"
      },
      {
        "txt": "if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { // no decimal point and no exponent try { return createInteger(str); } catch (final NumberFormatException nfe) { // NOPMD }"
      },
      {
        "txt": "try { return createLong(str); } catch (final NumberFormatException nfe) { // NOPMD } return createBigInteger(str); } final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str);"
      },
      {
        "txt": "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { // NOPMD } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {"
      },
      {
        "txt": "return d; } } } catch (final NumberFormatException nfe) { // NOPMD } return createBigDecimal(str); } private static boolean isAllZeros(final String str) { if (str == null) { return true;"
      },
      {
        "txt": "} for (int i = str.length() - 1; i >= 0; i--) { if (str.charAt(i) != '0') { return false; } } return str.length() > 0; } public static Float createFloat(final String str) { if (str == null) {"
      },
      {
        "txt": "return null; } return Float.valueOf(str); } public static Double createDouble(final String str) { if (str == null) { return null; } return Double.valueOf(str); }"
      },
      {
        "txt": "public static Integer createInteger(final String str) { if (str == null) { return null; } return Integer.decode(str); } public static Long createLong(final String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return Long.decode(str); } public static BigInteger createBigInteger(final String str) { if (str == null) { return null; } int pos = 0; // offset within string int radix = 10; boolean negate = false; // need to negate later? if (str.startsWith(\"-\")) {"
      },
      {
        "txt": "negate = true; pos = 1; } if (str.startsWith(\"0x\", pos) || str.startsWith(\"0x\", pos)) { // hex radix = 16; pos += 2; } else if (str.startsWith(\"#\", pos)) { // alternative hex (allowed by Long/Integer) radix = 16; pos ++; } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) { // octal; so long as there are additional digits"
      },
      {
        "txt": "radix = 8; pos ++; } // default is to treat as decimal final BigInteger value = new BigInteger(str.substring(pos), radix); return negate ? value.negate() : value; } public static BigDecimal createBigDecimal(final String str) { if (str == null) { return null; }"
      },
      {
        "txt": "if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.trim().startsWith(\"--\")) { throw new NumberFormatException(str + \" is not a valid number.\"); } return new BigDecimal(str); } public static long min(final long[] array) { validateArray(array);"
      },
      {
        "txt": "long min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } public static int min(final int[] array) { validateArray(array);"
      },
      {
        "txt": "int min = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] < min) { min = array[j]; } } return min; } public static short min(final short[] array) { validateArray(array);"
      },
      {
        "txt": "short min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } public static byte min(final byte[] array) { validateArray(array);"
      },
      {
        "txt": "byte min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } public static double min(final double[] array) { validateArray(array);"
      },
      {
        "txt": "double min = array[0]; for (int i = 1; i < array.length; i++) { if (Double.isNaN(array[i])) { return Double.NaN; } if (array[i] < min) { min = array[i]; } } return min;"
      },
      {
        "txt": "} public static float min(final float[] array) { validateArray(array); float min = array[0]; for (int i = 1; i < array.length; i++) { if (Float.isNaN(array[i])) { return Float.NaN; } if (array[i] < min) { min = array[i];"
      },
      {
        "txt": "} } return min; } public static long max(final long[] array) { validateArray(array); long max = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] > max) { max = array[j];"
      },
      {
        "txt": "} } return max; } public static int max(final int[] array) { validateArray(array); int max = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] > max) { max = array[j];"
      },
      {
        "txt": "} } return max; } public static short max(final short[] array) { validateArray(array); short max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) { max = array[i];"
      },
      {
        "txt": "} } return max; } public static byte max(final byte[] array) { validateArray(array); byte max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) { max = array[i];"
      },
      {
        "txt": "} } return max; } public static double max(final double[] array) { validateArray(array); double max = array[0]; for (int j = 1; j < array.length; j++) { if (Double.isNaN(array[j])) { return Double.NaN;"
      },
      {
        "txt": "} if (array[j] > max) { max = array[j]; } } return max; } public static float max(final float[] array) { validateArray(array); float max = array[0];"
      },
      {
        "txt": "for (int j = 1; j < array.length; j++) { if (Float.isNaN(array[j])) { return Float.NaN; } if (array[j] > max) { max = array[j]; } } return max; }"
      },
      {
        "txt": "private static void validateArray(final Object array) { if (array == null) { throw new IllegalArgumentException(\"The Array must not be null\"); } else if (Array.getLength(array) == 0) { throw new IllegalArgumentException(\"Array cannot be empty.\"); } } public static long min(long a, final long b, final long c) { if (b < a) { a = b;"
      },
      {
        "txt": "} if (c < a) { a = c; } return a; } public static int min(int a, final int b, final int c) { if (b < a) { a = b; }"
      },
      {
        "txt": "if (c < a) { a = c; } return a; } public static short min(short a, final short b, final short c) { if (b < a) { a = b; } if (c < a) {"
      },
      {
        "txt": "a = c; } return a; } public static byte min(byte a, final byte b, final byte c) { if (b < a) { a = b; } if (c < a) { a = c;"
      },
      {
        "txt": "} return a; } public static double min(final double a, final double b, final double c) { return Math.min(Math.min(a, b), c); } public static float min(final float a, final float b, final float c) { return Math.min(Math.min(a, b), c); } public static long max(long a, final long b, final long c) {"
      },
      {
        "txt": "if (b > a) { a = b; } if (c > a) { a = c; } return a; } public static int max(int a, final int b, final int c) { if (b > a) {"
      },
      {
        "txt": "a = b; } if (c > a) { a = c; } return a; } public static short max(short a, final short b, final short c) { if (b > a) { a = b;"
      },
      {
        "txt": "} if (c > a) { a = c; } return a; } public static byte max(byte a, final byte b, final byte c) { if (b > a) { a = b; }"
      },
      {
        "txt": "if (c > a) { a = c; } return a; } public static double max(final double a, final double b, final double c) { return Math.max(Math.max(a, b), c); } public static float max(final float a, final float b, final float c) { return Math.max(Math.max(a, b), c);"
      },
      {
        "txt": "} public static boolean isDigits(final String str) { if (StringUtils.isEmpty(str)) { return false; } for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } }"
      },
      {
        "txt": "return true; } public static boolean isNumber(final String str) { if (StringUtils.isEmpty(str)) { return false; } final char[] chars = str.toCharArray(); int sz = chars.length; boolean hasExp = false; boolean hasDecPoint = false;"
      },
      {
        "txt": "boolean allowSigns = false; boolean foundDigit = false; final int start = (chars[0] == '-') ? 1 : 0; if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { int i = start + 2; if (i == sz) { return false; // str == \"0x\" } for (; i < chars.length; i++) { if ((chars[i] < '0' || chars[i] > '9')"
      },
      {
        "txt": "&& (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { return false; } } return true; } sz--; // don't want to loop to the last char, check it afterwords int i = start; while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {"
      },
      {
        "txt": "if (chars[i] >= '0' && chars[i] <= '9') { foundDigit = true; allowSigns = false; } else if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } hasDecPoint = true; } else if (chars[i] == 'e' || chars[i] == 'E') { if (hasExp) {"
      },
      {
        "txt": "return false; } if (!foundDigit) { return false; } hasExp = true; allowSigns = true; } else if (chars[i] == '+' || chars[i] == '-') { if (!allowSigns) { return false;"
      },
      {
        "txt": "} allowSigns = false; foundDigit = false; // we need a digit after the E } else { return false; } i++; } if (i < chars.length) { if (chars[i] >= '0' && chars[i] <= '9') {"
      },
      {
        "txt": "return true; } if (chars[i] == 'e' || chars[i] == 'E') { return false; } if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } return foundDigit;"
      },
      {
        "txt": "} if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { return foundDigit; } if (chars[i] == 'l' || chars[i] == 'L') {"
      },
      {
        "txt": "return foundDigit && !hasExp && !hasDecPoint; } return false; } return !allowSigns && foundDigit; }"
      }
    ]
  },
  {
    "id": 2279,
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
    "start-bug-line": 468,
    "end-bug-line": 468,
    "bug": "if (hexDigits > 16) { // too many for Long",
    "fix": "if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3.math; import java.lang.reflect.Array; import java.math.BigDecimal; import java.math.BigInteger; import org.apache.commons.lang3.StringUtils;"
      },
      {
        "txt": "public class NumberUtils { public static final Long LONG_ZERO = Long.valueOf(0L); public static final Long LONG_ONE = Long.valueOf(1L); public static final Long LONG_MINUS_ONE = Long.valueOf(-1L); public static final Integer INTEGER_ZERO = Integer.valueOf(0); public static final Integer INTEGER_ONE = Integer.valueOf(1); public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1); public static final Short SHORT_ZERO = Short.valueOf((short) 0); public static final Short SHORT_ONE = Short.valueOf((short) 1); public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);"
      },
      {
        "txt": "public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1); public static final Double DOUBLE_ZERO = Double.valueOf(0.0d); public static final Double DOUBLE_ONE = Double.valueOf(1.0d); public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d); public static final Float FLOAT_ZERO = Float.valueOf(0.0f); public static final Float FLOAT_ONE = Float.valueOf(1.0f); public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f); public NumberUtils() {"
      },
      {
        "txt": "super(); } public static int toInt(final String str) { return toInt(str, 0); } public static int toInt(final String str, final int defaultValue) { if(str == null) { return defaultValue; } try {"
      },
      {
        "txt": "return Integer.parseInt(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static long toLong(final String str) { return toLong(str, 0L); } public static long toLong(final String str, final long defaultValue) { if (str == null) {"
      },
      {
        "txt": "return defaultValue; } try { return Long.parseLong(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static float toFloat(final String str) { return toFloat(str, 0.0f);"
      },
      {
        "txt": "} public static float toFloat(final String str, final float defaultValue) { if (str == null) { return defaultValue; } try { return Float.parseFloat(str); } catch (final NumberFormatException nfe) { return defaultValue; }"
      },
      {
        "txt": "} public static double toDouble(final String str) { return toDouble(str, 0.0d); } public static double toDouble(final String str, final double defaultValue) { if (str == null) { return defaultValue; } try { return Double.parseDouble(str);"
      },
      {
        "txt": "} catch (final NumberFormatException nfe) { return defaultValue; } } public static byte toByte(final String str) { return toByte(str, (byte) 0); } public static byte toByte(final String str, final byte defaultValue) { if(str == null) { return defaultValue;"
      },
      {
        "txt": "} try { return Byte.parseByte(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static short toShort(final String str) { return toShort(str, (short) 0); }"
      },
      {
        "txt": "public static short toShort(final String str, final short defaultValue) { if(str == null) { return defaultValue; } try { return Short.parseShort(str); } catch (final NumberFormatException nfe) { return defaultValue; } }"
      },
      {
        "txt": "public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"}; int pfxLen = 0; for(final String pfx : hex_prefixes) {"
      },
      {
        "txt": "pfxLen += pfx.length(); break; } } if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; <extra_id_0> return createBigInteger(str); } if (hexDigits > 8) { // too many for an int return createLong(str); } return createInteger(str);"
      },
      {
        "txt": "} return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; final int decPos = str.indexOf('.'); final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present int numDecimals = 0; // Check required precision (LANG-693)"
      },
      {
        "txt": "if (decPos > -1) { // there is a decimal point if (expPos > -1) { // there is an exponent if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos);"
      },
      {
        "txt": "numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers. } else { if (expPos > -1) { if (expPos > str.length()) { // prevents double exponent causing IOOBE throw new NumberFormatException(str + \" is not a valid number.\"); } mant = str.substring(0, expPos); } else { mant = str; }"
      },
      {
        "txt": "dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } final String numeric = str.substring(0, str.length() - 1); final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);"
      },
      {
        "txt": "switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (final NumberFormatException nfe) { // NOPMD }"
      },
      {
        "txt": "return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { final Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; }"
      },
      {
        "txt": "} catch (final NumberFormatException nfe) { // NOPMD } case 'd' : case 'D' : try { final Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { // NOPMD"
      },
      {
        "txt": "} try { return createBigDecimal(numeric); } catch (final NumberFormatException e) { // NOPMD } default : throw new NumberFormatException(str + \" is not a valid number.\"); } } if (expPos > -1 && expPos < str.length() - 1) {"
      },
      {
        "txt": "exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { // no decimal point and no exponent try { return createInteger(str); } catch (final NumberFormatException nfe) { // NOPMD } try {"
      },
      {
        "txt": "return createLong(str); } catch (final NumberFormatException nfe) { // NOPMD } return createBigInteger(str); } final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {"
      },
      {
        "txt": "return f; } } } catch (final NumberFormatException nfe) { // NOPMD } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d;"
      },
      {
        "txt": "} } } catch (final NumberFormatException nfe) { // NOPMD } return createBigDecimal(str); } private static boolean isAllZeros(final String str) { if (str == null) { return true; }"
      },
      {
        "txt": "for (int i = str.length() - 1; i >= 0; i--) { if (str.charAt(i) != '0') { return false; } } return str.length() > 0; } public static Float createFloat(final String str) { if (str == null) { return null;"
      },
      {
        "txt": "} return Float.valueOf(str); } public static Double createDouble(final String str) { if (str == null) { return null; } return Double.valueOf(str); } public static Integer createInteger(final String str) {"
      },
      {
        "txt": "if (str == null) { return null; } return Integer.decode(str); } public static Long createLong(final String str) { if (str == null) { return null; } return Long.decode(str);"
      },
      {
        "txt": "} public static BigInteger createBigInteger(final String str) { if (str == null) { return null; } int pos = 0; // offset within string int radix = 10; boolean negate = false; // need to negate later? if (str.startsWith(\"-\")) { negate = true;"
      },
      {
        "txt": "pos = 1; } if (str.startsWith(\"0x\", pos) || str.startsWith(\"0x\", pos)) { // hex radix = 16; pos += 2; } else if (str.startsWith(\"#\", pos)) { // alternative hex (allowed by Long/Integer) radix = 16; pos ++; } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) { // octal; so long as there are additional digits radix = 8;"
      },
      {
        "txt": "pos ++; } // default is to treat as decimal final BigInteger value = new BigInteger(str.substring(pos), radix); return negate ? value.negate() : value; } public static BigDecimal createBigDecimal(final String str) { if (str == null) { return null; } if (StringUtils.isBlank(str)) {"
      },
      {
        "txt": "throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.trim().startsWith(\"--\")) { throw new NumberFormatException(str + \" is not a valid number.\"); } return new BigDecimal(str); } public static long min(final long[] array) { validateArray(array); long min = array[0];"
      },
      {
        "txt": "for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } public static int min(final int[] array) { validateArray(array); int min = array[0];"
      },
      {
        "txt": "for (int j = 1; j < array.length; j++) { if (array[j] < min) { min = array[j]; } } return min; } public static short min(final short[] array) { validateArray(array); short min = array[0];"
      },
      {
        "txt": "for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } public static byte min(final byte[] array) { validateArray(array); byte min = array[0];"
      },
      {
        "txt": "for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i]; } } return min; } public static double min(final double[] array) { validateArray(array); double min = array[0];"
      },
      {
        "txt": "for (int i = 1; i < array.length; i++) { if (Double.isNaN(array[i])) { return Double.NaN; } if (array[i] < min) { min = array[i]; } } return min; }"
      },
      {
        "txt": "public static float min(final float[] array) { validateArray(array); float min = array[0]; for (int i = 1; i < array.length; i++) { if (Float.isNaN(array[i])) { return Float.NaN; } if (array[i] < min) { min = array[i]; }"
      },
      {
        "txt": "} return min; } public static long max(final long[] array) { validateArray(array); long max = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] > max) { max = array[j]; }"
      },
      {
        "txt": "} return max; } public static int max(final int[] array) { validateArray(array); int max = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] > max) { max = array[j]; }"
      },
      {
        "txt": "} return max; } public static short max(final short[] array) { validateArray(array); short max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) { max = array[i]; }"
      },
      {
        "txt": "} return max; } public static byte max(final byte[] array) { validateArray(array); byte max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) { max = array[i]; }"
      },
      {
        "txt": "} return max; } public static double max(final double[] array) { validateArray(array); double max = array[0]; for (int j = 1; j < array.length; j++) { if (Double.isNaN(array[j])) { return Double.NaN; }"
      },
      {
        "txt": "if (array[j] > max) { max = array[j]; } } return max; } public static float max(final float[] array) { validateArray(array); float max = array[0]; for (int j = 1; j < array.length; j++) {"
      },
      {
        "txt": "if (Float.isNaN(array[j])) { return Float.NaN; } if (array[j] > max) { max = array[j]; } } return max; } private static void validateArray(final Object array) {"
      },
      {
        "txt": "if (array == null) { throw new IllegalArgumentException(\"The Array must not be null\"); } else if (Array.getLength(array) == 0) { throw new IllegalArgumentException(\"Array cannot be empty.\"); } } public static long min(long a, final long b, final long c) { if (b < a) { a = b; }"
      },
      {
        "txt": "if (c < a) { a = c; } return a; } public static int min(int a, final int b, final int c) { if (b < a) { a = b; } if (c < a) {"
      },
      {
        "txt": "a = c; } return a; } public static short min(short a, final short b, final short c) { if (b < a) { a = b; } if (c < a) { a = c;"
      },
      {
        "txt": "} return a; } public static byte min(byte a, final byte b, final byte c) { if (b < a) { a = b; } if (c < a) { a = c; }"
      },
      {
        "txt": "return a; } public static double min(final double a, final double b, final double c) { return Math.min(Math.min(a, b), c); } public static float min(final float a, final float b, final float c) { return Math.min(Math.min(a, b), c); } public static long max(long a, final long b, final long c) { if (b > a) {"
      },
      {
        "txt": "a = b; } if (c > a) { a = c; } return a; } public static int max(int a, final int b, final int c) { if (b > a) { a = b;"
      },
      {
        "txt": "} if (c > a) { a = c; } return a; } public static short max(short a, final short b, final short c) { if (b > a) { a = b; }"
      },
      {
        "txt": "if (c > a) { a = c; } return a; } public static byte max(byte a, final byte b, final byte c) { if (b > a) { a = b; } if (c > a) {"
      },
      {
        "txt": "a = c; } return a; } public static double max(final double a, final double b, final double c) { return Math.max(Math.max(a, b), c); } public static float max(final float a, final float b, final float c) { return Math.max(Math.max(a, b), c); }"
      },
      {
        "txt": "public static boolean isDigits(final String str) { if (StringUtils.isEmpty(str)) { return false; } for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isNumber(final String str) { if (StringUtils.isEmpty(str)) { return false; } final char[] chars = str.toCharArray(); int sz = chars.length; boolean hasExp = false; boolean hasDecPoint = false; boolean allowSigns = false;"
      },
      {
        "txt": "boolean foundDigit = false; final int start = (chars[0] == '-') ? 1 : 0; if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { int i = start + 2; if (i == sz) { return false; // str == \"0x\" } for (; i < chars.length; i++) { if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f')"
      },
      {
        "txt": "&& (chars[i] < 'A' || chars[i] > 'F')) { return false; } } return true; } sz--; // don't want to loop to the last char, check it afterwords int i = start; while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { if (chars[i] >= '0' && chars[i] <= '9') {"
      },
      {
        "txt": "foundDigit = true; allowSigns = false; } else if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } hasDecPoint = true; } else if (chars[i] == 'e' || chars[i] == 'E') { if (hasExp) { return false;"
      },
      {
        "txt": "} if (!foundDigit) { return false; } hasExp = true; allowSigns = true; } else if (chars[i] == '+' || chars[i] == '-') { if (!allowSigns) { return false; }"
      },
      {
        "txt": "allowSigns = false; foundDigit = false; // we need a digit after the E } else { return false; } i++; } if (i < chars.length) { if (chars[i] >= '0' && chars[i] <= '9') { return true;"
      },
      {
        "txt": "} if (chars[i] == 'e' || chars[i] == 'E') { return false; } if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } return foundDigit; }"
      },
      {
        "txt": "if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { return foundDigit; } if (chars[i] == 'l' || chars[i] == 'L') { return foundDigit && !hasExp && !hasDecPoint;"
      },
      {
        "txt": "} return false; } return !allowSigns && foundDigit; }"
      }
    ]
  },
  {
    "id": 2280,
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
    "start-bug-line": 471,
    "end-bug-line": 471,
    "bug": "if (hexDigits > 8) { // too many for an int",
    "fix": "if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3.math; import java.lang.reflect.Array; import java.math.BigDecimal; import java.math.BigInteger; import org.apache.commons.lang3.StringUtils; public class NumberUtils { public static final Long LONG_ZERO = Long.valueOf(0L); public static final Long LONG_ONE = Long.valueOf(1L);"
      },
      {
        "txt": "public static final Long LONG_MINUS_ONE = Long.valueOf(-1L); public static final Integer INTEGER_ZERO = Integer.valueOf(0); public static final Integer INTEGER_ONE = Integer.valueOf(1); public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1); public static final Short SHORT_ZERO = Short.valueOf((short) 0); public static final Short SHORT_ONE = Short.valueOf((short) 1); public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1); public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0); public static final Byte BYTE_ONE = Byte.valueOf((byte) 1); public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);"
      },
      {
        "txt": "public static final Double DOUBLE_ZERO = Double.valueOf(0.0d); public static final Double DOUBLE_ONE = Double.valueOf(1.0d); public static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d); public static final Float FLOAT_ZERO = Float.valueOf(0.0f); public static final Float FLOAT_ONE = Float.valueOf(1.0f); public static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f); public NumberUtils() { super(); } public static int toInt(final String str) {"
      },
      {
        "txt": "return toInt(str, 0); } public static int toInt(final String str, final int defaultValue) { if(str == null) { return defaultValue; } try { return Integer.parseInt(str); } catch (final NumberFormatException nfe) { return defaultValue;"
      },
      {
        "txt": "} } public static long toLong(final String str) { return toLong(str, 0L); } public static long toLong(final String str, final long defaultValue) { if (str == null) { return defaultValue; } try {"
      },
      {
        "txt": "return Long.parseLong(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static float toFloat(final String str) { return toFloat(str, 0.0f); } public static float toFloat(final String str, final float defaultValue) { if (str == null) {"
      },
      {
        "txt": "return defaultValue; } try { return Float.parseFloat(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static double toDouble(final String str) { return toDouble(str, 0.0d);"
      },
      {
        "txt": "} public static double toDouble(final String str, final double defaultValue) { if (str == null) { return defaultValue; } try { return Double.parseDouble(str); } catch (final NumberFormatException nfe) { return defaultValue; }"
      },
      {
        "txt": "} public static byte toByte(final String str) { return toByte(str, (byte) 0); } public static byte toByte(final String str, final byte defaultValue) { if(str == null) { return defaultValue; } try { return Byte.parseByte(str);"
      },
      {
        "txt": "} catch (final NumberFormatException nfe) { return defaultValue; } } public static short toShort(final String str) { return toShort(str, (short) 0); } public static short toShort(final String str, final short defaultValue) { if(str == null) { return defaultValue;"
      },
      {
        "txt": "} try { return Short.parseShort(str); } catch (final NumberFormatException nfe) { return defaultValue; } } public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null;"
      },
      {
        "txt": "} if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break;"
      },
      {
        "txt": "} if (pfxLen > 0) { // we have a hex number final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { // too many for Long return createBigInteger(str); } <extra_id_0> return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant;"
      },
      {
        "txt": "final char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; final int decPos = str.indexOf('.'); final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present int numDecimals = 0; // Check required precision (LANG-693) if (decPos > -1) { // there is a decimal point if (expPos > -1) { // there is an exponent if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE"
      },
      {
        "txt": "throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers. } else { if (expPos > -1) {"
      },
      {
        "txt": "if (expPos > str.length()) { // prevents double exponent causing IOOBE throw new NumberFormatException(str + \" is not a valid number.\"); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') {"
      },
      {
        "txt": "if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } final String numeric = str.substring(0, str.length() - 1); final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' :"
      },
      {
        "txt": "if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (final NumberFormatException nfe) { // NOPMD } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\");"
      },
      {
        "txt": "case 'f' : case 'F' : try { final Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { // NOPMD } case 'd' :"
      },
      {
        "txt": "case 'D' : try { final Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { // NOPMD } try { return createBigDecimal(numeric);"
      },
      {
        "txt": "} catch (final NumberFormatException e) { // NOPMD } default : throw new NumberFormatException(str + \" is not a valid number.\"); } } if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null;"
      },
      {
        "txt": "} if (dec == null && exp == null) { // no decimal point and no exponent try { return createInteger(str); } catch (final NumberFormatException nfe) { // NOPMD } try { return createLong(str); } catch (final NumberFormatException nfe) { // NOPMD }"
      },
      {
        "txt": "return createBigInteger(str); } final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } }"
      },
      {
        "txt": "} catch (final NumberFormatException nfe) { // NOPMD } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } } catch (final NumberFormatException nfe) { // NOPMD"
      },
      {
        "txt": "} return createBigDecimal(str); } private static boolean isAllZeros(final String str) { if (str == null) { return true; } for (int i = str.length() - 1; i >= 0; i--) { if (str.charAt(i) != '0') { return false;"
      },
      {
        "txt": "} } return str.length() > 0; } public static Float createFloat(final String str) { if (str == null) { return null; } return Float.valueOf(str); }"
      },
      {
        "txt": "public static Double createDouble(final String str) { if (str == null) { return null; } return Double.valueOf(str); } public static Integer createInteger(final String str) { if (str == null) { return null; }"
      },
      {
        "txt": "return Integer.decode(str); } public static Long createLong(final String str) { if (str == null) { return null; } return Long.decode(str); } public static BigInteger createBigInteger(final String str) { if (str == null) {"
      },
      {
        "txt": "return null; } int pos = 0; // offset within string int radix = 10; boolean negate = false; // need to negate later? if (str.startsWith(\"-\")) { negate = true; pos = 1; } if (str.startsWith(\"0x\", pos) || str.startsWith(\"0x\", pos)) { // hex"
      },
      {
        "txt": "radix = 16; pos += 2; } else if (str.startsWith(\"#\", pos)) { // alternative hex (allowed by Long/Integer) radix = 16; pos ++; } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) { // octal; so long as there are additional digits radix = 8; pos ++; } // default is to treat as decimal final BigInteger value = new BigInteger(str.substring(pos), radix);"
      },
      {
        "txt": "return negate ? value.negate() : value; } public static BigDecimal createBigDecimal(final String str) { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.trim().startsWith(\"--\")) {"
      },
      {
        "txt": "throw new NumberFormatException(str + \" is not a valid number.\"); } return new BigDecimal(str); } public static long min(final long[] array) { validateArray(array); long min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i];"
      },
      {
        "txt": "} } return min; } public static int min(final int[] array) { validateArray(array); int min = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] < min) { min = array[j];"
      },
      {
        "txt": "} } return min; } public static short min(final short[] array) { validateArray(array); short min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i];"
      },
      {
        "txt": "} } return min; } public static byte min(final byte[] array) { validateArray(array); byte min = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] < min) { min = array[i];"
      },
      {
        "txt": "} } return min; } public static double min(final double[] array) { validateArray(array); double min = array[0]; for (int i = 1; i < array.length; i++) { if (Double.isNaN(array[i])) { return Double.NaN;"
      },
      {
        "txt": "} if (array[i] < min) { min = array[i]; } } return min; } public static float min(final float[] array) { validateArray(array); float min = array[0];"
      },
      {
        "txt": "for (int i = 1; i < array.length; i++) { if (Float.isNaN(array[i])) { return Float.NaN; } if (array[i] < min) { min = array[i]; } } return min; }"
      },
      {
        "txt": "public static long max(final long[] array) { validateArray(array); long max = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] > max) { max = array[j]; } } return max; }"
      },
      {
        "txt": "public static int max(final int[] array) { validateArray(array); int max = array[0]; for (int j = 1; j < array.length; j++) { if (array[j] > max) { max = array[j]; } } return max; }"
      },
      {
        "txt": "public static short max(final short[] array) { validateArray(array); short max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) { max = array[i]; } } return max; }"
      },
      {
        "txt": "public static byte max(final byte[] array) { validateArray(array); byte max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) { max = array[i]; } } return max; }"
      },
      {
        "txt": "public static double max(final double[] array) { validateArray(array); double max = array[0]; for (int j = 1; j < array.length; j++) { if (Double.isNaN(array[j])) { return Double.NaN; } if (array[j] > max) { max = array[j]; }"
      },
      {
        "txt": "} return max; } public static float max(final float[] array) { validateArray(array); float max = array[0]; for (int j = 1; j < array.length; j++) { if (Float.isNaN(array[j])) { return Float.NaN; }"
      },
      {
        "txt": "if (array[j] > max) { max = array[j]; } } return max; } private static void validateArray(final Object array) { if (array == null) { throw new IllegalArgumentException(\"The Array must not be null\"); } else if (Array.getLength(array) == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Array cannot be empty.\"); } } public static long min(long a, final long b, final long c) { if (b < a) { a = b; } if (c < a) { a = c; }"
      },
      {
        "txt": "return a; } public static int min(int a, final int b, final int c) { if (b < a) { a = b; } if (c < a) { a = c; } return a;"
      },
      {
        "txt": "} public static short min(short a, final short b, final short c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; }"
      },
      {
        "txt": "public static byte min(byte a, final byte b, final byte c) { if (b < a) { a = b; } if (c < a) { a = c; } return a; } public static double min(final double a, final double b, final double c) {"
      },
      {
        "txt": "return Math.min(Math.min(a, b), c); } public static float min(final float a, final float b, final float c) { return Math.min(Math.min(a, b), c); } public static long max(long a, final long b, final long c) { if (b > a) { a = b; } if (c > a) {"
      },
      {
        "txt": "a = c; } return a; } public static int max(int a, final int b, final int c) { if (b > a) { a = b; } if (c > a) { a = c;"
      },
      {
        "txt": "} return a; } public static short max(short a, final short b, final short c) { if (b > a) { a = b; } if (c > a) { a = c; }"
      },
      {
        "txt": "return a; } public static byte max(byte a, final byte b, final byte c) { if (b > a) { a = b; } if (c > a) { a = c; } return a;"
      },
      {
        "txt": "} public static double max(final double a, final double b, final double c) { return Math.max(Math.max(a, b), c); } public static float max(final float a, final float b, final float c) { return Math.max(Math.max(a, b), c); } public static boolean isDigits(final String str) { if (StringUtils.isEmpty(str)) { return false;"
      },
      {
        "txt": "} for (int i = 0; i < str.length(); i++) { if (!Character.isDigit(str.charAt(i))) { return false; } } return true; } public static boolean isNumber(final String str) { if (StringUtils.isEmpty(str)) {"
      },
      {
        "txt": "return false; } final char[] chars = str.toCharArray(); int sz = chars.length; boolean hasExp = false; boolean hasDecPoint = false; boolean allowSigns = false; boolean foundDigit = false; final int start = (chars[0] == '-') ? 1 : 0; if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {"
      },
      {
        "txt": "int i = start + 2; if (i == sz) { return false; // str == \"0x\" } for (; i < chars.length; i++) { if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { return false; }"
      },
      {
        "txt": "} return true; } sz--; // don't want to loop to the last char, check it afterwords int i = start; while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { if (chars[i] >= '0' && chars[i] <= '9') { foundDigit = true; allowSigns = false; } else if (chars[i] == '.') {"
      },
      {
        "txt": "if (hasDecPoint || hasExp) { return false; } hasDecPoint = true; } else if (chars[i] == 'e' || chars[i] == 'E') { if (hasExp) { return false; } if (!foundDigit) { return false;"
      },
      {
        "txt": "} hasExp = true; allowSigns = true; } else if (chars[i] == '+' || chars[i] == '-') { if (!allowSigns) { return false; } allowSigns = false; foundDigit = false; // we need a digit after the E } else {"
      },
      {
        "txt": "return false; } i++; } if (i < chars.length) { if (chars[i] >= '0' && chars[i] <= '9') { return true; } if (chars[i] == 'e' || chars[i] == 'E') { return false;"
      },
      {
        "txt": "} if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } return foundDigit; } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D'"
      },
      {
        "txt": "|| chars[i] == 'f' || chars[i] == 'F')) { return foundDigit; } if (chars[i] == 'l' || chars[i] == 'L') { return foundDigit && !hasExp && !hasDecPoint; } return false; }"
      },
      {
        "txt": "return !allowSigns && foundDigit; }"
      }
    ]
  }
]