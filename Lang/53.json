[
  {
    "id": 2416,
    "file_path": "src/java/org/apache/commons/lang/time/DateUtils.java",
    "start-bug-line": 643,
    "end-bug-line": 643,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang.time; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Calendar;"
      },
      {
        "txt": "import java.util.Date; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.TimeZone; public class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;"
      },
      {
        "txt": "public final static int SEMI_MONTH = 1001; private static final int[][] fields = { {Calendar.MILLISECOND}, {Calendar.SECOND}, {Calendar.MINUTE}, {Calendar.HOUR_OF_DAY, Calendar.HOUR}, {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, {Calendar.MONTH, DateUtils.SEMI_MONTH}, {Calendar.YEAR},"
      },
      {
        "txt": "{Calendar.ERA}}; public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() { super(); }"
      },
      {
        "txt": "public static boolean isSameDay(Date date1, Date date2) { if (date1 == null || date2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar cal1 = Calendar.getInstance(); cal1.setTime(date1); Calendar cal2 = Calendar.getInstance(); cal2.setTime(date2); return isSameDay(cal1, cal2); }"
      },
      {
        "txt": "public static boolean isSameDay(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); } public static boolean isSameInstant(Date date1, Date date2) { if (date1 == null || date2 == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } return date1.getTime() == date2.getTime(); } public static boolean isSameInstant(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return cal1.getTime().getTime() == cal2.getTime().getTime(); }"
      },
      {
        "txt": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&"
      },
      {
        "txt": "cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); } public static Date parseDate(String str, String[] parsePatterns) throws ParseException { if (str == null || parsePatterns == null) { throw new IllegalArgumentException(\"Date and Patterns must not be null\"); } SimpleDateFormat parser = null; ParsePosition pos = new ParsePosition(0); for (int i = 0; i < parsePatterns.length; i++) {"
      },
      {
        "txt": "if (i == 0) { parser = new SimpleDateFormat(parsePatterns[0]); } else { parser.applyPattern(parsePatterns[i]); } pos.setIndex(0); Date date = parser.parse(str, pos); if (date != null && pos.getIndex() == str.length()) { return date; }"
      },
      {
        "txt": "} throw new ParseException(\"Unable to parse the date: \" + str, -1); } public static Date addYears(Date date, int amount) { return add(date, Calendar.YEAR, amount); } public static Date addMonths(Date date, int amount) { return add(date, Calendar.MONTH, amount); } public static Date addWeeks(Date date, int amount) {"
      },
      {
        "txt": "return add(date, Calendar.WEEK_OF_YEAR, amount); } public static Date addDays(Date date, int amount) { return add(date, Calendar.DAY_OF_MONTH, amount); } public static Date addHours(Date date, int amount) { return add(date, Calendar.HOUR_OF_DAY, amount); } public static Date addMinutes(Date date, int amount) { return add(date, Calendar.MINUTE, amount);"
      },
      {
        "txt": "} public static Date addSeconds(Date date, int amount) { return add(date, Calendar.SECOND, amount); } public static Date addMilliseconds(Date date, int amount) { return add(date, Calendar.MILLISECOND, amount); } public static Date add(Date date, int calendarField, int amount) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} Calendar c = Calendar.getInstance(); c.setTime(date); c.add(calendarField, amount); return c.getTime(); } public static Date round(Date date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); }"
      },
      {
        "txt": "Calendar gval = Calendar.getInstance(); gval.setTime(date); modify(gval, field, true); return gval.getTime(); } public static Calendar round(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar rounded = (Calendar) date.clone();"
      },
      {
        "txt": "modify(rounded, field, true); return rounded; } public static Date round(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) { return round((Date) date, field); } else if (date instanceof Calendar) {"
      },
      {
        "txt": "return round((Calendar) date, field).getTime(); } else { throw new ClassCastException(\"Could not round \" + date); } } public static Date truncate(Date date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance();"
      },
      {
        "txt": "gval.setTime(date); modify(gval, field, false); return gval.getTime(); } public static Calendar truncate(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar truncated = (Calendar) date.clone(); modify(truncated, field, false);"
      },
      {
        "txt": "return truncated; } public static Date truncate(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) { return truncate((Date) date, field); } else if (date instanceof Calendar) { return truncate((Calendar) date, field).getTime();"
      },
      {
        "txt": "} else { throw new ClassCastException(\"Could not truncate \" + date); } } private static void modify(Calendar val, int field, boolean round) { if (val.get(Calendar.YEAR) > 280000000) { throw new ArithmeticException(\"Calendar value too large for accurate calculations\"); } if (field == Calendar.MILLISECOND) { return;"
      },
      {
        "txt": "Date date = val.getTime(); long time = date.getTime(); boolean done = false; int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; <extra_id_0> done = true; } } int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L);"
      },
      {
        "txt": "if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; } } int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); }"
      },
      {
        "txt": "if (date.getTime() != time) { date.setTime(time); val.setTime(date); } boolean roundUp = false; for (int i = 0; i < fields.length; i++) { for (int j = 0; j < fields[i].length; j++) { if (fields[i][j] == field) { if (round && roundUp) { if (field == DateUtils.SEMI_MONTH) {"
      },
      {
        "txt": "if (val.get(Calendar.DATE) == 1) { val.add(Calendar.DATE, 15); } else { val.add(Calendar.DATE, -15); val.add(Calendar.MONTH, 1); } } else { val.add(fields[i][0], 1); } }"
      },
      {
        "txt": "return; } } int offset = 0; boolean offsetSet = false; switch (field) { case DateUtils.SEMI_MONTH: if (fields[i][0] == Calendar.DATE) { offset = val.get(Calendar.DATE) - 1; if (offset >= 15) {"
      },
      {
        "txt": "offset -= 15; } roundUp = offset > 7; offsetSet = true; } break; case Calendar.AM_PM: if (fields[i][0] == Calendar.HOUR_OF_DAY) { offset = val.get(Calendar.HOUR_OF_DAY); if (offset >= 12) {"
      },
      {
        "txt": "offset -= 12; } roundUp = offset > 6; offsetSet = true; } break; } if (!offsetSet) { int min = val.getActualMinimum(fields[i][0]); int max = val.getActualMaximum(fields[i][0]);"
      },
      {
        "txt": "offset = val.get(fields[i][0]) - min; roundUp = offset > ((max - min) / 2); } if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); } } throw new IllegalArgumentException(\"The field \" + field + \" is not supported\"); } public static Iterator iterator(Date focus, int rangeStyle) {"
      },
      {
        "txt": "if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(focus); return iterator(gval, rangeStyle); } public static Iterator iterator(Calendar focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} Calendar start = null; Calendar end = null; int startCutoff = Calendar.SUNDAY; int endCutoff = Calendar.SATURDAY; switch (rangeStyle) { case RANGE_MONTH_SUNDAY: case RANGE_MONTH_MONDAY: start = truncate(focus, Calendar.MONTH); end = (Calendar) start.clone();"
      },
      {
        "txt": "end.add(Calendar.MONTH, 1); end.add(Calendar.DATE, -1); if (rangeStyle == RANGE_MONTH_MONDAY) { startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; } break; case RANGE_WEEK_SUNDAY: case RANGE_WEEK_MONDAY: case RANGE_WEEK_RELATIVE:"
      },
      {
        "txt": "case RANGE_WEEK_CENTER: start = truncate(focus, Calendar.DATE); end = truncate(focus, Calendar.DATE); switch (rangeStyle) { case RANGE_WEEK_SUNDAY: break; case RANGE_WEEK_MONDAY: startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; break;"
      },
      {
        "txt": "case RANGE_WEEK_RELATIVE: startCutoff = focus.get(Calendar.DAY_OF_WEEK); endCutoff = startCutoff - 1; break; case RANGE_WEEK_CENTER: startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; break; } break;"
      },
      {
        "txt": "default: throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\"); } if (startCutoff < Calendar.SUNDAY) { startCutoff += 7; } if (startCutoff > Calendar.SATURDAY) { startCutoff -= 7; } if (endCutoff < Calendar.SUNDAY) {"
      },
      {
        "txt": "endCutoff += 7; } if (endCutoff > Calendar.SATURDAY) { endCutoff -= 7; } while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { start.add(Calendar.DATE, -1); } while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { end.add(Calendar.DATE, 1);"
      },
      {
        "txt": "} return new DateIterator(start, end); } public static Iterator iterator(Object focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (focus instanceof Date) { return iterator((Date) focus, rangeStyle); } else if (focus instanceof Calendar) {"
      },
      {
        "txt": "return iterator((Calendar) focus, rangeStyle); } else { throw new ClassCastException(\"Could not iterate based on \" + focus); } } static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) { super();"
      },
      {
        "txt": "this.endFinal = endFinal; spot = startFinal; spot.add(Calendar.DATE, -1); } public boolean hasNext() { return spot.before(endFinal); } public Object next() { if (spot.equals(endFinal)) { throw new NoSuchElementException();"
      },
      {
        "txt": "} spot.add(Calendar.DATE, 1); return spot.clone(); } public void remove() { throw new UnsupportedOperationException(); } } public static final int MILLIS_IN_SECOND = 1000; public static final int MILLIS_IN_MINUTE = 60 * 1000;"
      },
      {
        "txt": "public static final int MILLIS_IN_HOUR = 60 * 60 * 1000; public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;"
      }
    ]
  },
  {
    "id": 2417,
    "file_path": "src/java/org/apache/commons/lang/time/DateUtils.java",
    "start-bug-line": 645,
    "end-bug-line": 645,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang.time; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.NoSuchElementException; import java.util.TimeZone; public class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = {"
      },
      {
        "txt": "{Calendar.MILLISECOND}, {Calendar.SECOND}, {Calendar.MINUTE}, {Calendar.HOUR_OF_DAY, Calendar.HOUR}, {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, {Calendar.MONTH, DateUtils.SEMI_MONTH}, {Calendar.YEAR}, {Calendar.ERA}}; public final static int RANGE_WEEK_SUNDAY = 1;"
      },
      {
        "txt": "public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() { super(); } public static boolean isSameDay(Date date1, Date date2) { if (date1 == null || date2 == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } Calendar cal1 = Calendar.getInstance(); cal1.setTime(date1); Calendar cal2 = Calendar.getInstance(); cal2.setTime(date2); return isSameDay(cal1, cal2); } public static boolean isSameDay(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); } public static boolean isSameInstant(Date date1, Date date2) { if (date1 == null || date2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); }"
      },
      {
        "txt": "return date1.getTime() == date2.getTime(); } public static boolean isSameInstant(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return cal1.getTime().getTime() == cal2.getTime().getTime(); } public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());"
      },
      {
        "txt": "} public static Date parseDate(String str, String[] parsePatterns) throws ParseException { if (str == null || parsePatterns == null) { throw new IllegalArgumentException(\"Date and Patterns must not be null\"); } SimpleDateFormat parser = null; ParsePosition pos = new ParsePosition(0); for (int i = 0; i < parsePatterns.length; i++) { if (i == 0) { parser = new SimpleDateFormat(parsePatterns[0]);"
      },
      {
        "txt": "} else { parser.applyPattern(parsePatterns[i]); } pos.setIndex(0); Date date = parser.parse(str, pos); if (date != null && pos.getIndex() == str.length()) { return date; } } throw new ParseException(\"Unable to parse the date: \" + str, -1);"
      },
      {
        "txt": "} public static Date addYears(Date date, int amount) { return add(date, Calendar.YEAR, amount); } public static Date addMonths(Date date, int amount) { return add(date, Calendar.MONTH, amount); } public static Date addWeeks(Date date, int amount) { return add(date, Calendar.WEEK_OF_YEAR, amount); }"
      },
      {
        "txt": "public static Date addDays(Date date, int amount) { return add(date, Calendar.DAY_OF_MONTH, amount); } public static Date addHours(Date date, int amount) { return add(date, Calendar.HOUR_OF_DAY, amount); } public static Date addMinutes(Date date, int amount) { return add(date, Calendar.MINUTE, amount); } public static Date addSeconds(Date date, int amount) {"
      },
      {
        "txt": "return add(date, Calendar.SECOND, amount); } public static Date addMilliseconds(Date date, int amount) { return add(date, Calendar.MILLISECOND, amount); } public static Date add(Date date, int calendarField, int amount) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar c = Calendar.getInstance();"
      },
      {
        "txt": "c.setTime(date); c.add(calendarField, amount); return c.getTime(); } public static Date round(Date date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(date);"
      },
      {
        "txt": "modify(gval, field, true); return gval.getTime(); } public static Calendar round(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar rounded = (Calendar) date.clone(); modify(rounded, field, true); return rounded;"
      },
      {
        "txt": "} public static Date round(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) { return round((Date) date, field); } else if (date instanceof Calendar) { return round((Calendar) date, field).getTime(); } else {"
      },
      {
        "txt": "throw new ClassCastException(\"Could not round \" + date); } } public static Date truncate(Date date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(date); modify(gval, field, false);"
      },
      {
        "txt": "return gval.getTime(); } public static Calendar truncate(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar truncated = (Calendar) date.clone(); modify(truncated, field, false); return truncated; }"
      },
      {
        "txt": "public static Date truncate(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) { return truncate((Date) date, field); } else if (date instanceof Calendar) { return truncate((Calendar) date, field).getTime(); } else { throw new ClassCastException(\"Could not truncate \" + date);"
      },
      {
        "txt": "} } private static void modify(Calendar val, int field, boolean round) { if (val.get(Calendar.YEAR) > 280000000) { throw new ArithmeticException(\"Calendar value too large for accurate calculations\"); } if (field == Calendar.MILLISECOND) { return; } Date date = val.getTime();"
      },
      {
        "txt": "boolean done = false; int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true; <extra_id_0> } int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true;"
      },
      {
        "txt": "if (field == Calendar.MINUTE) { done = true; } } int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } if (date.getTime() != time) { date.setTime(time);"
      },
      {
        "txt": "val.setTime(date); } boolean roundUp = false; for (int i = 0; i < fields.length; i++) { for (int j = 0; j < fields[i].length; j++) { if (fields[i][j] == field) { if (round && roundUp) { if (field == DateUtils.SEMI_MONTH) { if (val.get(Calendar.DATE) == 1) { val.add(Calendar.DATE, 15);"
      },
      {
        "txt": "} else { val.add(Calendar.DATE, -15); val.add(Calendar.MONTH, 1); } } else { val.add(fields[i][0], 1); } } return; }"
      },
      {
        "txt": "} int offset = 0; boolean offsetSet = false; switch (field) { case DateUtils.SEMI_MONTH: if (fields[i][0] == Calendar.DATE) { offset = val.get(Calendar.DATE) - 1; if (offset >= 15) { offset -= 15; }"
      },
      {
        "txt": "roundUp = offset > 7; offsetSet = true; } break; case Calendar.AM_PM: if (fields[i][0] == Calendar.HOUR_OF_DAY) { offset = val.get(Calendar.HOUR_OF_DAY); if (offset >= 12) { offset -= 12; }"
      },
      {
        "txt": "roundUp = offset > 6; offsetSet = true; } break; } if (!offsetSet) { int min = val.getActualMinimum(fields[i][0]); int max = val.getActualMaximum(fields[i][0]); offset = val.get(fields[i][0]) - min; roundUp = offset > ((max - min) / 2);"
      },
      {
        "txt": "} if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); } } throw new IllegalArgumentException(\"The field \" + field + \" is not supported\"); } public static Iterator iterator(Date focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} Calendar gval = Calendar.getInstance(); gval.setTime(focus); return iterator(gval, rangeStyle); } public static Iterator iterator(Calendar focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar start = null;"
      },
      {
        "txt": "Calendar end = null; int startCutoff = Calendar.SUNDAY; int endCutoff = Calendar.SATURDAY; switch (rangeStyle) { case RANGE_MONTH_SUNDAY: case RANGE_MONTH_MONDAY: start = truncate(focus, Calendar.MONTH); end = (Calendar) start.clone(); end.add(Calendar.MONTH, 1); end.add(Calendar.DATE, -1);"
      },
      {
        "txt": "if (rangeStyle == RANGE_MONTH_MONDAY) { startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; } break; case RANGE_WEEK_SUNDAY: case RANGE_WEEK_MONDAY: case RANGE_WEEK_RELATIVE: case RANGE_WEEK_CENTER: start = truncate(focus, Calendar.DATE);"
      },
      {
        "txt": "end = truncate(focus, Calendar.DATE); switch (rangeStyle) { case RANGE_WEEK_SUNDAY: break; case RANGE_WEEK_MONDAY: startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; break; case RANGE_WEEK_RELATIVE: startCutoff = focus.get(Calendar.DAY_OF_WEEK);"
      },
      {
        "txt": "endCutoff = startCutoff - 1; break; case RANGE_WEEK_CENTER: startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; break; } break; default: throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");"
      },
      {
        "txt": "} if (startCutoff < Calendar.SUNDAY) { startCutoff += 7; } if (startCutoff > Calendar.SATURDAY) { startCutoff -= 7; } if (endCutoff < Calendar.SUNDAY) { endCutoff += 7; }"
      },
      {
        "txt": "if (endCutoff > Calendar.SATURDAY) { endCutoff -= 7; } while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { start.add(Calendar.DATE, -1); } while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { end.add(Calendar.DATE, 1); } return new DateIterator(start, end);"
      },
      {
        "txt": "} public static Iterator iterator(Object focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (focus instanceof Date) { return iterator((Date) focus, rangeStyle); } else if (focus instanceof Calendar) { return iterator((Calendar) focus, rangeStyle); } else {"
      },
      {
        "txt": "throw new ClassCastException(\"Could not iterate based on \" + focus); } } static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) { super(); this.endFinal = endFinal; spot = startFinal;"
      },
      {
        "txt": "spot.add(Calendar.DATE, -1); } public boolean hasNext() { return spot.before(endFinal); } public Object next() { if (spot.equals(endFinal)) { throw new NoSuchElementException(); } spot.add(Calendar.DATE, 1);"
      },
      {
        "txt": "return spot.clone(); } public void remove() { throw new UnsupportedOperationException(); } } public static final int MILLIS_IN_SECOND = 1000; public static final int MILLIS_IN_MINUTE = 60 * 1000; public static final int MILLIS_IN_HOUR = 60 * 60 * 1000; public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;"
      }
    ]
  },
  {
    "id": 2418,
    "file_path": "src/java/org/apache/commons/lang/time/DateUtils.java",
    "start-bug-line": 652,
    "end-bug-line": 652,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang.time; import java.text.ParseException;"
      },
      {
        "txt": "import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.TimeZone; public class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000;"
      },
      {
        "txt": "public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = { {Calendar.MILLISECOND}, {Calendar.SECOND}, {Calendar.MINUTE}, {Calendar.HOUR_OF_DAY, Calendar.HOUR}, {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM"
      },
      {
        "txt": "}, {Calendar.MONTH, DateUtils.SEMI_MONTH}, {Calendar.YEAR}, {Calendar.ERA}}; public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6;"
      },
      {
        "txt": "public DateUtils() { super(); } public static boolean isSameDay(Date date1, Date date2) { if (date1 == null || date2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar cal1 = Calendar.getInstance(); cal1.setTime(date1); Calendar cal2 = Calendar.getInstance();"
      },
      {
        "txt": "cal2.setTime(date2); return isSameDay(cal1, cal2); } public static boolean isSameDay(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));"
      },
      {
        "txt": "} public static boolean isSameInstant(Date date1, Date date2) { if (date1 == null || date2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return date1.getTime() == date2.getTime(); } public static boolean isSameInstant(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} return cal1.getTime().getTime() == cal2.getTime().getTime(); } public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&"
      },
      {
        "txt": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); } public static Date parseDate(String str, String[] parsePatterns) throws ParseException { if (str == null || parsePatterns == null) { throw new IllegalArgumentException(\"Date and Patterns must not be null\"); }"
      },
      {
        "txt": "SimpleDateFormat parser = null; ParsePosition pos = new ParsePosition(0); for (int i = 0; i < parsePatterns.length; i++) { if (i == 0) { parser = new SimpleDateFormat(parsePatterns[0]); } else { parser.applyPattern(parsePatterns[i]); } pos.setIndex(0); Date date = parser.parse(str, pos);"
      },
      {
        "txt": "if (date != null && pos.getIndex() == str.length()) { return date; } } throw new ParseException(\"Unable to parse the date: \" + str, -1); } public static Date addYears(Date date, int amount) { return add(date, Calendar.YEAR, amount); } public static Date addMonths(Date date, int amount) {"
      },
      {
        "txt": "return add(date, Calendar.MONTH, amount); } public static Date addWeeks(Date date, int amount) { return add(date, Calendar.WEEK_OF_YEAR, amount); } public static Date addDays(Date date, int amount) { return add(date, Calendar.DAY_OF_MONTH, amount); } public static Date addHours(Date date, int amount) { return add(date, Calendar.HOUR_OF_DAY, amount);"
      },
      {
        "txt": "} public static Date addMinutes(Date date, int amount) { return add(date, Calendar.MINUTE, amount); } public static Date addSeconds(Date date, int amount) { return add(date, Calendar.SECOND, amount); } public static Date addMilliseconds(Date date, int amount) { return add(date, Calendar.MILLISECOND, amount); }"
      },
      {
        "txt": "public static Date add(Date date, int calendarField, int amount) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar c = Calendar.getInstance(); c.setTime(date); c.add(calendarField, amount); return c.getTime(); } public static Date round(Date date, int field) {"
      },
      {
        "txt": "if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(date); modify(gval, field, true); return gval.getTime(); } public static Calendar round(Calendar date, int field) { if (date == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } Calendar rounded = (Calendar) date.clone(); modify(rounded, field, true); return rounded; } public static Date round(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); }"
      },
      {
        "txt": "if (date instanceof Date) { return round((Date) date, field); } else if (date instanceof Calendar) { return round((Calendar) date, field).getTime(); } else { throw new ClassCastException(\"Could not round \" + date); } } public static Date truncate(Date date, int field) { if (date == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(date); modify(gval, field, false); return gval.getTime(); } public static Calendar truncate(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} Calendar truncated = (Calendar) date.clone(); modify(truncated, field, false); return truncated; } public static Date truncate(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) {"
      },
      {
        "txt": "return truncate((Date) date, field); } else if (date instanceof Calendar) { return truncate((Calendar) date, field).getTime(); } else { throw new ClassCastException(\"Could not truncate \" + date); } } private static void modify(Calendar val, int field, boolean round) { if (val.get(Calendar.YEAR) > 280000000) { throw new ArithmeticException(\"Calendar value too large for accurate calculations\");"
      },
      {
        "txt": "} if (field == Calendar.MILLISECOND) { return; } Date date = val.getTime(); long time = date.getTime(); boolean done = false; int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs;"
      },
      {
        "txt": "done = true; } } int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); <extra_id_0> done = true; } } int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L);"
      },
      {
        "txt": "if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } if (date.getTime() != time) { date.setTime(time); val.setTime(date); } boolean roundUp = false; for (int i = 0; i < fields.length; i++) { for (int j = 0; j < fields[i].length; j++) {"
      },
      {
        "txt": "if (fields[i][j] == field) { if (round && roundUp) { if (field == DateUtils.SEMI_MONTH) { if (val.get(Calendar.DATE) == 1) { val.add(Calendar.DATE, 15); } else { val.add(Calendar.DATE, -15); val.add(Calendar.MONTH, 1); } } else {"
      },
      {
        "txt": "val.add(fields[i][0], 1); } } return; } } int offset = 0; boolean offsetSet = false; switch (field) { case DateUtils.SEMI_MONTH:"
      },
      {
        "txt": "if (fields[i][0] == Calendar.DATE) { offset = val.get(Calendar.DATE) - 1; if (offset >= 15) { offset -= 15; } roundUp = offset > 7; offsetSet = true; } break; case Calendar.AM_PM:"
      },
      {
        "txt": "if (fields[i][0] == Calendar.HOUR_OF_DAY) { offset = val.get(Calendar.HOUR_OF_DAY); if (offset >= 12) { offset -= 12; } roundUp = offset > 6; offsetSet = true; } break; }"
      },
      {
        "txt": "if (!offsetSet) { int min = val.getActualMinimum(fields[i][0]); int max = val.getActualMaximum(fields[i][0]); offset = val.get(fields[i][0]) - min; roundUp = offset > ((max - min) / 2); } if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); } }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The field \" + field + \" is not supported\"); } public static Iterator iterator(Date focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(focus); return iterator(gval, rangeStyle); }"
      },
      {
        "txt": "public static Iterator iterator(Calendar focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar start = null; Calendar end = null; int startCutoff = Calendar.SUNDAY; int endCutoff = Calendar.SATURDAY; switch (rangeStyle) { case RANGE_MONTH_SUNDAY:"
      },
      {
        "txt": "case RANGE_MONTH_MONDAY: start = truncate(focus, Calendar.MONTH); end = (Calendar) start.clone(); end.add(Calendar.MONTH, 1); end.add(Calendar.DATE, -1); if (rangeStyle == RANGE_MONTH_MONDAY) { startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; } break;"
      },
      {
        "txt": "case RANGE_WEEK_SUNDAY: case RANGE_WEEK_MONDAY: case RANGE_WEEK_RELATIVE: case RANGE_WEEK_CENTER: start = truncate(focus, Calendar.DATE); end = truncate(focus, Calendar.DATE); switch (rangeStyle) { case RANGE_WEEK_SUNDAY: break; case RANGE_WEEK_MONDAY:"
      },
      {
        "txt": "startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; break; case RANGE_WEEK_RELATIVE: startCutoff = focus.get(Calendar.DAY_OF_WEEK); endCutoff = startCutoff - 1; break; case RANGE_WEEK_CENTER: startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;"
      },
      {
        "txt": "break; } break; default: throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\"); } if (startCutoff < Calendar.SUNDAY) { startCutoff += 7; } if (startCutoff > Calendar.SATURDAY) {"
      },
      {
        "txt": "startCutoff -= 7; } if (endCutoff < Calendar.SUNDAY) { endCutoff += 7; } if (endCutoff > Calendar.SATURDAY) { endCutoff -= 7; } while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { start.add(Calendar.DATE, -1);"
      },
      {
        "txt": "} while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { end.add(Calendar.DATE, 1); } return new DateIterator(start, end); } public static Iterator iterator(Object focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); }"
      },
      {
        "txt": "if (focus instanceof Date) { return iterator((Date) focus, rangeStyle); } else if (focus instanceof Calendar) { return iterator((Calendar) focus, rangeStyle); } else { throw new ClassCastException(\"Could not iterate based on \" + focus); } } static class DateIterator implements Iterator { private final Calendar endFinal;"
      },
      {
        "txt": "private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) { super(); this.endFinal = endFinal; spot = startFinal; spot.add(Calendar.DATE, -1); } public boolean hasNext() { return spot.before(endFinal); }"
      },
      {
        "txt": "public Object next() { if (spot.equals(endFinal)) { throw new NoSuchElementException(); } spot.add(Calendar.DATE, 1); return spot.clone(); } public void remove() { throw new UnsupportedOperationException(); }"
      },
      {
        "txt": "} public static final int MILLIS_IN_SECOND = 1000; public static final int MILLIS_IN_MINUTE = 60 * 1000; public static final int MILLIS_IN_HOUR = 60 * 60 * 1000; public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;"
      }
    ]
  },
  {
    "id": 2419,
    "file_path": "src/java/org/apache/commons/lang/time/DateUtils.java",
    "start-bug-line": 654,
    "end-bug-line": 654,
    "bug": "}",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang.time; import java.text.ParseException; import java.text.ParsePosition; import java.text.SimpleDateFormat;"
      },
      {
        "txt": "import java.util.Calendar; import java.util.Date; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.TimeZone; public class DateUtils { public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\"); public static final long MILLIS_PER_SECOND = 1000; public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;"
      },
      {
        "txt": "public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; public final static int SEMI_MONTH = 1001; private static final int[][] fields = { {Calendar.MILLISECOND}, {Calendar.SECOND}, {Calendar.MINUTE}, {Calendar.HOUR_OF_DAY, Calendar.HOUR}, {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, {Calendar.MONTH, DateUtils.SEMI_MONTH},"
      },
      {
        "txt": "{Calendar.YEAR}, {Calendar.ERA}}; public final static int RANGE_WEEK_SUNDAY = 1; public final static int RANGE_WEEK_MONDAY = 2; public final static int RANGE_WEEK_RELATIVE = 3; public final static int RANGE_WEEK_CENTER = 4; public final static int RANGE_MONTH_SUNDAY = 5; public final static int RANGE_MONTH_MONDAY = 6; public DateUtils() { super();"
      },
      {
        "txt": "} public static boolean isSameDay(Date date1, Date date2) { if (date1 == null || date2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar cal1 = Calendar.getInstance(); cal1.setTime(date1); Calendar cal2 = Calendar.getInstance(); cal2.setTime(date2); return isSameDay(cal1, cal2);"
      },
      {
        "txt": "} public static boolean isSameDay(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); } public static boolean isSameInstant(Date date1, Date date2) {"
      },
      {
        "txt": "if (date1 == null || date2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return date1.getTime() == date2.getTime(); } public static boolean isSameInstant(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return cal1.getTime().getTime() == cal2.getTime().getTime();"
      },
      {
        "txt": "} public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&"
      },
      {
        "txt": "cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); } public static Date parseDate(String str, String[] parsePatterns) throws ParseException { if (str == null || parsePatterns == null) { throw new IllegalArgumentException(\"Date and Patterns must not be null\"); } SimpleDateFormat parser = null; ParsePosition pos = new ParsePosition(0);"
      },
      {
        "txt": "for (int i = 0; i < parsePatterns.length; i++) { if (i == 0) { parser = new SimpleDateFormat(parsePatterns[0]); } else { parser.applyPattern(parsePatterns[i]); } pos.setIndex(0); Date date = parser.parse(str, pos); if (date != null && pos.getIndex() == str.length()) { return date;"
      },
      {
        "txt": "} } throw new ParseException(\"Unable to parse the date: \" + str, -1); } public static Date addYears(Date date, int amount) { return add(date, Calendar.YEAR, amount); } public static Date addMonths(Date date, int amount) { return add(date, Calendar.MONTH, amount); }"
      },
      {
        "txt": "public static Date addWeeks(Date date, int amount) { return add(date, Calendar.WEEK_OF_YEAR, amount); } public static Date addDays(Date date, int amount) { return add(date, Calendar.DAY_OF_MONTH, amount); } public static Date addHours(Date date, int amount) { return add(date, Calendar.HOUR_OF_DAY, amount); } public static Date addMinutes(Date date, int amount) {"
      },
      {
        "txt": "return add(date, Calendar.MINUTE, amount); } public static Date addSeconds(Date date, int amount) { return add(date, Calendar.SECOND, amount); } public static Date addMilliseconds(Date date, int amount) { return add(date, Calendar.MILLISECOND, amount); } public static Date add(Date date, int calendarField, int amount) { if (date == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } Calendar c = Calendar.getInstance(); c.setTime(date); c.add(calendarField, amount); return c.getTime(); } public static Date round(Date date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} Calendar gval = Calendar.getInstance(); gval.setTime(date); modify(gval, field, true); return gval.getTime(); } public static Calendar round(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); }"
      },
      {
        "txt": "Calendar rounded = (Calendar) date.clone(); modify(rounded, field, true); return rounded; } public static Date round(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) { return round((Date) date, field);"
      },
      {
        "txt": "} else if (date instanceof Calendar) { return round((Calendar) date, field).getTime(); } else { throw new ClassCastException(\"Could not round \" + date); } } public static Date truncate(Date date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); }"
      },
      {
        "txt": "Calendar gval = Calendar.getInstance(); gval.setTime(date); modify(gval, field, false); return gval.getTime(); } public static Calendar truncate(Calendar date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar truncated = (Calendar) date.clone();"
      },
      {
        "txt": "modify(truncated, field, false); return truncated; } public static Date truncate(Object date, int field) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date instanceof Date) { return truncate((Date) date, field); } else if (date instanceof Calendar) {"
      },
      {
        "txt": "return truncate((Calendar) date, field).getTime(); } else { throw new ClassCastException(\"Could not truncate \" + date); } } private static void modify(Calendar val, int field, boolean round) { if (val.get(Calendar.YEAR) > 280000000) { throw new ArithmeticException(\"Calendar value too large for accurate calculations\"); } if (field == Calendar.MILLISECOND) {"
      },
      {
        "txt": "return; } Date date = val.getTime(); long time = date.getTime(); boolean done = false; int millisecs = val.get(Calendar.MILLISECOND); if (!round || millisecs < 500) { time = time - millisecs; if (field == Calendar.SECOND) { done = true;"
      },
      {
        "txt": "} int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; <extra_id_0> } int minutes = val.get(Calendar.MINUTE); if (!done && (!round || minutes < 30)) { time = time - (minutes * 60000L); } if (date.getTime() != time) {"
      },
      {
        "txt": "} if (date.getTime() != time) { date.setTime(time); val.setTime(date); } boolean roundUp = false; for (int i = 0; i < fields.length; i++) { for (int j = 0; j < fields[i].length; j++) { if (fields[i][j] == field) { if (round && roundUp) {"
      },
      {
        "txt": "if (field == DateUtils.SEMI_MONTH) { if (val.get(Calendar.DATE) == 1) { val.add(Calendar.DATE, 15); } else { val.add(Calendar.DATE, -15); val.add(Calendar.MONTH, 1); } } else { val.add(fields[i][0], 1); }"
      },
      {
        "txt": "} return; } } int offset = 0; boolean offsetSet = false; switch (field) { case DateUtils.SEMI_MONTH: if (fields[i][0] == Calendar.DATE) { offset = val.get(Calendar.DATE) - 1;"
      },
      {
        "txt": "if (offset >= 15) { offset -= 15; } roundUp = offset > 7; offsetSet = true; } break; case Calendar.AM_PM: if (fields[i][0] == Calendar.HOUR_OF_DAY) { offset = val.get(Calendar.HOUR_OF_DAY);"
      },
      {
        "txt": "if (offset >= 12) { offset -= 12; } roundUp = offset > 6; offsetSet = true; } break; } if (!offsetSet) { int min = val.getActualMinimum(fields[i][0]);"
      },
      {
        "txt": "int max = val.getActualMaximum(fields[i][0]); offset = val.get(fields[i][0]) - min; roundUp = offset > ((max - min) / 2); } if (offset != 0) { val.set(fields[i][0], val.get(fields[i][0]) - offset); } } throw new IllegalArgumentException(\"The field \" + field + \" is not supported\"); }"
      },
      {
        "txt": "public static Iterator iterator(Date focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } Calendar gval = Calendar.getInstance(); gval.setTime(focus); return iterator(gval, rangeStyle); } public static Iterator iterator(Calendar focus, int rangeStyle) { if (focus == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The date must not be null\"); } Calendar start = null; Calendar end = null; int startCutoff = Calendar.SUNDAY; int endCutoff = Calendar.SATURDAY; switch (rangeStyle) { case RANGE_MONTH_SUNDAY: case RANGE_MONTH_MONDAY: start = truncate(focus, Calendar.MONTH);"
      },
      {
        "txt": "end = (Calendar) start.clone(); end.add(Calendar.MONTH, 1); end.add(Calendar.DATE, -1); if (rangeStyle == RANGE_MONTH_MONDAY) { startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY; } break; case RANGE_WEEK_SUNDAY: case RANGE_WEEK_MONDAY:"
      },
      {
        "txt": "case RANGE_WEEK_RELATIVE: case RANGE_WEEK_CENTER: start = truncate(focus, Calendar.DATE); end = truncate(focus, Calendar.DATE); switch (rangeStyle) { case RANGE_WEEK_SUNDAY: break; case RANGE_WEEK_MONDAY: startCutoff = Calendar.MONDAY; endCutoff = Calendar.SUNDAY;"
      },
      {
        "txt": "break; case RANGE_WEEK_RELATIVE: startCutoff = focus.get(Calendar.DAY_OF_WEEK); endCutoff = startCutoff - 1; break; case RANGE_WEEK_CENTER: startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; break; }"
      },
      {
        "txt": "break; default: throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\"); } if (startCutoff < Calendar.SUNDAY) { startCutoff += 7; } if (startCutoff > Calendar.SATURDAY) { startCutoff -= 7; }"
      },
      {
        "txt": "if (endCutoff < Calendar.SUNDAY) { endCutoff += 7; } if (endCutoff > Calendar.SATURDAY) { endCutoff -= 7; } while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { start.add(Calendar.DATE, -1); } while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {"
      },
      {
        "txt": "end.add(Calendar.DATE, 1); } return new DateIterator(start, end); } public static Iterator iterator(Object focus, int rangeStyle) { if (focus == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (focus instanceof Date) { return iterator((Date) focus, rangeStyle);"
      },
      {
        "txt": "} else if (focus instanceof Calendar) { return iterator((Calendar) focus, rangeStyle); } else { throw new ClassCastException(\"Could not iterate based on \" + focus); } } static class DateIterator implements Iterator { private final Calendar endFinal; private final Calendar spot; DateIterator(Calendar startFinal, Calendar endFinal) {"
      },
      {
        "txt": "super(); this.endFinal = endFinal; spot = startFinal; spot.add(Calendar.DATE, -1); } public boolean hasNext() { return spot.before(endFinal); } public Object next() { if (spot.equals(endFinal)) {"
      },
      {
        "txt": "throw new NoSuchElementException(); } spot.add(Calendar.DATE, 1); return spot.clone(); } public void remove() { throw new UnsupportedOperationException(); } } public static final int MILLIS_IN_SECOND = 1000;"
      },
      {
        "txt": "public static final int MILLIS_IN_MINUTE = 60 * 1000; public static final int MILLIS_IN_HOUR = 60 * 60 * 1000; public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;"
      }
    ]
  }
]