[
  {
    "id": 2383,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 191,
    "end-bug-line": 191,
    "bug": "",
    "fix": "StringBuffer arrayPrefix = new StringBuffer();",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet;"
      },
      {
        "txt": "import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {"
      },
      {
        "txt": "primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class); primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); }"
      },
      {
        "txt": "private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) { wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>();"
      },
      {
        "txt": "private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); } static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\");"
      },
      {
        "txt": "addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) {"
      },
      {
        "txt": "return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); }"
      },
      {
        "txt": "if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; } <extra_id_0> int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);"
      },
      {
        "txt": "if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass());"
      },
      {
        "txt": "} public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageName(cls.getName()); } public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "} int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null;"
      },
      {
        "txt": "} List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass); superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound); return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces();"
      },
      {
        "txt": "for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } } cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) {"
      },
      {
        "txt": "return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try { classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } }"
      },
      {
        "txt": "return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null; } List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null);"
      },
      {
        "txt": "} else { classNames.add(cls.getName()); } } return classNames; } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {"
      },
      {
        "txt": "if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) {"
      },
      {
        "txt": "if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {"
      },
      {
        "txt": "if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) {"
      },
      {
        "txt": "return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; } } }"
      },
      {
        "txt": "if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) {"
      },
      {
        "txt": "return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false; } return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls;"
      },
      {
        "txt": "if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; } public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) {"
      },
      {
        "txt": "return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]); } return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls);"
      },
      {
        "txt": "} public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) {"
      },
      {
        "txt": "convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) { if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; }"
      },
      {
        "txt": "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className); clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz;"
      },
      {
        "txt": "} public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException { return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;"
      },
      {
        "txt": "return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes); if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls));"
      },
      {
        "txt": "candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; } Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue;"
      },
      {
        "txt": "} if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } } throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className);"
      },
      {
        "txt": "if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) {"
      },
      {
        "txt": "classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString(); } return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) {"
      },
      {
        "txt": "return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }"
      },
      {
        "txt": "public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); } public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); } public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName());"
      },
      {
        "txt": "} public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); }"
      },
      {
        "txt": "private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else { int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); }"
      },
      {
        "txt": "if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring( 1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else {"
      },
      {
        "txt": "if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className); for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2384,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 193,
    "end-bug-line": 193,
    "bug": "",
    "fix": "if (className.startsWith(\"[\")) { while (className.charAt(0) == '[') { className = className.substring(1); arrayPrefix.append(\"[]\"); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet;"
      },
      {
        "txt": "import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {"
      },
      {
        "txt": "primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class); primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); }"
      },
      {
        "txt": "private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) { wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>();"
      },
      {
        "txt": "private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); } static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\");"
      },
      {
        "txt": "addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) {"
      },
      {
        "txt": "return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); }"
      },
      {
        "txt": "if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; } <extra_id_0> int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);"
      },
      {
        "txt": "if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass());"
      },
      {
        "txt": "} public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageName(cls.getName()); } public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "} int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null;"
      },
      {
        "txt": "} List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass); superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound); return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces();"
      },
      {
        "txt": "for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } } cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) {"
      },
      {
        "txt": "return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try { classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } }"
      },
      {
        "txt": "return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null; } List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null);"
      },
      {
        "txt": "} else { classNames.add(cls.getName()); } } return classNames; } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {"
      },
      {
        "txt": "if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) {"
      },
      {
        "txt": "if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {"
      },
      {
        "txt": "if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) {"
      },
      {
        "txt": "return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; } } }"
      },
      {
        "txt": "if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) {"
      },
      {
        "txt": "return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false; } return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls;"
      },
      {
        "txt": "if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; } public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) {"
      },
      {
        "txt": "return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]); } return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls);"
      },
      {
        "txt": "} public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) {"
      },
      {
        "txt": "convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) { if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; }"
      },
      {
        "txt": "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className); clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz;"
      },
      {
        "txt": "} public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException { return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;"
      },
      {
        "txt": "return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes); if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls));"
      },
      {
        "txt": "candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; } Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue;"
      },
      {
        "txt": "} if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } } throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className);"
      },
      {
        "txt": "if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) {"
      },
      {
        "txt": "classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString(); } return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) {"
      },
      {
        "txt": "return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }"
      },
      {
        "txt": "public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); } public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); } public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName());"
      },
      {
        "txt": "} public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); }"
      },
      {
        "txt": "private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else { int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); }"
      },
      {
        "txt": "if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring( 1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else {"
      },
      {
        "txt": "if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className); for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2385,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 194,
    "end-bug-line": 194,
    "bug": "",
    "fix": "if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { className = className.substring(1, className.length() - 1); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet;"
      },
      {
        "txt": "import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {"
      },
      {
        "txt": "primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class); primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); }"
      },
      {
        "txt": "private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) { wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>();"
      },
      {
        "txt": "private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); } static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\");"
      },
      {
        "txt": "addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) {"
      },
      {
        "txt": "return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); }"
      },
      {
        "txt": "if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; } <extra_id_0> int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);"
      },
      {
        "txt": "if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass());"
      },
      {
        "txt": "} public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageName(cls.getName()); } public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "} int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null;"
      },
      {
        "txt": "} List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass); superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound); return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces();"
      },
      {
        "txt": "for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } } cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) {"
      },
      {
        "txt": "return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try { classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } }"
      },
      {
        "txt": "return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null; } List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null);"
      },
      {
        "txt": "} else { classNames.add(cls.getName()); } } return classNames; } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {"
      },
      {
        "txt": "if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) {"
      },
      {
        "txt": "if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {"
      },
      {
        "txt": "if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) {"
      },
      {
        "txt": "return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; } } }"
      },
      {
        "txt": "if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) {"
      },
      {
        "txt": "return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false; } return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls;"
      },
      {
        "txt": "if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; } public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) {"
      },
      {
        "txt": "return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]); } return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls);"
      },
      {
        "txt": "} public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) {"
      },
      {
        "txt": "convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) { if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; }"
      },
      {
        "txt": "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className); clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz;"
      },
      {
        "txt": "} public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException { return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;"
      },
      {
        "txt": "return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes); if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls));"
      },
      {
        "txt": "candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; } Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue;"
      },
      {
        "txt": "} if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } } throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className);"
      },
      {
        "txt": "if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) {"
      },
      {
        "txt": "classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString(); } return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) {"
      },
      {
        "txt": "return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }"
      },
      {
        "txt": "public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); } public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); } public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName());"
      },
      {
        "txt": "} public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); }"
      },
      {
        "txt": "private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else { int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); }"
      },
      {
        "txt": "if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring( 1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else {"
      },
      {
        "txt": "if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className); for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2386,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 195,
    "end-bug-line": 195,
    "bug": "",
    "fix": "if (reverseAbbreviationMap.containsKey(className)) { className = reverseAbbreviationMap.get(className); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet;"
      },
      {
        "txt": "import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static {"
      },
      {
        "txt": "primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class); primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); }"
      },
      {
        "txt": "private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) { wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>();"
      },
      {
        "txt": "private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); } static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\");"
      },
      {
        "txt": "addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) {"
      },
      {
        "txt": "return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); }"
      },
      {
        "txt": "if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; } <extra_id_0> int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);"
      },
      {
        "txt": "if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass());"
      },
      {
        "txt": "} public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageName(cls.getName()); } public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "} int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null;"
      },
      {
        "txt": "} List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass); superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound); return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces();"
      },
      {
        "txt": "for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } } cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) {"
      },
      {
        "txt": "return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try { classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } }"
      },
      {
        "txt": "return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null; } List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null);"
      },
      {
        "txt": "} else { classNames.add(cls.getName()); } } return classNames; } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {"
      },
      {
        "txt": "if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) {"
      },
      {
        "txt": "if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {"
      },
      {
        "txt": "if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) {"
      },
      {
        "txt": "return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; } } }"
      },
      {
        "txt": "if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) {"
      },
      {
        "txt": "return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false; } return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls;"
      },
      {
        "txt": "if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; } public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) {"
      },
      {
        "txt": "return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]); } return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls);"
      },
      {
        "txt": "} public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) {"
      },
      {
        "txt": "convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) { if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; }"
      },
      {
        "txt": "public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className); clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz;"
      },
      {
        "txt": "} public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException { return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;"
      },
      {
        "txt": "return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes); if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls));"
      },
      {
        "txt": "candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; } Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue;"
      },
      {
        "txt": "} if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } } throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className);"
      },
      {
        "txt": "if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) {"
      },
      {
        "txt": "classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString(); } return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) {"
      },
      {
        "txt": "return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }"
      },
      {
        "txt": "public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); } public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); } public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName());"
      },
      {
        "txt": "} public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); }"
      },
      {
        "txt": "private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else { int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); }"
      },
      {
        "txt": "if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring( 1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else {"
      },
      {
        "txt": "if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className); for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); }"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2387,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 203,
    "end-bug-line": 203,
    "bug": "return out;",
    "fix": "return out + arrayPrefix;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang; import java.lang.reflect.Method; import java.lang.reflect.Modifier;"
      },
      {
        "txt": "import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$';"
      },
      {
        "txt": "public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static { primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class); primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class);"
      },
      {
        "txt": "primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); } private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) { wrapperPrimitiveMap.put(wrapperClass, primitiveClass); }"
      },
      {
        "txt": "} } private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); } static { addAbbreviation(\"int\", \"I\");"
      },
      {
        "txt": "addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() { super();"
      },
      {
        "txt": "} public static String getShortClassName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "} return getShortClassName(cls.getName()); } public static String getShortClassName(String className) { if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } <extra_id_0> } public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass());"
      },
      {
        "txt": "} return getPackageName(object.getClass()); } public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageName(cls.getName()); } public static String getPackageName(String className) {"
      },
      {
        "txt": "if (className == null) { return StringUtils.EMPTY; } int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass); superclass = superclass.getSuperclass(); } return classes;"
      },
      {
        "txt": "} public static List<Class<?>> getAllInterfaces(Class<?> cls) { if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound); return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {"
      },
      {
        "txt": "while (cls != null) { Class<?>[] interfaces = cls.getInterfaces(); for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } } cls = cls.getSuperclass(); } }"
      },
      {
        "txt": "public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try { classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null);"
      },
      {
        "txt": "} } return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null; } List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) {"
      },
      {
        "txt": "if (cls == null) { classNames.add(null); } else { classNames.add(cls.getName()); } } return classNames; } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false);"
      },
      {
        "txt": "} public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;"
      },
      {
        "txt": "} for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false);"
      },
      {
        "txt": "} public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) { if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) {"
      },
      {
        "txt": "cls = primitiveToWrapper(cls); if (cls == null) { return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; }"
      },
      {
        "txt": "} } if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) {"
      },
      {
        "txt": "return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false;"
      },
      {
        "txt": "} if (Double.TYPE.equals(cls)) { return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) {"
      },
      {
        "txt": "return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false; } return toClass.isAssignableFrom(cls); }"
      },
      {
        "txt": "public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls; if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; } public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null;"
      },
      {
        "txt": "} if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]); } return convertedClasses; }"
      },
      {
        "txt": "public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls); } public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; }"
      },
      {
        "txt": "Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) { if (cls == null) { return false; }"
      },
      {
        "txt": "return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; } public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className); clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader);"
      },
      {
        "txt": "} return clazz; } public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException { return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {"
      },
      {
        "txt": "ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes); if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; }"
      },
      {
        "txt": "List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls)); candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; } Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes);"
      },
      {
        "txt": "} catch (NoSuchMethodException ex) { continue; } if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } } throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); }"
      },
      {
        "txt": "private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); }"
      },
      {
        "txt": "String abbreviation = abbreviationMap.get(className); if (abbreviation != null) { classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString(); } return className; }"
      },
      {
        "txt": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); }"
      },
      {
        "txt": "return classes; } public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName()); } public static String getShortCanonicalName(Class<?> cls) { if (cls == null) {"
      },
      {
        "txt": "return StringUtils.EMPTY; } return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); } public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull;"
      },
      {
        "txt": "} return getPackageCanonicalName(object.getClass().getName()); } public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) {"
      },
      {
        "txt": "return ClassUtils.getPackageName(getCanonicalName(canonicalName)); } private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else { int dim = 0; while (className.startsWith(\"[\")) { dim++;"
      },
      {
        "txt": "className = className.substring(1); } if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring( 1, className.endsWith(\";\") ? className.length() - 1"
      },
      {
        "txt": ": className.length()); } else { if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className); for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); }"
      },
      {
        "txt": "return canonicalClassNameBuffer.toString(); } } }"
      }
    ]
  },
  {
    "id": 2388,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 245,
    "end-bug-line": 245,
    "bug": "if (className == null) {",
    "fix": "if (className == null || className.length() == 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List;"
      },
      {
        "txt": "import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.'; public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static { primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class);"
      },
      {
        "txt": "primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class); primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); } private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static {"
      },
      {
        "txt": "for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) { wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) {"
      },
      {
        "txt": "abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); } static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\");"
      },
      {
        "txt": "addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); } public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; }"
      },
      {
        "txt": "return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); } public static String getShortClassName(String className) { if (className == null) {"
      },
      {
        "txt": "return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; } int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) {"
      },
      {
        "txt": "out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; } public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass()); }"
      },
      {
        "txt": "if (cls == null) { return StringUtils.EMPTY; } return getPackageName(cls.getName()); } public static String getPackageName(String className) { <extra_id_0> return StringUtils.EMPTY; } int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return StringUtils.EMPTY; } return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass();"
      },
      {
        "txt": "while (superclass != null) { classes.add(superclass); superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) { if (cls == null) { return null; }"
      },
      {
        "txt": "LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound); return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces(); for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound);"
      },
      {
        "txt": "} } cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());"
      },
      {
        "txt": "for (String className : classNames) { try { classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } } return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) {"
      },
      {
        "txt": "if (classes == null) { return null; } List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null); } else { classNames.add(cls.getName()); }"
      },
      {
        "txt": "} return classNames; } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; }"
      },
      {
        "txt": "if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; }"
      },
      {
        "txt": "} return true; } public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) { if (toClass == null) { return false; }"
      },
      {
        "txt": "if (cls == null) { return !(toClass.isPrimitive()); } if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) { return false; } }"
      },
      {
        "txt": "if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls); if (cls == null) { return false; } } } if (cls.equals(toClass)) { return true; }"
      },
      {
        "txt": "if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) { return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) {"
      },
      {
        "txt": "return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) { return false; } if (Float.TYPE.equals(cls)) {"
      },
      {
        "txt": "return Double.TYPE.equals(toClass); } if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} return false; } return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls; if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); }"
      },
      {
        "txt": "return convertedClass; } public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length];"
      },
      {
        "txt": "for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]); } return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls); } public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) {"
      },
      {
        "txt": "return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses;"
      },
      {
        "txt": "} public static boolean isInnerClass(Class<?> cls) { if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; } public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz;"
      },
      {
        "txt": "if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className); clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz; } public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true);"
      },
      {
        "txt": "} public static Class<?> getClass(String className) throws ClassNotFoundException { return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[])"
      },
      {
        "txt": "throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes); if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls)); candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) {"
      },
      {
        "txt": "continue; } Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue; } if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod;"
      },
      {
        "txt": "} } throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) {"
      },
      {
        "txt": "StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) { className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) { classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\");"
      },
      {
        "txt": "} className = classNameBuffer.toString(); } return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY;"
      },
      {
        "txt": "} Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; } public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull;"
      },
      {
        "txt": "} return getShortCanonicalName(object.getClass().getName()); } public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) {"
      },
      {
        "txt": "return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); } public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName()); } public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) {"
      },
      {
        "txt": "return StringUtils.EMPTY; } return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); } private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) {"
      },
      {
        "txt": "return null; } else { int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); } if (dim < 1) { return className; } else {"
      },
      {
        "txt": "if (className.startsWith(\"L\")) { className = className.substring( 1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else { if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); }"
      },
      {
        "txt": "} StringBuffer canonicalClassNameBuffer = new StringBuffer(className); for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); } } }"
      }
    ]
  },
  {
    "id": 2389,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 250,
    "end-bug-line": 250,
    "bug": "",
    "fix": "while (className.charAt(0) == '[') { className = className.substring(1); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.';"
      },
      {
        "txt": "public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static { primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class);"
      },
      {
        "txt": "primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); } private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) {"
      },
      {
        "txt": "wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); }"
      },
      {
        "txt": "static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); }"
      },
      {
        "txt": "public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); } public static String getShortClassName(String className) { if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) {"
      },
      {
        "txt": "return StringUtils.EMPTY; } int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out;"
      },
      {
        "txt": "} public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass()); } public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "return getPackageName(cls.getName()); } public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY; } <extra_id_0> int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); }"
      },
      {
        "txt": "return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass);"
      },
      {
        "txt": "superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) { if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound);"
      },
      {
        "txt": "return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces(); for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } }"
      },
      {
        "txt": "cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try {"
      },
      {
        "txt": "classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } } return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null;"
      },
      {
        "txt": "} List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null); } else { classNames.add(cls.getName()); } } return classNames;"
      },
      {
        "txt": "} public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY;"
      },
      {
        "txt": "} if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) { if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive());"
      },
      {
        "txt": "} if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) { return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls);"
      },
      {
        "txt": "if (cls == null) { return false; } } } if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) {"
      },
      {
        "txt": "return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) { return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); }"
      },
      {
        "txt": "if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false;"
      },
      {
        "txt": "} return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls; if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; }"
      },
      {
        "txt": "public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]);"
      },
      {
        "txt": "} return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls); } public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; }"
      },
      {
        "txt": "if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; } public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className);"
      },
      {
        "txt": "clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz; } public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException {"
      },
      {
        "txt": "return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes);"
      },
      {
        "txt": "if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls)); candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; }"
      },
      {
        "txt": "Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue; } if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } }"
      },
      {
        "txt": "throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) {"
      },
      {
        "txt": "className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) { classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString();"
      },
      {
        "txt": "} return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length];"
      },
      {
        "txt": "for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; } public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName());"
      },
      {
        "txt": "} public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); }"
      },
      {
        "txt": "public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName()); } public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); } private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else {"
      },
      {
        "txt": "int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); } if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring("
      },
      {
        "txt": "1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else { if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className);"
      },
      {
        "txt": "for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); } } }"
      }
    ]
  },
  {
    "id": 2390,
    "file_path": "src/java/org/apache/commons/lang/ClassUtils.java",
    "start-bug-line": 251,
    "end-bug-line": 251,
    "bug": "",
    "fix": "if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { className = className.substring(1); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.';"
      },
      {
        "txt": "public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR); public static final char INNER_CLASS_SEPARATOR_CHAR = '$'; public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR); private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>(); static { primitiveWrapperMap.put(Boolean.TYPE, Boolean.class); primitiveWrapperMap.put(Byte.TYPE, Byte.class); primitiveWrapperMap.put(Character.TYPE, Character.class); primitiveWrapperMap.put(Short.TYPE, Short.class); primitiveWrapperMap.put(Integer.TYPE, Integer.class);"
      },
      {
        "txt": "primitiveWrapperMap.put(Long.TYPE, Long.class); primitiveWrapperMap.put(Double.TYPE, Double.class); primitiveWrapperMap.put(Float.TYPE, Float.class); primitiveWrapperMap.put(Void.TYPE, Void.TYPE); } private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>(); static { for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) { Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass); if (!primitiveClass.equals(wrapperClass)) {"
      },
      {
        "txt": "wrapperPrimitiveMap.put(wrapperClass, primitiveClass); } } } private static final Map<String, String> abbreviationMap = new HashMap<String, String>(); private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>(); private static void addAbbreviation(String primitive, String abbreviation) { abbreviationMap.put(primitive, abbreviation); reverseAbbreviationMap.put(abbreviation, primitive); }"
      },
      {
        "txt": "static { addAbbreviation(\"int\", \"I\"); addAbbreviation(\"boolean\", \"Z\"); addAbbreviation(\"float\", \"F\"); addAbbreviation(\"long\", \"J\"); addAbbreviation(\"short\", \"S\"); addAbbreviation(\"byte\", \"B\"); addAbbreviation(\"double\", \"D\"); addAbbreviation(\"char\", \"C\"); }"
      },
      {
        "txt": "public ClassUtils() { super(); } public static String getShortClassName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortClassName(object.getClass()); } public static String getShortClassName(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return StringUtils.EMPTY; } return getShortClassName(cls.getName()); } public static String getShortClassName(String className) { if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) {"
      },
      {
        "txt": "return StringUtils.EMPTY; } int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out;"
      },
      {
        "txt": "} public static String getPackageName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageName(object.getClass()); } public static String getPackageName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY;"
      },
      {
        "txt": "return getPackageName(cls.getName()); } public static String getPackageName(String className) { if (className == null) { return StringUtils.EMPTY; } <extra_id_0> int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); }"
      },
      {
        "txt": "return className.substring(0, i); } public static List<Class<?>> getAllSuperclasses(Class<?> cls) { if (cls == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(); Class<?> superclass = cls.getSuperclass(); while (superclass != null) { classes.add(superclass);"
      },
      {
        "txt": "superclass = superclass.getSuperclass(); } return classes; } public static List<Class<?>> getAllInterfaces(Class<?> cls) { if (cls == null) { return null; } LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>(); getAllInterfaces(cls, interfacesFound);"
      },
      {
        "txt": "return new ArrayList<Class<?>>(interfacesFound); } private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) { while (cls != null) { Class<?>[] interfaces = cls.getInterfaces(); for (Class<?> i : interfaces) { if (interfacesFound.add(i)) { getAllInterfaces(i, interfacesFound); } }"
      },
      {
        "txt": "cls = cls.getSuperclass(); } } public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) { if (classNames == null) { return null; } List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); for (String className : classNames) { try {"
      },
      {
        "txt": "classes.add(Class.forName(className)); } catch (Exception ex) { classes.add(null); } } return classes; } public static List<String> convertClassesToClassNames(List<Class<?>> classes) { if (classes == null) { return null;"
      },
      {
        "txt": "} List<String> classNames = new ArrayList<String>(classes.size()); for (Class<?> cls : classes) { if (cls == null) { classNames.add(null); } else { classNames.add(cls.getName()); } } return classNames;"
      },
      {
        "txt": "} public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) { return isAssignable(classArray, toClassArray, false); } public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { return false; } if (classArray == null) { classArray = ArrayUtils.EMPTY_CLASS_ARRAY;"
      },
      {
        "txt": "} if (toClassArray == null) { toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true;"
      },
      {
        "txt": "} public static boolean isAssignable(Class<?> cls, Class<?> toClass) { return isAssignable(cls, toClass, false); } public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) { if (toClass == null) { return false; } if (cls == null) { return !(toClass.isPrimitive());"
      },
      {
        "txt": "} if (autoboxing) { if (cls.isPrimitive() && !toClass.isPrimitive()) { cls = primitiveToWrapper(cls); if (cls == null) { return false; } } if (toClass.isPrimitive() && !cls.isPrimitive()) { cls = wrapperToPrimitive(cls);"
      },
      {
        "txt": "if (cls == null) { return false; } } } if (cls.equals(toClass)) { return true; } if (cls.isPrimitive()) { if (toClass.isPrimitive() == false) {"
      },
      {
        "txt": "return false; } if (Integer.TYPE.equals(cls)) { return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Long.TYPE.equals(cls)) { return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);"
      },
      {
        "txt": "} if (Boolean.TYPE.equals(cls)) { return false; } if (Double.TYPE.equals(cls)) { return false; } if (Float.TYPE.equals(cls)) { return Double.TYPE.equals(toClass); }"
      },
      {
        "txt": "if (Character.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } if (Short.TYPE.equals(cls)) { return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass)"
      },
      {
        "txt": "|| Double.TYPE.equals(toClass); } if (Byte.TYPE.equals(cls)) { return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); } return false;"
      },
      {
        "txt": "} return toClass.isAssignableFrom(cls); } public static Class<?> primitiveToWrapper(Class<?> cls) { Class<?> convertedClass = cls; if (cls != null && cls.isPrimitive()) { convertedClass = primitiveWrapperMap.get(cls); } return convertedClass; }"
      },
      {
        "txt": "public static Class<?>[] primitivesToWrappers(Class<?>[] classes) { if (classes == null) { return null; } if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = primitiveToWrapper(classes[i]);"
      },
      {
        "txt": "} return convertedClasses; } public static Class<?> wrapperToPrimitive(Class<?> cls) { return wrapperPrimitiveMap.get(cls); } public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) { if (classes == null) { return null; }"
      },
      {
        "txt": "if (classes.length == 0) { return classes; } Class<?>[] convertedClasses = new Class[classes.length]; for (int i = 0; i < classes.length; i++) { convertedClasses[i] = wrapperToPrimitive(classes[i]); } return convertedClasses; } public static boolean isInnerClass(Class<?> cls) {"
      },
      {
        "txt": "if (cls == null) { return false; } return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0; } public static Class<?> getClass( ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException { Class<?> clazz; if (abbreviationMap.containsKey(className)) { String clsName = \"[\" + abbreviationMap.get(className);"
      },
      {
        "txt": "clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); } else { clazz = Class.forName(toCanonicalName(className), initialize, classLoader); } return clazz; } public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException { return getClass(classLoader, className, true); } public static Class<?> getClass(String className) throws ClassNotFoundException {"
      },
      {
        "txt": "return getClass(className, true); } public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException { ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; return getClass(loader, className, initialize ); } public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[]) throws SecurityException, NoSuchMethodException { Method declaredMethod = cls.getMethod(methodName, parameterTypes);"
      },
      {
        "txt": "if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) { return declaredMethod; } List<Class<?>> candidateClasses = new ArrayList<Class<?>>(); candidateClasses.addAll(getAllInterfaces(cls)); candidateClasses.addAll(getAllSuperclasses(cls)); for (Class<?> candidateClass : candidateClasses) { if (!Modifier.isPublic(candidateClass.getModifiers())) { continue; }"
      },
      {
        "txt": "Method candidateMethod; try { candidateMethod = candidateClass.getMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { continue; } if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) { return candidateMethod; } }"
      },
      {
        "txt": "throw new NoSuchMethodException(\"Can't find a public method for \" + methodName + \" \" + ArrayUtils.toString(parameterTypes)); } private static String toCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { throw new NullPointerException(\"className must not be null.\"); } else if (className.endsWith(\"[]\")) { StringBuffer classNameBuffer = new StringBuffer(); while (className.endsWith(\"[]\")) {"
      },
      {
        "txt": "className = className.substring(0, className.length() - 2); classNameBuffer.append(\"[\"); } String abbreviation = abbreviationMap.get(className); if (abbreviation != null) { classNameBuffer.append(abbreviation); } else { classNameBuffer.append(\"L\").append(className).append(\";\"); } className = classNameBuffer.toString();"
      },
      {
        "txt": "} return className; } public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length];"
      },
      {
        "txt": "for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; } public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getShortCanonicalName(object.getClass().getName());"
      },
      {
        "txt": "} public static String getShortCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; } return getShortCanonicalName(cls.getName()); } public static String getShortCanonicalName(String canonicalName) { return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); }"
      },
      {
        "txt": "public static String getPackageCanonicalName(Object object, String valueIfNull) { if (object == null) { return valueIfNull; } return getPackageCanonicalName(object.getClass().getName()); } public static String getPackageCanonicalName(Class<?> cls) { if (cls == null) { return StringUtils.EMPTY; }"
      },
      {
        "txt": "return getPackageCanonicalName(cls.getName()); } public static String getPackageCanonicalName(String canonicalName) { return ClassUtils.getPackageName(getCanonicalName(canonicalName)); } private static String getCanonicalName(String className) { className = StringUtils.deleteWhitespace(className); if (className == null) { return null; } else {"
      },
      {
        "txt": "int dim = 0; while (className.startsWith(\"[\")) { dim++; className = className.substring(1); } if (dim < 1) { return className; } else { if (className.startsWith(\"L\")) { className = className.substring("
      },
      {
        "txt": "1, className.endsWith(\";\") ? className.length() - 1 : className.length()); } else { if (className.length() > 0) { className = reverseAbbreviationMap.get(className.substring(0, 1)); } } StringBuffer canonicalClassNameBuffer = new StringBuffer(className);"
      },
      {
        "txt": "for (int i = 0; i < dim; i++) { canonicalClassNameBuffer.append(\"[]\"); } return canonicalClassNameBuffer.toString(); } } }"
      }
    ]
  }
]