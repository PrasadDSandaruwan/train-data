[
  {
    "id": 2320,
    "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateFormat.java",
    "start-bug-line": 495,
    "end-bug-line": 496,
    "bug": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen);",
    "fix": "if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3.time; import java.io.IOException; import java.io.ObjectInputStream; import java.text.DateFormat; import java.text.DateFormatSymbols;"
      },
      {
        "txt": "import java.text.FieldPosition; import java.text.Format; import java.text.ParsePosition; import java.util.ArrayList; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.List; import java.util.Locale; import java.util.TimeZone;"
      },
      {
        "txt": "import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import org.apache.commons.lang3.Validate; public class FastDateFormat extends Format { private static final long serialVersionUID = 1L; public static final int FULL = DateFormat.FULL; public static final int LONG = DateFormat.LONG; public static final int MEDIUM = DateFormat.MEDIUM; public static final int SHORT = DateFormat.SHORT; private static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {"
      },
      {
        "txt": "@Override protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) { return new FastDateFormat(pattern, timeZone, locale); } }; private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<TimeZoneDisplayKey, String>(7); private final String mPattern; private final TimeZone mTimeZone; private final Locale mLocale;"
      },
      {
        "txt": "private transient Rule[] mRules; private transient int mMaxLengthEstimate; public static FastDateFormat getInstance() { return cache.getDateTimeInstance(SHORT, SHORT, null, null); } public static FastDateFormat getInstance(String pattern) { return cache.getInstance(pattern, null, null); } public static FastDateFormat getInstance(String pattern, TimeZone timeZone) { return cache.getInstance(pattern, timeZone, null);"
      },
      {
        "txt": "} public static FastDateFormat getInstance(String pattern, Locale locale) { return cache.getInstance(pattern, null, locale); } public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) { return cache.getInstance(pattern, timeZone, locale); } public static FastDateFormat getDateInstance(int style) { return cache.getDateTimeInstance(style, null, null, null); }"
      },
      {
        "txt": "public static FastDateFormat getDateInstance(int style, Locale locale) { return cache.getDateTimeInstance(style, null, null, locale); } public static FastDateFormat getDateInstance(int style, TimeZone timeZone) { return cache.getDateTimeInstance(style, null, timeZone, null); } public static FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) { return cache.getDateTimeInstance(style, null, timeZone, locale); } public static FastDateFormat getTimeInstance(int style) {"
      },
      {
        "txt": "return cache.getDateTimeInstance(null, style, null, null); } public static FastDateFormat getTimeInstance(int style, Locale locale) { return cache.getDateTimeInstance(null, style, null, locale); } public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) { return cache.getDateTimeInstance(null, style, timeZone, null); } public static FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) { return cache.getDateTimeInstance(null, style, timeZone, locale);"
      },
      {
        "txt": "} public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) { return cache.getDateTimeInstance(dateStyle, timeStyle, null, null); } public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) { return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale); } public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) { return getDateTimeInstance(dateStyle, timeStyle, timeZone, null); }"
      },
      {
        "txt": "public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) { return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); } static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) { TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale); String value = cTimeZoneDisplayCache.get(key); if (value == null) { value = tz.getDisplayName(daylight, style, locale); String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);"
      },
      {
        "txt": "if (prior != null) { value= prior; } } return value; } protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) { mPattern = pattern; mTimeZone = timeZone; mLocale = locale;"
      },
      {
        "txt": "init(); } private void init() { List<Rule> rulesList = parsePattern(); mRules = rulesList.toArray(new Rule[rulesList.size()]); int len = 0; for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); } mMaxLengthEstimate = len;"
      },
      {
        "txt": "} protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>(); String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();"
      },
      {
        "txt": "int length = mPattern.length(); int[] indexRef = new int[1]; for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0]; int tokenLen = token.length(); if (tokenLen == 0) { break; }"
      },
      {
        "txt": "char c = token.charAt(0); switch (c) { case 'G': // era designator (text) rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) <extra_id_0> } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': // month in year (text and number) if (tokenLen >= 4) {"
      },
      {
        "txt": "case 'M': // month in year (text and number) if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; } else { rule = UnpaddedMonthField.INSTANCE; }"
      },
      {
        "txt": "break; case 'd': // day in month (number) rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; case 'h': // hour in am/pm (number, 1..12) rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': // hour in day (number, 0..23) rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break;"
      },
      {
        "txt": "case 'm': // minute in hour (number) rule = selectNumberRule(Calendar.MINUTE, tokenLen); break; case 's': // second in minute (number) rule = selectNumberRule(Calendar.SECOND, tokenLen); break; case 'S': // millisecond (number) rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); break; case 'E': // day in week (text)"
      },
      {
        "txt": "rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; case 'D': // day in year (number) rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': // day of week in month (number) rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': // week in year (number) rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);"
      },
      {
        "txt": "break; case 'W': // week in month (number) rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': // am/pm marker (text) rule = new TextField(Calendar.AM_PM, AmPmStrings); break; case 'k': // hour in day (1..24) rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); break;"
      },
      {
        "txt": "case 'K': // hour in am/pm (0..11) rule = selectNumberRule(Calendar.HOUR, tokenLen); break; case 'z': // time zone (text) if (tokenLen >= 4) { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); } else { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); } break;"
      },
      {
        "txt": "case 'Z': // time zone (value) if (tokenLen == 1) { rule = TimeZoneNumberRule.INSTANCE_NO_COLON; } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\\'': // literal text String sub = token.substring(1); if (sub.length() == 1) {"
      },
      {
        "txt": "rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException(\"Illegal pattern component: \" + token); } rules.add(rule); }"
      },
      {
        "txt": "return rules; } protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { buf.append(c); while (i + 1 < length) {"
      },
      {
        "txt": "char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { buf.append('\\'');"
      },
      {
        "txt": "boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { i++; buf.append(c); } else { inLiteral = !inLiteral; }"
      },
      {
        "txt": "} else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i;"
      },
      {
        "txt": "return buf.toString(); } protected NumberRule selectNumberRule(int field, int padding) { switch (padding) { case 1: return new UnpaddedNumberField(field); case 2: return new TwoDigitNumberField(field); default: return new PaddedNumberField(field, padding);"
      },
      {
        "txt": "} } @Override public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { if (obj instanceof Date) { return format((Date) obj, toAppendTo); } else if (obj instanceof Calendar) { return format((Calendar) obj, toAppendTo); } else if (obj instanceof Long) { return format(((Long) obj).longValue(), toAppendTo);"
      },
      {
        "txt": "} else { throw new IllegalArgumentException(\"Unknown class: \" + (obj == null ? \"<null>\" : obj.getClass().getName())); } } public String format(long millis) { return format(new Date(millis)); } public String format(Date date) { Calendar c = new GregorianCalendar(mTimeZone, mLocale); // hard code GregorianCalendar"
      },
      {
        "txt": "c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); } public String format(Calendar calendar) { return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString(); } public StringBuffer format(long millis, StringBuffer buf) { return format(new Date(millis), buf); } public StringBuffer format(Date date, StringBuffer buf) {"
      },
      {
        "txt": "Calendar c = new GregorianCalendar(mTimeZone, mLocale); // hard code GregorianCalendar c.setTime(date); return applyRules(c, buf); } public StringBuffer format(Calendar calendar, StringBuffer buf) { return applyRules(calendar, buf); } protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) { for (Rule rule : mRules) { rule.appendTo(buf, calendar);"
      },
      {
        "txt": "} return buf; } @Override public Object parseObject(String source, ParsePosition pos) { pos.setIndex(0); pos.setErrorIndex(0); return null; } public String getPattern() {"
      },
      {
        "txt": "return mPattern; } public TimeZone getTimeZone() { return mTimeZone; } public Locale getLocale() { return mLocale; } public int getMaxLengthEstimate() { return mMaxLengthEstimate;"
      },
      {
        "txt": "} @Override public boolean equals(Object obj) { if (obj instanceof FastDateFormat == false) { return false; } FastDateFormat other = (FastDateFormat) obj; return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);"
      },
      {
        "txt": "} @Override public int hashCode() { return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode()); } @Override public String toString() { return \"FastDateFormat[\" + mPattern + \"]\"; } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {"
      },
      {
        "txt": "in.defaultReadObject(); init(); } private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule { void appendTo(StringBuffer buffer, int value); }"
      },
      {
        "txt": "private static class CharacterLiteral implements Rule { private final char mValue; CharacterLiteral(char value) { mValue = value; } public int estimateLength() { return 1; } public void appendTo(StringBuffer buffer, Calendar calendar) { buffer.append(mValue);"
      },
      {
        "txt": "} } private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value) { mValue = value; } public int estimateLength() { return mValue.length(); }"
      },
      {
        "txt": "public void appendTo(StringBuffer buffer, Calendar calendar) { buffer.append(mValue); } } private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values) { mField = field; mValues = values;"
      },
      {
        "txt": "} public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max;"
      },
      {
        "txt": "} public void appendTo(StringBuffer buffer, Calendar calendar) { buffer.append(mValues[calendar.get(mField)]); } } private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field) { mField = field; }"
      },
      {
        "txt": "public int estimateLength() { return 4; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(mField)); } public final void appendTo(StringBuffer buffer, int value) { if (value < 10) { buffer.append((char)(value + '0')); } else if (value < 100) {"
      },
      {
        "txt": "buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } else { buffer.append(Integer.toString(value)); } } } private static class UnpaddedMonthField implements NumberRule { static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField(); UnpaddedMonthField() {"
      },
      {
        "txt": "super(); } public int estimateLength() { return 2; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(Calendar.MONTH) + 1); } public final void appendTo(StringBuffer buffer, int value) { if (value < 10) {"
      },
      {
        "txt": "buffer.append((char)(value + '0')); } else { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } } } private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize;"
      },
      {
        "txt": "PaddedNumberField(int field, int size) { if (size < 3) { throw new IllegalArgumentException(); } mField = field; mSize = size; } public int estimateLength() { return 4; }"
      },
      {
        "txt": "public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(mField)); } public final void appendTo(StringBuffer buffer, int value) { if (value < 100) { for (int i = mSize; --i >= 2; ) { buffer.append('0'); } buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0'));"
      },
      {
        "txt": "} else { int digits; if (value < 1000) { digits = 3; } else { Validate.isTrue(value > -1, \"Negative values should not be possible\", value); digits = Integer.toString(value).length(); } for (int i = mSize; --i >= digits; ) { buffer.append('0');"
      },
      {
        "txt": "} buffer.append(Integer.toString(value)); } } } private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field) { mField = field; }"
      },
      {
        "txt": "public int estimateLength() { return 2; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(mField)); } public final void appendTo(StringBuffer buffer, int value) { if (value < 100) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0'));"
      },
      {
        "txt": "} else { buffer.append(Integer.toString(value)); } } } private static class TwoDigitYearField implements NumberRule { static final TwoDigitYearField INSTANCE = new TwoDigitYearField(); TwoDigitYearField() { super(); }"
      },
      {
        "txt": "public int estimateLength() { return 2; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(Calendar.YEAR) % 100); } public final void appendTo(StringBuffer buffer, int value) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); }"
      },
      {
        "txt": "} private static class TwoDigitMonthField implements NumberRule { static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField(); TwoDigitMonthField() { super(); } public int estimateLength() { return 2; } public void appendTo(StringBuffer buffer, Calendar calendar) {"
      },
      {
        "txt": "appendTo(buffer, calendar.get(Calendar.MONTH) + 1); } public final void appendTo(StringBuffer buffer, int value) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } } private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule) {"
      },
      {
        "txt": "mRule = rule; } public int estimateLength() { return mRule.estimateLength(); } public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; }"
      },
      {
        "txt": "mRule.appendTo(buffer, value); } public void appendTo(StringBuffer buffer, int value) { mRule.appendTo(buffer, value); } } private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule) { mRule = rule;"
      },
      {
        "txt": "} public int estimateLength() { return mRule.estimateLength(); } public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR_OF_DAY); if (value == 0) { value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1; } mRule.appendTo(buffer, value);"
      },
      {
        "txt": "} public void appendTo(StringBuffer buffer, int value) { mRule.appendTo(buffer, value); } } private static class TimeZoneNameRule implements Rule { private final TimeZone mTimeZone; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {"
      },
      {
        "txt": "mTimeZone = timeZone; mStandard = getTimeZoneDisplay(timeZone, false, style, locale); mDaylight = getTimeZoneDisplay(timeZone, true, style, locale); } public int estimateLength() { return Math.max(mStandard.length(), mDaylight.length()); } public void appendTo(StringBuffer buffer, Calendar calendar) { if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(mDaylight);"
      },
      {
        "txt": "} else { buffer.append(mStandard); } } } private static class TimeZoneNumberRule implements Rule { static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true); static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false); final boolean mColon; TimeZoneNumberRule(boolean colon) {"
      },
      {
        "txt": "mColon = colon; } public int estimateLength() { return 5; } public void appendTo(StringBuffer buffer, Calendar calendar) { int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); if (offset < 0) { buffer.append('-'); offset = -offset;"
      },
      {
        "txt": "} else { buffer.append('+'); } int hours = offset / (60 * 60 * 1000); buffer.append((char)(hours / 10 + '0')); buffer.append((char)(hours % 10 + '0')); if (mColon) { buffer.append(':'); } int minutes = offset / (60 * 1000) - 60 * hours;"
      },
      {
        "txt": "buffer.append((char)(minutes / 10 + '0')); buffer.append((char)(minutes % 10 + '0')); } } private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) {"
      },
      {
        "txt": "mTimeZone = timeZone; if (daylight) { style |= 0x80000000; } mStyle = style; mLocale = locale; } @Override public int hashCode() { return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();"
      },
      {
        "txt": "} @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof TimeZoneDisplayKey) { TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj; return mTimeZone.equals(other.mTimeZone) &&"
      },
      {
        "txt": "mStyle == other.mStyle && mLocale.equals(other.mLocale); } return false; } }"
      }
    ]
  },
  {
    "id": 2321,
    "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateFormat.java",
    "start-bug-line": 498,
    "end-bug-line": 498,
    "bug": "rule = TwoDigitYearField.INSTANCE;",
    "fix": "rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.lang3.time; import java.io.IOException; import java.io.ObjectInputStream; import java.text.DateFormat; import java.text.DateFormatSymbols; import java.text.FieldPosition; import java.text.Format; import java.text.ParsePosition;"
      },
      {
        "txt": "import java.util.ArrayList; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.List; import java.util.Locale; import java.util.TimeZone; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.ConcurrentMap; import org.apache.commons.lang3.Validate;"
      },
      {
        "txt": "public class FastDateFormat extends Format { private static final long serialVersionUID = 1L; public static final int FULL = DateFormat.FULL; public static final int LONG = DateFormat.LONG; public static final int MEDIUM = DateFormat.MEDIUM; public static final int SHORT = DateFormat.SHORT; private static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() { @Override protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) { return new FastDateFormat(pattern, timeZone, locale);"
      },
      {
        "txt": "} }; private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<TimeZoneDisplayKey, String>(7); private final String mPattern; private final TimeZone mTimeZone; private final Locale mLocale; private transient Rule[] mRules; private transient int mMaxLengthEstimate; public static FastDateFormat getInstance() {"
      },
      {
        "txt": "return cache.getDateTimeInstance(SHORT, SHORT, null, null); } public static FastDateFormat getInstance(String pattern) { return cache.getInstance(pattern, null, null); } public static FastDateFormat getInstance(String pattern, TimeZone timeZone) { return cache.getInstance(pattern, timeZone, null); } public static FastDateFormat getInstance(String pattern, Locale locale) { return cache.getInstance(pattern, null, locale);"
      },
      {
        "txt": "} public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) { return cache.getInstance(pattern, timeZone, locale); } public static FastDateFormat getDateInstance(int style) { return cache.getDateTimeInstance(style, null, null, null); } public static FastDateFormat getDateInstance(int style, Locale locale) { return cache.getDateTimeInstance(style, null, null, locale); }"
      },
      {
        "txt": "public static FastDateFormat getDateInstance(int style, TimeZone timeZone) { return cache.getDateTimeInstance(style, null, timeZone, null); } public static FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) { return cache.getDateTimeInstance(style, null, timeZone, locale); } public static FastDateFormat getTimeInstance(int style) { return cache.getDateTimeInstance(null, style, null, null); } public static FastDateFormat getTimeInstance(int style, Locale locale) {"
      },
      {
        "txt": "return cache.getDateTimeInstance(null, style, null, locale); } public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) { return cache.getDateTimeInstance(null, style, timeZone, null); } public static FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) { return cache.getDateTimeInstance(null, style, timeZone, locale); } public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) { return cache.getDateTimeInstance(dateStyle, timeStyle, null, null);"
      },
      {
        "txt": "} public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) { return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale); } public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) { return getDateTimeInstance(dateStyle, timeStyle, timeZone, null); } public static FastDateFormat getDateTimeInstance( int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) { return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);"
      },
      {
        "txt": "} static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) { TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale); String value = cTimeZoneDisplayCache.get(key); if (value == null) { value = tz.getDisplayName(daylight, style, locale); String prior = cTimeZoneDisplayCache.putIfAbsent(key, value); if (prior != null) { value= prior; }"
      },
      {
        "txt": "} return value; } protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) { mPattern = pattern; mTimeZone = timeZone; mLocale = locale; init(); } private void init() {"
      },
      {
        "txt": "List<Rule> rulesList = parsePattern(); mRules = rulesList.toArray(new Rule[rulesList.size()]); int len = 0; for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); } mMaxLengthEstimate = len; } protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale);"
      },
      {
        "txt": "List<Rule> rules = new ArrayList<Rule>(); String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings(); int length = mPattern.length(); int[] indexRef = new int[1]; for (int i = 0; i < length; i++) {"
      },
      {
        "txt": "indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0]; int tokenLen = token.length(); if (tokenLen == 0) { break; } Rule rule; char c = token.charAt(0); switch (c) {"
      },
      {
        "txt": "rule = new TextField(Calendar.ERA, ERAs); break; case 'y': // year (number) if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { <extra_id_0> } break; case 'M': // month in year (text and number) if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) {"
      },
      {
        "txt": "rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; } else { rule = UnpaddedMonthField.INSTANCE; } break; case 'd': // day in month (number)"
      },
      {
        "txt": "rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; case 'h': // hour in am/pm (number, 1..12) rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': // hour in day (number, 0..23) rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break; case 'm': // minute in hour (number) rule = selectNumberRule(Calendar.MINUTE, tokenLen);"
      },
      {
        "txt": "break; case 's': // second in minute (number) rule = selectNumberRule(Calendar.SECOND, tokenLen); break; case 'S': // millisecond (number) rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); break; case 'E': // day in week (text) rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break;"
      },
      {
        "txt": "case 'D': // day in year (number) rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': // day of week in month (number) rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': // week in year (number) rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); break; case 'W': // week in month (number)"
      },
      {
        "txt": "rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': // am/pm marker (text) rule = new TextField(Calendar.AM_PM, AmPmStrings); break; case 'k': // hour in day (1..24) rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); break; case 'K': // hour in am/pm (0..11) rule = selectNumberRule(Calendar.HOUR, tokenLen);"
      },
      {
        "txt": "break; case 'z': // time zone (text) if (tokenLen >= 4) { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); } else { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); } break; case 'Z': // time zone (value) if (tokenLen == 1) {"
      },
      {
        "txt": "rule = TimeZoneNumberRule.INSTANCE_NO_COLON; } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\\'': // literal text String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else {"
      },
      {
        "txt": "rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException(\"Illegal pattern component: \" + token); } rules.add(rule); } return rules; }"
      },
      {
        "txt": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) {"
      },
      {
        "txt": "buf.append(c); i++; } else { break; } } } else { buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) {"
      },
      {
        "txt": "c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {"
      },
      {
        "txt": "i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }"
      },
      {
        "txt": "protected NumberRule selectNumberRule(int field, int padding) { switch (padding) { case 1: return new UnpaddedNumberField(field); case 2: return new TwoDigitNumberField(field); default: return new PaddedNumberField(field, padding); } }"
      },
      {
        "txt": "@Override public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { if (obj instanceof Date) { return format((Date) obj, toAppendTo); } else if (obj instanceof Calendar) { return format((Calendar) obj, toAppendTo); } else if (obj instanceof Long) { return format(((Long) obj).longValue(), toAppendTo); } else { throw new IllegalArgumentException(\"Unknown class: \" +"
      },
      {
        "txt": "(obj == null ? \"<null>\" : obj.getClass().getName())); } } public String format(long millis) { return format(new Date(millis)); } public String format(Date date) { Calendar c = new GregorianCalendar(mTimeZone, mLocale); // hard code GregorianCalendar c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();"
      },
      {
        "txt": "} public String format(Calendar calendar) { return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString(); } public StringBuffer format(long millis, StringBuffer buf) { return format(new Date(millis), buf); } public StringBuffer format(Date date, StringBuffer buf) { Calendar c = new GregorianCalendar(mTimeZone, mLocale); // hard code GregorianCalendar c.setTime(date);"
      },
      {
        "txt": "return applyRules(c, buf); } public StringBuffer format(Calendar calendar, StringBuffer buf) { return applyRules(calendar, buf); } protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) { for (Rule rule : mRules) { rule.appendTo(buf, calendar); } return buf;"
      },
      {
        "txt": "} @Override public Object parseObject(String source, ParsePosition pos) { pos.setIndex(0); pos.setErrorIndex(0); return null; } public String getPattern() { return mPattern; }"
      },
      {
        "txt": "public TimeZone getTimeZone() { return mTimeZone; } public Locale getLocale() { return mLocale; } public int getMaxLengthEstimate() { return mMaxLengthEstimate; } @Override"
      },
      {
        "txt": "public boolean equals(Object obj) { if (obj instanceof FastDateFormat == false) { return false; } FastDateFormat other = (FastDateFormat) obj; return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); } @Override"
      },
      {
        "txt": "public int hashCode() { return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode()); } @Override public String toString() { return \"FastDateFormat[\" + mPattern + \"]\"; } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); init();"
      },
      {
        "txt": "} private interface Rule { int estimateLength(); void appendTo(StringBuffer buffer, Calendar calendar); } private interface NumberRule extends Rule { void appendTo(StringBuffer buffer, int value); } private static class CharacterLiteral implements Rule { private final char mValue;"
      },
      {
        "txt": "CharacterLiteral(char value) { mValue = value; } public int estimateLength() { return 1; } public void appendTo(StringBuffer buffer, Calendar calendar) { buffer.append(mValue); } }"
      },
      {
        "txt": "private static class StringLiteral implements Rule { private final String mValue; StringLiteral(String value) { mValue = value; } public int estimateLength() { return mValue.length(); } public void appendTo(StringBuffer buffer, Calendar calendar) { buffer.append(mValue);"
      },
      {
        "txt": "} } private static class TextField implements Rule { private final int mField; private final String[] mValues; TextField(int field, String[] values) { mField = field; mValues = values; } public int estimateLength() {"
      },
      {
        "txt": "int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; } public void appendTo(StringBuffer buffer, Calendar calendar) {"
      },
      {
        "txt": "buffer.append(mValues[calendar.get(mField)]); } } private static class UnpaddedNumberField implements NumberRule { private final int mField; UnpaddedNumberField(int field) { mField = field; } public int estimateLength() { return 4;"
      },
      {
        "txt": "} public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(mField)); } public final void appendTo(StringBuffer buffer, int value) { if (value < 10) { buffer.append((char)(value + '0')); } else if (value < 100) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0'));"
      },
      {
        "txt": "} else { buffer.append(Integer.toString(value)); } } } private static class UnpaddedMonthField implements NumberRule { static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField(); UnpaddedMonthField() { super(); }"
      },
      {
        "txt": "public int estimateLength() { return 2; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(Calendar.MONTH) + 1); } public final void appendTo(StringBuffer buffer, int value) { if (value < 10) { buffer.append((char)(value + '0')); } else {"
      },
      {
        "txt": "buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } } } private static class PaddedNumberField implements NumberRule { private final int mField; private final int mSize; PaddedNumberField(int field, int size) { if (size < 3) {"
      },
      {
        "txt": "throw new IllegalArgumentException(); } mField = field; mSize = size; } public int estimateLength() { return 4; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(mField));"
      },
      {
        "txt": "} public final void appendTo(StringBuffer buffer, int value) { if (value < 100) { for (int i = mSize; --i >= 2; ) { buffer.append('0'); } buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } else { int digits;"
      },
      {
        "txt": "if (value < 1000) { digits = 3; } else { Validate.isTrue(value > -1, \"Negative values should not be possible\", value); digits = Integer.toString(value).length(); } for (int i = mSize; --i >= digits; ) { buffer.append('0'); } buffer.append(Integer.toString(value));"
      },
      {
        "txt": "} } } private static class TwoDigitNumberField implements NumberRule { private final int mField; TwoDigitNumberField(int field) { mField = field; } public int estimateLength() { return 2;"
      },
      {
        "txt": "} public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(mField)); } public final void appendTo(StringBuffer buffer, int value) { if (value < 100) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } else { buffer.append(Integer.toString(value));"
      },
      {
        "txt": "} } } private static class TwoDigitYearField implements NumberRule { static final TwoDigitYearField INSTANCE = new TwoDigitYearField(); TwoDigitYearField() { super(); } public int estimateLength() { return 2;"
      },
      {
        "txt": "} public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(Calendar.YEAR) % 100); } public final void appendTo(StringBuffer buffer, int value) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } } private static class TwoDigitMonthField implements NumberRule {"
      },
      {
        "txt": "static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField(); TwoDigitMonthField() { super(); } public int estimateLength() { return 2; } public void appendTo(StringBuffer buffer, Calendar calendar) { appendTo(buffer, calendar.get(Calendar.MONTH) + 1); }"
      },
      {
        "txt": "public final void appendTo(StringBuffer buffer, int value) { buffer.append((char)(value / 10 + '0')); buffer.append((char)(value % 10 + '0')); } } private static class TwelveHourField implements NumberRule { private final NumberRule mRule; TwelveHourField(NumberRule rule) { mRule = rule; }"
      },
      {
        "txt": "public int estimateLength() { return mRule.estimateLength(); } public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }"
      },
      {
        "txt": "public void appendTo(StringBuffer buffer, int value) { mRule.appendTo(buffer, value); } } private static class TwentyFourHourField implements NumberRule { private final NumberRule mRule; TwentyFourHourField(NumberRule rule) { mRule = rule; } public int estimateLength() {"
      },
      {
        "txt": "return mRule.estimateLength(); } public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR_OF_DAY); if (value == 0) { value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1; } mRule.appendTo(buffer, value); } public void appendTo(StringBuffer buffer, int value) {"
      },
      {
        "txt": "mRule.appendTo(buffer, value); } } private static class TimeZoneNameRule implements Rule { private final TimeZone mTimeZone; private final String mStandard; private final String mDaylight; TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) { mTimeZone = timeZone; mStandard = getTimeZoneDisplay(timeZone, false, style, locale);"
      },
      {
        "txt": "mDaylight = getTimeZoneDisplay(timeZone, true, style, locale); } public int estimateLength() { return Math.max(mStandard.length(), mDaylight.length()); } public void appendTo(StringBuffer buffer, Calendar calendar) { if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) { buffer.append(mDaylight); } else { buffer.append(mStandard);"
      },
      {
        "txt": "} } } private static class TimeZoneNumberRule implements Rule { static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true); static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false); final boolean mColon; TimeZoneNumberRule(boolean colon) { mColon = colon; }"
      },
      {
        "txt": "public int estimateLength() { return 5; } public void appendTo(StringBuffer buffer, Calendar calendar) { int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); if (offset < 0) { buffer.append('-'); offset = -offset; } else { buffer.append('+');"
      },
      {
        "txt": "} int hours = offset / (60 * 60 * 1000); buffer.append((char)(hours / 10 + '0')); buffer.append((char)(hours % 10 + '0')); if (mColon) { buffer.append(':'); } int minutes = offset / (60 * 1000) - 60 * hours; buffer.append((char)(minutes / 10 + '0')); buffer.append((char)(minutes % 10 + '0'));"
      },
      {
        "txt": "} } private static class TimeZoneDisplayKey { private final TimeZone mTimeZone; private final int mStyle; private final Locale mLocale; TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) { mTimeZone = timeZone; if (daylight) {"
      },
      {
        "txt": "style |= 0x80000000; } mStyle = style; mLocale = locale; } @Override public int hashCode() { return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode(); } @Override"
      },
      {
        "txt": "public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof TimeZoneDisplayKey) { TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj; return mTimeZone.equals(other.mTimeZone) && mStyle == other.mStyle && mLocale.equals(other.mLocale);"
      },
      {
        "txt": "} return false; } }"
      }
    ]
  }
]