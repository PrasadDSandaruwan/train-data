[
  {
    "id": 2974,
    "file_path": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java",
    "start-bug-line": 801,
    "end-bug-line": 801,
    "bug": "",
    "fix": "if (sep.iAfterParser == null && sep.iAfterPrinter == null) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.format; import java.io.IOException; import java.io.Writer;"
      },
      {
        "txt": "import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Locale; import java.util.TreeSet; import org.joda.time.DateTimeConstants; import org.joda.time.DurationFieldType; import org.joda.time.PeriodType; import org.joda.time.ReadWritablePeriod; import org.joda.time.ReadablePeriod;"
      },
      {
        "txt": "public class PeriodFormatterBuilder { private static final int PRINT_ZERO_RARELY_FIRST = 1; private static final int PRINT_ZERO_RARELY_LAST = 2; private static final int PRINT_ZERO_IF_SUPPORTED = 3; private static final int PRINT_ZERO_ALWAYS = 4; private static final int PRINT_ZERO_NEVER = 5; private static final int YEARS = 0; private static final int MONTHS = 1; private static final int WEEKS = 2; private static final int DAYS = 3;"
      },
      {
        "txt": "private static final int HOURS = 4; private static final int MINUTES = 5; private static final int SECONDS = 6; private static final int MILLIS = 7; private static final int SECONDS_MILLIS = 8; private static final int SECONDS_OPTIONAL_MILLIS = 9; private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS; private int iMinPrintedDigits; private int iPrintZeroSetting; private int iMaxParsedDigits;"
      },
      {
        "txt": "private boolean iRejectSignedValues; private PeriodFieldAffix iPrefix; private List<Object> iElementPairs; private boolean iNotPrinter; private boolean iNotParser; private FieldFormatter[] iFieldFormatters; public PeriodFormatterBuilder() { clear(); } public PeriodFormatter toFormatter() {"
      },
      {
        "txt": "PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser); iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone(); return formatter; } public PeriodPrinter toPrinter() { if (iNotPrinter) { return null; } return toFormatter().getPrinter(); }"
      },
      {
        "txt": "public PeriodParser toParser() { if (iNotParser) { return null; } return toFormatter().getParser(); } public void clear() { iMinPrintedDigits = 1; iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; iMaxParsedDigits = 10;"
      },
      {
        "txt": "iRejectSignedValues = false; iPrefix = null; if (iElementPairs == null) { iElementPairs = new ArrayList<Object>(); } else { iElementPairs.clear(); } iNotPrinter = false; iNotParser = false; iFieldFormatters = new FieldFormatter[10];"
      },
      {
        "txt": "} public PeriodFormatterBuilder append(PeriodFormatter formatter) { if (formatter == null) { throw new IllegalArgumentException(\"No formatter supplied\"); } clearPrefix(); append0(formatter.getPrinter(), formatter.getParser()); return this; } public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {"
      },
      {
        "txt": "if (printer == null && parser == null) { throw new IllegalArgumentException(\"No printer or parser supplied\"); } clearPrefix(); append0(printer, parser); return this; } public PeriodFormatterBuilder appendLiteral(String text) { if (text == null) { throw new IllegalArgumentException(\"Literal must not be null\");"
      },
      {
        "txt": "} clearPrefix(); Literal literal = new Literal(text); append0(literal, literal); return this; } public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) { iMinPrintedDigits = minDigits; return this; }"
      },
      {
        "txt": "public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) { iMaxParsedDigits = maxDigits; return this; } public PeriodFormatterBuilder rejectSignedValues(boolean v) { iRejectSignedValues = v; return this; } public PeriodFormatterBuilder printZeroRarelyLast() { iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;"
      },
      {
        "txt": "return this; } public PeriodFormatterBuilder printZeroRarelyFirst() { iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST; return this; } public PeriodFormatterBuilder printZeroIfSupported() { iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED; return this; }"
      },
      {
        "txt": "public PeriodFormatterBuilder printZeroAlways() { iPrintZeroSetting = PRINT_ZERO_ALWAYS; return this; } public PeriodFormatterBuilder printZeroNever() { iPrintZeroSetting = PRINT_ZERO_NEVER; return this; } public PeriodFormatterBuilder appendPrefix(String text) { if (text == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(); } return appendPrefix(new SimpleAffix(text)); } public PeriodFormatterBuilder appendPrefix(String singularText, String pluralText) { if (singularText == null || pluralText == null) { throw new IllegalArgumentException(); } return appendPrefix(new PluralAffix(singularText, pluralText));"
      },
      {
        "txt": "} private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) { if (prefix == null) { throw new IllegalArgumentException(); } if (iPrefix != null) { prefix = new CompositeAffix(iPrefix, prefix); } iPrefix = prefix; return this;"
      },
      {
        "txt": "} public PeriodFormatterBuilder appendYears() { appendField(YEARS); return this; } public PeriodFormatterBuilder appendMonths() { appendField(MONTHS); return this; } public PeriodFormatterBuilder appendWeeks() {"
      },
      {
        "txt": "appendField(WEEKS); return this; } public PeriodFormatterBuilder appendDays() { appendField(DAYS); return this; } public PeriodFormatterBuilder appendHours() { appendField(HOURS); return this;"
      },
      {
        "txt": "} public PeriodFormatterBuilder appendMinutes() { appendField(MINUTES); return this; } public PeriodFormatterBuilder appendSeconds() { appendField(SECONDS); return this; } public PeriodFormatterBuilder appendSecondsWithMillis() {"
      },
      {
        "txt": "appendField(SECONDS_MILLIS); return this; } public PeriodFormatterBuilder appendSecondsWithOptionalMillis() { appendField(SECONDS_OPTIONAL_MILLIS); return this; } public PeriodFormatterBuilder appendMillis() { appendField(MILLIS); return this;"
      },
      {
        "txt": "} public PeriodFormatterBuilder appendMillis3Digit() { appendField(7, 3); return this; } private void appendField(int type) { appendField(type, iMinPrintedDigits); } private void appendField(int type, int minPrinted) { FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,"
      },
      {
        "txt": "iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null); append0(field, field); iFieldFormatters[type] = field; iPrefix = null; } public PeriodFormatterBuilder appendSuffix(String text) { if (text == null) { throw new IllegalArgumentException(); } return appendSuffix(new SimpleAffix(text));"
      },
      {
        "txt": "} public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) { if (singularText == null || pluralText == null) { throw new IllegalArgumentException(); } return appendSuffix(new PluralAffix(singularText, pluralText)); } private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { final Object originalPrinter;"
      },
      {
        "txt": "final Object originalParser; if (iElementPairs.size() > 0) { originalPrinter = iElementPairs.get(iElementPairs.size() - 2); originalParser = iElementPairs.get(iElementPairs.size() - 1); } else { originalPrinter = null; originalParser = null; } if (originalPrinter == null || originalParser == null || originalPrinter != originalParser ||"
      },
      {
        "txt": "!(originalPrinter instanceof FieldFormatter)) { throw new IllegalStateException(\"No field to apply suffix to\"); } clearPrefix(); FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); iElementPairs.set(iElementPairs.size() - 2, newField); iElementPairs.set(iElementPairs.size() - 1, newField); iFieldFormatters[newField.getFieldType()] = newField; return this; }"
      },
      {
        "txt": "public PeriodFormatterBuilder appendSeparator(String text) { return appendSeparator(text, text, null, true, true); } public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) { return appendSeparator(text, text, null, false, true); } public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) { return appendSeparator(text, text, null, true, false); } public PeriodFormatterBuilder appendSeparator(String text, String finalText) {"
      },
      {
        "txt": "return appendSeparator(text, finalText, null, true, true); } public PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants) { return appendSeparator(text, finalText, variants, true, true); } private PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants, boolean useBefore, boolean useAfter) { if (text == null || finalText == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(); } clearPrefix(); List<Object> pairs = iElementPairs; if (pairs.size() == 0) { if (useAfter && useBefore == false) { Separator separator = new Separator( text, finalText, variants, Literal.EMPTY, Literal.EMPTY, useBefore, useAfter); append0(separator, separator);"
      },
      {
        "txt": "} return this; } int i; Separator lastSeparator = null; for (i=pairs.size(); --i>=0; ) { if (pairs.get(i) instanceof Separator) { lastSeparator = (Separator) pairs.get(i); pairs = pairs.subList(i + 1, pairs.size()); break;"
      },
      {
        "txt": "} i--; // element pairs } if (lastSeparator != null && pairs.size() == 0) { throw new IllegalStateException(\"Cannot have two adjacent separators\"); } else { Object[] comp = createComposite(pairs); pairs.clear(); Separator separator = new Separator( text, finalText, variants,"
      },
      {
        "txt": "(PeriodPrinter) comp[0], (PeriodParser) comp[1], useBefore, useAfter); pairs.add(separator); pairs.add(separator); } return this; } private void clearPrefix() throws IllegalStateException { if (iPrefix != null) { throw new IllegalStateException(\"Prefix not followed by field\");"
      },
      {
        "txt": "} iPrefix = null; } private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) { iElementPairs.add(printer); iElementPairs.add(parser); iNotPrinter |= (printer == null); iNotParser |= (parser == null); return this; }"
      },
      {
        "txt": "if (notPrinter && notParser) { throw new IllegalStateException(\"Builder has created neither a printer nor a parser\"); } int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); <extra_id_0> sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); } Object[] comp = createComposite(elementPairs); if (notPrinter) { return new PeriodFormatter(null, (PeriodParser) comp[1]);"
      },
      {
        "txt": "if (notPrinter) { return new PeriodFormatter(null, (PeriodParser) comp[1]); } else if (notParser) { return new PeriodFormatter((PeriodPrinter) comp[0], null); } else { return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); } } private static Object[] createComposite(List<Object> elementPairs) { switch (elementPairs.size()) {"
      },
      {
        "txt": "case 0: return new Object[] {Literal.EMPTY, Literal.EMPTY}; case 1: return new Object[] {elementPairs.get(0), elementPairs.get(1)}; default: Composite comp = new Composite(elementPairs); return new Object[] {comp, comp}; } } static interface PeriodFieldAffix {"
      },
      {
        "txt": "int calculatePrintedLength(int value); void printTo(StringBuffer buf, int value); void printTo(Writer out, int value) throws IOException; int parse(String periodStr, int position); int scan(String periodStr, int position); } static class SimpleAffix implements PeriodFieldAffix { private final String iText; SimpleAffix(String text) { iText = text;"
      },
      {
        "txt": "} public int calculatePrintedLength(int value) { return iText.length(); } public void printTo(StringBuffer buf, int value) { buf.append(iText); } public void printTo(Writer out, int value) throws IOException { out.write(iText); }"
      },
      {
        "txt": "public int parse(String periodStr, int position) { String text = iText; int textLength = text.length(); if (periodStr.regionMatches(true, position, text, 0, textLength)) { return position + textLength; } return ~position; } public int scan(String periodStr, final int position) { String text = iText;"
      },
      {
        "txt": "int textLength = text.length(); int sourceLength = periodStr.length(); search: for (int pos = position; pos < sourceLength; pos++) { if (periodStr.regionMatches(true, pos, text, 0, textLength)) { return pos; } switch (periodStr.charAt(pos)) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':"
      },
      {
        "txt": "case '.': case ',': case '+': case '-': break; default: break search; } } return ~position; } } static class PluralAffix implements PeriodFieldAffix {"
      },
      {
        "txt": "private final String iSingularText; private final String iPluralText; PluralAffix(String singularText, String pluralText) { iSingularText = singularText; iPluralText = pluralText; } public int calculatePrintedLength(int value) { return (value == 1 ? iSingularText : iPluralText).length(); } public void printTo(StringBuffer buf, int value) {"
      },
      {
        "txt": "buf.append(value == 1 ? iSingularText : iPluralText); } public void printTo(Writer out, int value) throws IOException { out.write(value == 1 ? iSingularText : iPluralText); } public int parse(String periodStr, int position) { String text1 = iPluralText; String text2 = iSingularText; if (text1.length() < text2.length()) { String temp = text1;"
      },
      {
        "txt": "text1 = text2; text2 = temp; } if (periodStr.regionMatches (true, position, text1, 0, text1.length())) { return position + text1.length(); } if (periodStr.regionMatches (true, position, text2, 0, text2.length())) { return position + text2.length();"
      },
      {
        "txt": "} return ~position; } public int scan(String periodStr, final int position) { String text1 = iPluralText; String text2 = iSingularText; if (text1.length() < text2.length()) { String temp = text1; text1 = text2; text2 = temp;"
      },
      {
        "txt": "} int textLength1 = text1.length(); int textLength2 = text2.length(); int sourceLength = periodStr.length(); for (int pos = position; pos < sourceLength; pos++) { if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) { return pos; } if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) { return pos;"
      },
      {
        "txt": "} } return ~position; } } static class CompositeAffix implements PeriodFieldAffix { private final PeriodFieldAffix iLeft; private final PeriodFieldAffix iRight; CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) { iLeft = left;"
      },
      {
        "txt": "iRight = right; } public int calculatePrintedLength(int value) { return iLeft.calculatePrintedLength(value) + iRight.calculatePrintedLength(value); } public void printTo(StringBuffer buf, int value) { iLeft.printTo(buf, value); iRight.printTo(buf, value); }"
      },
      {
        "txt": "public void printTo(Writer out, int value) throws IOException { iLeft.printTo(out, value); iRight.printTo(out, value); } public int parse(String periodStr, int position) { position = iLeft.parse(periodStr, position); if (position >= 0) { position = iRight.parse(periodStr, position); } return position;"
      },
      {
        "txt": "} public int scan(String periodStr, final int position) { int pos = iLeft.scan(periodStr, position); if (pos >= 0) { return iRight.scan(periodStr, pos); } return ~position; } } static class FieldFormatter"
      },
      {
        "txt": "implements PeriodPrinter, PeriodParser { private final int iMinPrintedDigits; private final int iPrintZeroSetting; private final int iMaxParsedDigits; private final boolean iRejectSignedValues; private final int iFieldType; private final FieldFormatter[] iFieldFormatters; private final PeriodFieldAffix iPrefix; private final PeriodFieldAffix iSuffix; FieldFormatter(int minPrintedDigits, int printZeroSetting,"
      },
      {
        "txt": "int maxParsedDigits, boolean rejectSignedValues, int fieldType, FieldFormatter[] fieldFormatters, PeriodFieldAffix prefix, PeriodFieldAffix suffix) { iMinPrintedDigits = minPrintedDigits; iPrintZeroSetting = printZeroSetting; iMaxParsedDigits = maxParsedDigits; iRejectSignedValues = rejectSignedValues; iFieldType = fieldType; iFieldFormatters = fieldFormatters; iPrefix = prefix;"
      },
      {
        "txt": "iSuffix = suffix; } FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) { iMinPrintedDigits = field.iMinPrintedDigits; iPrintZeroSetting = field.iPrintZeroSetting; iMaxParsedDigits = field.iMaxParsedDigits; iRejectSignedValues = field.iRejectSignedValues; iFieldType = field.iFieldType; iFieldFormatters = field.iFieldFormatters; iPrefix = field.iPrefix;"
      },
      {
        "txt": "if (field.iSuffix != null) { suffix = new CompositeAffix(field.iSuffix, suffix); } iSuffix = suffix; } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { if (stopAt <= 0) { return 0; } if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {"
      },
      {
        "txt": "return 1; } return 0; } public int calculatePrintedLength(ReadablePeriod period, Locale locale) { long valueLong = getFieldValue(period); if (valueLong == Long.MAX_VALUE) { return 0; } int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);"
      },
      {
        "txt": "if (iFieldType >= SECONDS_MILLIS) { sum = Math.max(sum, 4); sum++; if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { sum -= 4; // remove three digits and decimal point } valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; } int value = (int) valueLong;"
      },
      {
        "txt": "if (iPrefix != null) { sum += iPrefix.calculatePrintedLength(value); } if (iSuffix != null) { sum += iSuffix.calculatePrintedLength(value); } return sum; } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { long valueLong = getFieldValue(period);"
      },
      {
        "txt": "if (valueLong == Long.MAX_VALUE) { return; } int value = (int) valueLong; if (iFieldType >= SECONDS_MILLIS) { value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); } if (iPrefix != null) { iPrefix.printTo(buf, value); }"
      },
      {
        "txt": "int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value); } else { FormatUtils.appendPaddedInteger(buf, value, minDigits); } if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { buf.append('.');"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, dp, 3); } } if (iSuffix != null) { iSuffix.printTo(buf, value); } } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { long valueLong = getFieldValue(period); if (valueLong == Long.MAX_VALUE) {"
      },
      {
        "txt": "return; } int value = (int) valueLong; if (iFieldType >= SECONDS_MILLIS) { value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); } if (iPrefix != null) { iPrefix.printTo(out, value); } int minDigits = iMinPrintedDigits;"
      },
      {
        "txt": "if (minDigits <= 1) { FormatUtils.writeUnpaddedInteger(out, value); } else { FormatUtils.writePaddedInteger(out, value, minDigits); } if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { out.write('.'); FormatUtils.writePaddedInteger(out, dp, 3);"
      },
      {
        "txt": "} } if (iSuffix != null) { iSuffix.printTo(out, value); } } public int parseInto( ReadWritablePeriod period, String text, int position, Locale locale) { boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);"
      },
      {
        "txt": "if (position >= text.length()) { return mustParse ? ~position : position; } if (iPrefix != null) { position = iPrefix.parse(text, position); if (position >= 0) { mustParse = true; } else { if (!mustParse) { return ~position;"
      },
      {
        "txt": "} return position; } } int suffixPos = -1; if (iSuffix != null && !mustParse) { suffixPos = iSuffix.scan(text, position); if (suffixPos >= 0) { mustParse = true; } else {"
      },
      {
        "txt": "if (!mustParse) { return ~suffixPos; } return suffixPos; } } if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { return position; } int limit;"
      },
      {
        "txt": "if (suffixPos > 0) { limit = Math.min(iMaxParsedDigits, suffixPos - position); } else { limit = Math.min(iMaxParsedDigits, text.length() - position); } int length = 0; int fractPos = -1; boolean hasDigits = false; while (length < limit) { char c = text.charAt(position + length);"
      },
      {
        "txt": "if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { boolean negative = c == '-'; if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { break; } if (negative) { length++; } else {"
      },
      {
        "txt": "position++; } limit = Math.min(limit + 1, text.length() - position); continue; } if (c >= '0' && c <= '9') { hasDigits = true; } else { if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {"
      },
      {
        "txt": "if (fractPos >= 0) { break; } fractPos = position + length + 1; limit = Math.min(limit + 1, text.length() - position); } else { break; } } length++;"
      },
      {
        "txt": "} if (!hasDigits) { return ~position; } if (suffixPos >= 0 && position + length != suffixPos) { return position; } if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { setFieldValue(period, iFieldType, parseInt(text, position, length)); } else if (fractPos < 0) {"
      },
      {
        "txt": "setFieldValue(period, SECONDS, parseInt(text, position, length)); setFieldValue(period, MILLIS, 0); } else { int wholeValue = parseInt(text, position, fractPos - position - 1); setFieldValue(period, SECONDS, wholeValue); int fractLen = position + length - fractPos; int fractValue; if (fractLen <= 0) { fractValue = 0; } else {"
      },
      {
        "txt": "if (fractLen >= 3) { fractValue = parseInt(text, fractPos, 3); } else { fractValue = parseInt(text, fractPos, fractLen); if (fractLen == 1) { fractValue *= 100; } else { fractValue *= 10; } }"
      },
      {
        "txt": "if (wholeValue < 0) { fractValue = -fractValue; } } setFieldValue(period, MILLIS, fractValue); } position += length; if (position >= 0 && iSuffix != null) { position = iSuffix.parse(text, position); }"
      },
      {
        "txt": "return position; } private int parseInt(String text, int position, int length) { if (length >= 10) { return Integer.parseInt(text.substring(position, position + length)); } if (length <= 0) { return 0; } int value = text.charAt(position++);"
      },
      {
        "txt": "length--; boolean negative; if (value == '-') { if (--length < 0) { return 0; } negative = true; value = text.charAt(position++); } else { negative = false;"
      },
      {
        "txt": "} value -= '0'; while (length-- > 0) { value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; } return negative ? -value : value; } long getFieldValue(ReadablePeriod period) { PeriodType type; if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {"
      },
      {
        "txt": "type = null; // Don't need to check if supported. } else { type = period.getPeriodType(); } if (type != null && isSupported(type, iFieldType) == false) { return Long.MAX_VALUE; } long value; switch (iFieldType) { default:"
      },
      {
        "txt": "return Long.MAX_VALUE; case YEARS: value = period.get(DurationFieldType.years()); break; case MONTHS: value = period.get(DurationFieldType.months()); break; case WEEKS: value = period.get(DurationFieldType.weeks()); break;"
      },
      {
        "txt": "case DAYS: value = period.get(DurationFieldType.days()); break; case HOURS: value = period.get(DurationFieldType.hours()); break; case MINUTES: value = period.get(DurationFieldType.minutes()); break; case SECONDS:"
      },
      {
        "txt": "value = period.get(DurationFieldType.seconds()); break; case MILLIS: value = period.get(DurationFieldType.millis()); break; case SECONDS_MILLIS: // drop through case SECONDS_OPTIONAL_MILLIS: int seconds = period.get(DurationFieldType.seconds()); int millis = period.get(DurationFieldType.millis()); value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;"
      },
      {
        "txt": "break; } if (value == 0) { switch (iPrintZeroSetting) { case PRINT_ZERO_NEVER: return Long.MAX_VALUE; case PRINT_ZERO_RARELY_LAST: if (isZero(period) && iFieldFormatters[iFieldType] == this) { for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { if (isSupported(type, i) && iFieldFormatters[i] != null) {"
      },
      {
        "txt": "return Long.MAX_VALUE; } } } else { return Long.MAX_VALUE; } break; case PRINT_ZERO_RARELY_FIRST: if (isZero(period) && iFieldFormatters[iFieldType] == this) { int i = Math.min(iFieldType, 8); // line split out for IBM JDK"
      },
      {
        "txt": "i--; // see bug 1660490 for (; i >= 0 && i <= MAX_FIELD; i--) { if (isSupported(type, i) && iFieldFormatters[i] != null) { return Long.MAX_VALUE; } } } else { return Long.MAX_VALUE; } break;"
      },
      {
        "txt": "} } return value; } boolean isZero(ReadablePeriod period) { for (int i = 0, isize = period.size(); i < isize; i++) { if (period.getValue(i) != 0) { return false; } }"
      },
      {
        "txt": "return true; } boolean isSupported(PeriodType type, int field) { switch (field) { default: return false; case YEARS: return type.isSupported(DurationFieldType.years()); case MONTHS: return type.isSupported(DurationFieldType.months());"
      },
      {
        "txt": "case WEEKS: return type.isSupported(DurationFieldType.weeks()); case DAYS: return type.isSupported(DurationFieldType.days()); case HOURS: return type.isSupported(DurationFieldType.hours()); case MINUTES: return type.isSupported(DurationFieldType.minutes()); case SECONDS: return type.isSupported(DurationFieldType.seconds());"
      },
      {
        "txt": "case MILLIS: return type.isSupported(DurationFieldType.millis()); case SECONDS_MILLIS: // drop through case SECONDS_OPTIONAL_MILLIS: return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); } } void setFieldValue(ReadWritablePeriod period, int field, int value) { switch (field) {"
      },
      {
        "txt": "default: break; case YEARS: period.setYears(value); break; case MONTHS: period.setMonths(value); break; case WEEKS: period.setWeeks(value);"
      },
      {
        "txt": "break; case DAYS: period.setDays(value); break; case HOURS: period.setHours(value); break; case MINUTES: period.setMinutes(value); break;"
      },
      {
        "txt": "case SECONDS: period.setSeconds(value); break; case MILLIS: period.setMillis(value); break; } } int getFieldType() { return iFieldType;"
      },
      {
        "txt": "} } static class Literal implements PeriodPrinter, PeriodParser { static final Literal EMPTY = new Literal(\"\"); private final String iText; Literal(String text) { iText = text; } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {"
      },
      {
        "txt": "return 0; } public int calculatePrintedLength(ReadablePeriod period, Locale locale) { return iText.length(); } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { buf.append(iText); } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { out.write(iText);"
      },
      {
        "txt": "} public int parseInto( ReadWritablePeriod period, String periodStr, int position, Locale locale) { if (periodStr.regionMatches(true, position, iText, 0, iText.length())) { return position + iText.length(); } return ~position; } }"
      },
      {
        "txt": "static class Separator implements PeriodPrinter, PeriodParser { private final String iText; private final String iFinalText; private final String[] iParsedForms; private final boolean iUseBefore; private final boolean iUseAfter; private final PeriodPrinter iBeforePrinter; private volatile PeriodPrinter iAfterPrinter; private final PeriodParser iBeforeParser;"
      },
      {
        "txt": "private volatile PeriodParser iAfterParser; Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { iText = text; iFinalText = finalText; if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { iParsedForms = new String[] {text}; } else {"
      },
      {
        "txt": "TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); parsedSet.add(text); parsedSet.add(finalText); if (variants != null) { for (int i=variants.length; --i>=0; ) { parsedSet.add(variants[i]); } } ArrayList<String> parsedList = new ArrayList<String>(parsedSet); Collections.reverse(parsedList);"
      },
      {
        "txt": "iParsedForms = parsedList.toArray(new String[parsedList.size()]); } iBeforePrinter = beforePrinter; iBeforeParser = beforeParser; iUseBefore = useBefore; iUseAfter = useAfter; } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale); if (sum < stopAt) {"
      },
      {
        "txt": "sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale); } return sum; } public int calculatePrintedLength(ReadablePeriod period, Locale locale) { PeriodPrinter before = iBeforePrinter; PeriodPrinter after = iAfterPrinter; int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); if (iUseBefore) {"
      },
      {
        "txt": "if (before.countFieldsToPrint(period, 1, locale) > 0) { if (iUseAfter) { int afterCount = after.countFieldsToPrint(period, 2, locale); if (afterCount > 0) { sum += (afterCount > 1 ? iText : iFinalText).length(); } } else { sum += iText.length(); } }"
      },
      {
        "txt": "} else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { sum += iText.length(); } return sum; } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { PeriodPrinter before = iBeforePrinter; PeriodPrinter after = iAfterPrinter; before.printTo(buf, period, locale); if (iUseBefore) {"
      },
      {
        "txt": "if (before.countFieldsToPrint(period, 1, locale) > 0) { if (iUseAfter) { int afterCount = after.countFieldsToPrint(period, 2, locale); if (afterCount > 0) { buf.append(afterCount > 1 ? iText : iFinalText); } } else { buf.append(iText); } }"
      },
      {
        "txt": "} else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { buf.append(iText); } after.printTo(buf, period, locale); } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { PeriodPrinter before = iBeforePrinter; PeriodPrinter after = iAfterPrinter; before.printTo(out, period, locale); if (iUseBefore) {"
      },
      {
        "txt": "if (before.countFieldsToPrint(period, 1, locale) > 0) { if (iUseAfter) { int afterCount = after.countFieldsToPrint(period, 2, locale); if (afterCount > 0) { out.write(afterCount > 1 ? iText : iFinalText); } } else { out.write(iText); } }"
      },
      {
        "txt": "} else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { out.write(iText); } after.printTo(out, period, locale); } public int parseInto( ReadWritablePeriod period, String periodStr, int position, Locale locale) { int oldPos = position; position = iBeforeParser.parseInto(period, periodStr, position, locale);"
      },
      {
        "txt": "if (position < 0) { return position; } boolean found = false; if (position > oldPos) { String[] parsedForms = iParsedForms; int length = parsedForms.length; for (int i=0; i < length; i++) { String parsedForm = parsedForms[i]; if ((parsedForm == null || parsedForm.length() == 0) ||"
      },
      {
        "txt": "periodStr.regionMatches (true, position, parsedForm, 0, parsedForm.length())) { position += parsedForm.length(); found = true; break; } } } oldPos = position; position = iAfterParser.parseInto(period, periodStr, position, locale);"
      },
      {
        "txt": "if (position < 0) { return position; } if (found && position == oldPos) { return ~oldPos; } if (position > oldPos && !found && !iUseBefore) { return ~oldPos; } return position;"
      },
      {
        "txt": "} Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) { iAfterPrinter = afterPrinter; iAfterParser = afterParser; return this; } } static class Composite implements PeriodPrinter, PeriodParser { private final PeriodPrinter[] iPrinters;"
      },
      {
        "txt": "private final PeriodParser[] iParsers; Composite(List<Object> elementPairs) { List<Object> printerList = new ArrayList<Object>(); List<Object> parserList = new ArrayList<Object>(); decompose(elementPairs, printerList, parserList); if (printerList.size() <= 0) { iPrinters = null; } else { iPrinters = printerList.toArray( new PeriodPrinter[printerList.size()]);"
      },
      {
        "txt": "} if (parserList.size() <= 0) { iParsers = null; } else { iParsers = parserList.toArray( new PeriodParser[parserList.size()]); } } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { int sum = 0;"
      },
      {
        "txt": "PeriodPrinter[] printers = iPrinters; for (int i=printers.length; sum < stopAt && --i>=0; ) { sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale); } return sum; } public int calculatePrintedLength(ReadablePeriod period, Locale locale) { int sum = 0; PeriodPrinter[] printers = iPrinters; for (int i=printers.length; --i>=0; ) {"
      },
      {
        "txt": "sum += printers[i].calculatePrintedLength(period, locale); } return sum; } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { PeriodPrinter[] printers = iPrinters; int len = printers.length; for (int i=0; i<len; i++) { printers[i].printTo(buf, period, locale); }"
      },
      {
        "txt": "} public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { PeriodPrinter[] printers = iPrinters; int len = printers.length; for (int i=0; i<len; i++) { printers[i].printTo(out, period, locale); } } public int parseInto( ReadWritablePeriod period, String periodStr,"
      },
      {
        "txt": "int position, Locale locale) { PeriodParser[] parsers = iParsers; if (parsers == null) { throw new UnsupportedOperationException(); } int len = parsers.length; for (int i=0; i<len && position >= 0; i++) { position = parsers[i].parseInto(period, periodStr, position, locale); } return position;"
      },
      {
        "txt": "} private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { int size = elementPairs.size(); for (int i=0; i<size; i+=2) { Object element = elementPairs.get(i); if (element instanceof PeriodPrinter) { if (element instanceof Composite) { addArrayToList(printerList, ((Composite) element).iPrinters); } else { printerList.add(element);"
      },
      {
        "txt": "} } element = elementPairs.get(i + 1); if (element instanceof PeriodParser) { if (element instanceof Composite) { addArrayToList(parserList, ((Composite) element).iParsers); } else { parserList.add(element); } }"
      },
      {
        "txt": "} } private void addArrayToList(List<Object> list, Object[] array) { if (array != null) { for (int i=0; i<array.length; i++) { list.add(array[i]); } } } }"
      }
    ]
  },
  {
    "id": 2975,
    "file_path": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java",
    "start-bug-line": 804,
    "end-bug-line": 804,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.format; import java.io.IOException; import java.io.Writer; import java.util.ArrayList; import java.util.Collections; import java.util.List;"
      },
      {
        "txt": "import java.util.Locale; import java.util.TreeSet; import org.joda.time.DateTimeConstants; import org.joda.time.DurationFieldType; import org.joda.time.PeriodType; import org.joda.time.ReadWritablePeriod; import org.joda.time.ReadablePeriod; public class PeriodFormatterBuilder { private static final int PRINT_ZERO_RARELY_FIRST = 1; private static final int PRINT_ZERO_RARELY_LAST = 2;"
      },
      {
        "txt": "private static final int PRINT_ZERO_IF_SUPPORTED = 3; private static final int PRINT_ZERO_ALWAYS = 4; private static final int PRINT_ZERO_NEVER = 5; private static final int YEARS = 0; private static final int MONTHS = 1; private static final int WEEKS = 2; private static final int DAYS = 3; private static final int HOURS = 4; private static final int MINUTES = 5; private static final int SECONDS = 6;"
      },
      {
        "txt": "private static final int MILLIS = 7; private static final int SECONDS_MILLIS = 8; private static final int SECONDS_OPTIONAL_MILLIS = 9; private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS; private int iMinPrintedDigits; private int iPrintZeroSetting; private int iMaxParsedDigits; private boolean iRejectSignedValues; private PeriodFieldAffix iPrefix; private List<Object> iElementPairs;"
      },
      {
        "txt": "private boolean iNotPrinter; private boolean iNotParser; private FieldFormatter[] iFieldFormatters; public PeriodFormatterBuilder() { clear(); } public PeriodFormatter toFormatter() { PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser); iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone(); return formatter;"
      },
      {
        "txt": "} public PeriodPrinter toPrinter() { if (iNotPrinter) { return null; } return toFormatter().getPrinter(); } public PeriodParser toParser() { if (iNotParser) { return null;"
      },
      {
        "txt": "} return toFormatter().getParser(); } public void clear() { iMinPrintedDigits = 1; iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; iMaxParsedDigits = 10; iRejectSignedValues = false; iPrefix = null; if (iElementPairs == null) {"
      },
      {
        "txt": "iElementPairs = new ArrayList<Object>(); } else { iElementPairs.clear(); } iNotPrinter = false; iNotParser = false; iFieldFormatters = new FieldFormatter[10]; } public PeriodFormatterBuilder append(PeriodFormatter formatter) { if (formatter == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"No formatter supplied\"); } clearPrefix(); append0(formatter.getPrinter(), formatter.getParser()); return this; } public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) { if (printer == null && parser == null) { throw new IllegalArgumentException(\"No printer or parser supplied\"); }"
      },
      {
        "txt": "clearPrefix(); append0(printer, parser); return this; } public PeriodFormatterBuilder appendLiteral(String text) { if (text == null) { throw new IllegalArgumentException(\"Literal must not be null\"); } clearPrefix(); Literal literal = new Literal(text);"
      },
      {
        "txt": "append0(literal, literal); return this; } public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) { iMinPrintedDigits = minDigits; return this; } public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) { iMaxParsedDigits = maxDigits; return this;"
      },
      {
        "txt": "} public PeriodFormatterBuilder rejectSignedValues(boolean v) { iRejectSignedValues = v; return this; } public PeriodFormatterBuilder printZeroRarelyLast() { iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; return this; } public PeriodFormatterBuilder printZeroRarelyFirst() {"
      },
      {
        "txt": "iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST; return this; } public PeriodFormatterBuilder printZeroIfSupported() { iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED; return this; } public PeriodFormatterBuilder printZeroAlways() { iPrintZeroSetting = PRINT_ZERO_ALWAYS; return this;"
      },
      {
        "txt": "} public PeriodFormatterBuilder printZeroNever() { iPrintZeroSetting = PRINT_ZERO_NEVER; return this; } public PeriodFormatterBuilder appendPrefix(String text) { if (text == null) { throw new IllegalArgumentException(); } return appendPrefix(new SimpleAffix(text));"
      },
      {
        "txt": "} public PeriodFormatterBuilder appendPrefix(String singularText, String pluralText) { if (singularText == null || pluralText == null) { throw new IllegalArgumentException(); } return appendPrefix(new PluralAffix(singularText, pluralText)); } private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) { if (prefix == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(); } if (iPrefix != null) { prefix = new CompositeAffix(iPrefix, prefix); } iPrefix = prefix; return this; } public PeriodFormatterBuilder appendYears() { appendField(YEARS);"
      },
      {
        "txt": "return this; } public PeriodFormatterBuilder appendMonths() { appendField(MONTHS); return this; } public PeriodFormatterBuilder appendWeeks() { appendField(WEEKS); return this; }"
      },
      {
        "txt": "public PeriodFormatterBuilder appendDays() { appendField(DAYS); return this; } public PeriodFormatterBuilder appendHours() { appendField(HOURS); return this; } public PeriodFormatterBuilder appendMinutes() { appendField(MINUTES);"
      },
      {
        "txt": "return this; } public PeriodFormatterBuilder appendSeconds() { appendField(SECONDS); return this; } public PeriodFormatterBuilder appendSecondsWithMillis() { appendField(SECONDS_MILLIS); return this; }"
      },
      {
        "txt": "public PeriodFormatterBuilder appendSecondsWithOptionalMillis() { appendField(SECONDS_OPTIONAL_MILLIS); return this; } public PeriodFormatterBuilder appendMillis() { appendField(MILLIS); return this; } public PeriodFormatterBuilder appendMillis3Digit() { appendField(7, 3);"
      },
      {
        "txt": "return this; } private void appendField(int type) { appendField(type, iMinPrintedDigits); } private void appendField(int type, int minPrinted) { FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting, iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null); append0(field, field); iFieldFormatters[type] = field;"
      },
      {
        "txt": "iPrefix = null; } public PeriodFormatterBuilder appendSuffix(String text) { if (text == null) { throw new IllegalArgumentException(); } return appendSuffix(new SimpleAffix(text)); } public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) {"
      },
      {
        "txt": "if (singularText == null || pluralText == null) { throw new IllegalArgumentException(); } return appendSuffix(new PluralAffix(singularText, pluralText)); } private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { final Object originalPrinter; final Object originalParser; if (iElementPairs.size() > 0) { originalPrinter = iElementPairs.get(iElementPairs.size() - 2);"
      },
      {
        "txt": "originalParser = iElementPairs.get(iElementPairs.size() - 1); } else { originalPrinter = null; originalParser = null; } if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { throw new IllegalStateException(\"No field to apply suffix to\"); }"
      },
      {
        "txt": "clearPrefix(); FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); iElementPairs.set(iElementPairs.size() - 2, newField); iElementPairs.set(iElementPairs.size() - 1, newField); iFieldFormatters[newField.getFieldType()] = newField; return this; } public PeriodFormatterBuilder appendSeparator(String text) { return appendSeparator(text, text, null, true, true); }"
      },
      {
        "txt": "public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) { return appendSeparator(text, text, null, false, true); } public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) { return appendSeparator(text, text, null, true, false); } public PeriodFormatterBuilder appendSeparator(String text, String finalText) { return appendSeparator(text, finalText, null, true, true); } public PeriodFormatterBuilder appendSeparator(String text, String finalText,"
      },
      {
        "txt": "String[] variants) { return appendSeparator(text, finalText, variants, true, true); } private PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants, boolean useBefore, boolean useAfter) { if (text == null || finalText == null) { throw new IllegalArgumentException(); } clearPrefix();"
      },
      {
        "txt": "List<Object> pairs = iElementPairs; if (pairs.size() == 0) { if (useAfter && useBefore == false) { Separator separator = new Separator( text, finalText, variants, Literal.EMPTY, Literal.EMPTY, useBefore, useAfter); append0(separator, separator); } return this; }"
      },
      {
        "txt": "int i; Separator lastSeparator = null; for (i=pairs.size(); --i>=0; ) { if (pairs.get(i) instanceof Separator) { lastSeparator = (Separator) pairs.get(i); pairs = pairs.subList(i + 1, pairs.size()); break; } i--; // element pairs }"
      },
      {
        "txt": "if (lastSeparator != null && pairs.size() == 0) { throw new IllegalStateException(\"Cannot have two adjacent separators\"); } else { Object[] comp = createComposite(pairs); pairs.clear(); Separator separator = new Separator( text, finalText, variants, (PeriodPrinter) comp[0], (PeriodParser) comp[1], useBefore, useAfter); pairs.add(separator);"
      },
      {
        "txt": "pairs.add(separator); } return this; } private void clearPrefix() throws IllegalStateException { if (iPrefix != null) { throw new IllegalStateException(\"Prefix not followed by field\"); } iPrefix = null; }"
      },
      {
        "txt": "private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) { iElementPairs.add(printer); iElementPairs.add(parser); iNotPrinter |= (printer == null); iNotParser |= (parser == null); return this; } private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { if (notPrinter && notParser) { throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");"
      },
      {
        "txt": "int size = elementPairs.size(); if (size >= 2 && elementPairs.get(0) instanceof Separator) { Separator sep = (Separator) elementPairs.get(0); PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); <extra_id_0> Object[] comp = createComposite(elementPairs); if (notPrinter) { return new PeriodFormatter(null, (PeriodParser) comp[1]); } else if (notParser) { return new PeriodFormatter((PeriodPrinter) comp[0], null); } else {"
      },
      {
        "txt": "return new PeriodFormatter((PeriodPrinter) comp[0], null); } else { return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); } } private static Object[] createComposite(List<Object> elementPairs) { switch (elementPairs.size()) { case 0: return new Object[] {Literal.EMPTY, Literal.EMPTY}; case 1:"
      },
      {
        "txt": "return new Object[] {elementPairs.get(0), elementPairs.get(1)}; default: Composite comp = new Composite(elementPairs); return new Object[] {comp, comp}; } } static interface PeriodFieldAffix { int calculatePrintedLength(int value); void printTo(StringBuffer buf, int value); void printTo(Writer out, int value) throws IOException;"
      },
      {
        "txt": "int parse(String periodStr, int position); int scan(String periodStr, int position); } static class SimpleAffix implements PeriodFieldAffix { private final String iText; SimpleAffix(String text) { iText = text; } public int calculatePrintedLength(int value) { return iText.length();"
      },
      {
        "txt": "} public void printTo(StringBuffer buf, int value) { buf.append(iText); } public void printTo(Writer out, int value) throws IOException { out.write(iText); } public int parse(String periodStr, int position) { String text = iText; int textLength = text.length();"
      },
      {
        "txt": "if (periodStr.regionMatches(true, position, text, 0, textLength)) { return position + textLength; } return ~position; } public int scan(String periodStr, final int position) { String text = iText; int textLength = text.length(); int sourceLength = periodStr.length(); search:"
      },
      {
        "txt": "for (int pos = position; pos < sourceLength; pos++) { if (periodStr.regionMatches(true, pos, text, 0, textLength)) { return pos; } switch (periodStr.charAt(pos)) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.': case ',': case '+': case '-': break; default:"
      },
      {
        "txt": "break search; } } return ~position; } } static class PluralAffix implements PeriodFieldAffix { private final String iSingularText; private final String iPluralText; PluralAffix(String singularText, String pluralText) {"
      },
      {
        "txt": "iSingularText = singularText; iPluralText = pluralText; } public int calculatePrintedLength(int value) { return (value == 1 ? iSingularText : iPluralText).length(); } public void printTo(StringBuffer buf, int value) { buf.append(value == 1 ? iSingularText : iPluralText); } public void printTo(Writer out, int value) throws IOException {"
      },
      {
        "txt": "out.write(value == 1 ? iSingularText : iPluralText); } public int parse(String periodStr, int position) { String text1 = iPluralText; String text2 = iSingularText; if (text1.length() < text2.length()) { String temp = text1; text1 = text2; text2 = temp; }"
      },
      {
        "txt": "if (periodStr.regionMatches (true, position, text1, 0, text1.length())) { return position + text1.length(); } if (periodStr.regionMatches (true, position, text2, 0, text2.length())) { return position + text2.length(); } return ~position; }"
      },
      {
        "txt": "public int scan(String periodStr, final int position) { String text1 = iPluralText; String text2 = iSingularText; if (text1.length() < text2.length()) { String temp = text1; text1 = text2; text2 = temp; } int textLength1 = text1.length(); int textLength2 = text2.length();"
      },
      {
        "txt": "int sourceLength = periodStr.length(); for (int pos = position; pos < sourceLength; pos++) { if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) { return pos; } if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) { return pos; } } return ~position;"
      },
      {
        "txt": "} } static class CompositeAffix implements PeriodFieldAffix { private final PeriodFieldAffix iLeft; private final PeriodFieldAffix iRight; CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) { iLeft = left; iRight = right; } public int calculatePrintedLength(int value) {"
      },
      {
        "txt": "return iLeft.calculatePrintedLength(value) + iRight.calculatePrintedLength(value); } public void printTo(StringBuffer buf, int value) { iLeft.printTo(buf, value); iRight.printTo(buf, value); } public void printTo(Writer out, int value) throws IOException { iLeft.printTo(out, value); iRight.printTo(out, value);"
      },
      {
        "txt": "} public int parse(String periodStr, int position) { position = iLeft.parse(periodStr, position); if (position >= 0) { position = iRight.parse(periodStr, position); } return position; } public int scan(String periodStr, final int position) { int pos = iLeft.scan(periodStr, position);"
      },
      {
        "txt": "if (pos >= 0) { return iRight.scan(periodStr, pos); } return ~position; } } static class FieldFormatter implements PeriodPrinter, PeriodParser { private final int iMinPrintedDigits; private final int iPrintZeroSetting;"
      },
      {
        "txt": "private final int iMaxParsedDigits; private final boolean iRejectSignedValues; private final int iFieldType; private final FieldFormatter[] iFieldFormatters; private final PeriodFieldAffix iPrefix; private final PeriodFieldAffix iSuffix; FieldFormatter(int minPrintedDigits, int printZeroSetting, int maxParsedDigits, boolean rejectSignedValues, int fieldType, FieldFormatter[] fieldFormatters, PeriodFieldAffix prefix, PeriodFieldAffix suffix) {"
      },
      {
        "txt": "iMinPrintedDigits = minPrintedDigits; iPrintZeroSetting = printZeroSetting; iMaxParsedDigits = maxParsedDigits; iRejectSignedValues = rejectSignedValues; iFieldType = fieldType; iFieldFormatters = fieldFormatters; iPrefix = prefix; iSuffix = suffix; } FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {"
      },
      {
        "txt": "iMinPrintedDigits = field.iMinPrintedDigits; iPrintZeroSetting = field.iPrintZeroSetting; iMaxParsedDigits = field.iMaxParsedDigits; iRejectSignedValues = field.iRejectSignedValues; iFieldType = field.iFieldType; iFieldFormatters = field.iFieldFormatters; iPrefix = field.iPrefix; if (field.iSuffix != null) { suffix = new CompositeAffix(field.iSuffix, suffix); }"
      },
      {
        "txt": "iSuffix = suffix; } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { if (stopAt <= 0) { return 0; } if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) { return 1; } return 0;"
      },
      {
        "txt": "} public int calculatePrintedLength(ReadablePeriod period, Locale locale) { long valueLong = getFieldValue(period); if (valueLong == Long.MAX_VALUE) { return 0; } int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); if (iFieldType >= SECONDS_MILLIS) { sum = Math.max(sum, 4); sum++;"
      },
      {
        "txt": "if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { sum -= 4; // remove three digits and decimal point } valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; } int value = (int) valueLong; if (iPrefix != null) { sum += iPrefix.calculatePrintedLength(value); }"
      },
      {
        "txt": "if (iSuffix != null) { sum += iSuffix.calculatePrintedLength(value); } return sum; } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { long valueLong = getFieldValue(period); if (valueLong == Long.MAX_VALUE) { return; }"
      },
      {
        "txt": "int value = (int) valueLong; if (iFieldType >= SECONDS_MILLIS) { value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); } if (iPrefix != null) { iPrefix.printTo(buf, value); } int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.appendUnpaddedInteger(buf, value);"
      },
      {
        "txt": "} else { FormatUtils.appendPaddedInteger(buf, value, minDigits); } if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, dp, 3); } }"
      },
      {
        "txt": "if (iSuffix != null) { iSuffix.printTo(buf, value); } } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { long valueLong = getFieldValue(period); if (valueLong == Long.MAX_VALUE) { return; } int value = (int) valueLong;"
      },
      {
        "txt": "if (iFieldType >= SECONDS_MILLIS) { value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); } if (iPrefix != null) { iPrefix.printTo(out, value); } int minDigits = iMinPrintedDigits; if (minDigits <= 1) { FormatUtils.writeUnpaddedInteger(out, value); } else {"
      },
      {
        "txt": "FormatUtils.writePaddedInteger(out, value, minDigits); } if (iFieldType >= SECONDS_MILLIS) { int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); if (iFieldType == SECONDS_MILLIS || dp > 0) { out.write('.'); FormatUtils.writePaddedInteger(out, dp, 3); } } if (iSuffix != null) {"
      },
      {
        "txt": "iSuffix.printTo(out, value); } } public int parseInto( ReadWritablePeriod period, String text, int position, Locale locale) { boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); if (position >= text.length()) { return mustParse ? ~position : position; }"
      },
      {
        "txt": "if (iPrefix != null) { position = iPrefix.parse(text, position); if (position >= 0) { mustParse = true; } else { if (!mustParse) { return ~position; } return position; }"
      },
      {
        "txt": "} int suffixPos = -1; if (iSuffix != null && !mustParse) { suffixPos = iSuffix.scan(text, position); if (suffixPos >= 0) { mustParse = true; } else { if (!mustParse) { return ~suffixPos; }"
      },
      {
        "txt": "return suffixPos; } } if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { return position; } int limit; if (suffixPos > 0) { limit = Math.min(iMaxParsedDigits, suffixPos - position); } else {"
      },
      {
        "txt": "limit = Math.min(iMaxParsedDigits, text.length() - position); } int length = 0; int fractPos = -1; boolean hasDigits = false; while (length < limit) { char c = text.charAt(position + length); if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { boolean negative = c == '-'; if (length + 1 >= limit ||"
      },
      {
        "txt": "(c = text.charAt(position + length + 1)) < '0' || c > '9') { break; } if (negative) { length++; } else { position++; } limit = Math.min(limit + 1, text.length() - position);"
      },
      {
        "txt": "continue; } if (c >= '0' && c <= '9') { hasDigits = true; } else { if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { if (fractPos >= 0) { break; }"
      },
      {
        "txt": "fractPos = position + length + 1; limit = Math.min(limit + 1, text.length() - position); } else { break; } } length++; } if (!hasDigits) { return ~position;"
      },
      {
        "txt": "} if (suffixPos >= 0 && position + length != suffixPos) { return position; } if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { setFieldValue(period, iFieldType, parseInt(text, position, length)); } else if (fractPos < 0) { setFieldValue(period, SECONDS, parseInt(text, position, length)); setFieldValue(period, MILLIS, 0); } else {"
      },
      {
        "txt": "int wholeValue = parseInt(text, position, fractPos - position - 1); setFieldValue(period, SECONDS, wholeValue); int fractLen = position + length - fractPos; int fractValue; if (fractLen <= 0) { fractValue = 0; } else { if (fractLen >= 3) { fractValue = parseInt(text, fractPos, 3); } else {"
      },
      {
        "txt": "fractValue = parseInt(text, fractPos, fractLen); if (fractLen == 1) { fractValue *= 100; } else { fractValue *= 10; } } if (wholeValue < 0) { fractValue = -fractValue; }"
      },
      {
        "txt": "} setFieldValue(period, MILLIS, fractValue); } position += length; if (position >= 0 && iSuffix != null) { position = iSuffix.parse(text, position); } return position; } private int parseInt(String text, int position, int length) {"
      },
      {
        "txt": "if (length >= 10) { return Integer.parseInt(text.substring(position, position + length)); } if (length <= 0) { return 0; } int value = text.charAt(position++); length--; boolean negative; if (value == '-') {"
      },
      {
        "txt": "if (--length < 0) { return 0; } negative = true; value = text.charAt(position++); } else { negative = false; } value -= '0'; while (length-- > 0) {"
      },
      {
        "txt": "value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; } return negative ? -value : value; } long getFieldValue(ReadablePeriod period) { PeriodType type; if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { type = null; // Don't need to check if supported. } else { type = period.getPeriodType();"
      },
      {
        "txt": "} if (type != null && isSupported(type, iFieldType) == false) { return Long.MAX_VALUE; } long value; switch (iFieldType) { default: return Long.MAX_VALUE; case YEARS: value = period.get(DurationFieldType.years());"
      },
      {
        "txt": "break; case MONTHS: value = period.get(DurationFieldType.months()); break; case WEEKS: value = period.get(DurationFieldType.weeks()); break; case DAYS: value = period.get(DurationFieldType.days()); break;"
      },
      {
        "txt": "case HOURS: value = period.get(DurationFieldType.hours()); break; case MINUTES: value = period.get(DurationFieldType.minutes()); break; case SECONDS: value = period.get(DurationFieldType.seconds()); break; case MILLIS:"
      },
      {
        "txt": "value = period.get(DurationFieldType.millis()); break; case SECONDS_MILLIS: // drop through case SECONDS_OPTIONAL_MILLIS: int seconds = period.get(DurationFieldType.seconds()); int millis = period.get(DurationFieldType.millis()); value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; break; } if (value == 0) {"
      },
      {
        "txt": "switch (iPrintZeroSetting) { case PRINT_ZERO_NEVER: return Long.MAX_VALUE; case PRINT_ZERO_RARELY_LAST: if (isZero(period) && iFieldFormatters[iFieldType] == this) { for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { if (isSupported(type, i) && iFieldFormatters[i] != null) { return Long.MAX_VALUE; } }"
      },
      {
        "txt": "} else { return Long.MAX_VALUE; } break; case PRINT_ZERO_RARELY_FIRST: if (isZero(period) && iFieldFormatters[iFieldType] == this) { int i = Math.min(iFieldType, 8); // line split out for IBM JDK i--; // see bug 1660490 for (; i >= 0 && i <= MAX_FIELD; i--) { if (isSupported(type, i) && iFieldFormatters[i] != null) {"
      },
      {
        "txt": "return Long.MAX_VALUE; } } } else { return Long.MAX_VALUE; } break; } } return value;"
      },
      {
        "txt": "} boolean isZero(ReadablePeriod period) { for (int i = 0, isize = period.size(); i < isize; i++) { if (period.getValue(i) != 0) { return false; } } return true; } boolean isSupported(PeriodType type, int field) {"
      },
      {
        "txt": "switch (field) { default: return false; case YEARS: return type.isSupported(DurationFieldType.years()); case MONTHS: return type.isSupported(DurationFieldType.months()); case WEEKS: return type.isSupported(DurationFieldType.weeks()); case DAYS:"
      },
      {
        "txt": "return type.isSupported(DurationFieldType.days()); case HOURS: return type.isSupported(DurationFieldType.hours()); case MINUTES: return type.isSupported(DurationFieldType.minutes()); case SECONDS: return type.isSupported(DurationFieldType.seconds()); case MILLIS: return type.isSupported(DurationFieldType.millis()); case SECONDS_MILLIS: // drop through"
      },
      {
        "txt": "case SECONDS_OPTIONAL_MILLIS: return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); } } void setFieldValue(ReadWritablePeriod period, int field, int value) { switch (field) { default: break; case YEARS:"
      },
      {
        "txt": "period.setYears(value); break; case MONTHS: period.setMonths(value); break; case WEEKS: period.setWeeks(value); break; case DAYS: period.setDays(value);"
      },
      {
        "txt": "break; case HOURS: period.setHours(value); break; case MINUTES: period.setMinutes(value); break; case SECONDS: period.setSeconds(value); break;"
      },
      {
        "txt": "case MILLIS: period.setMillis(value); break; } } int getFieldType() { return iFieldType; } } static class Literal"
      },
      {
        "txt": "implements PeriodPrinter, PeriodParser { static final Literal EMPTY = new Literal(\"\"); private final String iText; Literal(String text) { iText = text; } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { return 0; } public int calculatePrintedLength(ReadablePeriod period, Locale locale) {"
      },
      {
        "txt": "return iText.length(); } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { buf.append(iText); } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { out.write(iText); } public int parseInto( ReadWritablePeriod period, String periodStr,"
      },
      {
        "txt": "int position, Locale locale) { if (periodStr.regionMatches(true, position, iText, 0, iText.length())) { return position + iText.length(); } return ~position; } } static class Separator implements PeriodPrinter, PeriodParser { private final String iText;"
      },
      {
        "txt": "private final String iFinalText; private final String[] iParsedForms; private final boolean iUseBefore; private final boolean iUseAfter; private final PeriodPrinter iBeforePrinter; private volatile PeriodPrinter iAfterPrinter; private final PeriodParser iBeforeParser; private volatile PeriodParser iAfterParser; Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser,"
      },
      {
        "txt": "boolean useBefore, boolean useAfter) { iText = text; iFinalText = finalText; if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { iParsedForms = new String[] {text}; } else { TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); parsedSet.add(text); parsedSet.add(finalText);"
      },
      {
        "txt": "if (variants != null) { for (int i=variants.length; --i>=0; ) { parsedSet.add(variants[i]); } } ArrayList<String> parsedList = new ArrayList<String>(parsedSet); Collections.reverse(parsedList); iParsedForms = parsedList.toArray(new String[parsedList.size()]); } iBeforePrinter = beforePrinter;"
      },
      {
        "txt": "iBeforeParser = beforeParser; iUseBefore = useBefore; iUseAfter = useAfter; } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale); if (sum < stopAt) { sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale); } return sum;"
      },
      {
        "txt": "} public int calculatePrintedLength(ReadablePeriod period, Locale locale) { PeriodPrinter before = iBeforePrinter; PeriodPrinter after = iAfterPrinter; int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); if (iUseBefore) { if (before.countFieldsToPrint(period, 1, locale) > 0) { if (iUseAfter) { int afterCount = after.countFieldsToPrint(period, 2, locale);"
      },
      {
        "txt": "if (afterCount > 0) { sum += (afterCount > 1 ? iText : iFinalText).length(); } } else { sum += iText.length(); } } } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { sum += iText.length(); }"
      },
      {
        "txt": "return sum; } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { PeriodPrinter before = iBeforePrinter; PeriodPrinter after = iAfterPrinter; before.printTo(buf, period, locale); if (iUseBefore) { if (before.countFieldsToPrint(period, 1, locale) > 0) { if (iUseAfter) { int afterCount = after.countFieldsToPrint(period, 2, locale);"
      },
      {
        "txt": "if (afterCount > 0) { buf.append(afterCount > 1 ? iText : iFinalText); } } else { buf.append(iText); } } } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { buf.append(iText); }"
      },
      {
        "txt": "after.printTo(buf, period, locale); } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { PeriodPrinter before = iBeforePrinter; PeriodPrinter after = iAfterPrinter; before.printTo(out, period, locale); if (iUseBefore) { if (before.countFieldsToPrint(period, 1, locale) > 0) { if (iUseAfter) { int afterCount = after.countFieldsToPrint(period, 2, locale);"
      },
      {
        "txt": "if (afterCount > 0) { out.write(afterCount > 1 ? iText : iFinalText); } } else { out.write(iText); } } } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { out.write(iText); }"
      },
      {
        "txt": "after.printTo(out, period, locale); } public int parseInto( ReadWritablePeriod period, String periodStr, int position, Locale locale) { int oldPos = position; position = iBeforeParser.parseInto(period, periodStr, position, locale); if (position < 0) { return position; }"
      },
      {
        "txt": "boolean found = false; if (position > oldPos) { String[] parsedForms = iParsedForms; int length = parsedForms.length; for (int i=0; i < length; i++) { String parsedForm = parsedForms[i]; if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches (true, position, parsedForm, 0, parsedForm.length())) { position += parsedForm.length();"
      },
      {
        "txt": "found = true; break; } } } oldPos = position; position = iAfterParser.parseInto(period, periodStr, position, locale); if (position < 0) { return position; }"
      },
      {
        "txt": "if (found && position == oldPos) { return ~oldPos; } if (position > oldPos && !found && !iUseBefore) { return ~oldPos; } return position; } Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) { iAfterPrinter = afterPrinter;"
      },
      {
        "txt": "iAfterParser = afterParser; return this; } } static class Composite implements PeriodPrinter, PeriodParser { private final PeriodPrinter[] iPrinters; private final PeriodParser[] iParsers; Composite(List<Object> elementPairs) { List<Object> printerList = new ArrayList<Object>();"
      },
      {
        "txt": "List<Object> parserList = new ArrayList<Object>(); decompose(elementPairs, printerList, parserList); if (printerList.size() <= 0) { iPrinters = null; } else { iPrinters = printerList.toArray( new PeriodPrinter[printerList.size()]); } if (parserList.size() <= 0) { iParsers = null;"
      },
      {
        "txt": "} else { iParsers = parserList.toArray( new PeriodParser[parserList.size()]); } } public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { int sum = 0; PeriodPrinter[] printers = iPrinters; for (int i=printers.length; sum < stopAt && --i>=0; ) { sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);"
      },
      {
        "txt": "} return sum; } public int calculatePrintedLength(ReadablePeriod period, Locale locale) { int sum = 0; PeriodPrinter[] printers = iPrinters; for (int i=printers.length; --i>=0; ) { sum += printers[i].calculatePrintedLength(period, locale); } return sum;"
      },
      {
        "txt": "} public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { PeriodPrinter[] printers = iPrinters; int len = printers.length; for (int i=0; i<len; i++) { printers[i].printTo(buf, period, locale); } } public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException { PeriodPrinter[] printers = iPrinters;"
      },
      {
        "txt": "int len = printers.length; for (int i=0; i<len; i++) { printers[i].printTo(out, period, locale); } } public int parseInto( ReadWritablePeriod period, String periodStr, int position, Locale locale) { PeriodParser[] parsers = iParsers; if (parsers == null) {"
      },
      {
        "txt": "throw new UnsupportedOperationException(); } int len = parsers.length; for (int i=0; i<len && position >= 0; i++) { position = parsers[i].parseInto(period, periodStr, position, locale); } return position; } private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { int size = elementPairs.size();"
      },
      {
        "txt": "for (int i=0; i<size; i+=2) { Object element = elementPairs.get(i); if (element instanceof PeriodPrinter) { if (element instanceof Composite) { addArrayToList(printerList, ((Composite) element).iPrinters); } else { printerList.add(element); } } element = elementPairs.get(i + 1);"
      },
      {
        "txt": "if (element instanceof PeriodParser) { if (element instanceof Composite) { addArrayToList(parserList, ((Composite) element).iParsers); } else { parserList.add(element); } } } } private void addArrayToList(List<Object> list, Object[] array) {"
      },
      {
        "txt": "if (array != null) { for (int i=0; i<array.length; i++) { list.add(array[i]); } } } }"
      }
    ]
  }
]