[
  {
    "id": 2927,
    "file_path": "src/main/java/org/joda/time/LocalDate.java",
    "start-bug-line": 210,
    "end-bug-line": 210,
    "bug": "",
    "fix": "int era = calendar.get(Calendar.ERA);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException;"
      },
      {
        "txt": "import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashSet; import java.util.Locale; import java.util.Set; import java.util.TimeZone;"
      },
      {
        "txt": "import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter;"
      },
      {
        "txt": "import org.joda.time.format.ISODateTimeFormat; public final class LocalDate extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -8775358157899L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>(); static {"
      },
      {
        "txt": "DATE_DURATION_TYPES.add(DurationFieldType.days()); DATE_DURATION_TYPES.add(DurationFieldType.weeks()); DATE_DURATION_TYPES.add(DurationFieldType.months()); DATE_DURATION_TYPES.add(DurationFieldType.weekyears()); DATE_DURATION_TYPES.add(DurationFieldType.years()); DATE_DURATION_TYPES.add(DurationFieldType.centuries()); DATE_DURATION_TYPES.add(DurationFieldType.eras()); } private final long iLocalMillis; private final Chronology iChronology;"
      },
      {
        "txt": "private transient volatile int iHash; public static LocalDate now() { return new LocalDate(); } public static LocalDate now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new LocalDate(zone); }"
      },
      {
        "txt": "public static LocalDate now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDate(chronology); } @FromString public static LocalDate parse(String str) { return parse(str, ISODateTimeFormat.localDateParser()); }"
      },
      {
        "txt": "return formatter.parseLocalDate(str); } public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } <extra_id_0> return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); }"
      },
      {
        "txt": "); } @SuppressWarnings(\"deprecation\") public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1,"
      },
      {
        "txt": "date.getDate() ); } public LocalDate() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDate(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDate(Chronology chronology) {"
      },
      {
        "txt": "this(DateTimeUtils.currentTimeMillis(), chronology); } public LocalDate(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDate(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); } public LocalDate(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology);"
      },
      {
        "txt": "long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); chronology = chronology.withUTC(); iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); iChronology = chronology; } public LocalDate(Object instant) { this(instant, (Chronology) null); } public LocalDate(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);"
      },
      {
        "txt": "Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology);"
      },
      {
        "txt": "iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate( int year, int monthOfYear, int dayOfMonth) { this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); }"
      },
      {
        "txt": "public LocalDate( int year, int monthOfYear, int dayOfMonth, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); iChronology = chronology; iLocalMillis = instant;"
      },
      {
        "txt": "} private Object readResolve() { if (iChronology == null) { return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDate(iLocalMillis, iChronology.withUTC()); } return this; }"
      },
      {
        "txt": "public int size() { return 3; } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH:"
      },
      {
        "txt": "return chrono.dayOfMonth(); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) { case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR:"
      },
      {
        "txt": "return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH: return getChronology().dayOfMonth().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int get(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");"
      },
      {
        "txt": "} if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return fieldType.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; }"
      },
      {
        "txt": "DurationFieldType durType = type.getDurationType(); if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { return type.getField(getChronology()).isSupported(); } return false; } public boolean isSupported(DurationFieldType type) { if (type == null) {"
      },
      {
        "txt": "return false; } DurationField field = type.getField(getChronology()); if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { return field.isSupported(); } return false; } protected long getLocalMillis() {"
      },
      {
        "txt": "return iLocalMillis; } public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) { if (this == partial) { return true; } if (partial instanceof LocalDate) {"
      },
      {
        "txt": "LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) { return iLocalMillis == other.iLocalMillis; } } return super.equals(partial); } public int hashCode() { int hash = iHash; if (hash == 0) {"
      },
      {
        "txt": "hash = iHash = super.hashCode(); } return hash; } public int compareTo(ReadablePartial partial) { if (this == partial) { return 0; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial;"
      },
      {
        "txt": "if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); } public DateTime toDateTimeAtStartOfDay() { return toDateTimeAtStartOfDay(null); }"
      },
      {
        "txt": "public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; long instant = zone.convertLocalToUTC(localMillis, false); instant = chrono.dayOfMonth().roundFloor(instant); return new DateTime(instant, chrono); } @Deprecated public DateTime toDateTimeAtMidnight() {"
      },
      {
        "txt": "return toDateTimeAtMidnight(null); } @Deprecated public DateTime toDateTimeAtMidnight(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); } public DateTime toDateTimeAtCurrentTime() { return toDateTimeAtCurrentTime(null);"
      },
      {
        "txt": "} public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); long instantMillis = DateTimeUtils.currentTimeMillis(); long resolved = chrono.set(this, instantMillis); return new DateTime(resolved, chrono); } public DateMidnight toDateMidnight() { return toDateMidnight(null);"
      },
      {
        "txt": "} public DateMidnight toDateMidnight(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); } public LocalDateTime toLocalDateTime(LocalTime time) { if (time == null) { throw new IllegalArgumentException(\"The time must not be null\"); }"
      },
      {
        "txt": "if (getChronology() != time.getChronology()) { throw new IllegalArgumentException(\"The chronology of the time does not match\"); } long localMillis = getLocalMillis() + time.getLocalMillis(); return new LocalDateTime(localMillis, getChronology()); } public DateTime toDateTime(LocalTime time) { return toDateTime(time, null); } public DateTime toDateTime(LocalTime time, DateTimeZone zone) {"
      },
      {
        "txt": "if (time != null && getChronology() != time.getChronology()) { throw new IllegalArgumentException(\"The chronology of the time does not match\"); } Chronology chrono = getChronology().withZone(zone); long instant = DateTimeUtils.currentTimeMillis(); instant = chrono.set(this, instant); if (time != null) { instant = chrono.set(time, instant); } return new DateTime(instant, chrono);"
      },
      {
        "txt": "} public Interval toInterval() { return toInterval(null); } public Interval toInterval(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); DateTime start = toDateTimeAtStartOfDay(zone); DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone); return new Interval(start, end); }"
      },
      {
        "txt": "@SuppressWarnings(\"deprecation\") public Date toDate() { int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); LocalDate check = LocalDate.fromDateFields(date); if (check.isBefore(this)) { while (check.equals(this) == false) { date.setTime(date.getTime() + 3600000); check = LocalDate.fromDateFields(date); }"
      },
      {
        "txt": "while (date.getDate() == dom) { date.setTime(date.getTime() - 1000); } date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); if (earlier.getDate() == dom) { date = earlier; } }"
      },
      {
        "txt": "return date; } LocalDate withLocalMillis(long newMillis) { newMillis = iChronology.dayOfMonth().roundFloor(newMillis); return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology())); } public LocalDate withFields(ReadablePartial partial) { if (partial == null) { return this; }"
      },
      {
        "txt": "return withLocalMillis(getChronology().set(partial, getLocalMillis())); } public LocalDate withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } if (amount == 0) {"
      },
      {
        "txt": "return this; } long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); } public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getLocalMillis();"
      },
      {
        "txt": "Chronology chrono = getChronology(); for (int i = 0; i < period.size(); i++) { long value = FieldUtils.safeMultiply(period.getValue(i), scalar); DurationFieldType type = period.getFieldType(i); if (isSupported(type)) { instant = type.getField(chrono).add(instant, value); } } return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDate plus(ReadablePeriod period) { return withPeriodAdded(period, 1); } public LocalDate plusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDate plusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate plusWeeks(int weeks) { if (weeks == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().weeks().add(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDate plusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDate minus(ReadablePeriod period) { return withPeriodAdded(period, -1); } public LocalDate minusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDate minusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate minusWeeks(int weeks) { if (weeks == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDate minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days);"
      },
      {
        "txt": "return withLocalMillis(instant); } public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology()));"
      },
      {
        "txt": "} public int getEra() { return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis()); } public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() {"
      },
      {
        "txt": "return getChronology().monthOfYear().get(getLocalMillis()); } public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); } public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis());"
      },
      {
        "txt": "} public int getDayOfWeek() { return getChronology().dayOfWeek().get(getLocalMillis()); } public LocalDate withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDate withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); }"
      },
      {
        "txt": "public LocalDate withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); } public LocalDate withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDate withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDate withWeekyear(int weekyear) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); } public LocalDate withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDate withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));"
      },
      {
        "txt": "} public LocalDate withDayOfMonth(int dayOfMonth) { return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDate withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public Property era() { return new Property(this, getChronology().era()); }"
      },
      {
        "txt": "public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() {"
      },
      {
        "txt": "return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear());"
      },
      {
        "txt": "} public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); }"
      },
      {
        "txt": "@ToString public String toString() { return ISODateTimeFormat.date().print(this); } public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this); }"
      },
      {
        "txt": "public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -3193829732634L; private transient LocalDate iInstant; private transient DateTimeField iField;"
      },
      {
        "txt": "Property(LocalDate instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {"
      },
      {
        "txt": "iInstant = (LocalDate) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis(); }"
      },
      {
        "txt": "protected Chronology getChronology() { return iInstant.getChronology(); } public LocalDate getLocalDate() { return iInstant; } public LocalDate addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDate addWrapFieldToCopy(int value) {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); } public LocalDate setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDate setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDate setCopy(String text) { return setCopy(text, null);"
      },
      {
        "txt": "} public LocalDate withMaximumValue() { return setCopy(getMaximumValue()); } public LocalDate withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDate roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); }"
      },
      {
        "txt": "public LocalDate roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); } public LocalDate roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDate roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDate roundHalfEvenCopy() {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); } }"
      }
    ]
  },
  {
    "id": 2928,
    "file_path": "src/main/java/org/joda/time/LocalDate.java",
    "start-bug-line": 212,
    "end-bug-line": 212,
    "bug": "yearOfEra,",
    "fix": "(era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashSet; import java.util.Locale; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString;"
      },
      {
        "txt": "import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public final class LocalDate"
      },
      {
        "txt": "extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -8775358157899L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>(); static { DATE_DURATION_TYPES.add(DurationFieldType.days()); DATE_DURATION_TYPES.add(DurationFieldType.weeks());"
      },
      {
        "txt": "DATE_DURATION_TYPES.add(DurationFieldType.months()); DATE_DURATION_TYPES.add(DurationFieldType.weekyears()); DATE_DURATION_TYPES.add(DurationFieldType.years()); DATE_DURATION_TYPES.add(DurationFieldType.centuries()); DATE_DURATION_TYPES.add(DurationFieldType.eras()); } private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now() {"
      },
      {
        "txt": "return new LocalDate(); } public static LocalDate now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new LocalDate(zone); } public static LocalDate now(Chronology chronology) { if (chronology == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDate(chronology); } @FromString public static LocalDate parse(String str) { return parse(str, ISODateTimeFormat.localDateParser()); } public static LocalDate parse(String str, DateTimeFormatter formatter) { return formatter.parseLocalDate(str);"
      },
      {
        "txt": "public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( <extra_id_0> calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); } @SuppressWarnings(\"deprecation\") public static LocalDate fromDateFields(Date date) {"
      },
      {
        "txt": "@SuppressWarnings(\"deprecation\") public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, date.getDate() );"
      },
      {
        "txt": "} public LocalDate() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDate(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDate(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology); }"
      },
      {
        "txt": "public LocalDate(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDate(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); } public LocalDate(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); chronology = chronology.withUTC();"
      },
      {
        "txt": "iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); iChronology = chronology; } public LocalDate(Object instant) { this(instant, (Chronology) null); } public LocalDate(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology);"
      },
      {
        "txt": "iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());"
      },
      {
        "txt": "iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate( int year, int monthOfYear, int dayOfMonth) { this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); } public LocalDate( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); iChronology = chronology; iLocalMillis = instant; } private Object readResolve() {"
      },
      {
        "txt": "if (iChronology == null) { return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDate(iLocalMillis, iChronology.withUTC()); } return this; } public int size() { return 3;"
      },
      {
        "txt": "} protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH: return chrono.dayOfMonth(); default:"
      },
      {
        "txt": "throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) { case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH:"
      },
      {
        "txt": "return getChronology().dayOfMonth().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int get(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return fieldType.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } DurationFieldType durType = type.getDurationType(); if (DATE_DURATION_TYPES.contains(durType) ||"
      },
      {
        "txt": "durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { return type.getField(getChronology()).isSupported(); } return false; } public boolean isSupported(DurationFieldType type) { if (type == null) { return false; }"
      },
      {
        "txt": "DurationField field = type.getField(getChronology()); if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { return field.isSupported(); } return false; } protected long getLocalMillis() { return iLocalMillis; }"
      },
      {
        "txt": "public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) { if (this == partial) { return true; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) {"
      },
      {
        "txt": "return iLocalMillis == other.iLocalMillis; } } return super.equals(partial); } public int hashCode() { int hash = iHash; if (hash == 0) { hash = iHash = super.hashCode(); }"
      },
      {
        "txt": "return hash; } public int compareTo(ReadablePartial partial) { if (this == partial) { return 0; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 :"
      },
      {
        "txt": "(iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); } public DateTime toDateTimeAtStartOfDay() { return toDateTimeAtStartOfDay(null); } public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone);"
      },
      {
        "txt": "Chronology chrono = getChronology().withZone(zone); long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; long instant = zone.convertLocalToUTC(localMillis, false); instant = chrono.dayOfMonth().roundFloor(instant); return new DateTime(instant, chrono); } @Deprecated public DateTime toDateTimeAtMidnight() { return toDateTimeAtMidnight(null); }"
      },
      {
        "txt": "@Deprecated public DateTime toDateTimeAtMidnight(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); } public DateTime toDateTimeAtCurrentTime() { return toDateTimeAtCurrentTime(null); } public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {"
      },
      {
        "txt": "zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); long instantMillis = DateTimeUtils.currentTimeMillis(); long resolved = chrono.set(this, instantMillis); return new DateTime(resolved, chrono); } public DateMidnight toDateMidnight() { return toDateMidnight(null); } public DateMidnight toDateMidnight(DateTimeZone zone) {"
      },
      {
        "txt": "zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); } public LocalDateTime toLocalDateTime(LocalTime time) { if (time == null) { throw new IllegalArgumentException(\"The time must not be null\"); } if (getChronology() != time.getChronology()) { throw new IllegalArgumentException(\"The chronology of the time does not match\");"
      },
      {
        "txt": "} long localMillis = getLocalMillis() + time.getLocalMillis(); return new LocalDateTime(localMillis, getChronology()); } public DateTime toDateTime(LocalTime time) { return toDateTime(time, null); } public DateTime toDateTime(LocalTime time, DateTimeZone zone) { if (time != null && getChronology() != time.getChronology()) { throw new IllegalArgumentException(\"The chronology of the time does not match\");"
      },
      {
        "txt": "} Chronology chrono = getChronology().withZone(zone); long instant = DateTimeUtils.currentTimeMillis(); instant = chrono.set(this, instant); if (time != null) { instant = chrono.set(time, instant); } return new DateTime(instant, chrono); } public Interval toInterval() {"
      },
      {
        "txt": "return toInterval(null); } public Interval toInterval(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); DateTime start = toDateTimeAtStartOfDay(zone); DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone); return new Interval(start, end); } @SuppressWarnings(\"deprecation\") public Date toDate() {"
      },
      {
        "txt": "int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); LocalDate check = LocalDate.fromDateFields(date); if (check.isBefore(this)) { while (check.equals(this) == false) { date.setTime(date.getTime() + 3600000); check = LocalDate.fromDateFields(date); } while (date.getDate() == dom) { date.setTime(date.getTime() - 1000);"
      },
      {
        "txt": "} date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); if (earlier.getDate() == dom) { date = earlier; } } return date; }"
      },
      {
        "txt": "LocalDate withLocalMillis(long newMillis) { newMillis = iChronology.dayOfMonth().roundFloor(newMillis); return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology())); } public LocalDate withFields(ReadablePartial partial) { if (partial == null) { return this; } return withLocalMillis(getChronology().set(partial, getLocalMillis())); }"
      },
      {
        "txt": "public LocalDate withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } if (amount == 0) { return this; }"
      },
      {
        "txt": "long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); } public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getLocalMillis(); Chronology chrono = getChronology(); for (int i = 0; i < period.size(); i++) {"
      },
      {
        "txt": "long value = FieldUtils.safeMultiply(period.getValue(i), scalar); DurationFieldType type = period.getFieldType(i); if (isSupported(type)) { instant = type.getField(chrono).add(instant, value); } } return withLocalMillis(instant); } public LocalDate plus(ReadablePeriod period) { return withPeriodAdded(period, 1);"
      },
      {
        "txt": "} public LocalDate plusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDate plusMonths(int months) { if (months == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate plusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().add(getLocalMillis(), weeks);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDate plusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDate minus(ReadablePeriod period) {"
      },
      {
        "txt": "return withPeriodAdded(period, -1); } public LocalDate minusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDate minusMonths(int months) {"
      },
      {
        "txt": "if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate minusWeeks(int weeks) { if (weeks == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDate minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days); return withLocalMillis(instant); }"
      },
      {
        "txt": "public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology())); } public int getEra() {"
      },
      {
        "txt": "return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis());"
      },
      {
        "txt": "} public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); } public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); } public int getDayOfWeek() {"
      },
      {
        "txt": "return getChronology().dayOfWeek().get(getLocalMillis()); } public LocalDate withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDate withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); } public LocalDate withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));"
      },
      {
        "txt": "} public LocalDate withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDate withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDate withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); }"
      },
      {
        "txt": "public LocalDate withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDate withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); } public LocalDate withDayOfMonth(int dayOfMonth) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDate withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra());"
      },
      {
        "txt": "} public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); }"
      },
      {
        "txt": "public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } @ToString public String toString() {"
      },
      {
        "txt": "return ISODateTimeFormat.date().print(this); } public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this); } public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) {"
      },
      {
        "txt": "return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -3193829732634L; private transient LocalDate iInstant; private transient DateTimeField iField; Property(LocalDate instant, DateTimeField field) { super();"
      },
      {
        "txt": "iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDate) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject();"
      },
      {
        "txt": "iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis(); } protected Chronology getChronology() { return iInstant.getChronology();"
      },
      {
        "txt": "} public LocalDate getLocalDate() { return iInstant; } public LocalDate addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDate addWrapFieldToCopy(int value) { return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); }"
      },
      {
        "txt": "public LocalDate setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDate setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDate setCopy(String text) { return setCopy(text, null); } public LocalDate withMaximumValue() {"
      },
      {
        "txt": "return setCopy(getMaximumValue()); } public LocalDate withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDate roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); } public LocalDate roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));"
      },
      {
        "txt": "} public LocalDate roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDate roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDate roundHalfEvenCopy() { return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); }"
      }
    ]
  },
  {
    "id": 2929,
    "file_path": "src/main/java/org/joda/time/LocalDate.java",
    "start-bug-line": 243,
    "end-bug-line": 243,
    "bug": "",
    "fix": "if (date.getTime() < 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashSet; import java.util.Locale; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString;"
      },
      {
        "txt": "import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public final class LocalDate"
      },
      {
        "txt": "extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -8775358157899L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>(); static { DATE_DURATION_TYPES.add(DurationFieldType.days()); DATE_DURATION_TYPES.add(DurationFieldType.weeks());"
      },
      {
        "txt": "DATE_DURATION_TYPES.add(DurationFieldType.months()); DATE_DURATION_TYPES.add(DurationFieldType.weekyears()); DATE_DURATION_TYPES.add(DurationFieldType.years()); DATE_DURATION_TYPES.add(DurationFieldType.centuries()); DATE_DURATION_TYPES.add(DurationFieldType.eras()); } private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now() {"
      },
      {
        "txt": "return new LocalDate(); } public static LocalDate now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new LocalDate(zone); } public static LocalDate now(Chronology chronology) { if (chronology == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDate(chronology); } @FromString public static LocalDate parse(String str) { return parse(str, ISODateTimeFormat.localDateParser()); } public static LocalDate parse(String str, DateTimeFormatter formatter) { return formatter.parseLocalDate(str);"
      },
      {
        "txt": "} public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)"
      },
      {
        "txt": "} @SuppressWarnings(\"deprecation\") public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } <extra_id_0> return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, date.getDate() ); }"
      },
      {
        "txt": "); } public LocalDate() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDate(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDate(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology);"
      },
      {
        "txt": "} public LocalDate(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDate(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); } public LocalDate(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);"
      },
      {
        "txt": "chronology = chronology.withUTC(); iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); iChronology = chronology; } public LocalDate(Object instant) { this(instant, (Chronology) null); } public LocalDate(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone);"
      },
      {
        "txt": "chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC();"
      },
      {
        "txt": "int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate( int year, int monthOfYear, int dayOfMonth) { this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); } public LocalDate("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); iChronology = chronology; iLocalMillis = instant; }"
      },
      {
        "txt": "private Object readResolve() { if (iChronology == null) { return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDate(iLocalMillis, iChronology.withUTC()); } return this; } public int size() {"
      },
      {
        "txt": "return 3; } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH: return chrono.dayOfMonth();"
      },
      {
        "txt": "default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) { case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis());"
      },
      {
        "txt": "case DAY_OF_MONTH: return getChronology().dayOfMonth().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int get(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); }"
      },
      {
        "txt": "if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return fieldType.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } DurationFieldType durType = type.getDurationType();"
      },
      {
        "txt": "if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { return type.getField(getChronology()).isSupported(); } return false; } public boolean isSupported(DurationFieldType type) { if (type == null) { return false;"
      },
      {
        "txt": "} DurationField field = type.getField(getChronology()); if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { return field.isSupported(); } return false; } protected long getLocalMillis() { return iLocalMillis;"
      },
      {
        "txt": "} public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) { if (this == partial) { return true; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial;"
      },
      {
        "txt": "if (iChronology.equals(other.iChronology)) { return iLocalMillis == other.iLocalMillis; } } return super.equals(partial); } public int hashCode() { int hash = iHash; if (hash == 0) { hash = iHash = super.hashCode();"
      },
      {
        "txt": "} return hash; } public int compareTo(ReadablePartial partial) { if (this == partial) { return 0; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) {"
      },
      {
        "txt": "return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); } public DateTime toDateTimeAtStartOfDay() { return toDateTimeAtStartOfDay(null); } public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {"
      },
      {
        "txt": "zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; long instant = zone.convertLocalToUTC(localMillis, false); instant = chrono.dayOfMonth().roundFloor(instant); return new DateTime(instant, chrono); } @Deprecated public DateTime toDateTimeAtMidnight() { return toDateTimeAtMidnight(null);"
      },
      {
        "txt": "} @Deprecated public DateTime toDateTimeAtMidnight(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); } public DateTime toDateTimeAtCurrentTime() { return toDateTimeAtCurrentTime(null); }"
      },
      {
        "txt": "public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); long instantMillis = DateTimeUtils.currentTimeMillis(); long resolved = chrono.set(this, instantMillis); return new DateTime(resolved, chrono); } public DateMidnight toDateMidnight() { return toDateMidnight(null); }"
      },
      {
        "txt": "public DateMidnight toDateMidnight(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); } public LocalDateTime toLocalDateTime(LocalTime time) { if (time == null) { throw new IllegalArgumentException(\"The time must not be null\"); } if (getChronology() != time.getChronology()) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The chronology of the time does not match\"); } long localMillis = getLocalMillis() + time.getLocalMillis(); return new LocalDateTime(localMillis, getChronology()); } public DateTime toDateTime(LocalTime time) { return toDateTime(time, null); } public DateTime toDateTime(LocalTime time, DateTimeZone zone) { if (time != null && getChronology() != time.getChronology()) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The chronology of the time does not match\"); } Chronology chrono = getChronology().withZone(zone); long instant = DateTimeUtils.currentTimeMillis(); instant = chrono.set(this, instant); if (time != null) { instant = chrono.set(time, instant); } return new DateTime(instant, chrono); }"
      },
      {
        "txt": "public Interval toInterval() { return toInterval(null); } public Interval toInterval(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); DateTime start = toDateTimeAtStartOfDay(zone); DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone); return new Interval(start, end); } @SuppressWarnings(\"deprecation\")"
      },
      {
        "txt": "public Date toDate() { int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); LocalDate check = LocalDate.fromDateFields(date); if (check.isBefore(this)) { while (check.equals(this) == false) { date.setTime(date.getTime() + 3600000); check = LocalDate.fromDateFields(date); } while (date.getDate() == dom) {"
      },
      {
        "txt": "date.setTime(date.getTime() - 1000); } date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); if (earlier.getDate() == dom) { date = earlier; } } return date;"
      },
      {
        "txt": "} LocalDate withLocalMillis(long newMillis) { newMillis = iChronology.dayOfMonth().roundFloor(newMillis); return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology())); } public LocalDate withFields(ReadablePartial partial) { if (partial == null) { return this; } return withLocalMillis(getChronology().set(partial, getLocalMillis()));"
      },
      {
        "txt": "} public LocalDate withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } if (amount == 0) { return this;"
      },
      {
        "txt": "} long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); } public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getLocalMillis(); Chronology chrono = getChronology();"
      },
      {
        "txt": "for (int i = 0; i < period.size(); i++) { long value = FieldUtils.safeMultiply(period.getValue(i), scalar); DurationFieldType type = period.getFieldType(i); if (isSupported(type)) { instant = type.getField(chrono).add(instant, value); } } return withLocalMillis(instant); } public LocalDate plus(ReadablePeriod period) {"
      },
      {
        "txt": "return withPeriodAdded(period, 1); } public LocalDate plusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDate plusMonths(int months) {"
      },
      {
        "txt": "if (months == 0) { return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate plusWeeks(int weeks) { if (weeks == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().weeks().add(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDate plusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDate minus(ReadablePeriod period) { return withPeriodAdded(period, -1); } public LocalDate minusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDate minusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate minusWeeks(int weeks) { if (weeks == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDate minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days); return withLocalMillis(instant);"
      },
      {
        "txt": "} public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology())); }"
      },
      {
        "txt": "public int getEra() { return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() {"
      },
      {
        "txt": "return getChronology().yearOfCentury().get(getLocalMillis()); } public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis());"
      },
      {
        "txt": "} public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); } public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getDayOfWeek() { return getChronology().dayOfWeek().get(getLocalMillis()); } public LocalDate withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDate withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); } public LocalDate withYearOfEra(int yearOfEra) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); } public LocalDate withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDate withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDate withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));"
      },
      {
        "txt": "} public LocalDate withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDate withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); }"
      },
      {
        "txt": "public LocalDate withDayOfMonth(int dayOfMonth) { return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDate withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() {"
      },
      {
        "txt": "return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year());"
      },
      {
        "txt": "} public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); }"
      },
      {
        "txt": "public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } @ToString"
      },
      {
        "txt": "public String toString() { return ISODateTimeFormat.date().print(this); } public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this); } public String toString(String pattern, Locale locale) throws IllegalArgumentException {"
      },
      {
        "txt": "if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -3193829732634L; private transient LocalDate iInstant; private transient DateTimeField iField; Property(LocalDate instant, DateTimeField field) {"
      },
      {
        "txt": "super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDate) oos.readObject();"
      },
      {
        "txt": "DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis(); } protected Chronology getChronology() {"
      },
      {
        "txt": "return iInstant.getChronology(); } public LocalDate getLocalDate() { return iInstant; } public LocalDate addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDate addWrapFieldToCopy(int value) { return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));"
      },
      {
        "txt": "} public LocalDate setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDate setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDate setCopy(String text) { return setCopy(text, null); }"
      },
      {
        "txt": "public LocalDate withMaximumValue() { return setCopy(getMaximumValue()); } public LocalDate withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDate roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); } public LocalDate roundCeilingCopy() {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); } public LocalDate roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDate roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDate roundHalfEvenCopy() { return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2930,
    "file_path": "src/main/java/org/joda/time/LocalDate.java",
    "start-bug-line": 244,
    "end-bug-line": 244,
    "bug": "",
    "fix": "GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashSet; import java.util.Locale; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString;"
      },
      {
        "txt": "import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public final class LocalDate"
      },
      {
        "txt": "extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -8775358157899L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>(); static { DATE_DURATION_TYPES.add(DurationFieldType.days()); DATE_DURATION_TYPES.add(DurationFieldType.weeks());"
      },
      {
        "txt": "DATE_DURATION_TYPES.add(DurationFieldType.months()); DATE_DURATION_TYPES.add(DurationFieldType.weekyears()); DATE_DURATION_TYPES.add(DurationFieldType.years()); DATE_DURATION_TYPES.add(DurationFieldType.centuries()); DATE_DURATION_TYPES.add(DurationFieldType.eras()); } private final long iLocalMillis; private final Chronology iChronology; private transient volatile int iHash; public static LocalDate now() {"
      },
      {
        "txt": "return new LocalDate(); } public static LocalDate now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new LocalDate(zone); } public static LocalDate now(Chronology chronology) { if (chronology == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDate(chronology); } @FromString public static LocalDate parse(String str) { return parse(str, ISODateTimeFormat.localDateParser()); } public static LocalDate parse(String str, DateTimeFormatter formatter) { return formatter.parseLocalDate(str);"
      },
      {
        "txt": "} public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)"
      },
      {
        "txt": "} @SuppressWarnings(\"deprecation\") public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } <extra_id_0> date.getYear() + 1900, date.getMonth() + 1, date.getDate() ); } public LocalDate() {"
      },
      {
        "txt": "} public LocalDate() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDate(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDate(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology); }"
      },
      {
        "txt": "public LocalDate(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDate(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); } public LocalDate(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); chronology = chronology.withUTC();"
      },
      {
        "txt": "iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); iChronology = chronology; } public LocalDate(Object instant) { this(instant, (Chronology) null); } public LocalDate(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology);"
      },
      {
        "txt": "iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());"
      },
      {
        "txt": "iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); } public LocalDate( int year, int monthOfYear, int dayOfMonth) { this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); } public LocalDate( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); iChronology = chronology; iLocalMillis = instant; } private Object readResolve() {"
      },
      {
        "txt": "if (iChronology == null) { return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDate(iLocalMillis, iChronology.withUTC()); } return this; } public int size() { return 3;"
      },
      {
        "txt": "} protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH: return chrono.dayOfMonth(); default:"
      },
      {
        "txt": "throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) { case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH:"
      },
      {
        "txt": "return getChronology().dayOfMonth().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int get(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return fieldType.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } DurationFieldType durType = type.getDurationType(); if (DATE_DURATION_TYPES.contains(durType) ||"
      },
      {
        "txt": "durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { return type.getField(getChronology()).isSupported(); } return false; } public boolean isSupported(DurationFieldType type) { if (type == null) { return false; }"
      },
      {
        "txt": "DurationField field = type.getField(getChronology()); if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) { return field.isSupported(); } return false; } protected long getLocalMillis() { return iLocalMillis; }"
      },
      {
        "txt": "public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) { if (this == partial) { return true; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) {"
      },
      {
        "txt": "return iLocalMillis == other.iLocalMillis; } } return super.equals(partial); } public int hashCode() { int hash = iHash; if (hash == 0) { hash = iHash = super.hashCode(); }"
      },
      {
        "txt": "return hash; } public int compareTo(ReadablePartial partial) { if (this == partial) { return 0; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 :"
      },
      {
        "txt": "(iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); } public DateTime toDateTimeAtStartOfDay() { return toDateTimeAtStartOfDay(null); } public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone);"
      },
      {
        "txt": "Chronology chrono = getChronology().withZone(zone); long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; long instant = zone.convertLocalToUTC(localMillis, false); instant = chrono.dayOfMonth().roundFloor(instant); return new DateTime(instant, chrono); } @Deprecated public DateTime toDateTimeAtMidnight() { return toDateTimeAtMidnight(null); }"
      },
      {
        "txt": "@Deprecated public DateTime toDateTimeAtMidnight(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); } public DateTime toDateTimeAtCurrentTime() { return toDateTimeAtCurrentTime(null); } public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {"
      },
      {
        "txt": "zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); long instantMillis = DateTimeUtils.currentTimeMillis(); long resolved = chrono.set(this, instantMillis); return new DateTime(resolved, chrono); } public DateMidnight toDateMidnight() { return toDateMidnight(null); } public DateMidnight toDateMidnight(DateTimeZone zone) {"
      },
      {
        "txt": "zone = DateTimeUtils.getZone(zone); Chronology chrono = getChronology().withZone(zone); return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); } public LocalDateTime toLocalDateTime(LocalTime time) { if (time == null) { throw new IllegalArgumentException(\"The time must not be null\"); } if (getChronology() != time.getChronology()) { throw new IllegalArgumentException(\"The chronology of the time does not match\");"
      },
      {
        "txt": "} long localMillis = getLocalMillis() + time.getLocalMillis(); return new LocalDateTime(localMillis, getChronology()); } public DateTime toDateTime(LocalTime time) { return toDateTime(time, null); } public DateTime toDateTime(LocalTime time, DateTimeZone zone) { if (time != null && getChronology() != time.getChronology()) { throw new IllegalArgumentException(\"The chronology of the time does not match\");"
      },
      {
        "txt": "} Chronology chrono = getChronology().withZone(zone); long instant = DateTimeUtils.currentTimeMillis(); instant = chrono.set(this, instant); if (time != null) { instant = chrono.set(time, instant); } return new DateTime(instant, chrono); } public Interval toInterval() {"
      },
      {
        "txt": "return toInterval(null); } public Interval toInterval(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); DateTime start = toDateTimeAtStartOfDay(zone); DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone); return new Interval(start, end); } @SuppressWarnings(\"deprecation\") public Date toDate() {"
      },
      {
        "txt": "int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); LocalDate check = LocalDate.fromDateFields(date); if (check.isBefore(this)) { while (check.equals(this) == false) { date.setTime(date.getTime() + 3600000); check = LocalDate.fromDateFields(date); } while (date.getDate() == dom) { date.setTime(date.getTime() - 1000);"
      },
      {
        "txt": "} date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); if (earlier.getDate() == dom) { date = earlier; } } return date; }"
      },
      {
        "txt": "LocalDate withLocalMillis(long newMillis) { newMillis = iChronology.dayOfMonth().roundFloor(newMillis); return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology())); } public LocalDate withFields(ReadablePartial partial) { if (partial == null) { return this; } return withLocalMillis(getChronology().set(partial, getLocalMillis())); }"
      },
      {
        "txt": "public LocalDate withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } if (amount == 0) { return this; }"
      },
      {
        "txt": "long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); } public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getLocalMillis(); Chronology chrono = getChronology(); for (int i = 0; i < period.size(); i++) {"
      },
      {
        "txt": "long value = FieldUtils.safeMultiply(period.getValue(i), scalar); DurationFieldType type = period.getFieldType(i); if (isSupported(type)) { instant = type.getField(chrono).add(instant, value); } } return withLocalMillis(instant); } public LocalDate plus(ReadablePeriod period) { return withPeriodAdded(period, 1);"
      },
      {
        "txt": "} public LocalDate plusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDate plusMonths(int months) { if (months == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate plusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().add(getLocalMillis(), weeks);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDate plusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDate minus(ReadablePeriod period) {"
      },
      {
        "txt": "return withPeriodAdded(period, -1); } public LocalDate minusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDate minusMonths(int months) {"
      },
      {
        "txt": "if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDate minusWeeks(int weeks) { if (weeks == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDate minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days); return withLocalMillis(instant); }"
      },
      {
        "txt": "public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology())); } public int getEra() {"
      },
      {
        "txt": "return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis());"
      },
      {
        "txt": "} public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); } public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); } public int getDayOfWeek() {"
      },
      {
        "txt": "return getChronology().dayOfWeek().get(getLocalMillis()); } public LocalDate withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDate withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); } public LocalDate withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));"
      },
      {
        "txt": "} public LocalDate withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDate withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDate withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); }"
      },
      {
        "txt": "public LocalDate withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDate withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); } public LocalDate withDayOfMonth(int dayOfMonth) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDate withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra());"
      },
      {
        "txt": "} public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); }"
      },
      {
        "txt": "public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } @ToString public String toString() {"
      },
      {
        "txt": "return ISODateTimeFormat.date().print(this); } public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this); } public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) {"
      },
      {
        "txt": "return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -3193829732634L; private transient LocalDate iInstant; private transient DateTimeField iField; Property(LocalDate instant, DateTimeField field) { super();"
      },
      {
        "txt": "iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDate) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject();"
      },
      {
        "txt": "iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis(); } protected Chronology getChronology() { return iInstant.getChronology();"
      },
      {
        "txt": "} public LocalDate getLocalDate() { return iInstant; } public LocalDate addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDate addWrapFieldToCopy(int value) { return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); }"
      },
      {
        "txt": "public LocalDate setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDate setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDate setCopy(String text) { return setCopy(text, null); } public LocalDate withMaximumValue() {"
      },
      {
        "txt": "return setCopy(getMaximumValue()); } public LocalDate withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDate roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); } public LocalDate roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));"
      },
      {
        "txt": "} public LocalDate roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDate roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDate roundHalfEvenCopy() { return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); }"
      }
    ]
  },
  {
    "id": 2931,
    "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
    "start-bug-line": 199,
    "end-bug-line": 199,
    "bug": "",
    "fix": "int era = calendar.get(Calendar.ERA);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale;"
      },
      {
        "txt": "import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter;"
      },
      {
        "txt": "import org.joda.time.format.ISODateTimeFormat; public final class LocalDateTime extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -268716875315837168L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final int MILLIS_OF_DAY = 3; private final long iLocalMillis;"
      },
      {
        "txt": "private final Chronology iChronology; public static LocalDateTime now() { return new LocalDateTime(); } public static LocalDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new LocalDateTime(zone); }"
      },
      {
        "txt": "public static LocalDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDateTime(chronology); } @FromString public static LocalDateTime parse(String str) { return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); }"
      },
      {
        "txt": "return formatter.parseLocalDateTime(str); } public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } <extra_id_0> return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE),"
      },
      {
        "txt": "calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) ); } @SuppressWarnings(\"deprecation\") public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\");"
      },
      {
        "txt": "} return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 );"
      },
      {
        "txt": "} public LocalDateTime() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDateTime(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDateTime(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology); }"
      },
      {
        "txt": "public LocalDateTime(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDateTime(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); } public LocalDateTime(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); iLocalMillis = localMillis;"
      },
      {
        "txt": "iChronology = chronology.withUTC(); } public LocalDateTime(Object instant) { this(instant, (Chronology) null); } public LocalDateTime(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC();"
      },
      {
        "txt": "int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); } public LocalDateTime(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);"
      },
      {
        "txt": "} public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); }"
      },
      {
        "txt": "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); }"
      },
      {
        "txt": "public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());"
      },
      {
        "txt": "} public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {"
      },
      {
        "txt": "super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); iChronology = chronology; iLocalMillis = instant; } private Object readResolve() { if (iChronology == null) { return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());"
      },
      {
        "txt": "} if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDateTime(iLocalMillis, iChronology.withUTC()); } return this; } public int size() { return 4; } protected DateTimeField getField(int index, Chronology chrono) {"
      },
      {
        "txt": "switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH: return chrono.dayOfMonth(); case MILLIS_OF_DAY: return chrono.millisOfDay(); default:"
      },
      {
        "txt": "throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) { case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH:"
      },
      {
        "txt": "return getChronology().dayOfMonth().get(getLocalMillis()); case MILLIS_OF_DAY: return getChronology().millisOfDay().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int get(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");"
      },
      {
        "txt": "} return type.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } return type.getField(getChronology()).isSupported(); } public boolean isSupported(DurationFieldType type) {"
      },
      {
        "txt": "if (type == null) { return false; } return type.getField(getChronology()).isSupported(); } protected long getLocalMillis() { return iLocalMillis; } public Chronology getChronology() { return iChronology;"
      },
      {
        "txt": "} public boolean equals(Object partial) { if (this == partial) { return true; } if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return iLocalMillis == other.iLocalMillis; }"
      },
      {
        "txt": "} return super.equals(partial); } public int compareTo(ReadablePartial partial) { if (this == partial) { return 0; } if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) {"
      },
      {
        "txt": "return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); } public DateTime toDateTime() { return toDateTime((DateTimeZone) null); } public DateTime toDateTime(DateTimeZone zone) {"
      },
      {
        "txt": "zone = DateTimeUtils.getZone(zone); Chronology chrono = iChronology.withZone(zone); return new DateTime( getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), chrono); } public LocalDate toLocalDate() { return new LocalDate(getLocalMillis(), getChronology()); }"
      },
      {
        "txt": "public LocalTime toLocalTime() { return new LocalTime(getLocalMillis(), getChronology()); } @SuppressWarnings(\"deprecation\") public Date toDate() { int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); date.setTime(date.getTime() + getMillisOfSecond()); LocalDateTime check = LocalDateTime.fromDateFields(date);"
      },
      {
        "txt": "if (check.isBefore(this)) { while (check.isBefore(this)) { date.setTime(date.getTime() + 60000); check = LocalDateTime.fromDateFields(date); } while (check.isBefore(this) == false) { date.setTime(date.getTime() - 1000); check = LocalDateTime.fromDateFields(date); } date.setTime(date.getTime() + 1000);"
      },
      {
        "txt": "} else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); check = LocalDateTime.fromDateFields(earlier); if (check.equals(this)) { date = earlier; } } return date; } LocalDateTime withLocalMillis(long newMillis) {"
      },
      {
        "txt": "return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology())); } public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { Chronology chrono = getChronology(); long instant = getLocalMillis(); instant = chrono.year().set(instant, year); instant = chrono.monthOfYear().set(instant, monthOfYear); instant = chrono.dayOfMonth().set(instant, dayOfMonth); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { Chronology chrono = getChronology(); long instant = getLocalMillis(); instant = chrono.hourOfDay().set(instant, hourOfDay); instant = chrono.minuteOfHour().set(instant, minuteOfHour); instant = chrono.secondOfMinute().set(instant, secondOfMinute); instant = chrono.millisOfSecond().set(instant, millisOfSecond); return withLocalMillis(instant); } public LocalDateTime withFields(ReadablePartial partial) {"
      },
      {
        "txt": "if (partial == null) { return this; } return withLocalMillis(getChronology().set(partial, getLocalMillis())); } public LocalDateTime withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (amount == 0) { return this; } long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) { if (durationToAdd == null || scalar == 0) { return this; } long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar); return withLocalMillis(instant); } public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {"
      },
      {
        "txt": "if (period == null || scalar == 0) { return this; } long instant = getChronology().add(period, getLocalMillis(), scalar); return withLocalMillis(instant); } public LocalDateTime plus(ReadableDuration duration) { return withDurationAdded(duration, 1); } public LocalDateTime plus(ReadablePeriod period) {"
      },
      {
        "txt": "return withPeriodAdded(period, 1); } public LocalDateTime plusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime plusMonths(int months) {"
      },
      {
        "txt": "if (months == 0) { return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDateTime plusWeeks(int weeks) { if (weeks == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().weeks().add(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDateTime plusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime plusHours(int hours) { if (hours == 0) { return this; } long instant = getChronology().hours().add(getLocalMillis(), hours); return withLocalMillis(instant); } public LocalDateTime plusMinutes(int minutes) { if (minutes == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().minutes().add(getLocalMillis(), minutes); return withLocalMillis(instant); } public LocalDateTime plusSeconds(int seconds) { if (seconds == 0) { return this; } long instant = getChronology().seconds().add(getLocalMillis(), seconds); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime plusMillis(int millis) { if (millis == 0) { return this; } long instant = getChronology().millis().add(getLocalMillis(), millis); return withLocalMillis(instant); } public LocalDateTime minus(ReadableDuration duration) { return withDurationAdded(duration, -1);"
      },
      {
        "txt": "} public LocalDateTime minus(ReadablePeriod period) { return withPeriodAdded(period, -1); } public LocalDateTime minusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime minusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDateTime minusWeeks(int weeks) { if (weeks == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDateTime minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime minusHours(int hours) { if (hours == 0) { return this; } long instant = getChronology().hours().subtract(getLocalMillis(), hours); return withLocalMillis(instant); } public LocalDateTime minusMinutes(int minutes) {"
      },
      {
        "txt": "if (minutes == 0) { return this; } long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); return withLocalMillis(instant); } public LocalDateTime minusSeconds(int seconds) { if (seconds == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); return withLocalMillis(instant); } public LocalDateTime minusMillis(int millis) { if (millis == 0) { return this; } long instant = getChronology().millis().subtract(getLocalMillis(), millis); return withLocalMillis(instant); }"
      },
      {
        "txt": "public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology())); } public int getEra() {"
      },
      {
        "txt": "return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis());"
      },
      {
        "txt": "} public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); } public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); } public int getDayOfWeek() {"
      },
      {
        "txt": "return getChronology().dayOfWeek().get(getLocalMillis()); } public int getHourOfDay() { return getChronology().hourOfDay().get(getLocalMillis()); } public int getMinuteOfHour() { return getChronology().minuteOfHour().get(getLocalMillis()); } public int getSecondOfMinute() { return getChronology().secondOfMinute().get(getLocalMillis());"
      },
      {
        "txt": "} public int getMillisOfSecond() { return getChronology().millisOfSecond().get(getLocalMillis()); } public int getMillisOfDay() { return getChronology().millisOfDay().get(getLocalMillis()); } public LocalDateTime withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); }"
      },
      {
        "txt": "public LocalDateTime withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); } public LocalDateTime withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); } public LocalDateTime withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDateTime withYear(int year) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDateTime withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); } public LocalDateTime withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));"
      },
      {
        "txt": "} public LocalDateTime withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); } public LocalDateTime withDayOfMonth(int dayOfMonth) { return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDateTime withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); }"
      },
      {
        "txt": "public LocalDateTime withHourOfDay(int hour) { return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); } public LocalDateTime withMinuteOfHour(int minute) { return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); } public LocalDateTime withSecondOfMinute(int second) { return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); } public LocalDateTime withMillisOfSecond(int millis) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); } public LocalDateTime withMillisOfDay(int millis) { return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra());"
      },
      {
        "txt": "} public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); }"
      },
      {
        "txt": "public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay());"
      },
      {
        "txt": "} public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); }"
      },
      {
        "txt": "public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public String toString(String pattern) { if (pattern == null) { return toString();"
      },
      {
        "txt": "} return DateTimeFormat.forPattern(pattern).print(this); } public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty {"
      },
      {
        "txt": "private static final long serialVersionUID = -358138762846288L; private transient LocalDateTime iInstant; private transient DateTimeField iField; Property(LocalDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant);"
      },
      {
        "txt": "oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; }"
      },
      {
        "txt": "protected long getMillis() { return iInstant.getLocalMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public LocalDateTime getLocalDateTime() { return iInstant; } public LocalDateTime addToCopy(int value) {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDateTime addToCopy(long value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDateTime addWrapFieldToCopy(int value) { return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));"
      },
      {
        "txt": "} public LocalDateTime setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDateTime setCopy(String text) { return setCopy(text, null); } public LocalDateTime withMaximumValue() { return setCopy(getMaximumValue()); }"
      },
      {
        "txt": "public LocalDateTime withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDateTime roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); } public LocalDateTime roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfFloorCopy() {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDateTime roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfEvenCopy() { return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); } }"
      }
    ]
  },
  {
    "id": 2932,
    "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
    "start-bug-line": 201,
    "end-bug-line": 201,
    "bug": "yearOfEra,",
    "fix": "(era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import org.joda.convert.FromString;"
      },
      {
        "txt": "import org.joda.convert.ToString; import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public final class LocalDateTime"
      },
      {
        "txt": "extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -268716875315837168L; private static final int YEAR = 0; private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final int MILLIS_OF_DAY = 3; private final long iLocalMillis; private final Chronology iChronology; public static LocalDateTime now() {"
      },
      {
        "txt": "return new LocalDateTime(); } public static LocalDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new LocalDateTime(zone); } public static LocalDateTime now(Chronology chronology) { if (chronology == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDateTime(chronology); } @FromString public static LocalDateTime parse(String str) { return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); } public static LocalDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseLocalDateTime(str);"
      },
      {
        "txt": "public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( <extra_id_0> calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)"
      },
      {
        "txt": "calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) ); } @SuppressWarnings(\"deprecation\") public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return new LocalDateTime("
      },
      {
        "txt": "date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); } public LocalDateTime() {"
      },
      {
        "txt": "this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDateTime(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDateTime(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology); } public LocalDateTime(long instant) { this(instant, ISOChronology.getInstance());"
      },
      {
        "txt": "} public LocalDateTime(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); } public LocalDateTime(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); iLocalMillis = localMillis; iChronology = chronology.withUTC(); }"
      },
      {
        "txt": "public LocalDateTime(Object instant) { this(instant, (Chronology) null); } public LocalDateTime(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);"
      },
      {
        "txt": "} public LocalDateTime(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); } public LocalDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC()); } public LocalDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC();"
      },
      {
        "txt": "long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); iChronology = chronology; iLocalMillis = instant; } private Object readResolve() { if (iChronology == null) { return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {"
      },
      {
        "txt": "return new LocalDateTime(iLocalMillis, iChronology.withUTC()); } return this; } public int size() { return 4; } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR:"
      },
      {
        "txt": "return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH: return chrono.dayOfMonth(); case MILLIS_OF_DAY: return chrono.millisOfDay(); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); }"
      },
      {
        "txt": "} public int getValue(int index) { switch (index) { case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH: return getChronology().dayOfMonth().get(getLocalMillis()); case MILLIS_OF_DAY:"
      },
      {
        "txt": "return getChronology().millisOfDay().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int get(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } return type.getField(getChronology()).get(getLocalMillis());"
      },
      {
        "txt": "} public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } return type.getField(getChronology()).isSupported(); } public boolean isSupported(DurationFieldType type) { if (type == null) { return false;"
      },
      {
        "txt": "} return type.getField(getChronology()).isSupported(); } protected long getLocalMillis() { return iLocalMillis; } public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) {"
      },
      {
        "txt": "if (this == partial) { return true; } if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return iLocalMillis == other.iLocalMillis; } } return super.equals(partial);"
      },
      {
        "txt": "} public int compareTo(ReadablePartial partial) { if (this == partial) { return 0; } if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));"
      },
      {
        "txt": "} } return super.compareTo(partial); } public DateTime toDateTime() { return toDateTime((DateTimeZone) null); } public DateTime toDateTime(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = iChronology.withZone(zone);"
      },
      {
        "txt": "return new DateTime( getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), chrono); } public LocalDate toLocalDate() { return new LocalDate(getLocalMillis(), getChronology()); } public LocalTime toLocalTime() { return new LocalTime(getLocalMillis(), getChronology());"
      },
      {
        "txt": "} @SuppressWarnings(\"deprecation\") public Date toDate() { int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); date.setTime(date.getTime() + getMillisOfSecond()); LocalDateTime check = LocalDateTime.fromDateFields(date); if (check.isBefore(this)) { while (check.isBefore(this)) {"
      },
      {
        "txt": "date.setTime(date.getTime() + 60000); check = LocalDateTime.fromDateFields(date); } while (check.isBefore(this) == false) { date.setTime(date.getTime() - 1000); check = LocalDateTime.fromDateFields(date); } date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());"
      },
      {
        "txt": "check = LocalDateTime.fromDateFields(earlier); if (check.equals(this)) { date = earlier; } } return date; } LocalDateTime withLocalMillis(long newMillis) { return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology())); }"
      },
      {
        "txt": "public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { Chronology chrono = getChronology(); long instant = getLocalMillis(); instant = chrono.year().set(instant, year); instant = chrono.monthOfYear().set(instant, monthOfYear); instant = chrono.dayOfMonth().set(instant, dayOfMonth); return withLocalMillis(instant); } public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { Chronology chrono = getChronology();"
      },
      {
        "txt": "long instant = getLocalMillis(); instant = chrono.hourOfDay().set(instant, hourOfDay); instant = chrono.minuteOfHour().set(instant, minuteOfHour); instant = chrono.secondOfMinute().set(instant, secondOfMinute); instant = chrono.millisOfSecond().set(instant, millisOfSecond); return withLocalMillis(instant); } public LocalDateTime withFields(ReadablePartial partial) { if (partial == null) { return this;"
      },
      {
        "txt": "} return withLocalMillis(getChronology().set(partial, getLocalMillis())); } public LocalDateTime withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } if (amount == 0) { return this; } long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) { if (durationToAdd == null || scalar == 0) { return this; } long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar); return withLocalMillis(instant); } public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().add(period, getLocalMillis(), scalar); return withLocalMillis(instant); } public LocalDateTime plus(ReadableDuration duration) { return withDurationAdded(duration, 1); } public LocalDateTime plus(ReadablePeriod period) { return withPeriodAdded(period, 1); }"
      },
      {
        "txt": "public LocalDateTime plusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime plusMonths(int months) { if (months == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDateTime plusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().add(getLocalMillis(), weeks); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime plusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDateTime plusHours(int hours) { if (hours == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().hours().add(getLocalMillis(), hours); return withLocalMillis(instant); } public LocalDateTime plusMinutes(int minutes) { if (minutes == 0) { return this; } long instant = getChronology().minutes().add(getLocalMillis(), minutes);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime plusSeconds(int seconds) { if (seconds == 0) { return this; } long instant = getChronology().seconds().add(getLocalMillis(), seconds); return withLocalMillis(instant); } public LocalDateTime plusMillis(int millis) {"
      },
      {
        "txt": "if (millis == 0) { return this; } long instant = getChronology().millis().add(getLocalMillis(), millis); return withLocalMillis(instant); } public LocalDateTime minus(ReadableDuration duration) { return withDurationAdded(duration, -1); } public LocalDateTime minus(ReadablePeriod period) {"
      },
      {
        "txt": "return withPeriodAdded(period, -1); } public LocalDateTime minusYears(int years) { if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime minusMonths(int months) {"
      },
      {
        "txt": "if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDateTime minusWeeks(int weeks) { if (weeks == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDateTime minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime minusHours(int hours) { if (hours == 0) { return this; } long instant = getChronology().hours().subtract(getLocalMillis(), hours); return withLocalMillis(instant); } public LocalDateTime minusMinutes(int minutes) { if (minutes == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); return withLocalMillis(instant); } public LocalDateTime minusSeconds(int seconds) { if (seconds == 0) { return this; } long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime minusMillis(int millis) { if (millis == 0) { return this; } long instant = getChronology().millis().subtract(getLocalMillis(), millis); return withLocalMillis(instant); } public Property property(DateTimeFieldType fieldType) { if (fieldType == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology())); } public int getEra() { return getChronology().era().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis()); } public int getYear() {"
      },
      {
        "txt": "return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); } public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis());"
      },
      {
        "txt": "} public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); } public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); } public int getDayOfWeek() { return getChronology().dayOfWeek().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getHourOfDay() { return getChronology().hourOfDay().get(getLocalMillis()); } public int getMinuteOfHour() { return getChronology().minuteOfHour().get(getLocalMillis()); } public int getSecondOfMinute() { return getChronology().secondOfMinute().get(getLocalMillis()); } public int getMillisOfSecond() {"
      },
      {
        "txt": "return getChronology().millisOfSecond().get(getLocalMillis()); } public int getMillisOfDay() { return getChronology().millisOfDay().get(getLocalMillis()); } public LocalDateTime withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDateTime withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));"
      },
      {
        "txt": "} public LocalDateTime withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); } public LocalDateTime withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDateTime withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); }"
      },
      {
        "txt": "public LocalDateTime withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); } public LocalDateTime withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDateTime withDayOfYear(int dayOfYear) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); } public LocalDateTime withDayOfMonth(int dayOfMonth) { return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDateTime withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public LocalDateTime withHourOfDay(int hour) { return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));"
      },
      {
        "txt": "} public LocalDateTime withMinuteOfHour(int minute) { return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); } public LocalDateTime withSecondOfMinute(int second) { return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); } public LocalDateTime withMillisOfSecond(int millis) { return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); }"
      },
      {
        "txt": "public LocalDateTime withMillisOfDay(int millis) { return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear());"
      },
      {
        "txt": "} public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); }"
      },
      {
        "txt": "public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfHour() {"
      },
      {
        "txt": "return new Property(this, getChronology().minuteOfHour()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay());"
      },
      {
        "txt": "} @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this);"
      },
      {
        "txt": "} public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -358138762846288L; private transient LocalDateTime iInstant;"
      },
      {
        "txt": "private transient DateTimeField iField; Property(LocalDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); }"
      },
      {
        "txt": "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis();"
      },
      {
        "txt": "} protected Chronology getChronology() { return iInstant.getChronology(); } public LocalDateTime getLocalDateTime() { return iInstant; } public LocalDateTime addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); }"
      },
      {
        "txt": "public LocalDateTime addToCopy(long value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDateTime addWrapFieldToCopy(int value) { return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(String text, Locale locale) {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDateTime setCopy(String text) { return setCopy(text, null); } public LocalDateTime withMaximumValue() { return setCopy(getMaximumValue()); } public LocalDateTime withMinimumValue() { return setCopy(getMinimumValue());"
      },
      {
        "txt": "} public LocalDateTime roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); } public LocalDateTime roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); }"
      },
      {
        "txt": "public LocalDateTime roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfEvenCopy() { return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); } }"
      }
    ]
  },
  {
    "id": 2933,
    "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
    "start-bug-line": 236,
    "end-bug-line": 236,
    "bug": "",
    "fix": "if (date.getTime() < 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable;"
      },
      {
        "txt": "import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager;"
      },
      {
        "txt": "import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public final class LocalDateTime extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -268716875315837168L; private static final int YEAR = 0;"
      },
      {
        "txt": "private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final int MILLIS_OF_DAY = 3; private final long iLocalMillis; private final Chronology iChronology; public static LocalDateTime now() { return new LocalDateTime(); } public static LocalDateTime now(DateTimeZone zone) { if (zone == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Zone must not be null\"); } return new LocalDateTime(zone); } public static LocalDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDateTime(chronology); }"
      },
      {
        "txt": "@FromString public static LocalDateTime parse(String str) { return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); } public static LocalDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseLocalDateTime(str); } public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\");"
      },
      {
        "txt": "} int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)"
      },
      {
        "txt": "} @SuppressWarnings(\"deprecation\") public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } <extra_id_0> return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(),"
      },
      {
        "txt": "date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); } public LocalDateTime() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDateTime(DateTimeZone zone) {"
      },
      {
        "txt": "this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); } public LocalDateTime(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology); } public LocalDateTime(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDateTime(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone));"
      },
      {
        "txt": "} public LocalDateTime(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); iLocalMillis = localMillis; iChronology = chronology.withUTC(); } public LocalDateTime(Object instant) { this(instant, (Chronology) null); }"
      },
      {
        "txt": "public LocalDateTime(Object instant, DateTimeZone zone) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); } public LocalDateTime(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);"
      },
      {
        "txt": "chronology = converter.getChronology(instant, chronology); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); iChronology = chronology;"
      },
      {
        "txt": "iLocalMillis = instant; } private Object readResolve() { if (iChronology == null) { return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDateTime(iLocalMillis, iChronology.withUTC()); } return this;"
      },
      {
        "txt": "} public int size() { return 4; } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear();"
      },
      {
        "txt": "case DAY_OF_MONTH: return chrono.dayOfMonth(); case MILLIS_OF_DAY: return chrono.millisOfDay(); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) {"
      },
      {
        "txt": "case YEAR: return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH: return getChronology().dayOfMonth().get(getLocalMillis()); case MILLIS_OF_DAY: return getChronology().millisOfDay().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index);"
      },
      {
        "txt": "} } public int get(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } return type.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) {"
      },
      {
        "txt": "return false; } return type.getField(getChronology()).isSupported(); } public boolean isSupported(DurationFieldType type) { if (type == null) { return false; } return type.getField(getChronology()).isSupported(); }"
      },
      {
        "txt": "protected long getLocalMillis() { return iLocalMillis; } public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) { if (this == partial) { return true; }"
      },
      {
        "txt": "if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return iLocalMillis == other.iLocalMillis; } } return super.equals(partial); } public int compareTo(ReadablePartial partial) { if (this == partial) {"
      },
      {
        "txt": "return 0; } if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial);"
      },
      {
        "txt": "} public DateTime toDateTime() { return toDateTime((DateTimeZone) null); } public DateTime toDateTime(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = iChronology.withZone(zone); return new DateTime( getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(),"
      },
      {
        "txt": "getSecondOfMinute(), getMillisOfSecond(), chrono); } public LocalDate toLocalDate() { return new LocalDate(getLocalMillis(), getChronology()); } public LocalTime toLocalTime() { return new LocalTime(getLocalMillis(), getChronology()); } @SuppressWarnings(\"deprecation\") public Date toDate() {"
      },
      {
        "txt": "int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); date.setTime(date.getTime() + getMillisOfSecond()); LocalDateTime check = LocalDateTime.fromDateFields(date); if (check.isBefore(this)) { while (check.isBefore(this)) { date.setTime(date.getTime() + 60000); check = LocalDateTime.fromDateFields(date); }"
      },
      {
        "txt": "while (check.isBefore(this) == false) { date.setTime(date.getTime() - 1000); check = LocalDateTime.fromDateFields(date); } date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); check = LocalDateTime.fromDateFields(earlier); if (check.equals(this)) { date = earlier;"
      },
      {
        "txt": "} } return date; } LocalDateTime withLocalMillis(long newMillis) { return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology())); } public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { Chronology chrono = getChronology(); long instant = getLocalMillis();"
      },
      {
        "txt": "instant = chrono.year().set(instant, year); instant = chrono.monthOfYear().set(instant, monthOfYear); instant = chrono.dayOfMonth().set(instant, dayOfMonth); return withLocalMillis(instant); } public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { Chronology chrono = getChronology(); long instant = getLocalMillis(); instant = chrono.hourOfDay().set(instant, hourOfDay); instant = chrono.minuteOfHour().set(instant, minuteOfHour);"
      },
      {
        "txt": "instant = chrono.secondOfMinute().set(instant, secondOfMinute); instant = chrono.millisOfSecond().set(instant, millisOfSecond); return withLocalMillis(instant); } public LocalDateTime withFields(ReadablePartial partial) { if (partial == null) { return this; } return withLocalMillis(getChronology().set(partial, getLocalMillis())); }"
      },
      {
        "txt": "public LocalDateTime withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); return withLocalMillis(instant); } public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\");"
      },
      {
        "txt": "} if (amount == 0) { return this; } long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); } public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) { if (durationToAdd == null || scalar == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar); return withLocalMillis(instant); } public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getChronology().add(period, getLocalMillis(), scalar); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime plus(ReadableDuration duration) { return withDurationAdded(duration, 1); } public LocalDateTime plus(ReadablePeriod period) { return withPeriodAdded(period, 1); } public LocalDateTime plusYears(int years) { if (years == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime plusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime plusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().add(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDateTime plusDays(int days) { if (days == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDateTime plusHours(int hours) { if (hours == 0) { return this; } long instant = getChronology().hours().add(getLocalMillis(), hours);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime plusMinutes(int minutes) { if (minutes == 0) { return this; } long instant = getChronology().minutes().add(getLocalMillis(), minutes); return withLocalMillis(instant); } public LocalDateTime plusSeconds(int seconds) {"
      },
      {
        "txt": "if (seconds == 0) { return this; } long instant = getChronology().seconds().add(getLocalMillis(), seconds); return withLocalMillis(instant); } public LocalDateTime plusMillis(int millis) { if (millis == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().millis().add(getLocalMillis(), millis); return withLocalMillis(instant); } public LocalDateTime minus(ReadableDuration duration) { return withDurationAdded(duration, -1); } public LocalDateTime minus(ReadablePeriod period) { return withPeriodAdded(period, -1); } public LocalDateTime minusYears(int years) {"
      },
      {
        "txt": "if (years == 0) { return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime minusMonths(int months) { if (months == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().months().subtract(getLocalMillis(), months); return withLocalMillis(instant); } public LocalDateTime minusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime minusDays(int days) { if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDateTime minusHours(int hours) { if (hours == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().hours().subtract(getLocalMillis(), hours); return withLocalMillis(instant); } public LocalDateTime minusMinutes(int minutes) { if (minutes == 0) { return this; } long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime minusSeconds(int seconds) { if (seconds == 0) { return this; } long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); return withLocalMillis(instant); } public LocalDateTime minusMillis(int millis) { if (millis == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().millis().subtract(getLocalMillis(), millis); return withLocalMillis(instant); } public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\"); } return new Property(this, fieldType.getField(getChronology())); } public int getEra() { return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis()); } public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() {"
      },
      {
        "txt": "return getChronology().weekyear().get(getLocalMillis()); } public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); } public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis());"
      },
      {
        "txt": "} public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); } public int getDayOfWeek() { return getChronology().dayOfWeek().get(getLocalMillis()); } public int getHourOfDay() { return getChronology().hourOfDay().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getMinuteOfHour() { return getChronology().minuteOfHour().get(getLocalMillis()); } public int getSecondOfMinute() { return getChronology().secondOfMinute().get(getLocalMillis()); } public int getMillisOfSecond() { return getChronology().millisOfSecond().get(getLocalMillis()); } public int getMillisOfDay() {"
      },
      {
        "txt": "return getChronology().millisOfDay().get(getLocalMillis()); } public LocalDateTime withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDateTime withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); } public LocalDateTime withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));"
      },
      {
        "txt": "} public LocalDateTime withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDateTime withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDateTime withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); }"
      },
      {
        "txt": "public LocalDateTime withMonthOfYear(int monthOfYear) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDateTime withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); } public LocalDateTime withDayOfMonth(int dayOfMonth) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); } public LocalDateTime withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public LocalDateTime withHourOfDay(int hour) { return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); } public LocalDateTime withMinuteOfHour(int minute) { return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));"
      },
      {
        "txt": "} public LocalDateTime withSecondOfMinute(int second) { return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); } public LocalDateTime withMillisOfSecond(int millis) { return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); } public LocalDateTime withMillisOfDay(int millis) { return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); }"
      },
      {
        "txt": "public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear());"
      },
      {
        "txt": "} public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); }"
      },
      {
        "txt": "public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfMinute() {"
      },
      {
        "txt": "return new Property(this, getChronology().secondOfMinute()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } @ToString public String toString() {"
      },
      {
        "txt": "return ISODateTimeFormat.dateTime().print(this); } public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this); } public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) {"
      },
      {
        "txt": "return toString(); } return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -358138762846288L; private transient LocalDateTime iInstant; private transient DateTimeField iField; Property(LocalDateTime instant, DateTimeField field) { super();"
      },
      {
        "txt": "iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject();"
      },
      {
        "txt": "iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis(); } protected Chronology getChronology() { return iInstant.getChronology();"
      },
      {
        "txt": "} public LocalDateTime getLocalDateTime() { return iInstant; } public LocalDateTime addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDateTime addToCopy(long value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); }"
      },
      {
        "txt": "public LocalDateTime addWrapFieldToCopy(int value) { return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDateTime setCopy(String text) {"
      },
      {
        "txt": "return setCopy(text, null); } public LocalDateTime withMaximumValue() { return setCopy(getMaximumValue()); } public LocalDateTime withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDateTime roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));"
      },
      {
        "txt": "} public LocalDateTime roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDateTime roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); }"
      },
      {
        "txt": "public LocalDateTime roundHalfEvenCopy() { return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); } }"
      }
    ]
  },
  {
    "id": 2934,
    "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
    "start-bug-line": 237,
    "end-bug-line": 237,
    "bug": "",
    "fix": "GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable;"
      },
      {
        "txt": "import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseLocal; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager;"
      },
      {
        "txt": "import org.joda.time.convert.PartialConverter; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public final class LocalDateTime extends BaseLocal implements ReadablePartial, Serializable { private static final long serialVersionUID = -268716875315837168L; private static final int YEAR = 0;"
      },
      {
        "txt": "private static final int MONTH_OF_YEAR = 1; private static final int DAY_OF_MONTH = 2; private static final int MILLIS_OF_DAY = 3; private final long iLocalMillis; private final Chronology iChronology; public static LocalDateTime now() { return new LocalDateTime(); } public static LocalDateTime now(DateTimeZone zone) { if (zone == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Zone must not be null\"); } return new LocalDateTime(zone); } public static LocalDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new LocalDateTime(chronology); }"
      },
      {
        "txt": "@FromString public static LocalDateTime parse(String str) { return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); } public static LocalDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseLocalDateTime(str); } public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\");"
      },
      {
        "txt": "} int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime( yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)"
      },
      {
        "txt": "} @SuppressWarnings(\"deprecation\") public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } <extra_id_0> date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(),"
      },
      {
        "txt": "date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); } public LocalDateTime() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); } public LocalDateTime(DateTimeZone zone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));"
      },
      {
        "txt": "} public LocalDateTime(Chronology chronology) { this(DateTimeUtils.currentTimeMillis(), chronology); } public LocalDateTime(long instant) { this(instant, ISOChronology.getInstance()); } public LocalDateTime(long instant, DateTimeZone zone) { this(instant, ISOChronology.getInstance(zone)); }"
      },
      {
        "txt": "public LocalDateTime(long instant, Chronology chronology) { chronology = DateTimeUtils.getChronology(chronology); long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); iLocalMillis = localMillis; iChronology = chronology.withUTC(); } public LocalDateTime(Object instant) { this(instant, (Chronology) null); } public LocalDateTime(Object instant, DateTimeZone zone) {"
      },
      {
        "txt": "PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); Chronology chronology = converter.getChronology(instant, zone); chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); } public LocalDateTime(Object instant, Chronology chronology) { PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); chronology = converter.getChronology(instant, chronology);"
      },
      {
        "txt": "chronology = DateTimeUtils.getChronology(chronology); iChronology = chronology.withUTC(); int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) { this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC()); } public LocalDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); iChronology = chronology; iLocalMillis = instant;"
      },
      {
        "txt": "} private Object readResolve() { if (iChronology == null) { return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDateTime(iLocalMillis, iChronology.withUTC()); } return this; }"
      },
      {
        "txt": "public int size() { return 4; } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH:"
      },
      {
        "txt": "return chrono.dayOfMonth(); case MILLIS_OF_DAY: return chrono.millisOfDay(); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } } public int getValue(int index) { switch (index) { case YEAR:"
      },
      {
        "txt": "return getChronology().year().get(getLocalMillis()); case MONTH_OF_YEAR: return getChronology().monthOfYear().get(getLocalMillis()); case DAY_OF_MONTH: return getChronology().dayOfMonth().get(getLocalMillis()); case MILLIS_OF_DAY: return getChronology().millisOfDay().get(getLocalMillis()); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); }"
      },
      {
        "txt": "} public int get(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } return type.getField(getChronology()).get(getLocalMillis()); } public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false;"
      },
      {
        "txt": "} return type.getField(getChronology()).isSupported(); } public boolean isSupported(DurationFieldType type) { if (type == null) { return false; } return type.getField(getChronology()).isSupported(); } protected long getLocalMillis() {"
      },
      {
        "txt": "return iLocalMillis; } public Chronology getChronology() { return iChronology; } public boolean equals(Object partial) { if (this == partial) { return true; } if (partial instanceof LocalDateTime) {"
      },
      {
        "txt": "LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return iLocalMillis == other.iLocalMillis; } } return super.equals(partial); } public int compareTo(ReadablePartial partial) { if (this == partial) { return 0;"
      },
      {
        "txt": "} if (partial instanceof LocalDateTime) { LocalDateTime other = (LocalDateTime) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); }"
      },
      {
        "txt": "public DateTime toDateTime() { return toDateTime((DateTimeZone) null); } public DateTime toDateTime(DateTimeZone zone) { zone = DateTimeUtils.getZone(zone); Chronology chrono = iChronology.withZone(zone); return new DateTime( getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), chrono);"
      },
      {
        "txt": "} public LocalDate toLocalDate() { return new LocalDate(getLocalMillis(), getChronology()); } public LocalTime toLocalTime() { return new LocalTime(getLocalMillis(), getChronology()); } @SuppressWarnings(\"deprecation\") public Date toDate() { int dom = getDayOfMonth();"
      },
      {
        "txt": "Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); date.setTime(date.getTime() + getMillisOfSecond()); LocalDateTime check = LocalDateTime.fromDateFields(date); if (check.isBefore(this)) { while (check.isBefore(this)) { date.setTime(date.getTime() + 60000); check = LocalDateTime.fromDateFields(date); } while (check.isBefore(this) == false) {"
      },
      {
        "txt": "date.setTime(date.getTime() - 1000); check = LocalDateTime.fromDateFields(date); } date.setTime(date.getTime() + 1000); } else if (check.equals(this)) { Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); check = LocalDateTime.fromDateFields(earlier); if (check.equals(this)) { date = earlier; }"
      },
      {
        "txt": "} return date; } LocalDateTime withLocalMillis(long newMillis) { return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology())); } public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { Chronology chrono = getChronology(); long instant = getLocalMillis(); instant = chrono.year().set(instant, year);"
      },
      {
        "txt": "instant = chrono.monthOfYear().set(instant, monthOfYear); instant = chrono.dayOfMonth().set(instant, dayOfMonth); return withLocalMillis(instant); } public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { Chronology chrono = getChronology(); long instant = getLocalMillis(); instant = chrono.hourOfDay().set(instant, hourOfDay); instant = chrono.minuteOfHour().set(instant, minuteOfHour); instant = chrono.secondOfMinute().set(instant, secondOfMinute);"
      },
      {
        "txt": "instant = chrono.millisOfSecond().set(instant, millisOfSecond); return withLocalMillis(instant); } public LocalDateTime withFields(ReadablePartial partial) { if (partial == null) { return this; } return withLocalMillis(getChronology().set(partial, getLocalMillis())); } public LocalDateTime withField(DateTimeFieldType fieldType, int value) {"
      },
      {
        "txt": "if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); return withLocalMillis(instant); } public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); }"
      },
      {
        "txt": "if (amount == 0) { return this; } long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); return withLocalMillis(instant); } public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) { if (durationToAdd == null || scalar == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar); return withLocalMillis(instant); } public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getChronology().add(period, getLocalMillis(), scalar); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime plus(ReadableDuration duration) { return withDurationAdded(duration, 1); } public LocalDateTime plus(ReadablePeriod period) { return withPeriodAdded(period, 1); } public LocalDateTime plusYears(int years) { if (years == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().years().add(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime plusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().add(getLocalMillis(), months); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime plusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().add(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDateTime plusDays(int days) { if (days == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().days().add(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDateTime plusHours(int hours) { if (hours == 0) { return this; } long instant = getChronology().hours().add(getLocalMillis(), hours); return withLocalMillis(instant);"
      },
      {
        "txt": "} public LocalDateTime plusMinutes(int minutes) { if (minutes == 0) { return this; } long instant = getChronology().minutes().add(getLocalMillis(), minutes); return withLocalMillis(instant); } public LocalDateTime plusSeconds(int seconds) { if (seconds == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().seconds().add(getLocalMillis(), seconds); return withLocalMillis(instant); } public LocalDateTime plusMillis(int millis) { if (millis == 0) { return this; } long instant = getChronology().millis().add(getLocalMillis(), millis);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime minus(ReadableDuration duration) { return withDurationAdded(duration, -1); } public LocalDateTime minus(ReadablePeriod period) { return withPeriodAdded(period, -1); } public LocalDateTime minusYears(int years) { if (years == 0) {"
      },
      {
        "txt": "return this; } long instant = getChronology().years().subtract(getLocalMillis(), years); return withLocalMillis(instant); } public LocalDateTime minusMonths(int months) { if (months == 0) { return this; } long instant = getChronology().months().subtract(getLocalMillis(), months);"
      },
      {
        "txt": "return withLocalMillis(instant); } public LocalDateTime minusWeeks(int weeks) { if (weeks == 0) { return this; } long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); return withLocalMillis(instant); } public LocalDateTime minusDays(int days) {"
      },
      {
        "txt": "if (days == 0) { return this; } long instant = getChronology().days().subtract(getLocalMillis(), days); return withLocalMillis(instant); } public LocalDateTime minusHours(int hours) { if (hours == 0) { return this; }"
      },
      {
        "txt": "long instant = getChronology().hours().subtract(getLocalMillis(), hours); return withLocalMillis(instant); } public LocalDateTime minusMinutes(int minutes) { if (minutes == 0) { return this; } long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); return withLocalMillis(instant); }"
      },
      {
        "txt": "public LocalDateTime minusSeconds(int seconds) { if (seconds == 0) { return this; } long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); return withLocalMillis(instant); } public LocalDateTime minusMillis(int millis) { if (millis == 0) { return this;"
      },
      {
        "txt": "} long instant = getChronology().millis().subtract(getLocalMillis(), millis); return withLocalMillis(instant); } public Property property(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } if (isSupported(fieldType) == false) { throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");"
      },
      {
        "txt": "} return new Property(this, fieldType.getField(getChronology())); } public int getEra() { return getChronology().era().get(getLocalMillis()); } public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); } public int getYearOfEra() {"
      },
      {
        "txt": "return getChronology().yearOfEra().get(getLocalMillis()); } public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis()); } public int getYear() { return getChronology().year().get(getLocalMillis()); } public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis());"
      },
      {
        "txt": "} public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); } public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); } public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); }"
      },
      {
        "txt": "public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); } public int getDayOfWeek() { return getChronology().dayOfWeek().get(getLocalMillis()); } public int getHourOfDay() { return getChronology().hourOfDay().get(getLocalMillis()); } public int getMinuteOfHour() {"
      },
      {
        "txt": "return getChronology().minuteOfHour().get(getLocalMillis()); } public int getSecondOfMinute() { return getChronology().secondOfMinute().get(getLocalMillis()); } public int getMillisOfSecond() { return getChronology().millisOfSecond().get(getLocalMillis()); } public int getMillisOfDay() { return getChronology().millisOfDay().get(getLocalMillis());"
      },
      {
        "txt": "} public LocalDateTime withEra(int era) { return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); } public LocalDateTime withCenturyOfEra(int centuryOfEra) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); } public LocalDateTime withYearOfEra(int yearOfEra) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); }"
      },
      {
        "txt": "public LocalDateTime withYearOfCentury(int yearOfCentury) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); } public LocalDateTime withYear(int year) { return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); } public LocalDateTime withWeekyear(int weekyear) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); } public LocalDateTime withMonthOfYear(int monthOfYear) {"
      },
      {
        "txt": "return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); } public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); } public LocalDateTime withDayOfYear(int dayOfYear) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); } public LocalDateTime withDayOfMonth(int dayOfMonth) { return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));"
      },
      {
        "txt": "} public LocalDateTime withDayOfWeek(int dayOfWeek) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); } public LocalDateTime withHourOfDay(int hour) { return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); } public LocalDateTime withMinuteOfHour(int minute) { return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); }"
      },
      {
        "txt": "public LocalDateTime withSecondOfMinute(int second) { return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); } public LocalDateTime withMillisOfSecond(int millis) { return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); } public LocalDateTime withMillisOfDay(int millis) { return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); } public Property era() {"
      },
      {
        "txt": "return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra());"
      },
      {
        "txt": "} public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); }"
      },
      {
        "txt": "public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute());"
      },
      {
        "txt": "} public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this);"
      },
      {
        "txt": "} public String toString(String pattern) { if (pattern == null) { return toString(); } return DateTimeFormat.forPattern(pattern).print(this); } public String toString(String pattern, Locale locale) throws IllegalArgumentException { if (pattern == null) { return toString();"
      },
      {
        "txt": "} return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -358138762846288L; private transient LocalDateTime iInstant; private transient DateTimeField iField; Property(LocalDateTime instant, DateTimeField field) { super(); iInstant = instant;"
      },
      {
        "txt": "iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (LocalDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology());"
      },
      {
        "txt": "} public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getLocalMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); }"
      },
      {
        "txt": "public LocalDateTime getLocalDateTime() { return iInstant; } public LocalDateTime addToCopy(int value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDateTime addToCopy(long value) { return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); } public LocalDateTime addWrapFieldToCopy(int value) {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(int value) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); } public LocalDateTime setCopy(String text, Locale locale) { return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); } public LocalDateTime setCopy(String text) { return setCopy(text, null);"
      },
      {
        "txt": "} public LocalDateTime withMaximumValue() { return setCopy(getMaximumValue()); } public LocalDateTime withMinimumValue() { return setCopy(getMinimumValue()); } public LocalDateTime roundFloorCopy() { return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); }"
      },
      {
        "txt": "public LocalDateTime roundCeilingCopy() { return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfFloorCopy() { return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); } public LocalDateTime roundHalfCeilingCopy() { return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); } public LocalDateTime roundHalfEvenCopy() {"
      },
      {
        "txt": "return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); } }"
      }
    ]
  }
]