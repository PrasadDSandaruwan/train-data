[
  {
    "id": 2887,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 639,
    "end-bug-line": 639,
    "bug": "",
    "fix": "if (amount != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat;"
      },
      {
        "txt": "public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5;"
      },
      {
        "txt": "private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone);"
      },
      {
        "txt": "} public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());"
      },
      {
        "txt": "} public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); }"
      },
      {
        "txt": "public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) {"
      },
      {
        "txt": "super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology));"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute,"
      },
      {
        "txt": "int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode;"
      },
      {
        "txt": "} public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode);"
      },
      {
        "txt": "setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING:"
      },
      {
        "txt": "instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant);"
      },
      {
        "txt": "break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super"
      },
      {
        "txt": "} public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) {"
      },
      {
        "txt": "add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); }"
      },
      {
        "txt": "public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone());"
      },
      {
        "txt": "if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\");"
      },
      {
        "txt": "setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } <extra_id_0> } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years));"
      },
      {
        "txt": "public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) {"
      },
      {
        "txt": "setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks));"
      },
      {
        "txt": "} public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); }"
      },
      {
        "txt": "public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) {"
      },
      {
        "txt": "setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));"
      },
      {
        "txt": "} public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); }"
      },
      {
        "txt": "public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) {"
      },
      {
        "txt": "long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis);"
      },
      {
        "txt": "} public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) {"
      },
      {
        "txt": "int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); }"
      },
      {
        "txt": "setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant);"
      },
      {
        "txt": "} public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis("
      },
      {
        "txt": "year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");"
      },
      {
        "txt": "} return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear());"
      },
      {
        "txt": "} public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); }"
      },
      {
        "txt": "public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute());"
      },
      {
        "txt": "} public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); }"
      },
      {
        "txt": "public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this);"
      },
      {
        "txt": "} public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; }"
      },
      {
        "txt": "private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() {"
      },
      {
        "txt": "return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant;"
      },
      {
        "txt": "} public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2888,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 640,
    "end-bug-line": 640,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable;"
      },
      {
        "txt": "import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime"
      },
      {
        "txt": "extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField;"
      },
      {
        "txt": "private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); }"
      },
      {
        "txt": "public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); }"
      },
      {
        "txt": "public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) {"
      },
      {
        "txt": "super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology);"
      },
      {
        "txt": "} public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth,"
      },
      {
        "txt": "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond,"
      },
      {
        "txt": "Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; }"
      },
      {
        "txt": "public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis());"
      },
      {
        "txt": "} public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant);"
      },
      {
        "txt": "break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break;"
      },
      {
        "txt": "} super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super }"
      },
      {
        "txt": "public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1);"
      },
      {
        "txt": "} public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) {"
      },
      {
        "txt": "newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) {"
      },
      {
        "txt": "return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); }"
      },
      {
        "txt": "} public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); <extra_id_0> public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); }"
      },
      {
        "txt": "setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));"
      },
      {
        "txt": "} public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); }"
      },
      {
        "txt": "public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) {"
      },
      {
        "txt": "setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));"
      },
      {
        "txt": "} public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); }"
      },
      {
        "txt": "public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) {"
      },
      {
        "txt": "setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); }"
      },
      {
        "txt": "public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis);"
      },
      {
        "txt": "} public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); }"
      },
      {
        "txt": "public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); }"
      },
      {
        "txt": "return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury());"
      },
      {
        "txt": "} public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); }"
      },
      {
        "txt": "public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay());"
      },
      {
        "txt": "} public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); }"
      },
      {
        "txt": "public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() {"
      },
      {
        "txt": "try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); }"
      },
      {
        "txt": "public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException {"
      },
      {
        "txt": "oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField;"
      },
      {
        "txt": "} protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; }"
      },
      {
        "txt": "public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2889,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 660,
    "end-bug-line": 660,
    "bug": "",
    "fix": "if (years != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology;"
      },
      {
        "txt": "import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1;"
      },
      {
        "txt": "public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) {"
      },
      {
        "txt": "if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology);"
      },
      {
        "txt": "} @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super();"
      },
      {
        "txt": "} public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); }"
      },
      {
        "txt": "public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) {"
      },
      {
        "txt": "super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear,"
      },
      {
        "txt": "int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() {"
      },
      {
        "txt": "return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break;"
      },
      {
        "txt": "case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING:"
      },
      {
        "txt": "instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) {"
      },
      {
        "txt": "add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super }"
      },
      {
        "txt": "} public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super }"
      },
      {
        "txt": "} public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis);"
      },
      {
        "txt": "} public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\");"
      },
      {
        "txt": "setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { <extra_id_0> } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears));"
      },
      {
        "txt": "public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) {"
      },
      {
        "txt": "setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));"
      },
      {
        "txt": "} public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); }"
      },
      {
        "txt": "public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) {"
      },
      {
        "txt": "setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds));"
      },
      {
        "txt": "} public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); }"
      },
      {
        "txt": "public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) {"
      },
      {
        "txt": "instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology();"
      },
      {
        "txt": "long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);"
      },
      {
        "txt": "DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute,"
      },
      {
        "txt": "final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay,"
      },
      {
        "txt": "final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");"
      },
      {
        "txt": "} DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); }"
      },
      {
        "txt": "public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() {"
      },
      {
        "txt": "return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear());"
      },
      {
        "txt": "} public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); }"
      },
      {
        "txt": "public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond());"
      },
      {
        "txt": "} public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); }"
      },
      {
        "txt": "} @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) {"
      },
      {
        "txt": "super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject();"
      },
      {
        "txt": "DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() {"
      },
      {
        "txt": "return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2890,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 661,
    "end-bug-line": 661,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty;"
      },
      {
        "txt": "import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2;"
      },
      {
        "txt": "public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); }"
      },
      {
        "txt": "@FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); }"
      },
      {
        "txt": "public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) {"
      },
      {
        "txt": "super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone);"
      },
      {
        "txt": "} public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField;"
      },
      {
        "txt": "} public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);"
      },
      {
        "txt": "} iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR:"
      },
      {
        "txt": "instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant);"
      },
      {
        "txt": "break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super"
      },
      {
        "txt": "} public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar));"
      },
      {
        "txt": "} } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } }"
      },
      {
        "txt": "public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } }"
      },
      {
        "txt": "public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); }"
      },
      {
        "txt": "public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); }"
      },
      {
        "txt": "} public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); <extra_id_0> public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); }"
      },
      {
        "txt": "setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));"
      },
      {
        "txt": "} public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); }"
      },
      {
        "txt": "public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) {"
      },
      {
        "txt": "setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes));"
      },
      {
        "txt": "} public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); }"
      },
      {
        "txt": "public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) {"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis);"
      },
      {
        "txt": "} } setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);"
      },
      {
        "txt": "setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone();"
      },
      {
        "txt": "if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) {"
      },
      {
        "txt": "long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour,"
      },
      {
        "txt": "final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); }"
      },
      {
        "txt": "DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() {"
      },
      {
        "txt": "return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year());"
      },
      {
        "txt": "} public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); }"
      },
      {
        "txt": "public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay());"
      },
      {
        "txt": "} public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); }"
      },
      {
        "txt": "public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } }"
      },
      {
        "txt": "@ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super();"
      },
      {
        "txt": "iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject();"
      },
      {
        "txt": "iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology();"
      },
      {
        "txt": "} public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2891,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 681,
    "end-bug-line": 681,
    "bug": "",
    "fix": "if (weekyears != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale;"
      },
      {
        "txt": "import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime"
      },
      {
        "txt": "implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode;"
      },
      {
        "txt": "public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) {"
      },
      {
        "txt": "if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) {"
      },
      {
        "txt": "return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology);"
      },
      {
        "txt": "} public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); }"
      },
      {
        "txt": "public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) {"
      },
      {
        "txt": "setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); }"
      },
      {
        "txt": "public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break;"
      },
      {
        "txt": "case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; }"
      },
      {
        "txt": "super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) {"
      },
      {
        "txt": "add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); }"
      },
      {
        "txt": "public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone);"
      },
      {
        "txt": "Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return;"
      },
      {
        "txt": "} long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value));"
      },
      {
        "txt": "} public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); }"
      },
      {
        "txt": "setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { <extra_id_0> } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months));"
      },
      {
        "txt": "public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) {"
      },
      {
        "txt": "setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days));"
      },
      {
        "txt": "} public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); }"
      },
      {
        "txt": "public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) {"
      },
      {
        "txt": "setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));"
      },
      {
        "txt": "} public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) {"
      },
      {
        "txt": "ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate("
      },
      {
        "txt": "final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));"
      },
      {
        "txt": "} public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); }"
      },
      {
        "txt": "public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime("
      },
      {
        "txt": "final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant);"
      },
      {
        "txt": "} public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field);"
      },
      {
        "txt": "} public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); }"
      },
      {
        "txt": "public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth());"
      },
      {
        "txt": "} public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); }"
      },
      {
        "txt": "public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try {"
      },
      {
        "txt": "return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty {"
      },
      {
        "txt": "private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant);"
      },
      {
        "txt": "oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; }"
      },
      {
        "txt": "protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) {"
      },
      {
        "txt": "set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2892,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 682,
    "end-bug-line": 682,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString;"
      },
      {
        "txt": "import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() {"
      },
      {
        "txt": "return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime();"
      },
      {
        "txt": "} public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); }"
      },
      {
        "txt": "public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) {"
      },
      {
        "txt": "super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth,"
      },
      {
        "txt": "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR);"
      },
      {
        "txt": "} public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) {"
      },
      {
        "txt": "switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR:"
      },
      {
        "txt": "instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant);"
      },
      {
        "txt": "} public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1);"
      },
      {
        "txt": "} public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) {"
      },
      {
        "txt": "if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology();"
      },
      {
        "txt": "if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; }"
      },
      {
        "txt": "long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); }"
      },
      {
        "txt": "public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) {"
      },
      {
        "txt": "} public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); <extra_id_0> public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); }"
      },
      {
        "txt": "setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));"
      },
      {
        "txt": "} public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); }"
      },
      {
        "txt": "public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) {"
      },
      {
        "txt": "setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));"
      },
      {
        "txt": "} public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); }"
      },
      {
        "txt": "public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant;"
      },
      {
        "txt": "Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate( final int year,"
      },
      {
        "txt": "final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); }"
      },
      {
        "txt": "public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime("
      },
      {
        "txt": "final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year,"
      },
      {
        "txt": "final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); }"
      },
      {
        "txt": "public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); }"
      },
      {
        "txt": "public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear());"
      },
      {
        "txt": "} public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); }"
      },
      {
        "txt": "public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() {"
      },
      {
        "txt": "return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay());"
      },
      {
        "txt": "} public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone();"
      },
      {
        "txt": "} catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L;"
      },
      {
        "txt": "private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType());"
      },
      {
        "txt": "} private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() {"
      },
      {
        "txt": "return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null);"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } }"
      }
    ]
  },
  {
    "id": 2893,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 702,
    "end-bug-line": 702,
    "bug": "",
    "fix": "if (months != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException;"
      },
      {
        "txt": "import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils;"
      },
      {
        "txt": "import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3;"
      },
      {
        "txt": "public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\");"
      },
      {
        "txt": "} return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString"
      },
      {
        "txt": "public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) {"
      },
      {
        "txt": "super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone);"
      },
      {
        "txt": "} public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); }"
      },
      {
        "txt": "public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute,"
      },
      {
        "txt": "int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute,"
      },
      {
        "txt": "int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; }"
      },
      {
        "txt": "public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); }"
      },
      {
        "txt": "iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant);"
      },
      {
        "txt": "break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break;"
      },
      {
        "txt": "case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super }"
      },
      {
        "txt": "public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); }"
      },
      {
        "txt": "} public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) {"
      },
      {
        "txt": "super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) {"
      },
      {
        "txt": "newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) {"
      },
      {
        "txt": "if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount));"
      },
      {
        "txt": "} public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); }"
      },
      {
        "txt": "setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { <extra_id_0> } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks));"
      },
      {
        "txt": "public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) {"
      },
      {
        "txt": "setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours));"
      },
      {
        "txt": "} public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); }"
      },
      {
        "txt": "public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) {"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));"
      },
      {
        "txt": "} public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); }"
      },
      {
        "txt": "} setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight);"
      },
      {
        "txt": "} public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) {"
      },
      {
        "txt": "instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis("
      },
      {
        "txt": "getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute,"
      },
      {
        "txt": "final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology());"
      },
      {
        "txt": "if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra());"
      },
      {
        "txt": "} public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); }"
      },
      {
        "txt": "public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay());"
      },
      {
        "txt": "} public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); }"
      },
      {
        "txt": "public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() {"
      },
      {
        "txt": "return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString"
      },
      {
        "txt": "public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant;"
      },
      {
        "txt": "iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology());"
      },
      {
        "txt": "} public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); }"
      },
      {
        "txt": "public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) {"
      },
      {
        "txt": "iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2894,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 703,
    "end-bug-line": 703,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream;"
      },
      {
        "txt": "import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter;"
      },
      {
        "txt": "import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4;"
      },
      {
        "txt": "public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); }"
      },
      {
        "txt": "return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) {"
      },
      {
        "txt": "return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone);"
      },
      {
        "txt": "} public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); }"
      },
      {
        "txt": "public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) {"
      },
      {
        "txt": "super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond,"
      },
      {
        "txt": "DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() {"
      },
      {
        "txt": "return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field);"
      },
      {
        "txt": "iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break;"
      },
      {
        "txt": "case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN:"
      },
      {
        "txt": "instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) {"
      },
      {
        "txt": "setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } }"
      },
      {
        "txt": "public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology);"
      },
      {
        "txt": "} public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone);"
      },
      {
        "txt": "DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); }"
      },
      {
        "txt": "public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) {"
      },
      {
        "txt": "} public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); <extra_id_0> public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); }"
      },
      {
        "txt": "setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));"
      },
      {
        "txt": "} public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); }"
      },
      {
        "txt": "public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) {"
      },
      {
        "txt": "setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));"
      },
      {
        "txt": "} public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); }"
      },
      {
        "txt": "public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } }"
      },
      {
        "txt": "setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); }"
      },
      {
        "txt": "public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);"
      },
      {
        "txt": "} setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) {"
      },
      {
        "txt": "long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); }"
      },
      {
        "txt": "public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() {"
      },
      {
        "txt": "return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear());"
      },
      {
        "txt": "} public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); }"
      },
      {
        "txt": "public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() {"
      },
      {
        "txt": "return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone();"
      },
      {
        "txt": "} public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() {"
      },
      {
        "txt": "return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field;"
      },
      {
        "txt": "} private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); }"
      },
      {
        "txt": "public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() {"
      },
      {
        "txt": "return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2895,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 723,
    "end-bug-line": 723,
    "bug": "",
    "fix": "if (weeks != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString;"
      },
      {
        "txt": "import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L;"
      },
      {
        "txt": "public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime();"
      },
      {
        "txt": "} public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\");"
      },
      {
        "txt": "} return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); }"
      },
      {
        "txt": "public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) {"
      },
      {
        "txt": "super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null);"
      },
      {
        "txt": "} public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear,"
      },
      {
        "txt": "int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear,"
      },
      {
        "txt": "int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);"
      },
      {
        "txt": "} public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); }"
      },
      {
        "txt": "public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) {"
      },
      {
        "txt": "case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant);"
      },
      {
        "txt": "break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); }"
      },
      {
        "txt": "public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); }"
      },
      {
        "txt": "public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) {"
      },
      {
        "txt": "setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) {"
      },
      {
        "txt": "setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis());"
      },
      {
        "txt": "setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) {"
      },
      {
        "txt": "if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years));"
      },
      {
        "txt": "} public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); }"
      },
      {
        "txt": "setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { <extra_id_0> } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));"
      },
      {
        "txt": "public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) {"
      },
      {
        "txt": "setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));"
      },
      {
        "txt": "} public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); }"
      },
      {
        "txt": "public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) {"
      },
      {
        "txt": "setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology());"
      },
      {
        "txt": "DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate( final int year, final int monthOfYear,"
      },
      {
        "txt": "final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) {"
      },
      {
        "txt": "long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour,"
      },
      {
        "txt": "final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear,"
      },
      {
        "txt": "final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) {"
      },
      {
        "txt": "if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() {"
      },
      {
        "txt": "return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra());"
      },
      {
        "txt": "} public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); }"
      },
      {
        "txt": "public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour());"
      },
      {
        "txt": "} public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); }"
      },
      {
        "txt": "public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) {"
      },
      {
        "txt": "throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant;"
      },
      {
        "txt": "private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); }"
      },
      {
        "txt": "private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis();"
      },
      {
        "txt": "} protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2896,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 724,
    "end-bug-line": 724,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime;"
      },
      {
        "txt": "import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0;"
      },
      {
        "txt": "public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); }"
      },
      {
        "txt": "public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); }"
      },
      {
        "txt": "return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() {"
      },
      {
        "txt": "super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant);"
      },
      {
        "txt": "} public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); }"
      },
      {
        "txt": "public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); }"
      },
      {
        "txt": "public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) {"
      },
      {
        "txt": "if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE:"
      },
      {
        "txt": "break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break;"
      },
      {
        "txt": "case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) {"
      },
      {
        "txt": "long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) {"
      },
      {
        "txt": "if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super"
      },
      {
        "txt": "} } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super"
      },
      {
        "txt": "} } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super"
      },
      {
        "txt": "setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); }"
      },
      {
        "txt": "public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) {"
      },
      {
        "txt": "} public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); <extra_id_0> public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); }"
      },
      {
        "txt": "setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));"
      },
      {
        "txt": "} public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); }"
      },
      {
        "txt": "public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) {"
      },
      {
        "txt": "setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis));"
      },
      {
        "txt": "} public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone();"
      },
      {
        "txt": "if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) {"
      },
      {
        "txt": "Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour,"
      },
      {
        "txt": "final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth,"
      },
      {
        "txt": "final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era());"
      },
      {
        "txt": "} public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); }"
      },
      {
        "txt": "public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() {"
      },
      {
        "txt": "return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek());"
      },
      {
        "txt": "} public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); }"
      },
      {
        "txt": "public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() {"
      },
      {
        "txt": "return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\");"
      },
      {
        "txt": "} } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField;"
      },
      {
        "txt": "Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {"
      },
      {
        "txt": "iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); }"
      },
      {
        "txt": "protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; }"
      }
    ]
  },
  {
    "id": 2897,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 764,
    "end-bug-line": 764,
    "bug": "",
    "fix": "if (days != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology;"
      },
      {
        "txt": "import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1;"
      },
      {
        "txt": "public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) {"
      },
      {
        "txt": "if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology);"
      },
      {
        "txt": "} @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super();"
      },
      {
        "txt": "} public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); }"
      },
      {
        "txt": "public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) {"
      },
      {
        "txt": "super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay,"
      },
      {
        "txt": "int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear,"
      },
      {
        "txt": "int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() {"
      },
      {
        "txt": "return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break;"
      },
      {
        "txt": "case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING:"
      },
      {
        "txt": "instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) {"
      },
      {
        "txt": "add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super }"
      },
      {
        "txt": "} public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super }"
      },
      {
        "txt": "} public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis);"
      },
      {
        "txt": "} public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\");"
      },
      {
        "txt": "} setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) {"
      },
      {
        "txt": "setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months));"
      },
      {
        "txt": "} public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); }"
      },
      {
        "txt": "setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { <extra_id_0> } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours));"
      },
      {
        "txt": "public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) {"
      },
      {
        "txt": "setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds));"
      },
      {
        "txt": "} public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); }"
      },
      {
        "txt": "public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) {"
      },
      {
        "txt": "instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology();"
      },
      {
        "txt": "long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);"
      },
      {
        "txt": "DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute,"
      },
      {
        "txt": "final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay,"
      },
      {
        "txt": "final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");"
      },
      {
        "txt": "} DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); }"
      },
      {
        "txt": "public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() {"
      },
      {
        "txt": "return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear());"
      },
      {
        "txt": "} public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); }"
      },
      {
        "txt": "public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond());"
      },
      {
        "txt": "} public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); }"
      },
      {
        "txt": "} @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) {"
      },
      {
        "txt": "super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject();"
      },
      {
        "txt": "DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() {"
      },
      {
        "txt": "return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2898,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 765,
    "end-bug-line": 765,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty;"
      },
      {
        "txt": "import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2;"
      },
      {
        "txt": "public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); }"
      },
      {
        "txt": "@FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); }"
      },
      {
        "txt": "public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) {"
      },
      {
        "txt": "super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone);"
      },
      {
        "txt": "} public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField;"
      },
      {
        "txt": "} public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);"
      },
      {
        "txt": "} iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR:"
      },
      {
        "txt": "instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant);"
      },
      {
        "txt": "break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super"
      },
      {
        "txt": "} public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar));"
      },
      {
        "txt": "} } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } }"
      },
      {
        "txt": "public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } }"
      },
      {
        "txt": "public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); }"
      },
      {
        "txt": "public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); }"
      },
      {
        "txt": "setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear));"
      },
      {
        "txt": "} public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); }"
      },
      {
        "txt": "public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) {"
      },
      {
        "txt": "} public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); <extra_id_0> public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); }"
      },
      {
        "txt": "setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes));"
      },
      {
        "txt": "} public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); }"
      },
      {
        "txt": "public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) {"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis);"
      },
      {
        "txt": "} } setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);"
      },
      {
        "txt": "setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone();"
      },
      {
        "txt": "if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) {"
      },
      {
        "txt": "long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour,"
      },
      {
        "txt": "final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); }"
      },
      {
        "txt": "DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() {"
      },
      {
        "txt": "return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year());"
      },
      {
        "txt": "} public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); }"
      },
      {
        "txt": "public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay());"
      },
      {
        "txt": "} public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); }"
      },
      {
        "txt": "public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } }"
      },
      {
        "txt": "@ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super();"
      },
      {
        "txt": "iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject();"
      },
      {
        "txt": "iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology();"
      },
      {
        "txt": "} public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2899,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 785,
    "end-bug-line": 785,
    "bug": "",
    "fix": "if (hours != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale;"
      },
      {
        "txt": "import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime"
      },
      {
        "txt": "implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode;"
      },
      {
        "txt": "public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) {"
      },
      {
        "txt": "if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) {"
      },
      {
        "txt": "return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology);"
      },
      {
        "txt": "} public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); }"
      },
      {
        "txt": "public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) {"
      },
      {
        "txt": "setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); }"
      },
      {
        "txt": "public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break;"
      },
      {
        "txt": "case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; }"
      },
      {
        "txt": "super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) {"
      },
      {
        "txt": "add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); }"
      },
      {
        "txt": "public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone);"
      },
      {
        "txt": "Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return;"
      },
      {
        "txt": "} long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value));"
      },
      {
        "txt": "} public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); }"
      },
      {
        "txt": "public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) {"
      },
      {
        "txt": "setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks));"
      },
      {
        "txt": "} public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); }"
      },
      {
        "txt": "setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { <extra_id_0> } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));"
      },
      {
        "txt": "public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) {"
      },
      {
        "txt": "setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));"
      },
      {
        "txt": "} public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) {"
      },
      {
        "txt": "ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate("
      },
      {
        "txt": "final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));"
      },
      {
        "txt": "} public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); }"
      },
      {
        "txt": "public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime("
      },
      {
        "txt": "final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant);"
      },
      {
        "txt": "} public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field);"
      },
      {
        "txt": "} public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); }"
      },
      {
        "txt": "public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth());"
      },
      {
        "txt": "} public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); }"
      },
      {
        "txt": "public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try {"
      },
      {
        "txt": "return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty {"
      },
      {
        "txt": "private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant);"
      },
      {
        "txt": "oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; }"
      },
      {
        "txt": "protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) {"
      },
      {
        "txt": "set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2900,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 786,
    "end-bug-line": 786,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString;"
      },
      {
        "txt": "import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() {"
      },
      {
        "txt": "return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) {"
      },
      {
        "txt": "throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime();"
      },
      {
        "txt": "} public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology); }"
      },
      {
        "txt": "public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) {"
      },
      {
        "txt": "super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year,"
      },
      {
        "txt": "int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth,"
      },
      {
        "txt": "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR);"
      },
      {
        "txt": "} public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) {"
      },
      {
        "txt": "switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR:"
      },
      {
        "txt": "instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant);"
      },
      {
        "txt": "} public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1);"
      },
      {
        "txt": "} public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) {"
      },
      {
        "txt": "if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology();"
      },
      {
        "txt": "if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; }"
      },
      {
        "txt": "long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); }"
      },
      {
        "txt": "public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) {"
      },
      {
        "txt": "setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));"
      },
      {
        "txt": "} public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); }"
      },
      {
        "txt": "public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) {"
      },
      {
        "txt": "} public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); <extra_id_0> public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); }"
      },
      {
        "txt": "setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));"
      },
      {
        "txt": "} public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); }"
      },
      {
        "txt": "public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant;"
      },
      {
        "txt": "Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate( final int year,"
      },
      {
        "txt": "final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); }"
      },
      {
        "txt": "public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); } public void setTime("
      },
      {
        "txt": "final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime( final int year,"
      },
      {
        "txt": "final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); }"
      },
      {
        "txt": "public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); }"
      },
      {
        "txt": "public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear());"
      },
      {
        "txt": "} public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); }"
      },
      {
        "txt": "public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() {"
      },
      {
        "txt": "return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay());"
      },
      {
        "txt": "} public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try { return super.clone();"
      },
      {
        "txt": "} catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L;"
      },
      {
        "txt": "private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType());"
      },
      {
        "txt": "} private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; } protected long getMillis() {"
      },
      {
        "txt": "return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) { set(text, null);"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } }"
      }
    ]
  },
  {
    "id": 2901,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 816,
    "end-bug-line": 816,
    "bug": "",
    "fix": "if (minutes != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable;"
      },
      {
        "txt": "import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime"
      },
      {
        "txt": "extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField;"
      },
      {
        "txt": "private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); }"
      },
      {
        "txt": "public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); }"
      },
      {
        "txt": "public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) {"
      },
      {
        "txt": "super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology);"
      },
      {
        "txt": "} public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth,"
      },
      {
        "txt": "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond,"
      },
      {
        "txt": "Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; }"
      },
      {
        "txt": "public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis());"
      },
      {
        "txt": "} public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant);"
      },
      {
        "txt": "break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break;"
      },
      {
        "txt": "} super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super }"
      },
      {
        "txt": "public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1);"
      },
      {
        "txt": "} public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) {"
      },
      {
        "txt": "newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) {"
      },
      {
        "txt": "return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); }"
      },
      {
        "txt": "setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year));"
      },
      {
        "txt": "} public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); }"
      },
      {
        "txt": "public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) {"
      },
      {
        "txt": "setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));"
      },
      {
        "txt": "} public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); }"
      },
      {
        "txt": "setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { <extra_id_0> } public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));"
      },
      {
        "txt": "public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) {"
      },
      {
        "txt": "setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); }"
      },
      {
        "txt": "public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis);"
      },
      {
        "txt": "} public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); }"
      },
      {
        "txt": "public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); }"
      },
      {
        "txt": "return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury());"
      },
      {
        "txt": "} public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); }"
      },
      {
        "txt": "public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay());"
      },
      {
        "txt": "} public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); }"
      },
      {
        "txt": "public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() {"
      },
      {
        "txt": "try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); }"
      },
      {
        "txt": "public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException {"
      },
      {
        "txt": "oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField;"
      },
      {
        "txt": "} protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; }"
      },
      {
        "txt": "public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2902,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 817,
    "end-bug-line": 817,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale;"
      },
      {
        "txt": "import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime"
      },
      {
        "txt": "implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode;"
      },
      {
        "txt": "public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) {"
      },
      {
        "txt": "if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) {"
      },
      {
        "txt": "return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) { super(chronology);"
      },
      {
        "txt": "} public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); }"
      },
      {
        "txt": "public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime("
      },
      {
        "txt": "int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; } public void setRounding(DateTimeField field) {"
      },
      {
        "txt": "setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); }"
      },
      {
        "txt": "public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break;"
      },
      {
        "txt": "case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break; }"
      },
      {
        "txt": "super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) {"
      },
      {
        "txt": "add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1); }"
      },
      {
        "txt": "public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone);"
      },
      {
        "txt": "Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return;"
      },
      {
        "txt": "} long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value));"
      },
      {
        "txt": "} public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); }"
      },
      {
        "txt": "public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) {"
      },
      {
        "txt": "setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks));"
      },
      {
        "txt": "} public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); }"
      },
      {
        "txt": "public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) {"
      },
      {
        "txt": "} public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); <extra_id_0> public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); }"
      },
      {
        "txt": "setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));"
      },
      {
        "txt": "} public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) {"
      },
      {
        "txt": "ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); } public void setDate("
      },
      {
        "txt": "final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));"
      },
      {
        "txt": "} public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis); }"
      },
      {
        "txt": "public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public void setDateTime("
      },
      {
        "txt": "final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant);"
      },
      {
        "txt": "} public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field);"
      },
      {
        "txt": "} public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); }"
      },
      {
        "txt": "public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); } public Property monthOfYear() {"
      },
      {
        "txt": "return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth());"
      },
      {
        "txt": "} public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); }"
      },
      {
        "txt": "public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() { try {"
      },
      {
        "txt": "return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty {"
      },
      {
        "txt": "private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant);"
      },
      {
        "txt": "oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField; }"
      },
      {
        "txt": "protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; } public MutableDateTime add(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; } public MutableDateTime set(String text) {"
      },
      {
        "txt": "set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfEven() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2903,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 847,
    "end-bug-line": 847,
    "bug": "",
    "fix": "if (seconds != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat;"
      },
      {
        "txt": "public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5;"
      },
      {
        "txt": "private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone);"
      },
      {
        "txt": "} public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());"
      },
      {
        "txt": "} public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); }"
      },
      {
        "txt": "public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) {"
      },
      {
        "txt": "super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology));"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute,"
      },
      {
        "txt": "int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode;"
      },
      {
        "txt": "} public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode);"
      },
      {
        "txt": "setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING:"
      },
      {
        "txt": "instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant);"
      },
      {
        "txt": "break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super"
      },
      {
        "txt": "} public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) {"
      },
      {
        "txt": "add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); }"
      },
      {
        "txt": "public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone());"
      },
      {
        "txt": "if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\");"
      },
      {
        "txt": "} setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) {"
      },
      {
        "txt": "setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears));"
      },
      {
        "txt": "} public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); }"
      },
      {
        "txt": "public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) {"
      },
      {
        "txt": "setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours));"
      },
      {
        "txt": "} public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); }"
      },
      {
        "txt": "setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { <extra_id_0> } public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));"
      },
      {
        "txt": "public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) {"
      },
      {
        "txt": "long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis);"
      },
      {
        "txt": "} public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) {"
      },
      {
        "txt": "int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); }"
      },
      {
        "txt": "setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant);"
      },
      {
        "txt": "} public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis("
      },
      {
        "txt": "year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");"
      },
      {
        "txt": "} return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear());"
      },
      {
        "txt": "} public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); }"
      },
      {
        "txt": "public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute());"
      },
      {
        "txt": "} public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); }"
      },
      {
        "txt": "public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this);"
      },
      {
        "txt": "} public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; }"
      },
      {
        "txt": "private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() {"
      },
      {
        "txt": "return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant;"
      },
      {
        "txt": "} public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2904,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 848,
    "end-bug-line": 848,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable;"
      },
      {
        "txt": "import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime"
      },
      {
        "txt": "extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField;"
      },
      {
        "txt": "private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone); }"
      },
      {
        "txt": "public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); }"
      },
      {
        "txt": "public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); } public MutableDateTime(Chronology chronology) {"
      },
      {
        "txt": "super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology);"
      },
      {
        "txt": "} public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology)); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }"
      },
      {
        "txt": "public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth,"
      },
      {
        "txt": "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond,"
      },
      {
        "txt": "Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode; }"
      },
      {
        "txt": "public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis());"
      },
      {
        "txt": "} public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant);"
      },
      {
        "txt": "break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant); break;"
      },
      {
        "txt": "} super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super }"
      },
      {
        "txt": "public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) { add(period, 1);"
      },
      {
        "txt": "} public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); } public void setZone(DateTimeZone newZone) {"
      },
      {
        "txt": "newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) {"
      },
      {
        "txt": "return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); }"
      },
      {
        "txt": "setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year));"
      },
      {
        "txt": "} public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears)); }"
      },
      {
        "txt": "public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); } public void addWeeks(final int weeks) {"
      },
      {
        "txt": "setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));"
      },
      {
        "txt": "} public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours)); }"
      },
      {
        "txt": "public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); } public void setSecondOfDay(final int secondOfDay) {"
      },
      {
        "txt": "} public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); <extra_id_0> public void setMillisOfDay(final int millisOfDay) { setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); }"
      },
      {
        "txt": "setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis); }"
      },
      {
        "txt": "public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); } setTime(instantMillis);"
      },
      {
        "txt": "} public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); }"
      },
      {
        "txt": "public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); }"
      },
      {
        "txt": "return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury());"
      },
      {
        "txt": "} public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear()); }"
      },
      {
        "txt": "public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); } public Property dayOfMonth() {"
      },
      {
        "txt": "return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay());"
      },
      {
        "txt": "} public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute()); }"
      },
      {
        "txt": "public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); } public Object clone() {"
      },
      {
        "txt": "try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this); }"
      },
      {
        "txt": "public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; } private void writeObject(ObjectOutputStream oos) throws IOException {"
      },
      {
        "txt": "oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() { return iField;"
      },
      {
        "txt": "} protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant; }"
      },
      {
        "txt": "public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2905,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 880,
    "end-bug-line": 880,
    "bug": "",
    "fix": "if (millis != 0) {",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream;"
      },
      {
        "txt": "import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter;"
      },
      {
        "txt": "import org.joda.time.format.ISODateTimeFormat; public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4;"
      },
      {
        "txt": "public static final int ROUND_HALF_EVEN = 5; private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); }"
      },
      {
        "txt": "return new MutableDateTime(zone); } public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) {"
      },
      {
        "txt": "return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); } public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone);"
      },
      {
        "txt": "} public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); }"
      },
      {
        "txt": "public MutableDateTime(long instant, Chronology chronology) { super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) {"
      },
      {
        "txt": "super(instant, DateTimeUtils.getChronology(chronology)); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond,"
      },
      {
        "txt": "DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() {"
      },
      {
        "txt": "return iRoundingMode; } public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field);"
      },
      {
        "txt": "iRoundingMode = (field == null ? ROUND_NONE : mode); setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break;"
      },
      {
        "txt": "case ROUND_CEILING: instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN:"
      },
      {
        "txt": "instant = iRoundingField.roundHalfEven(instant); break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) {"
      },
      {
        "txt": "setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super } public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } }"
      },
      {
        "txt": "public void add(ReadablePeriod period) { add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology);"
      },
      {
        "txt": "} public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone);"
      },
      {
        "txt": "DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); }"
      },
      {
        "txt": "public void setYear(final int year) { setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) {"
      },
      {
        "txt": "setMillis(getChronology().weekyears().add(getMillis(), weekyears)); } public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));"
      },
      {
        "txt": "} public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); }"
      },
      {
        "txt": "public void setDayOfWeek(final int dayOfWeek) { setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) {"
      },
      {
        "txt": "setMillis(getChronology().hours().add(getMillis(), hours)); } public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes));"
      },
      {
        "txt": "} public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); }"
      },
      {
        "txt": "setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { <extra_id_0> } public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant);"
      },
      {
        "txt": "public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } }"
      },
      {
        "txt": "setDate(instantMillis); } public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); }"
      },
      {
        "txt": "public void setTime(final long millis) { int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);"
      },
      {
        "txt": "} setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "setMillis(instant); } public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) {"
      },
      {
        "txt": "long instant = getChronology().getDateTimeMillis( year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\"); } return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); }"
      },
      {
        "txt": "public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() {"
      },
      {
        "txt": "return new Property(this, getChronology().weekyear()); } public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear());"
      },
      {
        "txt": "} public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); }"
      },
      {
        "txt": "public Property minuteOfDay() { return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() {"
      },
      {
        "txt": "return new Property(this, getChronology().secondOfMinute()); } public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone();"
      },
      {
        "txt": "} public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() {"
      },
      {
        "txt": "return ISODateTimeFormat.dateTime().print(this); } public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field;"
      },
      {
        "txt": "} private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); }"
      },
      {
        "txt": "public DateTimeField getField() { return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() {"
      },
      {
        "txt": "return iInstant; } public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime addWrapField(int value) { iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; }"
      },
      {
        "txt": "public MutableDateTime roundCeiling() { iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));"
      },
      {
        "txt": "return iInstant; } public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  },
  {
    "id": 2906,
    "file_path": "src/main/java/org/joda/time/MutableDateTime.java",
    "start-bug-line": 881,
    "end-bug-line": 881,
    "bug": "",
    "fix": "}",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.Serializable; import java.util.Locale; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.base.BaseDateTime; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractReadableInstantFieldProperty; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.ISODateTimeFormat;"
      },
      {
        "txt": "public class MutableDateTime extends BaseDateTime implements ReadWritableDateTime, Cloneable, Serializable { private static final long serialVersionUID = 2852608688135209575L; public static final int ROUND_NONE = 0; public static final int ROUND_FLOOR = 1; public static final int ROUND_CEILING = 2; public static final int ROUND_HALF_FLOOR = 3; public static final int ROUND_HALF_CEILING = 4; public static final int ROUND_HALF_EVEN = 5;"
      },
      {
        "txt": "private DateTimeField iRoundingField; private int iRoundingMode; public static MutableDateTime now() { return new MutableDateTime(); } public static MutableDateTime now(DateTimeZone zone) { if (zone == null) { throw new NullPointerException(\"Zone must not be null\"); } return new MutableDateTime(zone);"
      },
      {
        "txt": "} public static MutableDateTime now(Chronology chronology) { if (chronology == null) { throw new NullPointerException(\"Chronology must not be null\"); } return new MutableDateTime(chronology); } @FromString public static MutableDateTime parse(String str) { return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed());"
      },
      {
        "txt": "} public static MutableDateTime parse(String str, DateTimeFormatter formatter) { return formatter.parseDateTime(str).toMutableDateTime(); } public MutableDateTime() { super(); } public MutableDateTime(DateTimeZone zone) { super(zone); }"
      },
      {
        "txt": "public MutableDateTime(Chronology chronology) { super(chronology); } public MutableDateTime(long instant) { super(instant); } public MutableDateTime(long instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(long instant, Chronology chronology) {"
      },
      {
        "txt": "super(instant, chronology); } public MutableDateTime(Object instant) { super(instant, (Chronology) null); } public MutableDateTime(Object instant, DateTimeZone zone) { super(instant, zone); } public MutableDateTime(Object instant, Chronology chronology) { super(instant, DateTimeUtils.getChronology(chronology));"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"
      },
      {
        "txt": "} public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) {"
      },
      {
        "txt": "super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); } public MutableDateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute,"
      },
      {
        "txt": "int millisOfSecond, Chronology chronology) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); } public DateTimeField getRoundingField() { return iRoundingField; } public int getRoundingMode() { return iRoundingMode;"
      },
      {
        "txt": "} public void setRounding(DateTimeField field) { setRounding(field, MutableDateTime.ROUND_FLOOR); } public void setRounding(DateTimeField field, int mode) { if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) { throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode); } iRoundingField = (mode == ROUND_NONE ? null : field); iRoundingMode = (field == null ? ROUND_NONE : mode);"
      },
      {
        "txt": "setMillis(getMillis()); } public void setMillis(long instant) { switch (iRoundingMode) { case ROUND_NONE: break; case ROUND_FLOOR: instant = iRoundingField.roundFloor(instant); break; case ROUND_CEILING:"
      },
      {
        "txt": "instant = iRoundingField.roundCeiling(instant); break; case ROUND_HALF_FLOOR: instant = iRoundingField.roundHalfFloor(instant); break; case ROUND_HALF_CEILING: instant = iRoundingField.roundHalfCeiling(instant); break; case ROUND_HALF_EVEN: instant = iRoundingField.roundHalfEven(instant);"
      },
      {
        "txt": "break; } super.setMillis(instant); } public void setMillis(ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); setMillis(instantMillis); // set via this class not super } public void add(long duration) { setMillis(FieldUtils.safeAdd(getMillis(), duration)); // set via this class not super"
      },
      {
        "txt": "} public void add(ReadableDuration duration) { add(duration, 1); } public void add(ReadableDuration duration, int scalar) { if (duration != null) { add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); } } public void add(ReadablePeriod period) {"
      },
      {
        "txt": "add(period, 1); } public void add(ReadablePeriod period, int scalar) { if (period != null) { setMillis(getChronology().add(period, getMillis(), scalar)); // set via this class not super } } public void setChronology(Chronology chronology) { super.setChronology(chronology); }"
      },
      {
        "txt": "public void setZone(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); Chronology chrono = getChronology(); if (chrono.getZone() != newZone) { setChronology(chrono.withZone(newZone)); // set via this class not super } } public void setZoneRetainFields(DateTimeZone newZone) { newZone = DateTimeUtils.getZone(newZone); DateTimeZone originalZone = DateTimeUtils.getZone(getZone());"
      },
      {
        "txt": "if (newZone == originalZone) { return; } long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); setChronology(getChronology().withZone(newZone)); // set via this class not super setMillis(millis); } public void set(DateTimeFieldType type, int value) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\");"
      },
      {
        "txt": "} setMillis(type.getField(getChronology()).set(getMillis(), value)); } public void add(DurationFieldType type, int amount) { if (type == null) { throw new IllegalArgumentException(\"Field must not be null\"); } setMillis(type.getField(getChronology()).add(getMillis(), amount)); } public void setYear(final int year) {"
      },
      {
        "txt": "setMillis(getChronology().year().set(getMillis(), year)); } public void addYears(final int years) { setMillis(getChronology().years().add(getMillis(), years)); } public void setWeekyear(final int weekyear) { setMillis(getChronology().weekyear().set(getMillis(), weekyear)); } public void addWeekyears(final int weekyears) { setMillis(getChronology().weekyears().add(getMillis(), weekyears));"
      },
      {
        "txt": "} public void setMonthOfYear(final int monthOfYear) { setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); } public void addMonths(final int months) { setMillis(getChronology().months().add(getMillis(), months)); } public void setWeekOfWeekyear(final int weekOfWeekyear) { setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); }"
      },
      {
        "txt": "public void addWeeks(final int weeks) { setMillis(getChronology().weeks().add(getMillis(), weeks)); } public void setDayOfYear(final int dayOfYear) { setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); } public void setDayOfMonth(final int dayOfMonth) { setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); } public void setDayOfWeek(final int dayOfWeek) {"
      },
      {
        "txt": "setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); } public void addDays(final int days) { setMillis(getChronology().days().add(getMillis(), days)); } public void setHourOfDay(final int hourOfDay) { setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay)); } public void addHours(final int hours) { setMillis(getChronology().hours().add(getMillis(), hours));"
      },
      {
        "txt": "} public void setMinuteOfDay(final int minuteOfDay) { setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); } public void setMinuteOfHour(final int minuteOfHour) { setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour)); } public void addMinutes(final int minutes) { setMillis(getChronology().minutes().add(getMillis(), minutes)); }"
      },
      {
        "txt": "public void setSecondOfDay(final int secondOfDay) { setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); } public void setSecondOfMinute(final int secondOfMinute) { setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute)); } public void addSeconds(final int seconds) { setMillis(getChronology().seconds().add(getMillis(), seconds)); } public void setMillisOfDay(final int millisOfDay) {"
      },
      {
        "txt": "} public void setMillisOfSecond(final int millisOfSecond) { setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); } public void addMillis(final int millis) { setMillis(getChronology().millis().add(getMillis(), millis)); <extra_id_0> public void setDate(final long instant) { setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); } public void setDate(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) {"
      },
      {
        "txt": "long instantMillis = DateTimeUtils.getInstantMillis(instant); if (instant instanceof ReadableDateTime) { ReadableDateTime rdt = (ReadableDateTime) instant; Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); } } setDate(instantMillis);"
      },
      {
        "txt": "} public void setDate( final int year, final int monthOfYear, final int dayOfMonth) { Chronology c = getChronology(); long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); setDate(instantMidnight); } public void setTime(final long millis) {"
      },
      {
        "txt": "int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); } public void setTime(final ReadableInstant instant) { long instantMillis = DateTimeUtils.getInstantMillis(instant); Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); DateTimeZone zone = instantChrono.getZone(); if (zone != null) { instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); }"
      },
      {
        "txt": "setTime(instantMillis); } public void setTime( final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis( getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant);"
      },
      {
        "txt": "} public void setDateTime( final int year, final int monthOfYear, final int dayOfMonth, final int hourOfDay, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { long instant = getChronology().getDateTimeMillis("
      },
      {
        "txt": "year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); setMillis(instant); } public Property property(DateTimeFieldType type) { if (type == null) { throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\"); } DateTimeField field = type.getField(getChronology()); if (field.isSupported() == false) { throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");"
      },
      {
        "txt": "} return new Property(this, field); } public Property era() { return new Property(this, getChronology().era()); } public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); } public Property yearOfCentury() {"
      },
      {
        "txt": "return new Property(this, getChronology().yearOfCentury()); } public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); } public Property year() { return new Property(this, getChronology().year()); } public Property weekyear() { return new Property(this, getChronology().weekyear());"
      },
      {
        "txt": "} public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); } public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); } public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); }"
      },
      {
        "txt": "public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); } public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); } public Property hourOfDay() { return new Property(this, getChronology().hourOfDay()); } public Property minuteOfDay() {"
      },
      {
        "txt": "return new Property(this, getChronology().minuteOfDay()); } public Property minuteOfHour() { return new Property(this, getChronology().minuteOfHour()); } public Property secondOfDay() { return new Property(this, getChronology().secondOfDay()); } public Property secondOfMinute() { return new Property(this, getChronology().secondOfMinute());"
      },
      {
        "txt": "} public Property millisOfDay() { return new Property(this, getChronology().millisOfDay()); } public Property millisOfSecond() { return new Property(this, getChronology().millisOfSecond()); } public MutableDateTime copy() { return (MutableDateTime) clone(); }"
      },
      {
        "txt": "public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException ex) { throw new InternalError(\"Clone error\"); } } @ToString public String toString() { return ISODateTimeFormat.dateTime().print(this);"
      },
      {
        "txt": "} public static final class Property extends AbstractReadableInstantFieldProperty { private static final long serialVersionUID = -4481126543819298617L; private MutableDateTime iInstant; private DateTimeField iField; Property(MutableDateTime instant, DateTimeField field) { super(); iInstant = instant; iField = field; }"
      },
      {
        "txt": "private void writeObject(ObjectOutputStream oos) throws IOException { oos.writeObject(iInstant); oos.writeObject(iField.getType()); } private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { iInstant = (MutableDateTime) oos.readObject(); DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); iField = type.getField(iInstant.getChronology()); } public DateTimeField getField() {"
      },
      {
        "txt": "return iField; } protected long getMillis() { return iInstant.getMillis(); } protected Chronology getChronology() { return iInstant.getChronology(); } public MutableDateTime getMutableDateTime() { return iInstant;"
      },
      {
        "txt": "} public MutableDateTime add(int value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime add(long value) { iInstant.setMillis(getField().add(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime addWrapField(int value) {"
      },
      {
        "txt": "iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(int value) { iInstant.setMillis(getField().set(iInstant.getMillis(), value)); return iInstant; } public MutableDateTime set(String text, Locale locale) { iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime set(String text) { set(text, null); return iInstant; } public MutableDateTime roundFloor() { iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundCeiling() {"
      },
      {
        "txt": "iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfFloor() { iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); return iInstant; } public MutableDateTime roundHalfCeiling() { iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis())); return iInstant;"
      },
      {
        "txt": "} public MutableDateTime roundHalfEven() { iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); return iInstant; } }"
      }
    ]
  }
]