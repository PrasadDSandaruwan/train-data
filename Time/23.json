[
  {
    "id": 2955,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 564,
    "end-bug-line": 564,
    "bug": "",
    "fix": "map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference;"
      },
      {
        "txt": "import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat;"
      },
      {
        "txt": "import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static {"
      },
      {
        "txt": "setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null;"
      },
      {
        "txt": "try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault());"
      },
      {
        "txt": "} } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp; } } }"
      },
      {
        "txt": "return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); }"
      },
      {
        "txt": "synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) {"
      },
      {
        "txt": "return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC;"
      },
      {
        "txt": "} else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); }"
      },
      {
        "txt": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);"
      },
      {
        "txt": "if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset);"
      },
      {
        "txt": "} public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID();"
      },
      {
        "txt": "if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id);"
      },
      {
        "txt": "} if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) {"
      },
      {
        "txt": "return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {"
      },
      {
        "txt": "if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get();"
      },
      {
        "txt": "if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs;"
      },
      {
        "txt": "} public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider);"
      },
      {
        "txt": "} private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); }"
      },
      {
        "txt": "if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() {"
      },
      {
        "txt": "Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex);"
      },
      {
        "txt": "} } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex);"
      },
      {
        "txt": "} } if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() { return cNameProvider; }"
      },
      {
        "txt": "public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider();"
      },
      {
        "txt": "} cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance();"
      },
      {
        "txt": "} catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider(); }"
      },
      {
        "txt": "} private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); <extra_id_0> map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\");"
      },
      {
        "txt": "map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\");"
      },
      {
        "txt": "map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\");"
      },
      {
        "txt": "map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); }"
      },
      {
        "txt": "private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this;"
      },
      {
        "txt": "} public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) {"
      },
      {
        "txt": "buf.append('+'); } else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':');"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) {"
      },
      {
        "txt": "return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4)"
      },
      {
        "txt": ".toFormatter(); } return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id;"
      },
      {
        "txt": "} @ToString public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) {"
      },
      {
        "txt": "if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name;"
      },
      {
        "txt": "} return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); }"
      },
      {
        "txt": "String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); }"
      },
      {
        "txt": "public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant);"
      },
      {
        "txt": "} public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) {"
      },
      {
        "txt": "return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev;"
      },
      {
        "txt": "} } } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\");"
      },
      {
        "txt": "} return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; }"
      },
      {
        "txt": "return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE;"
      },
      {
        "txt": "} long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\");"
      },
      {
        "txt": "} else { offset = offsetLocal; } } } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); }"
      },
      {
        "txt": "return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant);"
      },
      {
        "txt": "return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try { localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) {"
      },
      {
        "txt": "return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant; } long local = convertUTCToLocal(instant);"
      },
      {
        "txt": "return convertLocalToUTC(local, false, earlierOrLater ? after : before); } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() {"
      },
      {
        "txt": "return 57 + getID().hashCode(); } public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L;"
      },
      {
        "txt": "private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); }"
      },
      {
        "txt": "private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2956,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 572,
    "end-bug-line": 572,
    "bug": "map.put(\"IET\", \"America/Indianapolis\");",
    "fix": "map.put(\"IET\", \"America/Indiana/Indianapolis\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable;"
      },
      {
        "txt": "import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology;"
      },
      {
        "txt": "import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider;"
      },
      {
        "txt": "import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;"
      },
      {
        "txt": "private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault;"
      },
      {
        "txt": "if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { }"
      },
      {
        "txt": "if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp; }"
      },
      {
        "txt": "} } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault();"
      },
      {
        "txt": "} if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id);"
      },
      {
        "txt": "if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {"
      },
      {
        "txt": "return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0;"
      },
      {
        "txt": "try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\");"
      },
      {
        "txt": "} return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault();"
      },
      {
        "txt": "} final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); }"
      },
      {
        "txt": "if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3);"
      },
      {
        "txt": "int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");"
      },
      {
        "txt": "} private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);"
      },
      {
        "txt": "if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; }"
      },
      {
        "txt": "public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));"
      },
      {
        "txt": "} setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException"
      },
      {
        "txt": "(\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids;"
      },
      {
        "txt": "} private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() {"
      },
      {
        "txt": "return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) {"
      },
      {
        "txt": "if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) {"
      },
      {
        "txt": "try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) {"
      },
      {
        "txt": "nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\");"
      },
      {
        "txt": "map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible <extra_id_0> map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\");"
      },
      {
        "txt": "map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\");"
      },
      {
        "txt": "map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; }"
      },
      {
        "txt": "return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; }"
      },
      {
        "txt": "public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) {"
      },
      {
        "txt": "StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;"
      },
      {
        "txt": "int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2);"
      },
      {
        "txt": "offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) {"
      },
      {
        "txt": "cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\");"
      },
      {
        "txt": "} iID = id; } @ToString public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null);"
      },
      {
        "txt": "} public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey);"
      },
      {
        "txt": "if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) {"
      },
      {
        "txt": "locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; }"
      },
      {
        "txt": "return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant);"
      },
      {
        "txt": "public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted);"
      },
      {
        "txt": "long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal;"
      },
      {
        "txt": "if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset;"
      },
      {
        "txt": "if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) {"
      },
      {
        "txt": "return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal);"
      },
      {
        "txt": "if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +"
      },
      {
        "txt": "DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else { offset = offsetLocal; } } } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {"
      },
      {
        "txt": "throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant;"
      },
      {
        "txt": "} long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try { localDateTime.toDateTime(this);"
      },
      {
        "txt": "return false; } catch (IllegalArgumentException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant;"
      },
      {
        "txt": "} long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before); } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); }"
      },
      {
        "txt": "public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); }"
      },
      {
        "txt": "private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException {"
      },
      {
        "txt": "iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2957,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 575,
    "end-bug-line": 575,
    "bug": "map.put(\"AGT\", \"America/Buenos_Aires\");",
    "fix": "map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter;"
      },
      {
        "txt": "import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L;"
      },
      {
        "txt": "public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null);"
      },
      {
        "txt": "setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try {"
      },
      {
        "txt": "try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); }"
      },
      {
        "txt": "} catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp; } } } return zone;"
      },
      {
        "txt": "} public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) {"
      },
      {
        "txt": "cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC;"
      },
      {
        "txt": "} DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else {"
      },
      {
        "txt": "id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {"
      },
      {
        "txt": "if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) {"
      },
      {
        "txt": "minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); }"
      },
      {
        "txt": "public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) {"
      },
      {
        "txt": "return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); }"
      },
      {
        "txt": "if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC;"
      },
      {
        "txt": "} else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) {"
      },
      {
        "txt": "return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) {"
      },
      {
        "txt": "return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; }"
      },
      {
        "txt": "public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); }"
      },
      {
        "txt": "private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null;"
      },
      {
        "txt": "try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); }"
      },
      {
        "txt": "} } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); }"
      },
      {
        "txt": "} if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException {"
      },
      {
        "txt": "SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); }"
      },
      {
        "txt": "cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider;"
      },
      {
        "txt": "} private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\");"
      },
      {
        "txt": "map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); <extra_id_0> map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\");"
      },
      {
        "txt": "map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\");"
      },
      {
        "txt": "map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) {"
      },
      {
        "txt": "Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; }"
      },
      {
        "txt": "public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+');"
      },
      {
        "txt": "} else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2);"
      },
      {
        "txt": "offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString();"
      },
      {
        "txt": "} buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter();"
      },
      {
        "txt": "} return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; }"
      },
      {
        "txt": "@ToString public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) {"
      },
      {
        "txt": "locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; }"
      },
      {
        "txt": "return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant);"
      },
      {
        "txt": "if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant);"
      },
      {
        "txt": "public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); }"
      },
      {
        "txt": "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal;"
      },
      {
        "txt": "} } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; }"
      },
      {
        "txt": "} } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict);"
      },
      {
        "txt": "} public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; }"
      },
      {
        "txt": "long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else {"
      },
      {
        "txt": "offset = offsetLocal; } } } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC;"
      },
      {
        "txt": "} public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant);"
      },
      {
        "txt": "} public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try { localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) { return true;"
      },
      {
        "txt": "} } public long adjustOffset(long instant, boolean earlierOrLater) { long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant; } long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before);"
      },
      {
        "txt": "} public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode();"
      },
      {
        "txt": "} public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID;"
      },
      {
        "txt": "Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException {"
      },
      {
        "txt": "return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2958,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 577,
    "end-bug-line": 578,
    "bug": "map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\");",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils;"
      },
      {
        "txt": "import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider;"
      },
      {
        "txt": "private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); }"
      },
      {
        "txt": "public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\");"
      },
      {
        "txt": "if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { }"
      },
      {
        "txt": "if (temp == null) { temp = UTC; } cDefault = zone = temp; } } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException {"
      },
      {
        "txt": "SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; }"
      },
      {
        "txt": "} @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id);"
      },
      {
        "txt": "if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset);"
      },
      {
        "txt": "} } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC;"
      },
      {
        "txt": "} if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else {"
      },
      {
        "txt": "minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset);"
      },
      {
        "txt": "return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; }"
      },
      {
        "txt": "DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz;"
      },
      {
        "txt": "} if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset);"
      },
      {
        "txt": "return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; }"
      },
      {
        "txt": "if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; }"
      },
      {
        "txt": "} zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider;"
      },
      {
        "txt": "} public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) {"
      },
      {
        "txt": "provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); }"
      },
      {
        "txt": "if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass ="
      },
      {
        "txt": "System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) {"
      },
      {
        "txt": "} if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) {"
      },
      {
        "txt": "provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) {"
      },
      {
        "txt": "sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; }"
      },
      {
        "txt": "private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex);"
      },
      {
        "txt": "} } } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) {"
      },
      {
        "txt": "Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\");"
      },
      {
        "txt": "map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); <extra_id_0> map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\");"
      },
      {
        "txt": "map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\");"
      },
      {
        "txt": "map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null;"
      },
      {
        "txt": "} public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); }"
      },
      {
        "txt": "}; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset;"
      },
      {
        "txt": "} int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString();"
      },
      {
        "txt": "} int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3);"
      },
      {
        "txt": "return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; }"
      },
      {
        "txt": "private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID;"
      },
      {
        "txt": "} public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant);"
      },
      {
        "txt": "if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) {"
      },
      {
        "txt": "return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; }"
      },
      {
        "txt": "String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis());"
      },
      {
        "txt": "} return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal;"
      },
      {
        "txt": "final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal > 0) {"
      },
      {
        "txt": "long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted;"
      },
      {
        "txt": "} public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {"
      },
      {
        "txt": "int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal);"
      },
      {
        "txt": "int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE;"
      },
      {
        "txt": "} if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else { offset = offsetLocal; } }"
      },
      {
        "txt": "} } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) {"
      },
      {
        "txt": "newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) {"
      },
      {
        "txt": "return false; } try { localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) {"
      },
      {
        "txt": "long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant; } long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before); } public abstract boolean isFixed(); public abstract long nextTransition(long instant);"
      },
      {
        "txt": "public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID();"
      },
      {
        "txt": "} protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; }"
      },
      {
        "txt": "private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2959,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 581,
    "end-bug-line": 581,
    "bug": "map.put(\"EET\", \"Europe/Bucharest\");",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException;"
      },
      {
        "txt": "import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString;"
      },
      {
        "txt": "import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider;"
      },
      {
        "txt": "import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter;"
      },
      {
        "txt": "private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) {"
      },
      {
        "txt": "zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) {"
      },
      {
        "txt": "} if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp;"
      },
      {
        "txt": "} } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); }"
      },
      {
        "txt": "if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) {"
      },
      {
        "txt": "return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) {"
      },
      {
        "txt": "int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); }"
      },
      {
        "txt": "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); }"
      },
      {
        "txt": "int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) {"
      },
      {
        "txt": "return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId);"
      },
      {
        "txt": "} if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {"
      },
      {
        "txt": "convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone;"
      },
      {
        "txt": "Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone;"
      },
      {
        "txt": "} public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) {"
      },
      {
        "txt": "sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider;"
      },
      {
        "txt": "cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance();"
      },
      {
        "txt": "} catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");"
      },
      {
        "txt": "} catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; }"
      },
      {
        "txt": "public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); }"
      },
      {
        "txt": "private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");"
      },
      {
        "txt": "if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { }"
      },
      {
        "txt": "if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\");"
      },
      {
        "txt": "map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\");"
      },
      {
        "txt": "map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); <extra_id_0> map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\");"
      },
      {
        "txt": "map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map;"
      },
      {
        "txt": "} return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this;"
      },
      {
        "txt": "} public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); }"
      },
      {
        "txt": "private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2);"
      },
      {
        "txt": "offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':');"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() {"
      },
      {
        "txt": "if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) {"
      },
      {
        "txt": "return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; }"
      },
      {
        "txt": "String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) {"
      },
      {
        "txt": "if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name;"
      },
      {
        "txt": "} return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); }"
      },
      {
        "txt": "public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) {"
      },
      {
        "txt": "long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev);"
      },
      {
        "txt": "int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC);"
      },
      {
        "txt": "long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC);"
      },
      {
        "txt": "if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) {"
      },
      {
        "txt": "long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else { offset = offsetLocal; } } } } long instantUTC = instantLocal - offset;"
      },
      {
        "txt": "if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) {"
      },
      {
        "txt": "return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try {"
      },
      {
        "txt": "localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) {"
      },
      {
        "txt": "return instant; } long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before); } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID);"
      },
      {
        "txt": "} public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID);"
      },
      {
        "txt": "} private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); }"
      },
      {
        "txt": "private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2960,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 583,
    "end-bug-line": 583,
    "bug": "map.put(\"MET\", \"Asia/Tehran\");",
    "fix": "[Delete]",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference;"
      },
      {
        "txt": "import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils;"
      },
      {
        "txt": "import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider;"
      },
      {
        "txt": "public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion;"
      },
      {
        "txt": "static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) {"
      },
      {
        "txt": "DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) {"
      },
      {
        "txt": "temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp; } }"
      },
      {
        "txt": "} return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\");"
      },
      {
        "txt": "} synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); }"
      },
      {
        "txt": "if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) {"
      },
      {
        "txt": "return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0);"
      },
      {
        "txt": "} public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try {"
      },
      {
        "txt": "int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); }"
      },
      {
        "txt": "return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); }"
      },
      {
        "txt": "final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) {"
      },
      {
        "txt": "dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId);"
      },
      {
        "txt": "if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); }"
      },
      {
        "txt": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) {"
      },
      {
        "txt": "zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() {"
      },
      {
        "txt": "return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); }"
      },
      {
        "txt": "setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\");"
      },
      {
        "txt": "} if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; }"
      },
      {
        "txt": "private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread();"
      },
      {
        "txt": "thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread();"
      },
      {
        "txt": "thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() { return cNameProvider;"
      },
      {
        "txt": "} public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) {"
      },
      {
        "txt": "nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try {"
      },
      {
        "txt": "nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider();"
      },
      {
        "txt": "} return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible"
      },
      {
        "txt": "map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\");"
      },
      {
        "txt": "map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); <extra_id_0> map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\");"
      },
      {
        "txt": "map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id);"
      },
      {
        "txt": "} private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) {"
      },
      {
        "txt": "return this; } public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer();"
      },
      {
        "txt": "if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;"
      },
      {
        "txt": "buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;"
      },
      {
        "txt": "if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder()"
      },
      {
        "txt": ".appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); }"
      },
      {
        "txt": "iID = id; } @ToString public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); }"
      },
      {
        "txt": "public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) {"
      },
      {
        "txt": "return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault();"
      },
      {
        "txt": "} String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant));"
      },
      {
        "txt": "} public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) {"
      },
      {
        "txt": "return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);"
      },
      {
        "txt": "if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) {"
      },
      {
        "txt": "return offsetPrev; } } } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {"
      },
      {
        "txt": "throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC;"
      },
      {
        "txt": "} return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) {"
      },
      {
        "txt": "nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +"
      },
      {
        "txt": "\" (\" + getID() + \")\"); } else { offset = offsetLocal; } } } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");"
      },
      {
        "txt": "} return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; }"
      },
      {
        "txt": "long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try { localDateTime.toDateTime(this); return false;"
      },
      {
        "txt": "} catch (IllegalArgumentException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant; }"
      },
      {
        "txt": "long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before); } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object);"
      },
      {
        "txt": "public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable {"
      },
      {
        "txt": "private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF();"
      },
      {
        "txt": "} private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2961,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 586,
    "end-bug-line": 586,
    "bug": "map.put(\"IST\", \"Asia/Calcutta\");",
    "fix": "map.put(\"IST\", \"Asia/Kolkata\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale;"
      },
      {
        "txt": "import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder;"
      },
      {
        "txt": "import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);"
      },
      {
        "txt": "private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null);"
      },
      {
        "txt": "} public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try {"
      },
      {
        "txt": "String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) {"
      },
      {
        "txt": "} if (temp == null) { temp = UTC; } cDefault = zone = temp; } } } return zone; }"
      },
      {
        "txt": "public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone;"
      },
      {
        "txt": "} } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; }"
      },
      {
        "txt": "DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset);"
      },
      {
        "txt": "return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) {"
      },
      {
        "txt": "return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);"
      },
      {
        "txt": "} else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) {"
      },
      {
        "txt": "String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC;"
      },
      {
        "txt": "} DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) {"
      },
      {
        "txt": "return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else {"
      },
      {
        "txt": "convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC;"
      },
      {
        "txt": "} if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone;"
      },
      {
        "txt": "} } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() {"
      },
      {
        "txt": "return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) {"
      },
      {
        "txt": "if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\");"
      },
      {
        "txt": "} if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try {"
      },
      {
        "txt": "String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } }"
      },
      {
        "txt": "} catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } }"
      },
      {
        "txt": "if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager();"
      },
      {
        "txt": "if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider;"
      },
      {
        "txt": "} private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread();"
      },
      {
        "txt": "thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; }"
      },
      {
        "txt": "private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible"
      },
      {
        "txt": "map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\");"
      },
      {
        "txt": "map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); <extra_id_0> map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\");"
      },
      {
        "txt": "map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() {"
      },
      {
        "txt": "public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() {"
      },
      {
        "txt": "return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else {"
      },
      {
        "txt": "buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;"
      },
      {
        "txt": "if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); }"
      },
      {
        "txt": "buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); }"
      },
      {
        "txt": "return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString"
      },
      {
        "txt": "public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault();"
      },
      {
        "txt": "} String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant));"
      },
      {
        "txt": "} public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) {"
      },
      {
        "txt": "return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) {"
      },
      {
        "txt": "if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) {"
      },
      {
        "txt": "final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; }"
      },
      {
        "txt": "} } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } }"
      },
      {
        "txt": "} return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal;"
      },
      {
        "txt": "} public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); }"
      },
      {
        "txt": "public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset);"
      },
      {
        "txt": "if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else { offset = offsetLocal;"
      },
      {
        "txt": "} } } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; }"
      },
      {
        "txt": "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); }"
      },
      {
        "txt": "public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try { localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) { return true; }"
      },
      {
        "txt": "} public long adjustOffset(long instant, boolean earlierOrLater) { long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant; } long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before); }"
      },
      {
        "txt": "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); }"
      },
      {
        "txt": "public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {"
      },
      {
        "txt": "iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID);"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2962,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 588,
    "end-bug-line": 588,
    "bug": "map.put(\"VST\", \"Asia/Saigon\");",
    "fix": "map.put(\"VST\", \"Asia/Ho_Chi_Minh\");",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException;"
      },
      {
        "txt": "import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider;"
      },
      {
        "txt": "import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider;"
      },
      {
        "txt": "private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() {"
      },
      {
        "txt": "DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow"
      },
      {
        "txt": "temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) {"
      },
      {
        "txt": "temp = UTC; } cDefault = zone = temp; } } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager();"
      },
      {
        "txt": "if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } }"
      },
      {
        "txt": "@FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) {"
      },
      {
        "txt": "return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); }"
      },
      {
        "txt": "} throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; }"
      },
      {
        "txt": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);"
      },
      {
        "txt": "} offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset);"
      },
      {
        "txt": "} public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null;"
      },
      {
        "txt": "String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; }"
      },
      {
        "txt": "if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset);"
      },
      {
        "txt": "} } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) {"
      },
      {
        "txt": "iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } }"
      },
      {
        "txt": "zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; }"
      },
      {
        "txt": "public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider();"
      },
      {
        "txt": "} Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");"
      },
      {
        "txt": "if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { }"
      },
      {
        "txt": "if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider();"
      },
      {
        "txt": "} return provider; } public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));"
      },
      {
        "txt": "} setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() {"
      },
      {
        "txt": "NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); }"
      },
      {
        "txt": "} } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion;"
      },
      {
        "txt": "if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\");"
      },
      {
        "txt": "map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\");"
      },
      {
        "txt": "map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); <extra_id_0> map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\");"
      },
      {
        "txt": "map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null;"
      },
      {
        "txt": "} public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); }"
      },
      {
        "txt": "}; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset;"
      },
      {
        "txt": "} int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString();"
      },
      {
        "txt": "} int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3);"
      },
      {
        "txt": "return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; }"
      },
      {
        "txt": "private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID;"
      },
      {
        "txt": "} public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant);"
      },
      {
        "txt": "if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) {"
      },
      {
        "txt": "return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; }"
      },
      {
        "txt": "String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis());"
      },
      {
        "txt": "} return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal;"
      },
      {
        "txt": "final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal > 0) {"
      },
      {
        "txt": "long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted;"
      },
      {
        "txt": "} public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {"
      },
      {
        "txt": "int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal);"
      },
      {
        "txt": "int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE;"
      },
      {
        "txt": "} if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else { offset = offsetLocal; } }"
      },
      {
        "txt": "} } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) {"
      },
      {
        "txt": "newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) {"
      },
      {
        "txt": "return false; } try { localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) {"
      },
      {
        "txt": "long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (before == after) { return instant; } long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? after : before); } public abstract boolean isFixed(); public abstract long nextTransition(long instant);"
      },
      {
        "txt": "public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID();"
      },
      {
        "txt": "} protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; }"
      },
      {
        "txt": "private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  }
]