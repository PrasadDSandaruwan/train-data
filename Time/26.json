[
  {
    "id": 2965,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 936,
    "end-bug-line": 936,
    "bug": "",
    "fix": "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable;"
      },
      {
        "txt": "import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology;"
      },
      {
        "txt": "import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider;"
      },
      {
        "txt": "import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;"
      },
      {
        "txt": "private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault;"
      },
      {
        "txt": "if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { }"
      },
      {
        "txt": "if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp; }"
      },
      {
        "txt": "} } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault();"
      },
      {
        "txt": "} if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id);"
      },
      {
        "txt": "if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {"
      },
      {
        "txt": "return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0;"
      },
      {
        "txt": "try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\");"
      },
      {
        "txt": "} return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault();"
      },
      {
        "txt": "} final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); }"
      },
      {
        "txt": "if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3);"
      },
      {
        "txt": "int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");"
      },
      {
        "txt": "} private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);"
      },
      {
        "txt": "if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; }"
      },
      {
        "txt": "public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));"
      },
      {
        "txt": "} setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException"
      },
      {
        "txt": "(\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids;"
      },
      {
        "txt": "} private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() {"
      },
      {
        "txt": "return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) {"
      },
      {
        "txt": "if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) {"
      },
      {
        "txt": "try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) {"
      },
      {
        "txt": "nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"MIT\", \"Pacific/Apia\");"
      },
      {
        "txt": "map.put(\"HST\", \"Pacific/Honolulu\"); map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\");"
      },
      {
        "txt": "map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\");"
      },
      {
        "txt": "map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\");"
      },
      {
        "txt": "cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() {"
      },
      {
        "txt": "return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);"
      },
      {
        "txt": "} private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;"
      },
      {
        "txt": "buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); }"
      },
      {
        "txt": "private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) {"
      },
      {
        "txt": "if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID; } public abstract String getNameKey(long instant);"
      },
      {
        "txt": "public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID;"
      },
      {
        "txt": "} String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); }"
      },
      {
        "txt": "public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) {"
      },
      {
        "txt": "return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis());"
      },
      {
        "txt": "} public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { int offsetLocal = getOffset(instantLocal); int offsetAdjusted = getOffset(instantLocal - offsetLocal); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) {"
      },
      {
        "txt": "long nextLocal = nextTransition(instantLocal - offsetLocal); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) {"
      },
      {
        "txt": "long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } <extra_id_0> public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal);"
      },
      {
        "txt": "if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) {"
      },
      {
        "txt": "if (strict) { throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) + \" (\" + getID() + \")\"); } else { offset = offsetLocal; } } } }"
      },
      {
        "txt": "long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); }"
      },
      {
        "txt": "if (newZone == this) { return oldInstant; } long instantLocal = oldInstant + getOffset(oldInstant); return instantLocal - newZone.getOffsetFromLocal(instantLocal); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; }"
      },
      {
        "txt": "try { localDateTime.toDateTime(this); return false; } catch (IllegalArgumentException ex) { return true; } } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant);"
      },
      {
        "txt": "public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID(); }"
      },
      {
        "txt": "protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException {"
      },
      {
        "txt": "out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2966,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 436,
    "end-bug-line": 436,
    "bug": "return iZone.convertLocalToUTC(localInstant, false);",
    "fix": "return iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.HashMap; import java.util.Locale; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant; import org.joda.time.ReadablePartial;"
      },
      {
        "txt": "import org.joda.time.field.BaseDateTimeField; import org.joda.time.field.BaseDurationField; import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\"); } base = base.withUTC();"
      },
      {
        "txt": "if (base == null) { throw new IllegalArgumentException(\"UTC chronology must not be null\"); } if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); } static boolean useTimeArithmetic(DurationField field) { return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;"
      },
      {
        "txt": "} private ZonedChronology(Chronology base, DateTimeZone zone) { super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() { return getBase(); }"
      },
      {
        "txt": "public Chronology withZone(DateTimeZone zone) { if (zone == null) { zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) { return getBase(); }"
      },
      {
        "txt": "return new ZonedChronology(getBase(), zone); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay)); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(instant);"
      },
      {
        "txt": "instant -= offset; if (offset != zone.getOffset(instant)) { throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; } protected void assemble(Fields fields) { HashMap<Object, Object> converted = new HashMap<Object, Object>();"
      },
      {
        "txt": "fields.eras = convertField(fields.eras, converted); fields.centuries = convertField(fields.centuries, converted); fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted); fields.hours = convertField(fields.hours, converted); fields.minutes = convertField(fields.minutes, converted);"
      },
      {
        "txt": "fields.seconds = convertField(fields.seconds, converted); fields.millis = convertField(fields.millis, converted); fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted); fields.dayOfMonth = convertField(fields.dayOfMonth, converted); fields.dayOfYear = convertField(fields.dayOfYear, converted);"
      },
      {
        "txt": "fields.monthOfYear = convertField(fields.monthOfYear, converted); fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted); fields.minuteOfHour = convertField(fields.minuteOfHour, converted); fields.minuteOfDay = convertField(fields.minuteOfDay, converted);"
      },
      {
        "txt": "fields.hourOfDay = convertField(fields.hourOfDay, converted); fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; }"
      },
      {
        "txt": "if (converted.containsKey(field)) { return (DurationField)converted.get(field); } ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field;"
      },
      {
        "txt": "} if (converted.containsKey(field)) { return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); converted.put(field, zonedField);"
      },
      {
        "txt": "return zonedField; } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false; } ZonedChronology chrono = (ZonedChronology) obj;"
      },
      {
        "txt": "return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() { return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']'; }"
      },
      {
        "txt": "static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); }"
      },
      {
        "txt": "iField = field; iTimeField = useTimeArithmetic(field); iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() { return iField.getUnitMillis(); }"
      },
      {
        "txt": "public int getValue(long duration, long instant) { return iField.getValue(duration, addOffset(instant)); } public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long getMillis(long value, long instant) {"
      },
      {
        "txt": "return iField.getMillis(value, addOffset(instant)); } public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value);"
      },
      {
        "txt": "return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant);"
      },
      {
        "txt": "return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return offset; }"
      },
      {
        "txt": "private long addOffset(long instant) { return iZone.convertUTCToLocal(instant); } } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField;"
      },
      {
        "txt": "final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException();"
      },
      {
        "txt": "} iField = field; iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; } public boolean isLenient() { return iField.isLenient();"
      },
      {
        "txt": "} public int get(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale); } public String getAsShortText(long instant, Locale locale) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsShortText(localInstant, locale); } public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale); } public long add(long instant, int value) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); <extra_id_0> } } public long add(long instant, long value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value);"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long addWrapField(long instant, int value) {"
      },
      {
        "txt": "if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }"
      },
      {
        "txt": "public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\"); }"
      },
      {
        "txt": "return result; } public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference"
      },
      {
        "txt": "(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public final DurationField getDurationField() {"
      },
      {
        "txt": "return iDurationField; } public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.isLeap(localInstant); } public int getLeapAmount(long instant) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.getLeapAmount(localInstant); } public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset);"
      },
      {
        "txt": "return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long roundCeiling(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant);"
      },
      {
        "txt": "instant = iField.roundCeiling(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long remainder(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.remainder(localInstant); } public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant); } public int getMinimumValue(ReadablePartial instant) {"
      },
      {
        "txt": "return iField.getMinimumValue(instant); } public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); } public int getMaximumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.getMaximumValue(localInstant); } public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); } public int getMaximumTextLength(Locale locale) { return iField.getMaximumTextLength(locale);"
      },
      {
        "txt": "} public int getMaximumShortTextLength(Locale locale) { return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } }"
      }
    ]
  },
  {
    "id": 2967,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 448,
    "end-bug-line": 448,
    "bug": "return iZone.convertLocalToUTC(localInstant, false);",
    "fix": "return iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.chrono; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Locale; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant; import org.joda.time.ReadablePartial; import org.joda.time.field.BaseDateTimeField;"
      },
      {
        "txt": "import org.joda.time.field.BaseDurationField; import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\"); } base = base.withUTC(); if (base == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"UTC chronology must not be null\"); } if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); } static boolean useTimeArithmetic(DurationField field) { return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; }"
      },
      {
        "txt": "private ZonedChronology(Chronology base, DateTimeZone zone) { super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() { return getBase(); } public Chronology withZone(DateTimeZone zone) {"
      },
      {
        "txt": "if (zone == null) { zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) { return getBase(); } return new ZonedChronology(getBase(), zone);"
      },
      {
        "txt": "} public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay)); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)"
      },
      {
        "txt": "throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(instant); instant -= offset;"
      },
      {
        "txt": "if (offset != zone.getOffset(instant)) { throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; } protected void assemble(Fields fields) { HashMap<Object, Object> converted = new HashMap<Object, Object>(); fields.eras = convertField(fields.eras, converted);"
      },
      {
        "txt": "fields.centuries = convertField(fields.centuries, converted); fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted); fields.hours = convertField(fields.hours, converted); fields.minutes = convertField(fields.minutes, converted); fields.seconds = convertField(fields.seconds, converted);"
      },
      {
        "txt": "fields.millis = convertField(fields.millis, converted); fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted); fields.dayOfMonth = convertField(fields.dayOfMonth, converted); fields.dayOfYear = convertField(fields.dayOfYear, converted); fields.monthOfYear = convertField(fields.monthOfYear, converted);"
      },
      {
        "txt": "fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted); fields.minuteOfHour = convertField(fields.minuteOfHour, converted); fields.minuteOfDay = convertField(fields.minuteOfDay, converted); fields.hourOfDay = convertField(fields.hourOfDay, converted);"
      },
      {
        "txt": "fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; } if (converted.containsKey(field)) {"
      },
      {
        "txt": "return (DurationField)converted.get(field); } ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; }"
      },
      {
        "txt": "if (converted.containsKey(field)) { return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); converted.put(field, zonedField); return zonedField;"
      },
      {
        "txt": "} public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false; } ZonedChronology chrono = (ZonedChronology) obj; return"
      },
      {
        "txt": "getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() { return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']'; } static class ZonedDurationField extends BaseDurationField {"
      },
      {
        "txt": "private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); } iField = field;"
      },
      {
        "txt": "iTimeField = useTimeArithmetic(field); iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() { return iField.getUnitMillis(); } public int getValue(long duration, long instant) {"
      },
      {
        "txt": "return iField.getValue(duration, addOffset(instant)); } public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long getMillis(long value, long instant) { return iField.getMillis(value, addOffset(instant));"
      },
      {
        "txt": "} public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));"
      },
      {
        "txt": "} public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong"
      },
      {
        "txt": "(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return offset;"
      },
      {
        "txt": "} private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return offset; } private long addOffset(long instant) {"
      },
      {
        "txt": "return iZone.convertUTCToLocal(instant); } } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField; final DurationField iRangeDurationField;"
      },
      {
        "txt": "final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); }"
      },
      {
        "txt": "iField = field; iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; } public boolean isLenient() { return iField.isLenient(); }"
      },
      {
        "txt": "public int get(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale); } public String getAsShortText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.getAsShortText(localInstant, locale); } public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale); } public long add(long instant, int value) { if (iTimeField) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long add(long instant, long value) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); <extra_id_0> } } public long addWrapField(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value);"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long set(long instant, int value) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\"); } return result;"
      },
      {
        "txt": "} public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),"
      },
      {
        "txt": "subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public final DurationField getDurationField() { return iDurationField;"
      },
      {
        "txt": "} public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.isLeap(localInstant); } public int getLeapAmount(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.getLeapAmount(localInstant); } public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset;"
      },
      {
        "txt": "} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long roundCeiling(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundCeiling(instant + offset);"
      },
      {
        "txt": "return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long remainder(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.remainder(localInstant);"
      },
      {
        "txt": "} public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant); } public int getMinimumValue(ReadablePartial instant) { return iField.getMinimumValue(instant);"
      },
      {
        "txt": "} public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); } public int getMaximumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMaximumValue(localInstant);"
      },
      {
        "txt": "} public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); } public int getMaximumTextLength(Locale locale) { return iField.getMaximumTextLength(locale); }"
      },
      {
        "txt": "public int getMaximumShortTextLength(Locale locale) { return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return offset;"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2968,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 460,
    "end-bug-line": 460,
    "bug": "return iZone.convertLocalToUTC(localInstant, false);",
    "fix": "return iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.chrono; import java.util.HashMap; import java.util.Locale;"
      },
      {
        "txt": "import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant; import org.joda.time.ReadablePartial; import org.joda.time.field.BaseDateTimeField; import org.joda.time.field.BaseDurationField;"
      },
      {
        "txt": "import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\"); } base = base.withUTC(); if (base == null) { throw new IllegalArgumentException(\"UTC chronology must not be null\");"
      },
      {
        "txt": "} if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); } static boolean useTimeArithmetic(DurationField field) { return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; } private ZonedChronology(Chronology base, DateTimeZone zone) {"
      },
      {
        "txt": "super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() { return getBase(); } public Chronology withZone(DateTimeZone zone) { if (zone == null) {"
      },
      {
        "txt": "zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) { return getBase(); } return new ZonedChronology(getBase(), zone); }"
      },
      {
        "txt": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay)); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)"
      },
      {
        "txt": "throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException"
      },
      {
        "txt": "{ return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(instant); instant -= offset; if (offset != zone.getOffset(instant)) {"
      },
      {
        "txt": "throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; } protected void assemble(Fields fields) { HashMap<Object, Object> converted = new HashMap<Object, Object>(); fields.eras = convertField(fields.eras, converted); fields.centuries = convertField(fields.centuries, converted);"
      },
      {
        "txt": "fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted); fields.hours = convertField(fields.hours, converted); fields.minutes = convertField(fields.minutes, converted); fields.seconds = convertField(fields.seconds, converted); fields.millis = convertField(fields.millis, converted);"
      },
      {
        "txt": "fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted); fields.dayOfMonth = convertField(fields.dayOfMonth, converted); fields.dayOfYear = convertField(fields.dayOfYear, converted); fields.monthOfYear = convertField(fields.monthOfYear, converted); fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);"
      },
      {
        "txt": "fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted); fields.minuteOfHour = convertField(fields.minuteOfHour, converted); fields.minuteOfDay = convertField(fields.minuteOfDay, converted); fields.hourOfDay = convertField(fields.hourOfDay, converted); fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);"
      },
      {
        "txt": "fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; } if (converted.containsKey(field)) { return (DurationField)converted.get(field);"
      },
      {
        "txt": "} ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; } if (converted.containsKey(field)) {"
      },
      {
        "txt": "return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); converted.put(field, zonedField); return zonedField; }"
      },
      {
        "txt": "public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false; } ZonedChronology chrono = (ZonedChronology) obj; return getBase().equals(chrono.getBase()) &&"
      },
      {
        "txt": "getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() { return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']'; } static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L;"
      },
      {
        "txt": "final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); } iField = field; iTimeField = useTimeArithmetic(field);"
      },
      {
        "txt": "iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() { return iField.getUnitMillis(); } public int getValue(long duration, long instant) { return iField.getValue(duration, addOffset(instant));"
      },
      {
        "txt": "} public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long getMillis(long value, long instant) { return iField.getMillis(value, addOffset(instant)); }"
      },
      {
        "txt": "public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); }"
      },
      {
        "txt": "public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),"
      },
      {
        "txt": "subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return offset; }"
      },
      {
        "txt": "private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return offset; } private long addOffset(long instant) { return iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "} } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField; final DurationField iRangeDurationField; final DurationField iLeapDurationField;"
      },
      {
        "txt": "ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); } iField = field;"
      },
      {
        "txt": "iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; } public boolean isLenient() { return iField.isLenient(); } public int get(long instant) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale); } public String getAsShortText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsShortText(localInstant, locale);"
      },
      {
        "txt": "} public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale); } public long add(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant);"
      },
      {
        "txt": "long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long add(long instant, long value) { if (iTimeField) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } } public long addWrapField(long instant, int value) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); <extra_id_0> } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false);"
      },
      {
        "txt": "localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\"); } return result; }"
      },
      {
        "txt": "public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset);"
      },
      {
        "txt": "} public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public final DurationField getDurationField() { return iDurationField; }"
      },
      {
        "txt": "public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.isLeap(localInstant); } public int getLeapAmount(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getLeapAmount(localInstant);"
      },
      {
        "txt": "} public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; } else {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long roundCeiling(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundCeiling(instant + offset); return instant - offset;"
      },
      {
        "txt": "} else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long remainder(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.remainder(localInstant); }"
      },
      {
        "txt": "public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant); } public int getMinimumValue(ReadablePartial instant) { return iField.getMinimumValue(instant); }"
      },
      {
        "txt": "public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); } public int getMaximumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMaximumValue(localInstant); }"
      },
      {
        "txt": "public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); } public int getMaximumTextLength(Locale locale) { return iField.getMaximumTextLength(locale); } public int getMaximumShortTextLength(Locale locale) {"
      },
      {
        "txt": "return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return offset; }"
      }
    ]
  },
  {
    "id": 2969,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 467,
    "end-bug-line": 467,
    "bug": "long result = iZone.convertLocalToUTC(localInstant, false);",
    "fix": "long result = iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.chrono; import java.util.HashMap; import java.util.Locale; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException;"
      },
      {
        "txt": "import org.joda.time.Instant; import org.joda.time.ReadablePartial; import org.joda.time.field.BaseDateTimeField; import org.joda.time.field.BaseDurationField; import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\");"
      },
      {
        "txt": "} base = base.withUTC(); if (base == null) { throw new IllegalArgumentException(\"UTC chronology must not be null\"); } if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); }"
      },
      {
        "txt": "static boolean useTimeArithmetic(DurationField field) { return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; } private ZonedChronology(Chronology base, DateTimeZone zone) { super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() {"
      },
      {
        "txt": "return getBase(); } public Chronology withZone(DateTimeZone zone) { if (zone == null) { zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) {"
      },
      {
        "txt": "return getBase(); } return new ZonedChronology(getBase(), zone); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay));"
      },
      {
        "txt": "} public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); }"
      },
      {
        "txt": "public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) {"
      },
      {
        "txt": "DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(instant); instant -= offset; if (offset != zone.getOffset(instant)) { throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; }"
      },
      {
        "txt": "protected void assemble(Fields fields) { HashMap<Object, Object> converted = new HashMap<Object, Object>(); fields.eras = convertField(fields.eras, converted); fields.centuries = convertField(fields.centuries, converted); fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted);"
      },
      {
        "txt": "fields.hours = convertField(fields.hours, converted); fields.minutes = convertField(fields.minutes, converted); fields.seconds = convertField(fields.seconds, converted); fields.millis = convertField(fields.millis, converted); fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted);"
      },
      {
        "txt": "fields.dayOfMonth = convertField(fields.dayOfMonth, converted); fields.dayOfYear = convertField(fields.dayOfYear, converted); fields.monthOfYear = convertField(fields.monthOfYear, converted); fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted);"
      },
      {
        "txt": "fields.minuteOfHour = convertField(fields.minuteOfHour, converted); fields.minuteOfDay = convertField(fields.minuteOfDay, converted); fields.hourOfDay = convertField(fields.hourOfDay, converted); fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) {"
      },
      {
        "txt": "return field; } if (converted.containsKey(field)) { return (DurationField)converted.get(field); } ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {"
      },
      {
        "txt": "if (field == null || !field.isSupported()) { return field; } if (converted.containsKey(field)) { return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted),"
      },
      {
        "txt": "convertField(field.getLeapDurationField(), converted)); converted.put(field, zonedField); return zonedField; } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false;"
      },
      {
        "txt": "} ZonedChronology chrono = (ZonedChronology) obj; return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() {"
      },
      {
        "txt": "return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']'; } static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) {"
      },
      {
        "txt": "throw new IllegalArgumentException(); } iField = field; iTimeField = useTimeArithmetic(field); iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() {"
      },
      {
        "txt": "return iField.getUnitMillis(); } public int getValue(long duration, long instant) { return iField.getValue(duration, addOffset(instant)); } public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant));"
      },
      {
        "txt": "} public long getMillis(long value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); }"
      },
      {
        "txt": "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {"
      },
      {
        "txt": "throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return offset; } private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } private long addOffset(long instant) { return iZone.convertUTCToLocal(instant); } } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone;"
      },
      {
        "txt": "final DurationField iDurationField; final boolean iTimeField; final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType());"
      },
      {
        "txt": "if (!field.isSupported()) { throw new IllegalArgumentException(); } iField = field; iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; }"
      },
      {
        "txt": "public boolean isLenient() { return iField.isLenient(); } public int get(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale);"
      },
      {
        "txt": "} public String getAsShortText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsShortText(localInstant, locale); } public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale);"
      },
      {
        "txt": "} public long add(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false);"
      },
      {
        "txt": "} } public long add(long instant, long value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value);"
      },
      {
        "txt": "return iZone.convertLocalToUTC(localInstant, false); } } public long addWrapField(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iZone.convertLocalToUTC(localInstant, false); } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); <extra_id_0> if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\"); }"
      },
      {
        "txt": "\" (\" + iZone.getID() + \")\"); } return result; } public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset);"
      },
      {
        "txt": "} public final DurationField getDurationField() { return iDurationField; } public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.isLeap(localInstant);"
      },
      {
        "txt": "} public int getLeapAmount(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getLeapAmount(localInstant); } public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) { if (iTimeField) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long roundCeiling(long instant) {"
      },
      {
        "txt": "if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundCeiling(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } }"
      },
      {
        "txt": "public long remainder(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.remainder(localInstant); } public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant);"
      },
      {
        "txt": "} public int getMinimumValue(ReadablePartial instant) { return iField.getMinimumValue(instant); } public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); }"
      },
      {
        "txt": "public int getMaximumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMaximumValue(localInstant); } public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); }"
      },
      {
        "txt": "public int getMaximumTextLength(Locale locale) { return iField.getMaximumTextLength(locale); } public int getMaximumShortTextLength(Locale locale) { return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {"
      },
      {
        "txt": "throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return offset; } }"
      }
    ]
  },
  {
    "id": 2970,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 481,
    "end-bug-line": 481,
    "bug": "return iZone.convertLocalToUTC(localInstant, false);",
    "fix": "return iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.HashMap; import java.util.Locale; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant; import org.joda.time.ReadablePartial;"
      },
      {
        "txt": "import org.joda.time.field.BaseDateTimeField; import org.joda.time.field.BaseDurationField; import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\"); } base = base.withUTC();"
      },
      {
        "txt": "if (base == null) { throw new IllegalArgumentException(\"UTC chronology must not be null\"); } if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); } static boolean useTimeArithmetic(DurationField field) { return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;"
      },
      {
        "txt": "} private ZonedChronology(Chronology base, DateTimeZone zone) { super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() { return getBase(); }"
      },
      {
        "txt": "public Chronology withZone(DateTimeZone zone) { if (zone == null) { zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) { return getBase(); }"
      },
      {
        "txt": "return new ZonedChronology(getBase(), zone); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay)); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(instant);"
      },
      {
        "txt": "instant -= offset; if (offset != zone.getOffset(instant)) { throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; } protected void assemble(Fields fields) { HashMap<Object, Object> converted = new HashMap<Object, Object>();"
      },
      {
        "txt": "fields.eras = convertField(fields.eras, converted); fields.centuries = convertField(fields.centuries, converted); fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted); fields.hours = convertField(fields.hours, converted); fields.minutes = convertField(fields.minutes, converted);"
      },
      {
        "txt": "fields.seconds = convertField(fields.seconds, converted); fields.millis = convertField(fields.millis, converted); fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted); fields.dayOfMonth = convertField(fields.dayOfMonth, converted); fields.dayOfYear = convertField(fields.dayOfYear, converted);"
      },
      {
        "txt": "fields.monthOfYear = convertField(fields.monthOfYear, converted); fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted); fields.minuteOfHour = convertField(fields.minuteOfHour, converted); fields.minuteOfDay = convertField(fields.minuteOfDay, converted);"
      },
      {
        "txt": "fields.hourOfDay = convertField(fields.hourOfDay, converted); fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; }"
      },
      {
        "txt": "if (converted.containsKey(field)) { return (DurationField)converted.get(field); } ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field;"
      },
      {
        "txt": "} if (converted.containsKey(field)) { return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); converted.put(field, zonedField);"
      },
      {
        "txt": "return zonedField; } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false; } ZonedChronology chrono = (ZonedChronology) obj;"
      },
      {
        "txt": "return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() { return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']'; }"
      },
      {
        "txt": "static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); }"
      },
      {
        "txt": "iField = field; iTimeField = useTimeArithmetic(field); iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() { return iField.getUnitMillis(); }"
      },
      {
        "txt": "public int getValue(long duration, long instant) { return iField.getValue(duration, addOffset(instant)); } public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long getMillis(long value, long instant) {"
      },
      {
        "txt": "return iField.getMillis(value, addOffset(instant)); } public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value);"
      },
      {
        "txt": "return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant);"
      },
      {
        "txt": "return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return offset; }"
      },
      {
        "txt": "private long addOffset(long instant) { return iZone.convertUTCToLocal(instant); } } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField;"
      },
      {
        "txt": "final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException();"
      },
      {
        "txt": "} iField = field; iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; } public boolean isLenient() { return iField.isLenient();"
      },
      {
        "txt": "} public int get(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale); } public String getAsShortText(long instant, Locale locale) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsShortText(localInstant, locale); } public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale); } public long add(long instant, int value) {"
      },
      {
        "txt": "if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }"
      },
      {
        "txt": "public long add(long instant, long value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); }"
      },
      {
        "txt": "} public long addWrapField(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false);"
      },
      {
        "txt": "} } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +"
      },
      {
        "txt": "} return result; } public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); <extra_id_0> } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset);"
      },
      {
        "txt": "(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public final DurationField getDurationField() {"
      },
      {
        "txt": "return iDurationField; } public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.isLeap(localInstant); } public int getLeapAmount(long instant) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.getLeapAmount(localInstant); } public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset);"
      },
      {
        "txt": "return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long roundCeiling(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant);"
      },
      {
        "txt": "instant = iField.roundCeiling(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long remainder(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.remainder(localInstant); } public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant); } public int getMinimumValue(ReadablePartial instant) {"
      },
      {
        "txt": "return iField.getMinimumValue(instant); } public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); } public int getMaximumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.getMaximumValue(localInstant); } public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); } public int getMaximumTextLength(Locale locale) { return iField.getMaximumTextLength(locale);"
      },
      {
        "txt": "} public int getMaximumShortTextLength(Locale locale) { return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } }"
      }
    ]
  },
  {
    "id": 2971,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 528,
    "end-bug-line": 528,
    "bug": "return iZone.convertLocalToUTC(localInstant, false);",
    "fix": "return iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.chrono; import java.util.HashMap; import java.util.Locale; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant;"
      },
      {
        "txt": "import org.joda.time.ReadablePartial; import org.joda.time.field.BaseDateTimeField; import org.joda.time.field.BaseDurationField; import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\"); }"
      },
      {
        "txt": "base = base.withUTC(); if (base == null) { throw new IllegalArgumentException(\"UTC chronology must not be null\"); } if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); } static boolean useTimeArithmetic(DurationField field) {"
      },
      {
        "txt": "return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12; } private ZonedChronology(Chronology base, DateTimeZone zone) { super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() { return getBase();"
      },
      {
        "txt": "} public Chronology withZone(DateTimeZone zone) { if (zone == null) { zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) { return getBase();"
      },
      {
        "txt": "} return new ZonedChronology(getBase(), zone); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay)); }"
      },
      {
        "txt": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } public long getDateTimeMillis(long instant,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) { DateTimeZone zone = getZone();"
      },
      {
        "txt": "int offset = zone.getOffsetFromLocal(instant); instant -= offset; if (offset != zone.getOffset(instant)) { throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; } protected void assemble(Fields fields) {"
      },
      {
        "txt": "HashMap<Object, Object> converted = new HashMap<Object, Object>(); fields.eras = convertField(fields.eras, converted); fields.centuries = convertField(fields.centuries, converted); fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted); fields.hours = convertField(fields.hours, converted);"
      },
      {
        "txt": "fields.minutes = convertField(fields.minutes, converted); fields.seconds = convertField(fields.seconds, converted); fields.millis = convertField(fields.millis, converted); fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted); fields.dayOfMonth = convertField(fields.dayOfMonth, converted);"
      },
      {
        "txt": "fields.dayOfYear = convertField(fields.dayOfYear, converted); fields.monthOfYear = convertField(fields.monthOfYear, converted); fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted); fields.minuteOfHour = convertField(fields.minuteOfHour, converted);"
      },
      {
        "txt": "fields.minuteOfDay = convertField(fields.minuteOfDay, converted); fields.hourOfDay = convertField(fields.hourOfDay, converted); fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field;"
      },
      {
        "txt": "} if (converted.containsKey(field)) { return (DurationField)converted.get(field); } ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) {"
      },
      {
        "txt": "return field; } if (converted.containsKey(field)) { return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted));"
      },
      {
        "txt": "converted.put(field, zonedField); return zonedField; } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false; }"
      },
      {
        "txt": "ZonedChronology chrono = (ZonedChronology) obj; return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() { return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';"
      },
      {
        "txt": "} static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException();"
      },
      {
        "txt": "} iField = field; iTimeField = useTimeArithmetic(field); iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() { return iField.getUnitMillis();"
      },
      {
        "txt": "} public int getValue(long duration, long instant) { return iField.getValue(duration, addOffset(instant)); } public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant)); }"
      },
      {
        "txt": "public long getMillis(long value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) { int offset = getOffsetToAdd(instant);"
      },
      {
        "txt": "instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\");"
      },
      {
        "txt": "} return offset; } private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return offset;"
      },
      {
        "txt": "} private long addOffset(long instant) { return iZone.convertUTCToLocal(instant); } } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField;"
      },
      {
        "txt": "final boolean iTimeField; final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType()); if (!field.isSupported()) {"
      },
      {
        "txt": "throw new IllegalArgumentException(); } iField = field; iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; } public boolean isLenient() {"
      },
      {
        "txt": "return iField.isLenient(); } public int get(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale); }"
      },
      {
        "txt": "public String getAsShortText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsShortText(localInstant, locale); } public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale); }"
      },
      {
        "txt": "public long add(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); }"
      },
      {
        "txt": "} public long add(long instant, long value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false);"
      },
      {
        "txt": "} } public long addWrapField(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value);"
      },
      {
        "txt": "return iZone.convertLocalToUTC(localInstant, false); } } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" +"
      },
      {
        "txt": "DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\"); } return result; } public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); }"
      },
      {
        "txt": "public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),"
      },
      {
        "txt": "subtrahendInstant + offset); } public final DurationField getDurationField() { return iDurationField; } public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.isLeap(localInstant); } public int getLeapAmount(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getLeapAmount(localInstant); } public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); <extra_id_0> } } public long roundCeiling(long instant) { if (iTimeField) { int offset = getOffsetToAdd(instant); instant = iField.roundCeiling(instant + offset);"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); instant = iField.roundCeiling(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long remainder(long instant) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.remainder(localInstant); } public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant); }"
      },
      {
        "txt": "public int getMinimumValue(ReadablePartial instant) { return iField.getMinimumValue(instant); } public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); } public int getMaximumValue(long instant) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.getMaximumValue(localInstant); } public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); } public int getMaximumTextLength(Locale locale) {"
      },
      {
        "txt": "return iField.getMaximumTextLength(locale); } public int getMaximumShortTextLength(Locale locale) { return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\");"
      },
      {
        "txt": "} return offset; } }"
      }
    ]
  },
  {
    "id": 2972,
    "file_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
    "start-bug-line": 540,
    "end-bug-line": 540,
    "bug": "return iZone.convertLocalToUTC(localInstant, false);",
    "fix": "return iZone.convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.HashMap; import java.util.Locale; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant; import org.joda.time.ReadablePartial;"
      },
      {
        "txt": "import org.joda.time.field.BaseDateTimeField; import org.joda.time.field.BaseDurationField; import org.joda.time.format.DateTimeFormat; public final class ZonedChronology extends AssembledChronology { private static final long serialVersionUID = -1079258847191166848L; public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) { if (base == null) { throw new IllegalArgumentException(\"Must supply a chronology\"); } base = base.withUTC();"
      },
      {
        "txt": "if (base == null) { throw new IllegalArgumentException(\"UTC chronology must not be null\"); } if (zone == null) { throw new IllegalArgumentException(\"DateTimeZone must not be null\"); } return new ZonedChronology(base, zone); } static boolean useTimeArithmetic(DurationField field) { return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;"
      },
      {
        "txt": "} private ZonedChronology(Chronology base, DateTimeZone zone) { super(base, zone); } public DateTimeZone getZone() { return (DateTimeZone)getParam(); } public Chronology withUTC() { return getBase(); }"
      },
      {
        "txt": "public Chronology withZone(DateTimeZone zone) { if (zone == null) { zone = DateTimeZone.getDefault(); } if (zone == getParam()) { return this; } if (zone == DateTimeZone.UTC) { return getBase(); }"
      },
      {
        "txt": "return new ZonedChronology(getBase(), zone); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, millisOfDay)); } public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,"
      },
      {
        "txt": "int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour,"
      },
      {
        "txt": "int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { return localToUTC(getBase().getDateTimeMillis (instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); } private long localToUTC(long instant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(instant);"
      },
      {
        "txt": "instant -= offset; if (offset != zone.getOffset(instant)) { throw new IllegalArgumentException (\"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant))); } return instant; } protected void assemble(Fields fields) { HashMap<Object, Object> converted = new HashMap<Object, Object>();"
      },
      {
        "txt": "fields.eras = convertField(fields.eras, converted); fields.centuries = convertField(fields.centuries, converted); fields.years = convertField(fields.years, converted); fields.months = convertField(fields.months, converted); fields.weekyears = convertField(fields.weekyears, converted); fields.weeks = convertField(fields.weeks, converted); fields.days = convertField(fields.days, converted); fields.halfdays = convertField(fields.halfdays, converted); fields.hours = convertField(fields.hours, converted); fields.minutes = convertField(fields.minutes, converted);"
      },
      {
        "txt": "fields.seconds = convertField(fields.seconds, converted); fields.millis = convertField(fields.millis, converted); fields.year = convertField(fields.year, converted); fields.yearOfEra = convertField(fields.yearOfEra, converted); fields.yearOfCentury = convertField(fields.yearOfCentury, converted); fields.centuryOfEra = convertField(fields.centuryOfEra, converted); fields.era = convertField(fields.era, converted); fields.dayOfWeek = convertField(fields.dayOfWeek, converted); fields.dayOfMonth = convertField(fields.dayOfMonth, converted); fields.dayOfYear = convertField(fields.dayOfYear, converted);"
      },
      {
        "txt": "fields.monthOfYear = convertField(fields.monthOfYear, converted); fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted); fields.weekyear = convertField(fields.weekyear, converted); fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted); fields.millisOfSecond = convertField(fields.millisOfSecond, converted); fields.millisOfDay = convertField(fields.millisOfDay, converted); fields.secondOfMinute = convertField(fields.secondOfMinute, converted); fields.secondOfDay = convertField(fields.secondOfDay, converted); fields.minuteOfHour = convertField(fields.minuteOfHour, converted); fields.minuteOfDay = convertField(fields.minuteOfDay, converted);"
      },
      {
        "txt": "fields.hourOfDay = convertField(fields.hourOfDay, converted); fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted); fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted); fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted); fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted); } private DurationField convertField(DurationField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field; }"
      },
      {
        "txt": "if (converted.containsKey(field)) { return (DurationField)converted.get(field); } ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); converted.put(field, zonedField); return zonedField; } private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) { if (field == null || !field.isSupported()) { return field;"
      },
      {
        "txt": "} if (converted.containsKey(field)) { return (DateTimeField)converted.get(field); } ZonedDateTimeField zonedField = new ZonedDateTimeField(field, getZone(), convertField(field.getDurationField(), converted), convertField(field.getRangeDurationField(), converted), convertField(field.getLeapDurationField(), converted)); converted.put(field, zonedField);"
      },
      {
        "txt": "return zonedField; } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof ZonedChronology == false) { return false; } ZonedChronology chrono = (ZonedChronology) obj;"
      },
      {
        "txt": "return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); } public int hashCode() { return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; } public String toString() { return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']'; }"
      },
      {
        "txt": "static class ZonedDurationField extends BaseDurationField { private static final long serialVersionUID = -485345310999208286L; final DurationField iField; final boolean iTimeField; final DateTimeZone iZone; ZonedDurationField(DurationField field, DateTimeZone zone) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException(); }"
      },
      {
        "txt": "iField = field; iTimeField = useTimeArithmetic(field); iZone = zone; } public boolean isPrecise() { return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed(); } public long getUnitMillis() { return iField.getUnitMillis(); }"
      },
      {
        "txt": "public int getValue(long duration, long instant) { return iField.getValue(duration, addOffset(instant)); } public long getValueAsLong(long duration, long instant) { return iField.getValueAsLong(duration, addOffset(instant)); } public long getMillis(int value, long instant) { return iField.getMillis(value, addOffset(instant)); } public long getMillis(long value, long instant) {"
      },
      {
        "txt": "return iField.getMillis(value, addOffset(instant)); } public long add(long instant, int value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value); return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public long add(long instant, long value) { int offset = getOffsetToAdd(instant); instant = iField.add(instant + offset, value);"
      },
      {
        "txt": "return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); } public int getDifference(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant);"
      },
      {
        "txt": "return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } private int getOffsetFromLocalToSubtract(long instant) { int offset = this.iZone.getOffsetFromLocal(instant); long diff = instant - offset; if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return offset; }"
      },
      {
        "txt": "private long addOffset(long instant) { return iZone.convertUTCToLocal(instant); } } static final class ZonedDateTimeField extends BaseDateTimeField { private static final long serialVersionUID = -3968986277775529794L; final DateTimeField iField; final DateTimeZone iZone; final DurationField iDurationField; final boolean iTimeField;"
      },
      {
        "txt": "final DurationField iRangeDurationField; final DurationField iLeapDurationField; ZonedDateTimeField(DateTimeField field, DateTimeZone zone, DurationField durationField, DurationField rangeDurationField, DurationField leapDurationField) { super(field.getType()); if (!field.isSupported()) { throw new IllegalArgumentException();"
      },
      {
        "txt": "} iField = field; iZone = zone; iDurationField = durationField; iTimeField = useTimeArithmetic(durationField); iRangeDurationField = rangeDurationField; iLeapDurationField = leapDurationField; } public boolean isLenient() { return iField.isLenient();"
      },
      {
        "txt": "} public int get(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.get(localInstant); } public String getAsText(long instant, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsText(localInstant, locale); } public String getAsShortText(long instant, Locale locale) {"
      },
      {
        "txt": "long localInstant = iZone.convertUTCToLocal(instant); return iField.getAsShortText(localInstant, locale); } public String getAsText(int fieldValue, Locale locale) { return iField.getAsText(fieldValue, locale); } public String getAsShortText(int fieldValue, Locale locale) { return iField.getAsShortText(fieldValue, locale); } public long add(long instant, int value) {"
      },
      {
        "txt": "if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); } }"
      },
      {
        "txt": "public long add(long instant, long value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.add(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.add(localInstant, value); return iZone.convertLocalToUTC(localInstant, false); }"
      },
      {
        "txt": "} public long addWrapField(long instant, int value) { if (iTimeField) { int offset = getOffsetToAdd(instant); long localInstant = iField.addWrapField(instant + offset, value); return localInstant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.addWrapField(localInstant, value); return iZone.convertLocalToUTC(localInstant, false);"
      },
      {
        "txt": "} } public long set(long instant, int value) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, value); long result = iZone.convertLocalToUTC(localInstant, false); if (get(result) != value) { throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +"
      },
      {
        "txt": "\" (\" + iZone.getID() + \")\"); } return result; } public long set(long instant, String text, Locale locale) { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.set(localInstant, text, locale); return iZone.convertLocalToUTC(localInstant, false); } public int getDifference(long minuendInstant, long subtrahendInstant) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifference (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { int offset = getOffsetToAdd(subtrahendInstant); return iField.getDifferenceAsLong (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset);"
      },
      {
        "txt": "} public final DurationField getDurationField() { return iDurationField; } public final DurationField getRangeDurationField() { return iRangeDurationField; } public boolean isLeap(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.isLeap(localInstant);"
      },
      {
        "txt": "} public int getLeapAmount(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getLeapAmount(localInstant); } public final DurationField getLeapDurationField() { return iLeapDurationField; } public long roundFloor(long instant) { if (iTimeField) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); instant = iField.roundFloor(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundFloor(localInstant); return iZone.convertLocalToUTC(localInstant, false); } } public long roundCeiling(long instant) {"
      },
      {
        "txt": "int offset = getOffsetToAdd(instant); instant = iField.roundCeiling(instant + offset); return instant - offset; } else { long localInstant = iZone.convertUTCToLocal(instant); localInstant = iField.roundCeiling(localInstant); <extra_id_0> } } public long remainder(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.remainder(localInstant); }"
      },
      {
        "txt": "return iField.remainder(localInstant); } public int getMinimumValue() { return iField.getMinimumValue(); } public int getMinimumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant); return iField.getMinimumValue(localInstant); } public int getMinimumValue(ReadablePartial instant) {"
      },
      {
        "txt": "return iField.getMinimumValue(instant); } public int getMinimumValue(ReadablePartial instant, int[] values) { return iField.getMinimumValue(instant, values); } public int getMaximumValue() { return iField.getMaximumValue(); } public int getMaximumValue(long instant) { long localInstant = iZone.convertUTCToLocal(instant);"
      },
      {
        "txt": "return iField.getMaximumValue(localInstant); } public int getMaximumValue(ReadablePartial instant) { return iField.getMaximumValue(instant); } public int getMaximumValue(ReadablePartial instant, int[] values) { return iField.getMaximumValue(instant, values); } public int getMaximumTextLength(Locale locale) { return iField.getMaximumTextLength(locale);"
      },
      {
        "txt": "} public int getMaximumShortTextLength(Locale locale) { return iField.getMaximumShortTextLength(locale); } private int getOffsetToAdd(long instant) { int offset = this.iZone.getOffset(instant); long sum = instant + offset; if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return offset; } }"
      }
    ]
  },
  {
    "id": 2973,
    "file_path": "src/main/java/org/joda/time/field/LenientDateTimeField.java",
    "start-bug-line": 75,
    "end-bug-line": 75,
    "bug": "return iBase.getZone().convertLocalToUTC(localInstant, false);",
    "fix": "return iBase.getZone().convertLocalToUTC(localInstant, false, instant);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time.field; import org.joda.time.Chronology;"
      },
      {
        "txt": "import org.joda.time.DateTimeField; public class LenientDateTimeField extends DelegatedDateTimeField { private static final long serialVersionUID = 8714085824173290599L; private final Chronology iBase; public static DateTimeField getInstance(DateTimeField field, Chronology base) { if (field == null) { return null; } if (field instanceof StrictDateTimeField) { field = ((StrictDateTimeField)field).getWrappedField();"
      },
      {
        "txt": "} if (field.isLenient()) { return field; } return new LenientDateTimeField(field, base); } protected LenientDateTimeField(DateTimeField field, Chronology base) { super(field); iBase = base; }"
      },
      {
        "txt": "return true; } public long set(long instant, int value) { long localInstant = iBase.getZone().convertUTCToLocal(instant); long difference = FieldUtils.safeSubtract(value, get(instant)); localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference); <extra_id_0> } }"
      }
    ]
  }
]