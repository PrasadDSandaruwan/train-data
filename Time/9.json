[
  {
    "id": 2918,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 96,
    "end-bug-line": 96,
    "bug": "",
    "fix": "private static final int MAX_MILLIS = (86400 * 1000) - 1;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException;"
      },
      {
        "txt": "import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone;"
      },
      {
        "txt": "import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); <extra_id_0> private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;"
      },
      {
        "txt": "private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) {"
      },
      {
        "txt": "synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); }"
      },
      {
        "txt": "} catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; }"
      },
      {
        "txt": "cDefault = zone = temp; } } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));"
      },
      {
        "txt": "} if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) {"
      },
      {
        "txt": "if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; }"
      },
      {
        "txt": "if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");"
      },
      {
        "txt": "} public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);"
      },
      {
        "txt": "} int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);"
      },
      {
        "txt": "} catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) {"
      },
      {
        "txt": "if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) {"
      },
      {
        "txt": "dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getID();"
      },
      {
        "txt": "if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } }"
      },
      {
        "txt": "} throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); }"
      },
      {
        "txt": "DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));"
      },
      {
        "txt": "return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager();"
      },
      {
        "txt": "if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs();"
      },
      {
        "txt": "if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); }"
      },
      {
        "txt": "cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try {"
      },
      {
        "txt": "provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try {"
      },
      {
        "txt": "provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider;"
      },
      {
        "txt": "} public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider);"
      },
      {
        "txt": "} private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try {"
      },
      {
        "txt": "String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) {"
      },
      {
        "txt": "} if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>();"
      },
      {
        "txt": "map.put(\"GMT\", \"UTC\"); map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\");"
      },
      {
        "txt": "map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\");"
      },
      {
        "txt": "map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\");"
      },
      {
        "txt": "map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() {"
      },
      {
        "txt": "return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName();"
      },
      {
        "txt": "} }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-');"
      },
      {
        "txt": "offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) {"
      },
      {
        "txt": "return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.');"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter;"
      },
      {
        "txt": "} private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() {"
      },
      {
        "txt": "return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); }"
      },
      {
        "txt": "String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); }"
      },
      {
        "txt": "public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID;"
      },
      {
        "txt": "} String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) {"
      },
      {
        "txt": "return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal);"
      },
      {
        "txt": "final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } }"
      },
      {
        "txt": "} else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } }"
      },
      {
        "txt": "return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; }"
      },
      {
        "txt": "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) {"
      },
      {
        "txt": "int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) {"
      },
      {
        "txt": "nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalInstantException(instantLocal, getID()); } else { offset = offsetLocal; } } }"
      },
      {
        "txt": "} long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault();"
      },
      {
        "txt": "} if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false;"
      },
      {
        "txt": "} try { localDateTime.toDateTime(this); return false; } catch (IllegalInstantException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;"
      },
      {
        "txt": "long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff;"
      },
      {
        "txt": "if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; } }"
      },
      {
        "txt": "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); }"
      },
      {
        "txt": "public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {"
      },
      {
        "txt": "iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID);"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2919,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 257,
    "end-bug-line": 257,
    "bug": "",
    "fix": "if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;"
      },
      {
        "txt": "import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString;"
      },
      {
        "txt": "import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider;"
      },
      {
        "txt": "import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter;"
      },
      {
        "txt": "private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) {"
      },
      {
        "txt": "zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) {"
      },
      {
        "txt": "} if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; } cDefault = zone = temp;"
      },
      {
        "txt": "} } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); }"
      },
      {
        "txt": "if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) { if (id == null) {"
      },
      {
        "txt": "return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) {"
      },
      {
        "txt": "int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); }"
      },
      {
        "txt": "return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } <extra_id_0> throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) {"
      },
      {
        "txt": "int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); }"
      },
      {
        "txt": "return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); }"
      },
      {
        "txt": "final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) {"
      },
      {
        "txt": "dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getID(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId);"
      },
      {
        "txt": "if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); }"
      },
      {
        "txt": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) {"
      },
      {
        "txt": "zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() {"
      },
      {
        "txt": "return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); }"
      },
      {
        "txt": "setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\");"
      },
      {
        "txt": "} if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; }"
      },
      {
        "txt": "private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread();"
      },
      {
        "txt": "thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread();"
      },
      {
        "txt": "thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() { return cNameProvider;"
      },
      {
        "txt": "} public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) {"
      },
      {
        "txt": "nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try {"
      },
      {
        "txt": "nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider();"
      },
      {
        "txt": "} return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\");"
      },
      {
        "txt": "map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\");"
      },
      {
        "txt": "map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\");"
      },
      {
        "txt": "map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\");"
      },
      {
        "txt": "cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() {"
      },
      {
        "txt": "return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);"
      },
      {
        "txt": "} private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;"
      },
      {
        "txt": "buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); }"
      },
      {
        "txt": "private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) {"
      },
      {
        "txt": "if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID; } public abstract String getNameKey(long instant);"
      },
      {
        "txt": "public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID;"
      },
      {
        "txt": "} String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); }"
      },
      {
        "txt": "public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) {"
      },
      {
        "txt": "return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis());"
      },
      {
        "txt": "} public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) {"
      },
      {
        "txt": "if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) {"
      },
      {
        "txt": "int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) {"
      },
      {
        "txt": "int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal;"
      },
      {
        "txt": "int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) {"
      },
      {
        "txt": "if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) {"
      },
      {
        "txt": "if (strict) { throw new IllegalInstantException(instantLocal, getID()); } else { offset = offsetLocal; } } } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {"
      },
      {
        "txt": "throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant;"
      },
      {
        "txt": "} long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try { localDateTime.toDateTime(this);"
      },
      {
        "txt": "return false; } catch (IllegalInstantException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter);"
      },
      {
        "txt": "if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap }"
      },
      {
        "txt": "long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; } } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant);"
      },
      {
        "txt": "public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID(); }"
      },
      {
        "txt": "protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException {"
      },
      {
        "txt": "out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2920,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 262,
    "end-bug-line": 262,
    "bug": "int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);",
    "fix": "int hoursInMinutes = hoursOffset * 60;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap;"
      },
      {
        "txt": "import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder;"
      },
      {
        "txt": "import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);"
      },
      {
        "txt": "private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null);"
      },
      {
        "txt": "} public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try {"
      },
      {
        "txt": "String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) {"
      },
      {
        "txt": "} if (temp == null) { temp = UTC; } cDefault = zone = temp; } } } return zone; }"
      },
      {
        "txt": "public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone;"
      },
      {
        "txt": "} } @FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; }"
      },
      {
        "txt": "DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset);"
      },
      {
        "txt": "return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) {"
      },
      {
        "txt": "} if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { <extra_id_0> if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);"
      },
      {
        "txt": "} offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset);"
      },
      {
        "txt": "} public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null;"
      },
      {
        "txt": "String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; }"
      },
      {
        "txt": "if (convId == null) { convId = zone.getID(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset);"
      },
      {
        "txt": "} } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) {"
      },
      {
        "txt": "iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } }"
      },
      {
        "txt": "zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; }"
      },
      {
        "txt": "public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider();"
      },
      {
        "txt": "} Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");"
      },
      {
        "txt": "if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { }"
      },
      {
        "txt": "if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider();"
      },
      {
        "txt": "} return provider; } public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));"
      },
      {
        "txt": "} setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() {"
      },
      {
        "txt": "NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); }"
      },
      {
        "txt": "} } catch (SecurityException ex) { } if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion;"
      },
      {
        "txt": "if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible"
      },
      {
        "txt": "map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");"
      },
      {
        "txt": "map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\"); map.put(\"CTT\", \"Asia/Shanghai\");"
      },
      {
        "txt": "map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) {"
      },
      {
        "txt": "Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; }"
      },
      {
        "txt": "public String toString() { return getClass().getName(); } }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+');"
      },
      {
        "txt": "} else { buf.append('-'); offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2);"
      },
      {
        "txt": "offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString();"
      },
      {
        "txt": "} buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter();"
      },
      {
        "txt": "} return cOffsetFormatter; } private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; }"
      },
      {
        "txt": "@ToString public final String getID() { return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) {"
      },
      {
        "txt": "locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; }"
      },
      {
        "txt": "return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant);"
      },
      {
        "txt": "if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant);"
      },
      {
        "txt": "public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); }"
      },
      {
        "txt": "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal;"
      },
      {
        "txt": "} } } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; }"
      },
      {
        "txt": "} } return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); }"
      },
      {
        "txt": "return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict);"
      },
      {
        "txt": "} public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; }"
      },
      {
        "txt": "long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalInstantException(instantLocal, getID()); } else { offset = offsetLocal; }"
      },
      {
        "txt": "} } } long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {"
      },
      {
        "txt": "if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {"
      },
      {
        "txt": "if (isFixed()) { return false; } try { localDateTime.toDateTime(this); return false; } catch (IllegalInstantException ex) { return true; } }"
      },
      {
        "txt": "public long adjustOffset(long instant, boolean earlierOrLater) { long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore);"
      },
      {
        "txt": "long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant;"
      },
      {
        "txt": "} } public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() {"
      },
      {
        "txt": "return 57 + getID().hashCode(); } public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L;"
      },
      {
        "txt": "private transient String iID; Stub(String id) { iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); }"
      },
      {
        "txt": "private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2921,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 264,
    "end-bug-line": 264,
    "bug": "minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);",
    "fix": "minutesOffset = hoursInMinutes - minutesOffset;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider;"
      },
      {
        "txt": "import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider;"
      },
      {
        "txt": "private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() {"
      },
      {
        "txt": "DateTimeZone zone = cDefault; if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow"
      },
      {
        "txt": "temp = forID(id); } } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) {"
      },
      {
        "txt": "temp = UTC; } cDefault = zone = temp; } } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager();"
      },
      {
        "txt": "if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } }"
      },
      {
        "txt": "@FromString public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) {"
      },
      {
        "txt": "return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); }"
      },
      {
        "txt": "} throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { <extra_id_0> } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\");"
      },
      {
        "txt": "} catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) {"
      },
      {
        "txt": "if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) {"
      },
      {
        "txt": "dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getID();"
      },
      {
        "txt": "if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } }"
      },
      {
        "txt": "} throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); }"
      },
      {
        "txt": "DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));"
      },
      {
        "txt": "return zone; } public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager();"
      },
      {
        "txt": "if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs();"
      },
      {
        "txt": "if (ids == null || ids.size() == 0) { throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); }"
      },
      {
        "txt": "cProvider = provider; cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try {"
      },
      {
        "txt": "provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try {"
      },
      {
        "txt": "provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider;"
      },
      {
        "txt": "} public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider);"
      },
      {
        "txt": "} private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try {"
      },
      {
        "txt": "String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) {"
      },
      {
        "txt": "} if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>();"
      },
      {
        "txt": "map.put(\"GMT\", \"UTC\"); map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\");"
      },
      {
        "txt": "map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\");"
      },
      {
        "txt": "map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\");"
      },
      {
        "txt": "map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() {"
      },
      {
        "txt": "return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName();"
      },
      {
        "txt": "} }; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-');"
      },
      {
        "txt": "offset = -offset; } int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) {"
      },
      {
        "txt": "return buf.toString(); } int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.');"
      },
      {
        "txt": "FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter;"
      },
      {
        "txt": "} private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() {"
      },
      {
        "txt": "return iID; } public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); }"
      },
      {
        "txt": "String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); }"
      },
      {
        "txt": "public final String getName(long instant) { return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID;"
      },
      {
        "txt": "} String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) {"
      },
      {
        "txt": "return getOffset(DateTimeUtils.currentTimeMillis()); } return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal);"
      },
      {
        "txt": "final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } }"
      },
      {
        "txt": "} else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } }"
      },
      {
        "txt": "return offsetAdjusted; } public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; }"
      },
      {
        "txt": "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) {"
      },
      {
        "txt": "int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) {"
      },
      {
        "txt": "nextAdjusted = Long.MAX_VALUE; } if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalInstantException(instantLocal, getID()); } else { offset = offsetLocal; } } }"
      },
      {
        "txt": "} long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault();"
      },
      {
        "txt": "} if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false;"
      },
      {
        "txt": "} try { localDateTime.toDateTime(this); return false; } catch (IllegalInstantException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;"
      },
      {
        "txt": "long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff;"
      },
      {
        "txt": "if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; } }"
      },
      {
        "txt": "public abstract boolean isFixed(); public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); }"
      },
      {
        "txt": "public String toString() { return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) {"
      },
      {
        "txt": "iID = id; } private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID);"
      },
      {
        "txt": "} }"
      }
    ]
  },
  {
    "id": 2922,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 266,
    "end-bug-line": 266,
    "bug": "minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);",
    "fix": "minutesOffset = hoursInMinutes + minutesOffset;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException; import java.io.ObjectInputStream;"
      },
      {
        "txt": "import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone;"
      },
      {
        "txt": "import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone; import org.joda.time.tz.NameProvider;"
      },
      {
        "txt": "import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs; private static volatile DateTimeZone cDefault;"
      },
      {
        "txt": "private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault; if (zone == null) {"
      },
      {
        "txt": "synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id); }"
      },
      {
        "txt": "} catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC; }"
      },
      {
        "txt": "cDefault = zone = temp; } } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));"
      },
      {
        "txt": "} if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString public static DateTimeZone forID(String id) {"
      },
      {
        "txt": "if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; }"
      },
      {
        "txt": "if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");"
      },
      {
        "txt": "} public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);"
      },
      {
        "txt": "int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { <extra_id_0> } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset);"
      },
      {
        "txt": "} return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { String id = printOffset(millisOffset); return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault();"
      },
      {
        "txt": "} final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); }"
      },
      {
        "txt": "if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getID(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) { convId = convId.substring(3);"
      },
      {
        "txt": "int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } } throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");"
      },
      {
        "txt": "} private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone; Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);"
      },
      {
        "txt": "if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone; }"
      },
      {
        "txt": "public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));"
      },
      {
        "txt": "} setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) { throw new IllegalArgumentException"
      },
      {
        "txt": "(\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider; cAvailableIDs = ids;"
      },
      {
        "txt": "} private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance(); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\"); } catch (Exception ex) {"
      },
      {
        "txt": "Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; } public static NameProvider getNameProvider() {"
      },
      {
        "txt": "return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); } private static void setNameProvider0(NameProvider nameProvider) {"
      },
      {
        "txt": "if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\"); if (providerClass != null) {"
      },
      {
        "txt": "try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (nameProvider == null) {"
      },
      {
        "txt": "nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\"); map.put(\"WET\", \"WET\");"
      },
      {
        "txt": "map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\");"
      },
      {
        "txt": "map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\");"
      },
      {
        "txt": "map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\"); map.put(\"SST\", \"Pacific/Guadalcanal\");"
      },
      {
        "txt": "map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null; }"
      },
      {
        "txt": "public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } };"
      },
      {
        "txt": "return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset; }"
      },
      {
        "txt": "int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString(); }"
      },
      {
        "txt": "int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3); return buf.toString();"
      },
      {
        "txt": "} private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; } private final String iID;"
      },
      {
        "txt": "protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID; }"
      },
      {
        "txt": "public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) {"
      },
      {
        "txt": "return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) { return getName(instant, null);"
      },
      {
        "txt": "} public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey);"
      },
      {
        "txt": "if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis()); }"
      },
      {
        "txt": "return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted);"
      },
      {
        "txt": "if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal >= 0) { long prev = previousTransition(instantAdjusted);"
      },
      {
        "txt": "if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }"
      },
      {
        "txt": "public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { int offsetOriginal = getOffset(originalInstantUTC);"
      },
      {
        "txt": "long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal); int offset = getOffset(instantLocal - offsetLocal);"
      },
      {
        "txt": "if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE; }"
      },
      {
        "txt": "if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalInstantException(instantLocal, getID()); } else { offset = offsetLocal; } } } } long instantUTC = instantLocal - offset;"
      },
      {
        "txt": "if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); } if (newZone == this) {"
      },
      {
        "txt": "return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; } try {"
      },
      {
        "txt": "localDateTime.toDateTime(this); return false; } catch (IllegalInstantException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore);"
      },
      {
        "txt": "long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap"
      },
      {
        "txt": "} long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; } } public abstract boolean isFixed(); public abstract long nextTransition(long instant);"
      },
      {
        "txt": "public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() { return getID();"
      },
      {
        "txt": "} protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id; }"
      },
      {
        "txt": "private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); } }"
      }
    ]
  },
  {
    "id": 2923,
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java",
    "start-bug-line": 282,
    "end-bug-line": 282,
    "bug": "",
    "fix": "if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.joda.time; import java.io.IOException;"
      },
      {
        "txt": "import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.ref.Reference; import java.lang.ref.SoftReference; import java.util.HashMap; import java.util.Locale; import java.util.Map; import java.util.Set;"
      },
      {
        "txt": "import java.util.TimeZone; import org.joda.convert.FromString; import org.joda.convert.ToString; import org.joda.time.chrono.BaseChronology; import org.joda.time.field.FieldUtils; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; import org.joda.time.format.FormatUtils; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.FixedDateTimeZone;"
      },
      {
        "txt": "import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; public abstract class DateTimeZone implements Serializable { private static final long serialVersionUID = 5546345482340108586L; public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0); private static Provider cProvider; private static NameProvider cNameProvider; private static Set<String> cAvailableIDs;"
      },
      {
        "txt": "private static volatile DateTimeZone cDefault; private static DateTimeFormatter cOffsetFormatter; private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache; private static Map<String, String> cZoneIdConversion; static { setProvider0(null); setNameProvider0(null); } public static DateTimeZone getDefault() { DateTimeZone zone = cDefault;"
      },
      {
        "txt": "if (zone == null) { synchronized(DateTimeZone.class) { zone = cDefault; if (zone == null) { DateTimeZone temp = null; try { try { String id = System.getProperty(\"user.timezone\"); if (id != null) { // null check avoids stack overflow temp = forID(id);"
      },
      {
        "txt": "} } catch (RuntimeException ex) { } if (temp == null) { temp = forTimeZone(TimeZone.getDefault()); } } catch (IllegalArgumentException ex) { } if (temp == null) { temp = UTC;"
      },
      {
        "txt": "} cDefault = zone = temp; } } } return zone; } public static void setDefault(DateTimeZone zone) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) {"
      },
      {
        "txt": "sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\")); } if (zone == null) { throw new IllegalArgumentException(\"The datetime zone must not be null\"); } synchronized(DateTimeZone.class) { cDefault = zone; } } @FromString"
      },
      {
        "txt": "public static DateTimeZone forID(String id) { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone;"
      },
      {
        "txt": "} if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = parseOffset(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = printOffset(offset); return fixedOffsetZone(id, offset); } }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { return forOffsetHoursMinutes(hoursOffset, 0); } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) {"
      },
      {
        "txt": "throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); }"
      },
      {
        "txt": "} catch (ArithmeticException ex) { throw new IllegalArgumentException(\"Offset is too large\"); } return forOffsetMillis(offset); } public static DateTimeZone forOffsetMillis(int millisOffset) { <extra_id_0> return fixedOffsetZone(id, millisOffset); } public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); }"
      },
      {
        "txt": "return getDefault(); } final String id = zone.getID(); if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId);"
      },
      {
        "txt": "} if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; } if (convId == null) { convId = zone.getID(); if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {"
      },
      {
        "txt": "convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) { return DateTimeZone.UTC; } else { convId = printOffset(offset); return fixedOffsetZone(convId, offset); } } }"
      },
      {
        "txt": "throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\"); } private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { if (offset == 0) { return DateTimeZone.UTC; } if (iFixedOffsetCache == null) { iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); } DateTimeZone zone;"
      },
      {
        "txt": "Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); if (ref != null) { zone = ref.get(); if (zone != null) { return zone; } } zone = new FixedDateTimeZone(id, null, offset, offset); iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); return zone;"
      },
      {
        "txt": "} public static Set<String> getAvailableIDs() { return cAvailableIDs; } public static Provider getProvider() { return cProvider; } public static void setProvider(Provider provider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) {"
      },
      {
        "txt": "sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\")); } setProvider0(provider); } private static void setProvider0(Provider provider) { if (provider == null) { provider = getDefaultProvider(); } Set<String> ids = provider.getAvailableIDs(); if (ids == null || ids.size() == 0) {"
      },
      {
        "txt": "throw new IllegalArgumentException (\"The provider doesn't have any available ids\"); } if (!ids.contains(\"UTC\")) { throw new IllegalArgumentException(\"The provider doesn't support UTC\"); } if (!UTC.equals(provider.getZone(\"UTC\"))) { throw new IllegalArgumentException(\"Invalid UTC zone provided\"); } cProvider = provider;"
      },
      {
        "txt": "cAvailableIDs = ids; } private static Provider getDefaultProvider() { Provider provider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { provider = (Provider) Class.forName(providerClass).newInstance();"
      },
      {
        "txt": "} catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { } if (provider == null) { try { provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");"
      },
      {
        "txt": "} catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } if (provider == null) { provider = new UTCProvider(); } return provider; }"
      },
      {
        "txt": "public static NameProvider getNameProvider() { return cNameProvider; } public static void setNameProvider(NameProvider nameProvider) throws SecurityException { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\")); } setNameProvider0(nameProvider); }"
      },
      {
        "txt": "private static void setNameProvider0(NameProvider nameProvider) { if (nameProvider == null) { nameProvider = getDefaultNameProvider(); } cNameProvider = nameProvider; } private static NameProvider getDefaultNameProvider() { NameProvider nameProvider = null; try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");"
      },
      {
        "txt": "if (providerClass != null) { try { nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); } catch (Exception ex) { Thread thread = Thread.currentThread(); thread.getThreadGroup().uncaughtException(thread, ex); } } } catch (SecurityException ex) { }"
      },
      {
        "txt": "if (nameProvider == null) { nameProvider = new DefaultNameProvider(); } return nameProvider; } private static synchronized String getConvertedId(String id) { Map<String, String> map = cZoneIdConversion; if (map == null) { map = new HashMap<String, String>(); map.put(\"GMT\", \"UTC\");"
      },
      {
        "txt": "map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible"
      },
      {
        "txt": "map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\");"
      },
      {
        "txt": "map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\"); map.put(\"CTT\", \"Asia/Shanghai\"); map.put(\"JST\", \"Asia/Tokyo\"); map.put(\"ACT\", \"Australia/Darwin\"); map.put(\"AET\", \"Australia/Sydney\");"
      },
      {
        "txt": "map.put(\"SST\", \"Pacific/Guadalcanal\"); map.put(\"NST\", \"Pacific/Auckland\"); cZoneIdConversion = map; } return map.get(id); } private static int parseOffset(String str) { Chronology chrono = new BaseChronology() { public DateTimeZone getZone() { return null;"
      },
      {
        "txt": "} public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); }"
      },
      {
        "txt": "}; return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); } private static String printOffset(int offset) { StringBuffer buf = new StringBuffer(); if (offset >= 0) { buf.append('+'); } else { buf.append('-'); offset = -offset;"
      },
      {
        "txt": "} int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; FormatUtils.appendPaddedInteger(buf, hours, 2); offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; buf.append(':'); FormatUtils.appendPaddedInteger(buf, minutes, 2); offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; if (offset == 0) { return buf.toString();"
      },
      {
        "txt": "} int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; buf.append(':'); FormatUtils.appendPaddedInteger(buf, seconds, 2); offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; if (offset == 0) { return buf.toString(); } buf.append('.'); FormatUtils.appendPaddedInteger(buf, offset, 3);"
      },
      {
        "txt": "return buf.toString(); } private static synchronized DateTimeFormatter offsetFormatter() { if (cOffsetFormatter == null) { cOffsetFormatter = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); } return cOffsetFormatter; }"
      },
      {
        "txt": "private final String iID; protected DateTimeZone(String id) { if (id == null) { throw new IllegalArgumentException(\"Id must not be null\"); } iID = id; } @ToString public final String getID() { return iID;"
      },
      {
        "txt": "} public abstract String getNameKey(long instant); public final String getShortName(long instant) { return getShortName(instant, null); } public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant);"
      },
      {
        "txt": "if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public final String getName(long instant) {"
      },
      {
        "txt": "return getName(instant, null); } public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; }"
      },
      {
        "txt": "String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return printOffset(getOffset(instant)); } public abstract int getOffset(long instant); public final int getOffset(ReadableInstant instant) { if (instant == null) { return getOffset(DateTimeUtils.currentTimeMillis());"
      },
      {
        "txt": "} return getOffset(instant.getMillis()); } public abstract int getStandardOffset(long instant); public boolean isStandardOffset(long instant) { return getOffset(instant) == getStandardOffset(instant); } public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal;"
      },
      {
        "txt": "final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } } else if (offsetLocal >= 0) {"
      },
      {
        "txt": "long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted;"
      },
      {
        "txt": "} public long convertUTCToLocal(long instantUTC) { int offset = getOffset(instantUTC); long instantLocal = instantUTC + offset; if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { throw new ArithmeticException(\"Adding time zone offset caused overflow\"); } return instantLocal; } public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {"
      },
      {
        "txt": "int offsetOriginal = getOffset(originalInstantUTC); long instantUTC = instantLocal - offsetOriginal; int offsetLocalFromOriginal = getOffset(instantUTC); if (offsetLocalFromOriginal == offsetOriginal) { return instantUTC; } return convertLocalToUTC(instantLocal, strict); } public long convertLocalToUTC(long instantLocal, boolean strict) { int offsetLocal = getOffset(instantLocal);"
      },
      {
        "txt": "int offset = getOffset(instantLocal - offsetLocal); if (offsetLocal != offset) { if (strict || offsetLocal < 0) { long nextLocal = nextTransition(instantLocal - offsetLocal); if (nextLocal == (instantLocal - offsetLocal)) { nextLocal = Long.MAX_VALUE; } long nextAdjusted = nextTransition(instantLocal - offset); if (nextAdjusted == (instantLocal - offset)) { nextAdjusted = Long.MAX_VALUE;"
      },
      {
        "txt": "} if (nextLocal != nextAdjusted) { if (strict) { throw new IllegalInstantException(instantLocal, getID()); } else { offset = offsetLocal; } } } }"
      },
      {
        "txt": "long instantUTC = instantLocal - offset; if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { throw new ArithmeticException(\"Subtracting time zone offset caused overflow\"); } return instantUTC; } public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { if (newZone == null) { newZone = DateTimeZone.getDefault(); }"
      },
      {
        "txt": "if (newZone == this) { return oldInstant; } long instantLocal = convertUTCToLocal(oldInstant); return newZone.convertLocalToUTC(instantLocal, false, oldInstant); } public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { if (isFixed()) { return false; }"
      },
      {
        "txt": "try { localDateTime.toDateTime(this); return false; } catch (IllegalInstantException ex) { return true; } } public long adjustOffset(long instant, boolean earlierOrLater) { long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;"
      },
      {
        "txt": "long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) {"
      },
      {
        "txt": "return instant; // not an overlap } long afterStart = instant - overlapStart; if (afterStart >= diff) { return earlierOrLater ? instant : instant - diff; } else { return earlierOrLater ? instant + diff : instant; } } public abstract boolean isFixed();"
      },
      {
        "txt": "public abstract long nextTransition(long instant); public abstract long previousTransition(long instant); public java.util.TimeZone toTimeZone() { return java.util.TimeZone.getTimeZone(iID); } public abstract boolean equals(Object object); public int hashCode() { return 57 + getID().hashCode(); } public String toString() {"
      },
      {
        "txt": "return getID(); } protected Object writeReplace() throws ObjectStreamException { return new Stub(iID); } private static final class Stub implements Serializable { private static final long serialVersionUID = -6471952376487863581L; private transient String iID; Stub(String id) { iID = id;"
      },
      {
        "txt": "} private void writeObject(ObjectOutputStream out) throws IOException { out.writeUTF(iID); } private void readObject(ObjectInputStream in) throws IOException { iID = in.readUTF(); } private Object readResolve() throws ObjectStreamException { return forID(iID); }"
      }
    ]
  }
]