[
  {
    "id": 962,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
    "start-bug-line": 98,
    "end-bug-line": 98,
    "bug": "private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";",
    "fix": "private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/%s_lang.txt\";",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.io.InputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.EnumMap; import java.util.HashSet; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Scanner;"
      },
      {
        "txt": "import java.util.Set; import java.util.regex.Pattern; public class Lang { private static final class LangRule { private final boolean acceptOnMatch; private final Set<String> languages; private final Pattern pattern; private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) { this.pattern = pattern; this.languages = languages;"
      },
      {
        "txt": "} public boolean matches(final String txt) { return this.pattern.matcher(txt).find(); } } private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class); <extra_id_0> static { for (final NameType s : NameType.values()) { Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s))); } } public static Lang instance(final NameType nameType) {"
      },
      {
        "txt": "} public static Lang instance(final NameType nameType) { return Langs.get(nameType); } public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) { final List<LangRule> rules = new ArrayList<LangRule>(); final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName); if (lRulesIS == null) { throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN); }"
      },
      {
        "txt": "final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING); try { boolean inExtendedComment = false; while (scanner.hasNextLine()) { final String rawLine = scanner.nextLine(); String line = rawLine; if (inExtendedComment) { if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; }"
      },
      {
        "txt": "} else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } line = line.trim(); if (line.length() == 0) {"
      },
      {
        "txt": "continue; // empty lines can be safely skipped } final String[] parts = line.split(\"\\\\s+\"); if (parts.length != 3) { throw new IllegalArgumentException(\"Malformed line '\" + rawLine + \"' in language resource '\" + languageRulesResourceName + \"'\"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split(\"\\\\+\"); final boolean accept = parts[2].equals(\"true\");"
      },
      {
        "txt": "rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } } finally { scanner.close(); } return new Lang(rules, languages); } private final Languages languages;"
      },
      {
        "txt": "private final List<LangRule> rules; private Lang(final List<LangRule> rules, final Languages languages) { this.rules = Collections.unmodifiableList(rules); this.languages = languages; } public String guessLanguage(final String text) { final Languages.LanguageSet ls = guessLanguages(text); return ls.isSingleton() ? ls.getAny() : Languages.ANY; } public Languages.LanguageSet guessLanguages(final String input) {"
      },
      {
        "txt": "final String text = input.toLowerCase(Locale.ENGLISH); final Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (final LangRule rule : this.rules) { if (rule.matches(text)) { if (rule.acceptOnMatch) { langs.retainAll(rule.languages); } else { langs.removeAll(rule.languages); } }"
      },
      {
        "txt": "} final Languages.LanguageSet ls = Languages.LanguageSet.from(langs); return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls; }"
      }
    ]
  },
  {
    "id": 963,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/Lang.java",
    "start-bug-line": 102,
    "end-bug-line": 102,
    "bug": "Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));",
    "fix": "Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.io.InputStream; import java.util.ArrayList; import java.util.Arrays;"
      },
      {
        "txt": "import java.util.Collections; import java.util.EnumMap; import java.util.HashSet; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Scanner; import java.util.Set; import java.util.regex.Pattern; public class Lang {"
      },
      {
        "txt": "private static final class LangRule { private final boolean acceptOnMatch; private final Set<String> languages; private final Pattern pattern; private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) { this.pattern = pattern; this.languages = languages; this.acceptOnMatch = acceptOnMatch; } public boolean matches(final String txt) {"
      },
      {
        "txt": "} } private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class); private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\"; static { for (final NameType s : NameType.values()) { <extra_id_0> } } public static Lang instance(final NameType nameType) { return Langs.get(nameType); } public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {"
      },
      {
        "txt": "} public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) { final List<LangRule> rules = new ArrayList<LangRule>(); final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName); if (lRulesIS == null) { throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN); } final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING); try { boolean inExtendedComment = false;"
      },
      {
        "txt": "while (scanner.hasNextLine()) { final String rawLine = scanner.nextLine(); String line = rawLine; if (inExtendedComment) { if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true;"
      },
      {
        "txt": "} else { final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } line = line.trim(); if (line.length() == 0) { continue; // empty lines can be safely skipped } final String[] parts = line.split(\"\\\\s+\");"
      },
      {
        "txt": "if (parts.length != 3) { throw new IllegalArgumentException(\"Malformed line '\" + rawLine + \"' in language resource '\" + languageRulesResourceName + \"'\"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split(\"\\\\+\"); final boolean accept = parts[2].equals(\"true\"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } }"
      },
      {
        "txt": "} } finally { scanner.close(); } return new Lang(rules, languages); } private final Languages languages; private final List<LangRule> rules; private Lang(final List<LangRule> rules, final Languages languages) { this.rules = Collections.unmodifiableList(rules);"
      },
      {
        "txt": "this.languages = languages; } public String guessLanguage(final String text) { final Languages.LanguageSet ls = guessLanguages(text); return ls.isSingleton() ? ls.getAny() : Languages.ANY; } public Languages.LanguageSet guessLanguages(final String input) { final String text = input.toLowerCase(Locale.ENGLISH); final Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (final LangRule rule : this.rules) {"
      },
      {
        "txt": "if (rule.matches(text)) { if (rule.acceptOnMatch) { langs.retainAll(rule.languages); } else { langs.removeAll(rule.languages); } } } final Languages.LanguageSet ls = Languages.LanguageSet.from(langs); return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;"
      }
    ]
  },
  {
    "id": 964,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
    "start-bug-line": 31,
    "end-bug-line": 31,
    "bug": "import java.util.TreeSet;",
    "fix": "import java.util.TreeMap;",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.EnumMap;"
      },
      {
        "txt": "import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Set; <extra_id_0> import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme; public class PhoneticEngine { static final class PhonemeBuilder { public static PhonemeBuilder empty(final Languages.LanguageSet languages) { return new PhonemeBuilder(new Rule.Phoneme(\"\", languages));"
      },
      {
        "txt": "public static PhonemeBuilder empty(final Languages.LanguageSet languages) { return new PhonemeBuilder(new Rule.Phoneme(\"\", languages)); } private final Set<Rule.Phoneme> phonemes; private PhonemeBuilder(final Rule.Phoneme phoneme) { this.phonemes = new LinkedHashSet<Rule.Phoneme>(); this.phonemes.add(phoneme); } private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) { this.phonemes = phonemes;"
      },
      {
        "txt": "} public void append(final CharSequence str) { for (final Rule.Phoneme ph : this.phonemes) { ph.append(str); } } public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) { final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes); EXPR: for (final Rule.Phoneme left : this.phonemes) { for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {"
      },
      {
        "txt": "final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages()); if (!languages.isEmpty()) { final Rule.Phoneme join = new Phoneme(left, right, languages); if (newPhonemes.size() < maxPhonemes) { newPhonemes.add(join); if (newPhonemes.size() >= maxPhonemes) { break EXPR; } } }"
      },
      {
        "txt": "} } this.phonemes.clear(); this.phonemes.addAll(newPhonemes); } public Set<Rule.Phoneme> getPhonemes() { return this.phonemes; } public String makeString() { final StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (final Rule.Phoneme ph : this.phonemes) { if (sb.length() > 0) { sb.append(\"|\"); } sb.append(ph.getPhonemeText()); } return sb.toString(); } } private static final class RulesApplication {"
      },
      {
        "txt": "private final Map<String, List<Rule>> finalRules; private final CharSequence input; private PhonemeBuilder phonemeBuilder; private int i; private final int maxPhonemes; private boolean found; public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) { if (finalRules == null) { throw new NullPointerException(\"The finalRules argument must not be null\");"
      },
      {
        "txt": "} this.finalRules = finalRules; this.phonemeBuilder = phonemeBuilder; this.input = input; this.i = i; this.maxPhonemes = maxPhonemes; } public int getI() { return this.i; }"
      },
      {
        "txt": "public PhonemeBuilder getPhonemeBuilder() { return this.phonemeBuilder; } public RulesApplication invoke() { this.found = false; int patternLength = 1; final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength)); if (rules != null) { for (final Rule rule : rules) { final String pattern = rule.getPattern();"
      },
      {
        "txt": "patternLength = pattern.length(); if (rule.patternAndContextMatches(this.input, this.i)) { this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes); this.found = true; break; } } } if (!this.found) { patternLength = 1;"
      },
      {
        "txt": "} this.i += patternLength; return this; } public boolean isFound() { return this.found; } } private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class); static {"
      },
      {
        "txt": "NAME_PREFIXES.put(NameType.ASHKENAZI, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\","
      },
      {
        "txt": "\"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); } private static String join(final Iterable<String> strings, final String sep) { final StringBuilder sb = new StringBuilder(); final Iterator<String> si = strings.iterator(); if (si.hasNext()) { sb.append(si.next()); } while (si.hasNext()) { sb.append(sep).append(si.next());"
      },
      {
        "txt": "} return sb.toString(); } private static final int DEFAULT_MAX_PHONEMES = 20; private final Lang lang; private final NameType nameType; private final RuleType ruleType; private final boolean concat; private final int maxPhonemes; public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {"
      },
      {
        "txt": "this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES); } public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) { if (ruleType == RuleType.RULES) { throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES); } this.nameType = nameType; this.ruleType = ruleType; this.concat = concat;"
      },
      {
        "txt": "this.lang = Lang.instance(nameType); this.maxPhonemes = maxPhonemes; } private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) { if (finalRules == null) { throw new NullPointerException(\"finalRules can not be null\"); } if (finalRules.isEmpty()) { return phonemeBuilder;"
      },
      {
        "txt": "} final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages()); final String phonemeText = phoneme.getPhonemeText().toString(); for (int i = 0; i < phonemeText.length();) { final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke(); final boolean found = rulesApplication.isFound(); subBuilder = rulesApplication.getPhonemeBuilder();"
      },
      {
        "txt": "if (!found) { subBuilder.append(phonemeText.subSequence(i, i + 1)); } i = rulesApplication.getI(); } phonemes.addAll(subBuilder.getPhonemes()); } return new PhonemeBuilder(phonemes); } public String encode(final String input) {"
      },
      {
        "txt": "final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); } public String encode(String input, final Languages.LanguageSet languageSet) { final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet); final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\"); final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'"
      },
      {
        "txt": "final String remainder = input.substring(2); final String combined = \"d\" + remainder; return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { if (input.startsWith(l + \" \")) { final String remainder = input.substring(l.length() + 1); // input without the prefix final String combined = l + remainder; // input with prefix without space return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; }"
      },
      {
        "txt": "} } final List<String> words = Arrays.asList(input.split(\"\\\\s+\")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split(\"'\"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart);"
      },
      {
        "txt": "} words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break;"
      },
      {
        "txt": "default: throw new IllegalStateException(\"Unreachable case: \" + this.nameType); } if (this.concat) { input = join(words2, \" \"); } else if (words2.size() == 1) { input = words.iterator().next(); } else { final StringBuilder result = new StringBuilder(); for (final String word : words2) {"
      },
      {
        "txt": "result.append(\"-\").append(encode(word)); } return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder();"
      },
      {
        "txt": "} phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } public Lang getLang() { return this.lang; } public NameType getNameType() { return this.nameType;"
      },
      {
        "txt": "} public RuleType getRuleType() { return this.ruleType; } public boolean isConcat() { return this.concat; } public int getMaxPhonemes() { return this.maxPhonemes; }"
      }
    ]
  },
  {
    "id": 965,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
    "start-bug-line": 338,
    "end-bug-line": 338,
    "bug": "final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);",
    "fix": "final Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.EnumMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Locale; import java.util.Map;"
      },
      {
        "txt": "import java.util.Set; import java.util.TreeSet; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme; public class PhoneticEngine { static final class PhonemeBuilder { public static PhonemeBuilder empty(final Languages.LanguageSet languages) { return new PhonemeBuilder(new Rule.Phoneme(\"\", languages)); } private final Set<Rule.Phoneme> phonemes;"
      },
      {
        "txt": "private PhonemeBuilder(final Rule.Phoneme phoneme) { this.phonemes = new LinkedHashSet<Rule.Phoneme>(); this.phonemes.add(phoneme); } private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) { this.phonemes = phonemes; } public void append(final CharSequence str) { for (final Rule.Phoneme ph : this.phonemes) { ph.append(str);"
      },
      {
        "txt": "} } public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) { final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes); EXPR: for (final Rule.Phoneme left : this.phonemes) { for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) { final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages()); if (!languages.isEmpty()) { final Rule.Phoneme join = new Phoneme(left, right, languages); if (newPhonemes.size() < maxPhonemes) {"
      },
      {
        "txt": "newPhonemes.add(join); if (newPhonemes.size() >= maxPhonemes) { break EXPR; } } } } } this.phonemes.clear(); this.phonemes.addAll(newPhonemes);"
      },
      {
        "txt": "} public Set<Rule.Phoneme> getPhonemes() { return this.phonemes; } public String makeString() { final StringBuilder sb = new StringBuilder(); for (final Rule.Phoneme ph : this.phonemes) { if (sb.length() > 0) { sb.append(\"|\"); }"
      },
      {
        "txt": "sb.append(ph.getPhonemeText()); } return sb.toString(); } } private static final class RulesApplication { private final Map<String, List<Rule>> finalRules; private final CharSequence input; private PhonemeBuilder phonemeBuilder; private int i;"
      },
      {
        "txt": "private final int maxPhonemes; private boolean found; public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) { if (finalRules == null) { throw new NullPointerException(\"The finalRules argument must not be null\"); } this.finalRules = finalRules; this.phonemeBuilder = phonemeBuilder; this.input = input;"
      },
      {
        "txt": "this.i = i; this.maxPhonemes = maxPhonemes; } public int getI() { return this.i; } public PhonemeBuilder getPhonemeBuilder() { return this.phonemeBuilder; } public RulesApplication invoke() {"
      },
      {
        "txt": "this.found = false; int patternLength = 1; final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength)); if (rules != null) { for (final Rule rule : rules) { final String pattern = rule.getPattern(); patternLength = pattern.length(); if (rule.patternAndContextMatches(this.input, this.i)) { this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes); this.found = true;"
      },
      {
        "txt": "break; } } } if (!this.found) { patternLength = 1; } this.i += patternLength; return this; }"
      },
      {
        "txt": "public boolean isFound() { return this.found; } } private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class); static { NAME_PREFIXES.put(NameType.ASHKENAZI, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.SEPHARDIC,"
      },
      {
        "txt": "Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); } private static String join(final Iterable<String> strings, final String sep) { final StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "final Iterator<String> si = strings.iterator(); if (si.hasNext()) { sb.append(si.next()); } while (si.hasNext()) { sb.append(sep).append(si.next()); } return sb.toString(); } private static final int DEFAULT_MAX_PHONEMES = 20;"
      },
      {
        "txt": "private final Lang lang; private final NameType nameType; private final RuleType ruleType; private final boolean concat; private final int maxPhonemes; public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) { this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES); } public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) {"
      },
      {
        "txt": "if (ruleType == RuleType.RULES) { throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES); } this.nameType = nameType; this.ruleType = ruleType; this.concat = concat; this.lang = Lang.instance(nameType); this.maxPhonemes = maxPhonemes; } private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,"
      },
      {
        "txt": "if (finalRules == null) { throw new NullPointerException(\"finalRules can not be null\"); } if (finalRules.isEmpty()) { return phonemeBuilder; } <extra_id_0> for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages()); final String phonemeText = phoneme.getPhonemeText().toString(); for (int i = 0; i < phonemeText.length();) { final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();"
      },
      {
        "txt": "final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke(); final boolean found = rulesApplication.isFound(); subBuilder = rulesApplication.getPhonemeBuilder(); if (!found) { subBuilder.append(phonemeText.subSequence(i, i + 1)); } i = rulesApplication.getI(); } phonemes.addAll(subBuilder.getPhonemes());"
      },
      {
        "txt": "} return new PhonemeBuilder(phonemes); } public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); } public String encode(String input, final Languages.LanguageSet languageSet) { final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet); final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");"
      },
      {
        "txt": "final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d' final String remainder = input.substring(2); final String combined = \"d\" + remainder; return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { if (input.startsWith(l + \" \")) {"
      },
      {
        "txt": "final String remainder = input.substring(l.length() + 1); // input without the prefix final String combined = l + remainder; // input with prefix without space return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; } } } final List<String> words = Arrays.asList(input.split(\"\\\\s+\")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC:"
      },
      {
        "txt": "for (final String aWord : words) { final String[] parts = aWord.split(\"'\"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType));"
      },
      {
        "txt": "break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException(\"Unreachable case: \" + this.nameType); } if (this.concat) { input = join(words2, \" \"); } else if (words2.size() == 1) {"
      },
      {
        "txt": "input = words.iterator().next(); } else { final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append(\"-\").append(encode(word)); } return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); for (int i = 0; i < input.length();) {"
      },
      {
        "txt": "final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } public Lang getLang() {"
      },
      {
        "txt": "return this.lang; } public NameType getNameType() { return this.nameType; } public RuleType getRuleType() { return this.ruleType; } public boolean isConcat() { return this.concat;"
      },
      {
        "txt": "} public int getMaxPhonemes() { return this.maxPhonemes; }"
      }
    ]
  },
  {
    "id": 966,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
    "start-bug-line": 361,
    "end-bug-line": 361,
    "bug": "phonemes.addAll(subBuilder.getPhonemes());",
    "fix": "for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) { if (phonemes.containsKey(newPhoneme)) { final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme); final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages()); phonemes.put(mergedPhoneme, mergedPhoneme); } else { phonemes.put(newPhoneme, newPhoneme); } }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.EnumMap;"
      },
      {
        "txt": "import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeSet; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme;"
      },
      {
        "txt": "public class PhoneticEngine { static final class PhonemeBuilder { public static PhonemeBuilder empty(final Languages.LanguageSet languages) { return new PhonemeBuilder(new Rule.Phoneme(\"\", languages)); } private final Set<Rule.Phoneme> phonemes; private PhonemeBuilder(final Rule.Phoneme phoneme) { this.phonemes = new LinkedHashSet<Rule.Phoneme>(); this.phonemes.add(phoneme); }"
      },
      {
        "txt": "private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) { this.phonemes = phonemes; } public void append(final CharSequence str) { for (final Rule.Phoneme ph : this.phonemes) { ph.append(str); } } public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) { final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);"
      },
      {
        "txt": "EXPR: for (final Rule.Phoneme left : this.phonemes) { for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) { final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages()); if (!languages.isEmpty()) { final Rule.Phoneme join = new Phoneme(left, right, languages); if (newPhonemes.size() < maxPhonemes) { newPhonemes.add(join); if (newPhonemes.size() >= maxPhonemes) { break EXPR; }"
      },
      {
        "txt": "} } } } this.phonemes.clear(); this.phonemes.addAll(newPhonemes); } public Set<Rule.Phoneme> getPhonemes() { return this.phonemes; }"
      },
      {
        "txt": "public String makeString() { final StringBuilder sb = new StringBuilder(); for (final Rule.Phoneme ph : this.phonemes) { if (sb.length() > 0) { sb.append(\"|\"); } sb.append(ph.getPhonemeText()); } return sb.toString(); }"
      },
      {
        "txt": "} private static final class RulesApplication { private final Map<String, List<Rule>> finalRules; private final CharSequence input; private PhonemeBuilder phonemeBuilder; private int i; private final int maxPhonemes; private boolean found; public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {"
      },
      {
        "txt": "if (finalRules == null) { throw new NullPointerException(\"The finalRules argument must not be null\"); } this.finalRules = finalRules; this.phonemeBuilder = phonemeBuilder; this.input = input; this.i = i; this.maxPhonemes = maxPhonemes; } public int getI() {"
      },
      {
        "txt": "return this.i; } public PhonemeBuilder getPhonemeBuilder() { return this.phonemeBuilder; } public RulesApplication invoke() { this.found = false; int patternLength = 1; final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength)); if (rules != null) {"
      },
      {
        "txt": "for (final Rule rule : rules) { final String pattern = rule.getPattern(); patternLength = pattern.length(); if (rule.patternAndContextMatches(this.input, this.i)) { this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes); this.found = true; break; } } }"
      },
      {
        "txt": "if (!this.found) { patternLength = 1; } this.i += patternLength; return this; } public boolean isFound() { return this.found; } }"
      },
      {
        "txt": "private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class); static { NAME_PREFIXES.put(NameType.ASHKENAZI, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.GENERIC,"
      },
      {
        "txt": "Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); } private static String join(final Iterable<String> strings, final String sep) { final StringBuilder sb = new StringBuilder(); final Iterator<String> si = strings.iterator(); if (si.hasNext()) { sb.append(si.next()); }"
      },
      {
        "txt": "while (si.hasNext()) { sb.append(sep).append(si.next()); } return sb.toString(); } private static final int DEFAULT_MAX_PHONEMES = 20; private final Lang lang; private final NameType nameType; private final RuleType ruleType; private final boolean concat;"
      },
      {
        "txt": "private final int maxPhonemes; public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) { this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES); } public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) { if (ruleType == RuleType.RULES) { throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES); } this.nameType = nameType;"
      },
      {
        "txt": "this.ruleType = ruleType; this.concat = concat; this.lang = Lang.instance(nameType); this.maxPhonemes = maxPhonemes; } private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) { if (finalRules == null) { throw new NullPointerException(\"finalRules can not be null\"); }"
      },
      {
        "txt": "if (finalRules.isEmpty()) { return phonemeBuilder; } final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages()); final String phonemeText = phoneme.getPhonemeText().toString(); for (int i = 0; i < phonemeText.length();) { final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();"
      },
      {
        "txt": "subBuilder = rulesApplication.getPhonemeBuilder(); if (!found) { subBuilder.append(phonemeText.subSequence(i, i + 1)); } i = rulesApplication.getI(); } <extra_id_0> } return new PhonemeBuilder(phonemes); } public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet);"
      },
      {
        "txt": "final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); } public String encode(String input, final Languages.LanguageSet languageSet) { final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet); final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\"); final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'"
      },
      {
        "txt": "final String remainder = input.substring(2); final String combined = \"d\" + remainder; return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { if (input.startsWith(l + \" \")) { final String remainder = input.substring(l.length() + 1); // input without the prefix final String combined = l + remainder; // input with prefix without space return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; }"
      },
      {
        "txt": "} } final List<String> words = Arrays.asList(input.split(\"\\\\s+\")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split(\"'\"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart);"
      },
      {
        "txt": "} words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break;"
      },
      {
        "txt": "default: throw new IllegalStateException(\"Unreachable case: \" + this.nameType); } if (this.concat) { input = join(words2, \" \"); } else if (words2.size() == 1) { input = words.iterator().next(); } else { final StringBuilder result = new StringBuilder(); for (final String word : words2) {"
      },
      {
        "txt": "result.append(\"-\").append(encode(word)); } return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder();"
      },
      {
        "txt": "} phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } public Lang getLang() { return this.lang; } public NameType getNameType() { return this.nameType;"
      },
      {
        "txt": "} public RuleType getRuleType() { return this.ruleType; } public boolean isConcat() { return this.concat; } public int getMaxPhonemes() { return this.maxPhonemes; }"
      }
    ]
  },
  {
    "id": 967,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java",
    "start-bug-line": 364,
    "end-bug-line": 364,
    "bug": "return new PhonemeBuilder(phonemes);",
    "fix": "return new PhonemeBuilder(phonemes.keySet());",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.EnumMap; import java.util.HashSet; import java.util.Iterator;"
      },
      {
        "txt": "import java.util.LinkedHashSet; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeSet; import org.apache.commons.codec.language.bm.Languages.LanguageSet; import org.apache.commons.codec.language.bm.Rule.Phoneme; public class PhoneticEngine { static final class PhonemeBuilder {"
      },
      {
        "txt": "public static PhonemeBuilder empty(final Languages.LanguageSet languages) { return new PhonemeBuilder(new Rule.Phoneme(\"\", languages)); } private final Set<Rule.Phoneme> phonemes; private PhonemeBuilder(final Rule.Phoneme phoneme) { this.phonemes = new LinkedHashSet<Rule.Phoneme>(); this.phonemes.add(phoneme); } private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) { this.phonemes = phonemes;"
      },
      {
        "txt": "} public void append(final CharSequence str) { for (final Rule.Phoneme ph : this.phonemes) { ph.append(str); } } public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) { final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes); EXPR: for (final Rule.Phoneme left : this.phonemes) { for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {"
      },
      {
        "txt": "final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages()); if (!languages.isEmpty()) { final Rule.Phoneme join = new Phoneme(left, right, languages); if (newPhonemes.size() < maxPhonemes) { newPhonemes.add(join); if (newPhonemes.size() >= maxPhonemes) { break EXPR; } } }"
      },
      {
        "txt": "} } this.phonemes.clear(); this.phonemes.addAll(newPhonemes); } public Set<Rule.Phoneme> getPhonemes() { return this.phonemes; } public String makeString() { final StringBuilder sb = new StringBuilder();"
      },
      {
        "txt": "for (final Rule.Phoneme ph : this.phonemes) { if (sb.length() > 0) { sb.append(\"|\"); } sb.append(ph.getPhonemeText()); } return sb.toString(); } } private static final class RulesApplication {"
      },
      {
        "txt": "private final Map<String, List<Rule>> finalRules; private final CharSequence input; private PhonemeBuilder phonemeBuilder; private int i; private final int maxPhonemes; private boolean found; public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) { if (finalRules == null) { throw new NullPointerException(\"The finalRules argument must not be null\");"
      },
      {
        "txt": "} this.finalRules = finalRules; this.phonemeBuilder = phonemeBuilder; this.input = input; this.i = i; this.maxPhonemes = maxPhonemes; } public int getI() { return this.i; }"
      },
      {
        "txt": "public PhonemeBuilder getPhonemeBuilder() { return this.phonemeBuilder; } public RulesApplication invoke() { this.found = false; int patternLength = 1; final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength)); if (rules != null) { for (final Rule rule : rules) { final String pattern = rule.getPattern();"
      },
      {
        "txt": "patternLength = pattern.length(); if (rule.patternAndContextMatches(this.input, this.i)) { this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes); this.found = true; break; } } } if (!this.found) { patternLength = 1;"
      },
      {
        "txt": "} this.i += patternLength; return this; } public boolean isFound() { return this.found; } } private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class); static {"
      },
      {
        "txt": "NAME_PREFIXES.put(NameType.ASHKENAZI, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet( new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\","
      },
      {
        "txt": "\"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\")))); } private static String join(final Iterable<String> strings, final String sep) { final StringBuilder sb = new StringBuilder(); final Iterator<String> si = strings.iterator(); if (si.hasNext()) { sb.append(si.next()); } while (si.hasNext()) { sb.append(sep).append(si.next());"
      },
      {
        "txt": "} return sb.toString(); } private static final int DEFAULT_MAX_PHONEMES = 20; private final Lang lang; private final NameType nameType; private final RuleType ruleType; private final boolean concat; private final int maxPhonemes; public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {"
      },
      {
        "txt": "this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES); } public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) { if (ruleType == RuleType.RULES) { throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES); } this.nameType = nameType; this.ruleType = ruleType; this.concat = concat;"
      },
      {
        "txt": "this.lang = Lang.instance(nameType); this.maxPhonemes = maxPhonemes; } private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) { if (finalRules == null) { throw new NullPointerException(\"finalRules can not be null\"); } if (finalRules.isEmpty()) { return phonemeBuilder;"
      },
      {
        "txt": "} final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR); for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) { PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages()); final String phonemeText = phoneme.getPhonemeText().toString(); for (int i = 0; i < phonemeText.length();) { final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke(); final boolean found = rulesApplication.isFound(); subBuilder = rulesApplication.getPhonemeBuilder();"
      },
      {
        "txt": "subBuilder.append(phonemeText.subSequence(i, i + 1)); } i = rulesApplication.getI(); } phonemes.addAll(subBuilder.getPhonemes()); } <extra_id_0> } public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); } public String encode(String input, final Languages.LanguageSet languageSet) {"
      },
      {
        "txt": "} public String encode(String input, final Languages.LanguageSet languageSet) { final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet); final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\"); final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d' final String remainder = input.substring(2); final String combined = \"d\" + remainder;"
      },
      {
        "txt": "return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { if (input.startsWith(l + \" \")) { final String remainder = input.substring(l.length() + 1); // input without the prefix final String combined = l + remainder; // input with prefix without space return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\"; } } }"
      },
      {
        "txt": "final List<String> words = Arrays.asList(input.split(\"\\\\s+\")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split(\"'\"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType));"
      },
      {
        "txt": "break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException(\"Unreachable case: \" + this.nameType);"
      },
      {
        "txt": "} if (this.concat) { input = join(words2, \" \"); } else if (words2.size() == 1) { input = words.iterator().next(); } else { final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append(\"-\").append(encode(word)); }"
      },
      {
        "txt": "return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);"
      },
      {
        "txt": "phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } public Lang getLang() { return this.lang; } public NameType getNameType() { return this.nameType; } public RuleType getRuleType() {"
      },
      {
        "txt": "return this.ruleType; } public boolean isConcat() { return this.concat; } public int getMaxPhonemes() { return this.maxPhonemes; }"
      }
    ]
  },
  {
    "id": 968,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
    "start-bug-line": 158,
    "end-bug-line": 158,
    "bug": "",
    "fix": "public Phoneme mergeWithLanguage(final LanguageSet lang) { return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang)); }",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.io.InputStream;"
      },
      {
        "txt": "import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.EnumMap; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Scanner;"
      },
      {
        "txt": "import java.util.Set; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.apache.commons.codec.language.bm.Languages.LanguageSet; public class Rule { public static final class Phoneme implements PhonemeExpr { public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() { @Override public int compare(final Phoneme o1, final Phoneme o2) { for (int i = 0; i < o1.phonemeText.length(); i++) {"
      },
      {
        "txt": "if (i >= o2.phonemeText.length()) { return +1; } final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i); if (c != 0) { return c; } } if (o1.phonemeText.length() < o2.phonemeText.length()) { return -1;"
      },
      {
        "txt": "} return 0; } }; private final StringBuilder phonemeText; private final Languages.LanguageSet languages; public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) { this.phonemeText = new StringBuilder(phonemeText); this.languages = languages; }"
      },
      {
        "txt": "public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) { this(phonemeLeft.phonemeText, phonemeLeft.languages); this.phonemeText.append(phonemeRight.phonemeText); } public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) { this(phonemeLeft.phonemeText, languages); this.phonemeText.append(phonemeRight.phonemeText); } public Phoneme append(final CharSequence str) { this.phonemeText.append(str);"
      },
      {
        "txt": "return this; } public Languages.LanguageSet getLanguages() { return this.languages; } @Override public Iterable<Phoneme> getPhonemes() { return Collections.singleton(this); } public CharSequence getPhonemeText() {"
      },
      {
        "txt": "} @Deprecated public Phoneme join(final Phoneme right) { return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages)); } <extra_id_0> @Override public String toString() { return phonemeText.toString() + \"[\" + languages + \"]\"; } } public interface PhonemeExpr {"
      },
      {
        "txt": "} public interface PhonemeExpr { Iterable<Phoneme> getPhonemes(); } public static final class PhonemeList implements PhonemeExpr { private final List<Phoneme> phonemes; public PhonemeList(final List<Phoneme> phonemes) { this.phonemes = phonemes; } @Override"
      },
      {
        "txt": "public List<Phoneme> getPhonemes() { return this.phonemes; } } public interface RPattern { boolean isMatch(CharSequence input); } public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() { @Override public boolean isMatch(final CharSequence input) {"
      },
      {
        "txt": "return true; } }; public static final String ALL = \"ALL\"; private static final String DOUBLE_QUOTE = \"\\\"\"; private static final String HASH_INCLUDE = \"#include\"; private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES = new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class); static { for (final NameType s : NameType.values()) {"
      },
      {
        "txt": "final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts = new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class); for (final RuleType rt : RuleType.values()) { final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>(); final Languages ls = Languages.getInstance(s); for (final String l : ls.getLanguages()) { try { rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l))); } catch (final IllegalStateException e) { throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);"
      },
      {
        "txt": "} } if (!rt.equals(RuleType.RULES)) { rs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\"))); } rts.put(rt, Collections.unmodifiableMap(rs)); } RULES.put(s, Collections.unmodifiableMap(rts)); } }"
      },
      {
        "txt": "private static boolean contains(final CharSequence chars, final char input) { for (int i = 0; i < chars.length(); i++) { if (chars.charAt(i) == input) { return true; } } return false; } private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) { return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\","
      },
      {
        "txt": "nameType.getName(), rt.getName(), lang); } private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) { final String resName = createResourceName(nameType, rt, lang); final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName); if (rulesIS == null) { throw new IllegalArgumentException(\"Unable to load resource: \" + resName); } return new Scanner(rulesIS, ResourceConstants.ENCODING); }"
      },
      {
        "txt": "private static Scanner createScanner(final String lang) { final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang); final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName); if (rulesIS == null) { throw new IllegalArgumentException(\"Unable to load resource: \" + resName); } return new Scanner(rulesIS, ResourceConstants.ENCODING); } private static boolean endsWith(final CharSequence input, final CharSequence suffix) { if (suffix.length() > input.length()) {"
      },
      {
        "txt": "return false; } for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) { if (input.charAt(i) != suffix.charAt(j)) { return false; } } return true; } public static List<Rule> getInstance(final NameType nameType, final RuleType rt,"
      },
      {
        "txt": "final Languages.LanguageSet langs) { final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs); final List<Rule> allRules = new ArrayList<Rule>(); for (final List<Rule> rules : ruleMap.values()) { allRules.addAll(rules); } return allRules; } public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) { return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));"
      },
      {
        "txt": "} public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) { return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) : getInstanceMap(nameType, rt, Languages.ANY); } public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final String lang) { final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang); if (rules == null) {"
      },
      {
        "txt": "throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\", nameType.getName(), rt.getName(), lang)); } return rules; } private static Phoneme parsePhoneme(final String ph) { final int open = ph.indexOf(\"[\"); if (open >= 0) { if (!ph.endsWith(\"]\")) { throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");"
      },
      {
        "txt": "} final String before = ph.substring(0, open); final String in = ph.substring(open + 1, ph.length() - 1); final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\"))); return new Phoneme(before, Languages.LanguageSet.from(langs)); } else { return new Phoneme(ph, Languages.ANY_LANGUAGE); } } private static PhonemeExpr parsePhonemeExpr(final String ph) {"
      },
      {
        "txt": "if (ph.startsWith(\"(\")) { // we have a bracketed list of options if (!ph.endsWith(\")\")) { throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\"); } final List<Phoneme> phs = new ArrayList<Phoneme>(); final String body = ph.substring(1, ph.length() - 1); for (final String part : body.split(\"[|]\")) { phs.add(parsePhoneme(part)); } if (body.startsWith(\"|\") || body.endsWith(\"|\")) {"
      },
      {
        "txt": "phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE)); } return new PhonemeList(phs); } else { return parsePhoneme(ph); } } private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) { final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>(); int currentLine = 0;"
      },
      {
        "txt": "boolean inMultilineComment = false; while (scanner.hasNextLine()) { currentLine++; final String rawLine = scanner.nextLine(); String line = rawLine; if (inMultilineComment) { if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inMultilineComment = false; } } else {"
      },
      {
        "txt": "if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } line = line.trim(); if (line.length() == 0) { continue; // empty lines can be safely skipped"
      },
      {
        "txt": "} if (line.startsWith(HASH_INCLUDE)) { final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(\" \")) { throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" + location); } else { lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl)); } } else {"
      },
      {
        "txt": "final String[] parts = line.split(\"\\\\s+\"); if (parts.length != 4) { throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location); } else { try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));"
      },
      {
        "txt": "final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(\"Rule\"); sb.append(\"{line=\").append(myLine); sb.append(\", loc='\").append(loc).append('\\'');"
      },
      {
        "txt": "sb.append(\", pat='\").append(pat).append('\\''); sb.append(\", lcon='\").append(lCon).append('\\''); sb.append(\", rcon='\").append(rCon).append('\\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) {"
      },
      {
        "txt": "rules = new ArrayList<Rule>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e); } } }"
      },
      {
        "txt": "} } } return lines; } private static RPattern pattern(final String regex) { final boolean startsWith = regex.startsWith(\"^\"); final boolean endsWith = regex.endsWith(\"$\"); final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length()); final boolean boxes = content.contains(\"[\");"
      },
      {
        "txt": "if (!boxes) { if (startsWith && endsWith) { if (content.length() == 0) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } else {"
      },
      {
        "txt": "return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { return ALL_STRINGS_RMATCHER; } else if (startsWith) {"
      },
      {
        "txt": "return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) {"
      },
      {
        "txt": "return endsWith(input, content); } }; } } else { final boolean startsWithBox = content.startsWith(\"[\"); final boolean endsWithBox = content.endsWith(\"]\"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains(\"[\")) {"
      },
      {
        "txt": "final boolean negate = boxContent.startsWith(\"^\"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) {"
      },
      {
        "txt": "return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } };"
      },
      {
        "txt": "} else if (endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } }"
      },
      {
        "txt": "} } return new RPattern() { Pattern pattern = Pattern.compile(regex); @Override public boolean isMatch(final CharSequence input) { final Matcher matcher = pattern.matcher(input); return matcher.find(); } };"
      },
      {
        "txt": "} private static boolean startsWith(final CharSequence input, final CharSequence prefix) { if (prefix.length() > input.length()) { return false; } for (int i = 0; i < prefix.length(); i++) { if (input.charAt(i) != prefix.charAt(i)) { return false; } }"
      },
      {
        "txt": "return true; } private static String stripQuotes(String str) { if (str.startsWith(DOUBLE_QUOTE)) { str = str.substring(1); } if (str.endsWith(DOUBLE_QUOTE)) { str = str.substring(0, str.length() - 1); } return str;"
      },
      {
        "txt": "} private final RPattern lContext; private final String pattern; private final PhonemeExpr phoneme; private final RPattern rContext; public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) { this.pattern = pattern; this.lContext = pattern(lContext + \"$\"); this.rContext = pattern(\"^\" + rContext); this.phoneme = phoneme;"
      },
      {
        "txt": "} public RPattern getLContext() { return this.lContext; } public String getPattern() { return this.pattern; } public PhonemeExpr getPhoneme() { return this.phoneme; }"
      },
      {
        "txt": "public RPattern getRContext() { return this.rContext; } public boolean patternAndContextMatches(final CharSequence input, final int i) { if (i < 0) { throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\"); } final int patternLength = this.pattern.length(); final int ipl = i + patternLength; if (ipl > input.length()) {"
      },
      {
        "txt": "return false; } if (!input.subSequence(i, ipl).equals(this.pattern)) { return false; } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) { return false; } return this.lContext.isMatch(input.subSequence(0, i)); }"
      }
    ]
  },
  {
    "id": 969,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
    "start-bug-line": 0,
    "end-bug-line": 0,
    "bug": "",
    "fix": "/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */  // ASHKENAZIC  // 1. following are rules to accept the language // 1.1 Special letter combinations zh polish+russian+german+english true eau french true [aoeiu\u00e4\u00f6\u00fc]h german true ^vogel german, true vogel$ german true witz german true tz$ german+russian+english true ^tz russian+english true g\u00fce spanish true g\u00fci spanish true ghe romanian true ghi romanian true vici$ romanian true schi$ romanian true chsch german true tsch german true ssch german true sch$ german+russian true ^sch german+russian true ^rz polish true rz$ polish+german true [^aoeiu\u00e4\u00f6\u00fc]rz polish true rz[^aoeiu\u00e4\u00f6\u00fc] polish true cki$ polish true ska$ polish true cka$ polish true ue german+russian true ae german+russian+english true oe german+french+russian+english true th$ german true ^th german true th[^aoeiu] german true mann german true cz polish true cy polish true niew polish true stein german true heim$ german true heimer$ german true ii$ russian true iy$ russian true yy$ russian true yi$ russian true yj$ russian true ij$ russian true gaus$ russian true gauz$ russian true gauz$ russian true goltz$ russian true gol'tz$ russian true golts$ russian true gol'ts$ russian true ^goltz russian true ^gol'tz russian true ^golts russian true ^gol'ts russian true gendler$ russian true gejmer$ russian true gejm$ russian true geimer$ russian true geim$ russian true geymer russian true geym$ russian true gof$ russian true thal german true zweig german true ck$ german+english true c$ polish+romanian+hungarian true sz polish+hungarian true gue spanish+french true gui spanish+french true guy french true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german true  gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian true ly hungarian+russian+polish true ny hungarian+russian+polish true ty hungarian+russian+polish true  // 1.2 special characters \u00e2 romanian+french true \u0103 romanian true \u00e0 french true \u00e4 german true \u00e1 hungarian+spanish true \u0105 polish true \u0107 polish true \u00e7 french true \u0119 polish true \u00e9 french+hungarian+spanish true \u00e8 french true \u00ea french true \u00ed hungarian+spanish true \u00ee romanian+french true \u0142 polish true \u0144 polish true \u00f1 spanish true \u00f3 polish+hungarian+spanish true \u00f6 german+hungarian true \u00f5 hungarian true \u015f romanian true \u015b polish true \u0163 romanian true \u00fc german+hungarian true \u00f9 french true \u0171 hungarian true \u00fa hungarian+spanish true \u017a polish true \u017c polish true  \u00df german true  // Every Cyrillic word has at least one Cyrillic vowel (\u0430\u0451\u0435\u043e\u0438\u0443\u044b\u044d\u044e\u044f) \u0430 cyrillic true \u0451 cyrillic true \u043e cyrillic true \u0435 cyrillic true \u0438 cyrillic true \u0443 cyrillic true \u044b cyrillic true \u044d cyrillic true \u044e cyrillic true \u044f cyrillic true  // Hebrew \u05d0 hebrew true \u05d1 hebrew true \u05d2 ebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true   // 2. following are rules to reject the language // Every Latin character word has at least one Latin vowel a cyrillic+hebrew false o cyrillic+hebrew false e cyrillic+hebrew false i cyrillic+hebrew false y cyrillic+hebrew+romanian false u cyrillic+hebrew false  v[^aoeiu\u00e4\u00fc\u00f6] german false // in german \"v\" can be found before a vowel only y[^aoeiu] german false  // in german \"y\" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french false ou german false aj german+english+french false ej german+english+french false oj german+english+french false uj german+english+french false k romanian false v polish false ky polish false eu russian+polish false w french+romanian+spanish+hungarian+russian false kie french+spanish false gie french+romanian+spanish false q hungarian+polish+russian+romanian false sch hungarian+polish+french+spanish false ^h russian false",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.io.InputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator;"
      },
      {
        "txt": "import java.util.Collections; import java.util.Comparator; import java.util.EnumMap; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Scanner; import java.util.Set; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import org.apache.commons.codec.language.bm.Languages.LanguageSet; public class Rule { public static final class Phoneme implements PhonemeExpr { public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() { @Override public int compare(final Phoneme o1, final Phoneme o2) { for (int i = 0; i < o1.phonemeText.length(); i++) { if (i >= o2.phonemeText.length()) { return +1;"
      },
      {
        "txt": "} final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i); if (c != 0) { return c; } } if (o1.phonemeText.length() < o2.phonemeText.length()) { return -1; } return 0;"
      },
      {
        "txt": "} }; private final StringBuilder phonemeText; private final Languages.LanguageSet languages; public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) { this.phonemeText = new StringBuilder(phonemeText); this.languages = languages; } public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) { this(phonemeLeft.phonemeText, phonemeLeft.languages);"
      },
      {
        "txt": "this.phonemeText.append(phonemeRight.phonemeText); } public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) { this(phonemeLeft.phonemeText, languages); this.phonemeText.append(phonemeRight.phonemeText); } public Phoneme append(final CharSequence str) { this.phonemeText.append(str); return this; }"
      },
      {
        "txt": "public Languages.LanguageSet getLanguages() { return this.languages; } @Override public Iterable<Phoneme> getPhonemes() { return Collections.singleton(this); } public CharSequence getPhonemeText() { return this.phonemeText; }"
      },
      {
        "txt": "@Deprecated public Phoneme join(final Phoneme right) { return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages)); } @Override public String toString() { return phonemeText.toString() + \"[\" + languages + \"]\"; } }"
      },
      {
        "txt": "public interface PhonemeExpr { Iterable<Phoneme> getPhonemes(); } public static final class PhonemeList implements PhonemeExpr { private final List<Phoneme> phonemes; public PhonemeList(final List<Phoneme> phonemes) { this.phonemes = phonemes; } @Override public List<Phoneme> getPhonemes() {"
      },
      {
        "txt": "return this.phonemes; } } public interface RPattern { boolean isMatch(CharSequence input); } public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() { @Override public boolean isMatch(final CharSequence input) { return true;"
      },
      {
        "txt": "} }; public static final String ALL = \"ALL\"; private static final String DOUBLE_QUOTE = \"\\\"\"; private static final String HASH_INCLUDE = \"#include\"; private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES = new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class); static { for (final NameType s : NameType.values()) { final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts ="
      },
      {
        "txt": "new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class); for (final RuleType rt : RuleType.values()) { final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>(); final Languages ls = Languages.getInstance(s); for (final String l : ls.getLanguages()) { try { rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l))); } catch (final IllegalStateException e) { throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e); }"
      },
      {
        "txt": "} if (!rt.equals(RuleType.RULES)) { rs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\"))); } rts.put(rt, Collections.unmodifiableMap(rs)); } RULES.put(s, Collections.unmodifiableMap(rts)); } } private static boolean contains(final CharSequence chars, final char input) {"
      },
      {
        "txt": "for (int i = 0; i < chars.length(); i++) { if (chars.charAt(i) == input) { return true; } } return false; } private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) { return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);"
      },
      {
        "txt": "} private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) { final String resName = createResourceName(nameType, rt, lang); final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName); if (rulesIS == null) { throw new IllegalArgumentException(\"Unable to load resource: \" + resName); } return new Scanner(rulesIS, ResourceConstants.ENCODING); } private static Scanner createScanner(final String lang) {"
      },
      {
        "txt": "final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang); final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName); if (rulesIS == null) { throw new IllegalArgumentException(\"Unable to load resource: \" + resName); } return new Scanner(rulesIS, ResourceConstants.ENCODING); } private static boolean endsWith(final CharSequence input, final CharSequence suffix) { if (suffix.length() > input.length()) { return false;"
      },
      {
        "txt": "} for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) { if (input.charAt(i) != suffix.charAt(j)) { return false; } } return true; } public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {"
      },
      {
        "txt": "final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs); final List<Rule> allRules = new ArrayList<Rule>(); for (final List<Rule> rules : ruleMap.values()) { allRules.addAll(rules); } return allRules; } public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) { return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang)))); }"
      },
      {
        "txt": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) { return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) : getInstanceMap(nameType, rt, Languages.ANY); } public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final String lang) { final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang); if (rules == null) { throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\","
      },
      {
        "txt": "nameType.getName(), rt.getName(), lang)); } return rules; } private static Phoneme parsePhoneme(final String ph) { final int open = ph.indexOf(\"[\"); if (open >= 0) { if (!ph.endsWith(\"]\")) { throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\"); }"
      },
      {
        "txt": "final String before = ph.substring(0, open); final String in = ph.substring(open + 1, ph.length() - 1); final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\"))); return new Phoneme(before, Languages.LanguageSet.from(langs)); } else { return new Phoneme(ph, Languages.ANY_LANGUAGE); } } private static PhonemeExpr parsePhonemeExpr(final String ph) { if (ph.startsWith(\"(\")) { // we have a bracketed list of options"
      },
      {
        "txt": "if (!ph.endsWith(\")\")) { throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\"); } final List<Phoneme> phs = new ArrayList<Phoneme>(); final String body = ph.substring(1, ph.length() - 1); for (final String part : body.split(\"[|]\")) { phs.add(parsePhoneme(part)); } if (body.startsWith(\"|\") || body.endsWith(\"|\")) { phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));"
      },
      {
        "txt": "} return new PhonemeList(phs); } else { return parsePhoneme(ph); } } private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) { final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>(); int currentLine = 0; boolean inMultilineComment = false;"
      },
      {
        "txt": "while (scanner.hasNextLine()) { currentLine++; final String rawLine = scanner.nextLine(); String line = rawLine; if (inMultilineComment) { if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inMultilineComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) {"
      },
      {
        "txt": "inMultilineComment = true; } else { final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } line = line.trim(); if (line.length() == 0) { continue; // empty lines can be safely skipped }"
      },
      {
        "txt": "if (line.startsWith(HASH_INCLUDE)) { final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(\" \")) { throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" + location); } else { lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl)); } } else { final String[] parts = line.split(\"\\\\s+\");"
      },
      {
        "txt": "if (parts.length != 4) { throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location); } else { try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine;"
      },
      {
        "txt": "final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(\"Rule\"); sb.append(\"{line=\").append(myLine); sb.append(\", loc='\").append(loc).append('\\''); sb.append(\", pat='\").append(pat).append('\\'');"
      },
      {
        "txt": "sb.append(\", lcon='\").append(lCon).append('\\''); sb.append(\", rcon='\").append(rCon).append('\\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<Rule>();"
      },
      {
        "txt": "lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e); } } } }"
      },
      {
        "txt": "} } return lines; } private static RPattern pattern(final String regex) { final boolean startsWith = regex.startsWith(\"^\"); final boolean endsWith = regex.endsWith(\"$\"); final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length()); final boolean boxes = content.contains(\"[\"); if (!boxes) {"
      },
      {
        "txt": "if (startsWith && endsWith) { if (content.length() == 0) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() {"
      },
      {
        "txt": "@Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { return ALL_STRINGS_RMATCHER; } else if (startsWith) { return new RPattern() {"
      },
      {
        "txt": "@Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content);"
      },
      {
        "txt": "} }; } } else { final boolean startsWithBox = content.startsWith(\"[\"); final boolean endsWithBox = content.endsWith(\"]\"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains(\"[\")) { final boolean negate = boxContent.startsWith(\"^\");"
      },
      {
        "txt": "if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;"
      },
      {
        "txt": "} }; } else if (startsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) {"
      },
      {
        "txt": "return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } }"
      },
      {
        "txt": "} return new RPattern() { Pattern pattern = Pattern.compile(regex); @Override public boolean isMatch(final CharSequence input) { final Matcher matcher = pattern.matcher(input); return matcher.find(); } }; }"
      },
      {
        "txt": "private static boolean startsWith(final CharSequence input, final CharSequence prefix) { if (prefix.length() > input.length()) { return false; } for (int i = 0; i < prefix.length(); i++) { if (input.charAt(i) != prefix.charAt(i)) { return false; } } return true;"
      },
      {
        "txt": "} private static String stripQuotes(String str) { if (str.startsWith(DOUBLE_QUOTE)) { str = str.substring(1); } if (str.endsWith(DOUBLE_QUOTE)) { str = str.substring(0, str.length() - 1); } return str; }"
      },
      {
        "txt": "private final RPattern lContext; private final String pattern; private final PhonemeExpr phoneme; private final RPattern rContext; public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) { this.pattern = pattern; this.lContext = pattern(lContext + \"$\"); this.rContext = pattern(\"^\" + rContext); this.phoneme = phoneme; }"
      },
      {
        "txt": "public RPattern getLContext() { return this.lContext; } public String getPattern() { return this.pattern; } public PhonemeExpr getPhoneme() { return this.phoneme; } public RPattern getRContext() {"
      },
      {
        "txt": "return this.rContext; } public boolean patternAndContextMatches(final CharSequence input, final int i) { if (i < 0) { throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\"); } final int patternLength = this.pattern.length(); final int ipl = i + patternLength; if (ipl > input.length()) { return false;"
      },
      {
        "txt": "} if (!input.subSequence(i, ipl).equals(this.pattern)) { return false; } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) { return false; } return this.lContext.isMatch(input.subSequence(0, i)); }"
      }
    ]
  },
  {
    "id": 970,
    "file_path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
    "start-bug-line": 0,
    "end-bug-line": 0,
    "bug": "",
    "fix": "/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */  // GENERIC  // 1. following are rules to accept the language // 1.1 Special letter combinations ^o\u2019 english true ^o' english true ^mc english true ^fitz english true ceau french+romanian true eau romanian true eau$ french true // mp: I've added this eaux$ french true // mp: I've added this ault$ french true oult$ french true eux$ french true eix$ french true glou$ greeklatin true uu dutch true tx spanish true witz german true tz$ german+russian+english true ^tz russian+english true poulos$ greeklatin true pulos$ greeklatin true iou greeklatin true sj$ dutch true ^sj dutch true g\u00fce spanish true g\u00fci spanish true ghe romanian+greeklatin true ghi romanian+greeklatin true escu$ romanian true esco$ romanian true vici$ romanian true schi$ romanian true ii$ russian true iy$ russian true yy$ russian true yi$ russian true ^rz polish true rz$ polish+german true [bcdfgklmnpstwz]rz polish true rz[bcdfghklmnpstw] polish true cki$ polish true ska$ polish true cka$ polish true ae german+russian+english true oe german+french+russian+english+dutch true th$ german+english true ^th german+english+greeklatin true mann german true cz polish true cy polish+greeklatin true niew polish true etti$ italian true eti$ italian true ati$ italian true ato$ italian true [aoei]no$ italian true [aoei]ni$ italian true esi$ italian true oli$ italian true field$ english true stein german true heim$ german true heimer$ german true thal german true zweig german true [aeou]h german true \u00e4h german true \u00f6h german true \u00fch german true [ln]h[ao]$ portuguese true [ln]h[aou] portuguese+french+german+dutch+czech+spanish+turkish true chsch german true tsch german true sch$ german+russian true ^sch german+russian true ck$ german+english true c$ polish+romanian+hungarian+czech+turkish true sz polish+hungarian true cs$ hungarian true ^cs hungarian true dzs hungarian true zs$ hungarian true ^zs hungarian true ^wl polish true ^wr polish+english+german+dutch true  gy$ hungarian true gy[aeou] hungarian true gy hungarian+russian+french+greeklatin true guy french true gu[ei] spanish+french+portuguese true gu[ao] spanish+portuguese true gi[aou] italian+greeklatin true  ly hungarian+russian+polish+greeklatin true ny hungarian+russian+polish+spanish+greeklatin true ty hungarian+russian+polish+greeklatin true  // 1.2 special characters \u0107 polish true \u00e7 french+spanish+portuguese+turkish true \u010d czech true \u010f czech true \u011f turkish true \u0142 polish true \u0144 polish true \u00f1 spanish true \u0148 czech true \u0159 czech true \u015b polish true \u015f romanian+turkish true \u0161 czech true \u0163 romanian true \u0165 czech true \u017a polish true \u017c polish true  \u00df german true  \u00e4 german true \u00e1 hungarian+spanish+portuguese+czech+greeklatin true \u00e2 romanian+french+portuguese true \u0103 romanian true \u0105 polish true \u00e0 portuguese true \u00e3 portuguese true \u0119 polish true \u00e9 french+hungarian+czech+greeklatin true \u00e8 french+spanish+italian true \u00ea french true \u011b czech true \u00ea french+portuguese true \u00ed hungarian+spanish+portuguese+czech+greeklatin true \u00ee romanian+french true \u0131 turkish true \u00f3 polish+hungarian+spanish+italian+portuguese+czech+greeklatin true \u00f6 german+hungarian+turkish true \u00f4 french+portuguese true \u00f5 portuguese+hungarian true \u00f2 italian+spanish true \u0171 hungarian true \u00fa hungarian+spanish+portuguese+czech+greeklatin true \u00fc german+hungarian+spanish+portuguese+turkish true \u00f9 french true \u016f czech true \u00fd czech+greeklatin true  // Every Cyrillic word has at least one Cyrillic vowel (\u0430\u0451\u0435\u043e\u0438\u0443\u044b\u044d\u044e\u044f) \u0430 cyrillic true \u0451 cyrillic true \u043e cyrillic true \u0435 cyrillic true \u0438 cyrillic true \u0443 cyrillic true \u044b cyrillic true \u044d cyrillic true \u044e cyrillic true \u044f cyrillic true  // Every Greek word has at least one Greek vowel \u03b1 greek true \u03b5 greek true \u03b7 greek true \u03b9 greek true \u03bf greek true \u03c5 greek true \u03c9 greek true  // Arabic (only initial) \u0627 arabic true // alif (isol + init) \u0628 arabic true // ba' \u062a arabic true // ta' \u062b arabic true // tha' \u062c arabic true // jim \u062d arabic true // h.a' \u062e' arabic true // kha' \u062f arabic true // dal (isol + init) \u0630 arabic true // dhal (isol + init) \u0631 arabic true // ra' (isol + init) \u0632 arabic true // za' (isol + init) \u0633 arabic true // sin \u0634 arabic true // shin \u0635 arabic true // s.ad \u0636 arabic true // d.ad \u0637 arabic true // t.a' \u0638 arabic true // z.a' \u0639 arabic true // 'ayn \u063a arabic true // ghayn \u0641 arabic true // fa' \u0642 arabic true // qaf \u0643 arabic true // kaf \u0644 arabic true // lam \u0645 arabic true // mim \u0646 arabic true // nun \u0647 arabic true // ha' \u0648 arabic true // waw (isol + init) \u064a arabic true // ya'  \u0622 arabic true // alif madda \u0625 arabic true // alif + diacritic \u0623 arabic true // alif + hamza \u0624 arabic true //  waw + hamza \u0626 arabic true //  ya' + hamza \u0644\u0627 arabic true // ligature l+a  // Hebrew \u05d0 hebrew true \u05d1 hebrew true \u05d2 hebrew true \u05d3 hebrew true \u05d4 hebrew true \u05d5 hebrew true \u05d6 hebrew true \u05d7 hebrew true \u05d8 hebrew true \u05d9 hebrew true \u05db hebrew true \u05dc hebrew true \u05de hebrew true \u05e0 hebrew true \u05e1 hebrew true \u05e2 hebrew true \u05e4 hebrew true \u05e6 hebrew true \u05e7 hebrew true \u05e8 hebrew true \u05e9 hebrew true \u05ea hebrew true  // 2. following are rules to reject the language  // Every Latin character word has at least one Latin vowel a cyrillic+hebrew+greek+arabic false o cyrillic+hebrew+greek+arabic false e cyrillic+hebrew+greek+arabic false i cyrillic+hebrew+greek+arabic false y cyrillic+hebrew+greek+arabic+romanian+dutch false u cyrillic+hebrew+greek+arabic false  j italian false j[^aoeiuy] french+spanish+portuguese+greeklatin false g czech false k romanian+spanish+portuguese+french+italian false q hungarian+polish+russian+romanian+czech+dutch+turkish+greeklatin false v polish false w french+romanian+spanish+hungarian+russian+czech+turkish+greeklatin false x czech+hungarian+dutch+turkish false // polish excluded from the list  dj spanish+turkish false v[^aoeiu] german false // in german, \"v\" can be found before a vowel only y[^aoeiu] german false  // in german, \"y\" usually appears only in the last position; sometimes before a vowel c[^aohk] german false dzi german+english+french+turkish false ou german false a[eiou] turkish false // no diphthongs in Turkish \u00f6[eaiou] turkish false \u00fc[eaiou] turkish false e[aiou] turkish false i[aeou] turkish false o[aieu] turkish false u[aieo] turkish false aj german+english+french+dutch false ej german+english+french+dutch false oj german+english+french+dutch false uj german+english+french+dutch false eu russian+polish false ky polish false kie french+spanish+greeklatin false gie portuguese+romanian+spanish+greeklatin false ch[aou] italian false ch turkish false son$ german false sc[ei] french false sch hungarian+polish+french+spanish false ^h russian false",
    "fixes": [],
    "err": "",
    "ctxs": [
      {
        "txt": "package org.apache.commons.codec.language.bm; import java.io.InputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator;"
      },
      {
        "txt": "import java.util.Collections; import java.util.Comparator; import java.util.EnumMap; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Scanner; import java.util.Set; import java.util.regex.Matcher;"
      },
      {
        "txt": "import java.util.regex.Pattern; import org.apache.commons.codec.language.bm.Languages.LanguageSet; public class Rule { public static final class Phoneme implements PhonemeExpr { public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() { @Override public int compare(final Phoneme o1, final Phoneme o2) { for (int i = 0; i < o1.phonemeText.length(); i++) { if (i >= o2.phonemeText.length()) { return +1;"
      },
      {
        "txt": "} final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i); if (c != 0) { return c; } } if (o1.phonemeText.length() < o2.phonemeText.length()) { return -1; } return 0;"
      },
      {
        "txt": "} }; private final StringBuilder phonemeText; private final Languages.LanguageSet languages; public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) { this.phonemeText = new StringBuilder(phonemeText); this.languages = languages; } public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) { this(phonemeLeft.phonemeText, phonemeLeft.languages);"
      },
      {
        "txt": "this.phonemeText.append(phonemeRight.phonemeText); } public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) { this(phonemeLeft.phonemeText, languages); this.phonemeText.append(phonemeRight.phonemeText); } public Phoneme append(final CharSequence str) { this.phonemeText.append(str); return this; }"
      },
      {
        "txt": "public Languages.LanguageSet getLanguages() { return this.languages; } @Override public Iterable<Phoneme> getPhonemes() { return Collections.singleton(this); } public CharSequence getPhonemeText() { return this.phonemeText; }"
      },
      {
        "txt": "@Deprecated public Phoneme join(final Phoneme right) { return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages)); } @Override public String toString() { return phonemeText.toString() + \"[\" + languages + \"]\"; } }"
      },
      {
        "txt": "public interface PhonemeExpr { Iterable<Phoneme> getPhonemes(); } public static final class PhonemeList implements PhonemeExpr { private final List<Phoneme> phonemes; public PhonemeList(final List<Phoneme> phonemes) { this.phonemes = phonemes; } @Override public List<Phoneme> getPhonemes() {"
      },
      {
        "txt": "return this.phonemes; } } public interface RPattern { boolean isMatch(CharSequence input); } public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() { @Override public boolean isMatch(final CharSequence input) { return true;"
      },
      {
        "txt": "} }; public static final String ALL = \"ALL\"; private static final String DOUBLE_QUOTE = \"\\\"\"; private static final String HASH_INCLUDE = \"#include\"; private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES = new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class); static { for (final NameType s : NameType.values()) { final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts ="
      },
      {
        "txt": "new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class); for (final RuleType rt : RuleType.values()) { final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>(); final Languages ls = Languages.getInstance(s); for (final String l : ls.getLanguages()) { try { rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l))); } catch (final IllegalStateException e) { throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e); }"
      },
      {
        "txt": "} if (!rt.equals(RuleType.RULES)) { rs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\"))); } rts.put(rt, Collections.unmodifiableMap(rs)); } RULES.put(s, Collections.unmodifiableMap(rts)); } } private static boolean contains(final CharSequence chars, final char input) {"
      },
      {
        "txt": "for (int i = 0; i < chars.length(); i++) { if (chars.charAt(i) == input) { return true; } } return false; } private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) { return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);"
      },
      {
        "txt": "} private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) { final String resName = createResourceName(nameType, rt, lang); final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName); if (rulesIS == null) { throw new IllegalArgumentException(\"Unable to load resource: \" + resName); } return new Scanner(rulesIS, ResourceConstants.ENCODING); } private static Scanner createScanner(final String lang) {"
      },
      {
        "txt": "final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang); final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName); if (rulesIS == null) { throw new IllegalArgumentException(\"Unable to load resource: \" + resName); } return new Scanner(rulesIS, ResourceConstants.ENCODING); } private static boolean endsWith(final CharSequence input, final CharSequence suffix) { if (suffix.length() > input.length()) { return false;"
      },
      {
        "txt": "} for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) { if (input.charAt(i) != suffix.charAt(j)) { return false; } } return true; } public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {"
      },
      {
        "txt": "final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs); final List<Rule> allRules = new ArrayList<Rule>(); for (final List<Rule> rules : ruleMap.values()) { allRules.addAll(rules); } return allRules; } public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) { return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang)))); }"
      },
      {
        "txt": "public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) { return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) : getInstanceMap(nameType, rt, Languages.ANY); } public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final String lang) { final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang); if (rules == null) { throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\","
      },
      {
        "txt": "nameType.getName(), rt.getName(), lang)); } return rules; } private static Phoneme parsePhoneme(final String ph) { final int open = ph.indexOf(\"[\"); if (open >= 0) { if (!ph.endsWith(\"]\")) { throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\"); }"
      },
      {
        "txt": "final String before = ph.substring(0, open); final String in = ph.substring(open + 1, ph.length() - 1); final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\"))); return new Phoneme(before, Languages.LanguageSet.from(langs)); } else { return new Phoneme(ph, Languages.ANY_LANGUAGE); } } private static PhonemeExpr parsePhonemeExpr(final String ph) { if (ph.startsWith(\"(\")) { // we have a bracketed list of options"
      },
      {
        "txt": "if (!ph.endsWith(\")\")) { throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\"); } final List<Phoneme> phs = new ArrayList<Phoneme>(); final String body = ph.substring(1, ph.length() - 1); for (final String part : body.split(\"[|]\")) { phs.add(parsePhoneme(part)); } if (body.startsWith(\"|\") || body.endsWith(\"|\")) { phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));"
      },
      {
        "txt": "} return new PhonemeList(phs); } else { return parsePhoneme(ph); } } private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) { final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>(); int currentLine = 0; boolean inMultilineComment = false;"
      },
      {
        "txt": "while (scanner.hasNextLine()) { currentLine++; final String rawLine = scanner.nextLine(); String line = rawLine; if (inMultilineComment) { if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inMultilineComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) {"
      },
      {
        "txt": "inMultilineComment = true; } else { final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } line = line.trim(); if (line.length() == 0) { continue; // empty lines can be safely skipped }"
      },
      {
        "txt": "if (line.startsWith(HASH_INCLUDE)) { final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(\" \")) { throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" + location); } else { lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl)); } } else { final String[] parts = line.split(\"\\\\s+\");"
      },
      {
        "txt": "if (parts.length != 4) { throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length + \" parts: \" + rawLine + \" in \" + location); } else { try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine;"
      },
      {
        "txt": "final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(\"Rule\"); sb.append(\"{line=\").append(myLine); sb.append(\", loc='\").append(loc).append('\\''); sb.append(\", pat='\").append(pat).append('\\'');"
      },
      {
        "txt": "sb.append(\", lcon='\").append(lCon).append('\\''); sb.append(\", rcon='\").append(rCon).append('\\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<Rule>();"
      },
      {
        "txt": "lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" + location, e); } } } }"
      },
      {
        "txt": "} } return lines; } private static RPattern pattern(final String regex) { final boolean startsWith = regex.startsWith(\"^\"); final boolean endsWith = regex.endsWith(\"$\"); final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length()); final boolean boxes = content.contains(\"[\"); if (!boxes) {"
      },
      {
        "txt": "if (startsWith && endsWith) { if (content.length() == 0) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() {"
      },
      {
        "txt": "@Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { return ALL_STRINGS_RMATCHER; } else if (startsWith) { return new RPattern() {"
      },
      {
        "txt": "@Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content);"
      },
      {
        "txt": "} }; } } else { final boolean startsWithBox = content.startsWith(\"[\"); final boolean endsWithBox = content.endsWith(\"]\"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains(\"[\")) { final boolean negate = boxContent.startsWith(\"^\");"
      },
      {
        "txt": "if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;"
      },
      {
        "txt": "} }; } else if (startsWith) { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) {"
      },
      {
        "txt": "return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } }"
      },
      {
        "txt": "} return new RPattern() { Pattern pattern = Pattern.compile(regex); @Override public boolean isMatch(final CharSequence input) { final Matcher matcher = pattern.matcher(input); return matcher.find(); } }; }"
      },
      {
        "txt": "private static boolean startsWith(final CharSequence input, final CharSequence prefix) { if (prefix.length() > input.length()) { return false; } for (int i = 0; i < prefix.length(); i++) { if (input.charAt(i) != prefix.charAt(i)) { return false; } } return true;"
      },
      {
        "txt": "} private static String stripQuotes(String str) { if (str.startsWith(DOUBLE_QUOTE)) { str = str.substring(1); } if (str.endsWith(DOUBLE_QUOTE)) { str = str.substring(0, str.length() - 1); } return str; }"
      },
      {
        "txt": "private final RPattern lContext; private final String pattern; private final PhonemeExpr phoneme; private final RPattern rContext; public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) { this.pattern = pattern; this.lContext = pattern(lContext + \"$\"); this.rContext = pattern(\"^\" + rContext); this.phoneme = phoneme; }"
      },
      {
        "txt": "public RPattern getLContext() { return this.lContext; } public String getPattern() { return this.pattern; } public PhonemeExpr getPhoneme() { return this.phoneme; } public RPattern getRContext() {"
      },
      {
        "txt": "return this.rContext; } public boolean patternAndContextMatches(final CharSequence input, final int i) { if (i < 0) { throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\"); } final int patternLength = this.pattern.length(); final int ipl = i + patternLength; if (ipl > input.length()) { return false;"
      },
      {
        "txt": "} if (!input.subSequence(i, ipl).equals(this.pattern)) { return false; } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) { return false; } return this.lContext.isMatch(input.subSequence(0, i)); }"
      }
    ]
  }
]